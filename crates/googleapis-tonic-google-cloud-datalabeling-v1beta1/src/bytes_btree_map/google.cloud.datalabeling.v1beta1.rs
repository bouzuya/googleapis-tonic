// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSpecSet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub annotation_specs: ::prost::alloc::vec::Vec<AnnotationSpec>,
    #[prost(string, repeated, tag = "5")]
    pub blocking_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSpec {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Annotation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "AnnotationSource", tag = "2")]
    pub annotation_source: i32,
    #[prost(message, optional, tag = "3")]
    pub annotation_value: ::core::option::Option<AnnotationValue>,
    #[prost(message, optional, tag = "4")]
    pub annotation_metadata: ::core::option::Option<AnnotationMetadata>,
    #[prost(enumeration = "AnnotationSentiment", tag = "6")]
    pub annotation_sentiment: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationValue {
    #[prost(oneof = "annotation_value::ValueType", tags = "1, 2, 8, 9, 3, 10, 4, 5, 6")]
    pub value_type: ::core::option::Option<annotation_value::ValueType>,
}
/// Nested message and enum types in `AnnotationValue`.
pub mod annotation_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueType {
        #[prost(message, tag = "1")]
        ImageClassificationAnnotation(super::ImageClassificationAnnotation),
        #[prost(message, tag = "2")]
        ImageBoundingPolyAnnotation(super::ImageBoundingPolyAnnotation),
        #[prost(message, tag = "8")]
        ImagePolylineAnnotation(super::ImagePolylineAnnotation),
        #[prost(message, tag = "9")]
        ImageSegmentationAnnotation(super::ImageSegmentationAnnotation),
        #[prost(message, tag = "3")]
        TextClassificationAnnotation(super::TextClassificationAnnotation),
        #[prost(message, tag = "10")]
        TextEntityExtractionAnnotation(super::TextEntityExtractionAnnotation),
        #[prost(message, tag = "4")]
        VideoClassificationAnnotation(super::VideoClassificationAnnotation),
        #[prost(message, tag = "5")]
        VideoObjectTrackingAnnotation(super::VideoObjectTrackingAnnotation),
        #[prost(message, tag = "6")]
        VideoEventAnnotation(super::VideoEventAnnotation),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageClassificationAnnotation {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vertex {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedVertex {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoundingPoly {
    #[prost(message, repeated, tag = "1")]
    pub vertices: ::prost::alloc::vec::Vec<Vertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedBoundingPoly {
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageBoundingPolyAnnotation {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
    #[prost(oneof = "image_bounding_poly_annotation::BoundedArea", tags = "2, 3")]
    pub bounded_area: ::core::option::Option<
        image_bounding_poly_annotation::BoundedArea,
    >,
}
/// Nested message and enum types in `ImageBoundingPolyAnnotation`.
pub mod image_bounding_poly_annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BoundedArea {
        #[prost(message, tag = "2")]
        BoundingPoly(super::BoundingPoly),
        #[prost(message, tag = "3")]
        NormalizedBoundingPoly(super::NormalizedBoundingPoly),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Polyline {
    #[prost(message, repeated, tag = "1")]
    pub vertices: ::prost::alloc::vec::Vec<Vertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedPolyline {
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePolylineAnnotation {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
    #[prost(oneof = "image_polyline_annotation::Poly", tags = "2, 3")]
    pub poly: ::core::option::Option<image_polyline_annotation::Poly>,
}
/// Nested message and enum types in `ImagePolylineAnnotation`.
pub mod image_polyline_annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Poly {
        #[prost(message, tag = "2")]
        Polyline(super::Polyline),
        #[prost(message, tag = "3")]
        NormalizedPolyline(super::NormalizedPolyline),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSegmentationAnnotation {
    #[prost(btree_map = "string, message", tag = "1")]
    pub annotation_colors: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        AnnotationSpec,
    >,
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub image_bytes: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextClassificationAnnotation {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextEntityExtractionAnnotation {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
    #[prost(message, optional, tag = "2")]
    pub sequential_segment: ::core::option::Option<SequentialSegment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SequentialSegment {
    #[prost(int32, tag = "1")]
    pub start: i32,
    #[prost(int32, tag = "2")]
    pub end: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeSegment {
    #[prost(message, optional, tag = "1")]
    pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoClassificationAnnotation {
    #[prost(message, optional, tag = "1")]
    pub time_segment: ::core::option::Option<TimeSegment>,
    #[prost(message, optional, tag = "2")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectTrackingFrame {
    #[prost(message, optional, tag = "3")]
    pub time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(oneof = "object_tracking_frame::BoundedArea", tags = "1, 2")]
    pub bounded_area: ::core::option::Option<object_tracking_frame::BoundedArea>,
}
/// Nested message and enum types in `ObjectTrackingFrame`.
pub mod object_tracking_frame {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BoundedArea {
        #[prost(message, tag = "1")]
        BoundingPoly(super::BoundingPoly),
        #[prost(message, tag = "2")]
        NormalizedBoundingPoly(super::NormalizedBoundingPoly),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoObjectTrackingAnnotation {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
    #[prost(message, optional, tag = "2")]
    pub time_segment: ::core::option::Option<TimeSegment>,
    #[prost(message, repeated, tag = "3")]
    pub object_tracking_frames: ::prost::alloc::vec::Vec<ObjectTrackingFrame>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoEventAnnotation {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
    #[prost(message, optional, tag = "2")]
    pub time_segment: ::core::option::Option<TimeSegment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationMetadata {
    #[prost(message, optional, tag = "2")]
    pub operator_metadata: ::core::option::Option<OperatorMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorMetadata {
    #[prost(float, tag = "1")]
    pub score: f32,
    #[prost(int32, tag = "2")]
    pub total_votes: i32,
    #[prost(int32, tag = "3")]
    pub label_votes: i32,
    #[prost(string, repeated, tag = "4")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnnotationSource {
    Unspecified = 0,
    Operator = 3,
}
impl AnnotationSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnnotationSource::Unspecified => "ANNOTATION_SOURCE_UNSPECIFIED",
            AnnotationSource::Operator => "OPERATOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANNOTATION_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "OPERATOR" => Some(Self::Operator),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnnotationSentiment {
    Unspecified = 0,
    Negative = 1,
    Positive = 2,
}
impl AnnotationSentiment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnnotationSentiment::Unspecified => "ANNOTATION_SENTIMENT_UNSPECIFIED",
            AnnotationSentiment::Negative => "NEGATIVE",
            AnnotationSentiment::Positive => "POSITIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANNOTATION_SENTIMENT_UNSPECIFIED" => Some(Self::Unspecified),
            "NEGATIVE" => Some(Self::Negative),
            "POSITIVE" => Some(Self::Positive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnnotationType {
    Unspecified = 0,
    ImageClassificationAnnotation = 1,
    ImageBoundingBoxAnnotation = 2,
    ImageOrientedBoundingBoxAnnotation = 13,
    ImageBoundingPolyAnnotation = 10,
    ImagePolylineAnnotation = 11,
    ImageSegmentationAnnotation = 12,
    VideoShotsClassificationAnnotation = 3,
    VideoObjectTrackingAnnotation = 4,
    VideoObjectDetectionAnnotation = 5,
    VideoEventAnnotation = 6,
    TextClassificationAnnotation = 8,
    TextEntityExtractionAnnotation = 9,
    GeneralClassificationAnnotation = 14,
}
impl AnnotationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnnotationType::Unspecified => "ANNOTATION_TYPE_UNSPECIFIED",
            AnnotationType::ImageClassificationAnnotation => {
                "IMAGE_CLASSIFICATION_ANNOTATION"
            }
            AnnotationType::ImageBoundingBoxAnnotation => "IMAGE_BOUNDING_BOX_ANNOTATION",
            AnnotationType::ImageOrientedBoundingBoxAnnotation => {
                "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION"
            }
            AnnotationType::ImageBoundingPolyAnnotation => {
                "IMAGE_BOUNDING_POLY_ANNOTATION"
            }
            AnnotationType::ImagePolylineAnnotation => "IMAGE_POLYLINE_ANNOTATION",
            AnnotationType::ImageSegmentationAnnotation => {
                "IMAGE_SEGMENTATION_ANNOTATION"
            }
            AnnotationType::VideoShotsClassificationAnnotation => {
                "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION"
            }
            AnnotationType::VideoObjectTrackingAnnotation => {
                "VIDEO_OBJECT_TRACKING_ANNOTATION"
            }
            AnnotationType::VideoObjectDetectionAnnotation => {
                "VIDEO_OBJECT_DETECTION_ANNOTATION"
            }
            AnnotationType::VideoEventAnnotation => "VIDEO_EVENT_ANNOTATION",
            AnnotationType::TextClassificationAnnotation => {
                "TEXT_CLASSIFICATION_ANNOTATION"
            }
            AnnotationType::TextEntityExtractionAnnotation => {
                "TEXT_ENTITY_EXTRACTION_ANNOTATION"
            }
            AnnotationType::GeneralClassificationAnnotation => {
                "GENERAL_CLASSIFICATION_ANNOTATION"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANNOTATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "IMAGE_CLASSIFICATION_ANNOTATION" => {
                Some(Self::ImageClassificationAnnotation)
            }
            "IMAGE_BOUNDING_BOX_ANNOTATION" => Some(Self::ImageBoundingBoxAnnotation),
            "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" => {
                Some(Self::ImageOrientedBoundingBoxAnnotation)
            }
            "IMAGE_BOUNDING_POLY_ANNOTATION" => Some(Self::ImageBoundingPolyAnnotation),
            "IMAGE_POLYLINE_ANNOTATION" => Some(Self::ImagePolylineAnnotation),
            "IMAGE_SEGMENTATION_ANNOTATION" => Some(Self::ImageSegmentationAnnotation),
            "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" => {
                Some(Self::VideoShotsClassificationAnnotation)
            }
            "VIDEO_OBJECT_TRACKING_ANNOTATION" => {
                Some(Self::VideoObjectTrackingAnnotation)
            }
            "VIDEO_OBJECT_DETECTION_ANNOTATION" => {
                Some(Self::VideoObjectDetectionAnnotation)
            }
            "VIDEO_EVENT_ANNOTATION" => Some(Self::VideoEventAnnotation),
            "TEXT_CLASSIFICATION_ANNOTATION" => Some(Self::TextClassificationAnnotation),
            "TEXT_ENTITY_EXTRACTION_ANNOTATION" => {
                Some(Self::TextEntityExtractionAnnotation)
            }
            "GENERAL_CLASSIFICATION_ANNOTATION" => {
                Some(Self::GeneralClassificationAnnotation)
            }
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePayload {
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub image_thumbnail: ::prost::bytes::Bytes,
    #[prost(string, tag = "3")]
    pub image_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub signed_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextPayload {
    #[prost(string, tag = "1")]
    pub text_content: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoThumbnail {
    #[prost(bytes = "bytes", tag = "1")]
    pub thumbnail: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoPayload {
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub video_uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub video_thumbnails: ::prost::alloc::vec::Vec<VideoThumbnail>,
    #[prost(float, tag = "4")]
    pub frame_rate: f32,
    #[prost(string, tag = "5")]
    pub signed_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HumanAnnotationConfig {
    #[prost(string, tag = "1")]
    pub instruction: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub annotated_dataset_display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub annotated_dataset_description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub label_group: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub replica_count: i32,
    #[prost(message, optional, tag = "7")]
    pub question_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, repeated, tag = "9")]
    pub contributor_emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "10")]
    pub user_email_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageClassificationConfig {
    #[prost(string, tag = "1")]
    pub annotation_spec_set: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub allow_multi_label: bool,
    #[prost(enumeration = "StringAggregationType", tag = "3")]
    pub answer_aggregation_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoundingPolyConfig {
    #[prost(string, tag = "1")]
    pub annotation_spec_set: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instruction_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolylineConfig {
    #[prost(string, tag = "1")]
    pub annotation_spec_set: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instruction_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentationConfig {
    #[prost(string, tag = "1")]
    pub annotation_spec_set: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instruction_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoClassificationConfig {
    #[prost(message, repeated, tag = "1")]
    pub annotation_spec_set_configs: ::prost::alloc::vec::Vec<
        video_classification_config::AnnotationSpecSetConfig,
    >,
    #[prost(bool, tag = "2")]
    pub apply_shot_detection: bool,
}
/// Nested message and enum types in `VideoClassificationConfig`.
pub mod video_classification_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnnotationSpecSetConfig {
        #[prost(string, tag = "1")]
        pub annotation_spec_set: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub allow_multi_label: bool,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectDetectionConfig {
    #[prost(string, tag = "1")]
    pub annotation_spec_set: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub extraction_frame_rate: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectTrackingConfig {
    #[prost(string, tag = "1")]
    pub annotation_spec_set: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventConfig {
    #[prost(string, repeated, tag = "1")]
    pub annotation_spec_sets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextClassificationConfig {
    #[prost(bool, tag = "1")]
    pub allow_multi_label: bool,
    #[prost(string, tag = "2")]
    pub annotation_spec_set: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub sentiment_config: ::core::option::Option<SentimentConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SentimentConfig {
    #[prost(bool, tag = "1")]
    pub enable_label_sentiment_selection: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextEntityExtractionConfig {
    #[prost(string, tag = "1")]
    pub annotation_spec_set: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StringAggregationType {
    Unspecified = 0,
    MajorityVote = 1,
    UnanimousVote = 2,
    NoAggregation = 3,
}
impl StringAggregationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StringAggregationType::Unspecified => "STRING_AGGREGATION_TYPE_UNSPECIFIED",
            StringAggregationType::MajorityVote => "MAJORITY_VOTE",
            StringAggregationType::UnanimousVote => "UNANIMOUS_VOTE",
            StringAggregationType::NoAggregation => "NO_AGGREGATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STRING_AGGREGATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MAJORITY_VOTE" => Some(Self::MajorityVote),
            "UNANIMOUS_VOTE" => Some(Self::UnanimousVote),
            "NO_AGGREGATION" => Some(Self::NoAggregation),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dataset {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "5")]
    pub input_configs: ::prost::alloc::vec::Vec<InputConfig>,
    #[prost(string, repeated, tag = "6")]
    pub blocking_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "7")]
    pub data_item_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputConfig {
    #[prost(enumeration = "DataType", tag = "1")]
    pub data_type: i32,
    #[prost(enumeration = "AnnotationType", tag = "3")]
    pub annotation_type: i32,
    #[prost(message, optional, tag = "4")]
    pub classification_metadata: ::core::option::Option<ClassificationMetadata>,
    #[prost(oneof = "input_config::DataTypeMetadata", tags = "6")]
    pub data_type_metadata: ::core::option::Option<input_config::DataTypeMetadata>,
    #[prost(oneof = "input_config::Source", tags = "2, 5")]
    pub source: ::core::option::Option<input_config::Source>,
}
/// Nested message and enum types in `InputConfig`.
pub mod input_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataTypeMetadata {
        #[prost(message, tag = "6")]
        TextMetadata(super::TextMetadata),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "5")]
        BigquerySource(super::BigQuerySource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextMetadata {
    #[prost(string, tag = "1")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClassificationMetadata {
    #[prost(bool, tag = "1")]
    pub is_multi_label: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    #[prost(string, tag = "1")]
    pub input_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuerySource {
    #[prost(string, tag = "1")]
    pub input_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputConfig {
    #[prost(oneof = "output_config::Destination", tags = "1, 2")]
    pub destination: ::core::option::Option<output_config::Destination>,
}
/// Nested message and enum types in `OutputConfig`.
pub mod output_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(message, tag = "1")]
        GcsDestination(super::GcsDestination),
        #[prost(message, tag = "2")]
        GcsFolderDestination(super::GcsFolderDestination),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsDestination {
    #[prost(string, tag = "1")]
    pub output_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsFolderDestination {
    #[prost(string, tag = "1")]
    pub output_folder_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataItem {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "data_item::Payload", tags = "2, 3, 4")]
    pub payload: ::core::option::Option<data_item::Payload>,
}
/// Nested message and enum types in `DataItem`.
pub mod data_item {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "2")]
        ImagePayload(super::ImagePayload),
        #[prost(message, tag = "3")]
        TextPayload(super::TextPayload),
        #[prost(message, tag = "4")]
        VideoPayload(super::VideoPayload),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotatedDataset {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "AnnotationSource", tag = "3")]
    pub annotation_source: i32,
    #[prost(enumeration = "AnnotationType", tag = "8")]
    pub annotation_type: i32,
    #[prost(int64, tag = "4")]
    pub example_count: i64,
    #[prost(int64, tag = "5")]
    pub completed_example_count: i64,
    #[prost(message, optional, tag = "6")]
    pub label_stats: ::core::option::Option<LabelStats>,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub metadata: ::core::option::Option<AnnotatedDatasetMetadata>,
    #[prost(string, repeated, tag = "11")]
    pub blocking_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelStats {
    #[prost(btree_map = "string, int64", tag = "1")]
    pub example_count: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        i64,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotatedDatasetMetadata {
    #[prost(message, optional, tag = "1")]
    pub human_annotation_config: ::core::option::Option<HumanAnnotationConfig>,
    #[prost(
        oneof = "annotated_dataset_metadata::AnnotationRequestConfig",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11"
    )]
    pub annotation_request_config: ::core::option::Option<
        annotated_dataset_metadata::AnnotationRequestConfig,
    >,
}
/// Nested message and enum types in `AnnotatedDatasetMetadata`.
pub mod annotated_dataset_metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AnnotationRequestConfig {
        #[prost(message, tag = "2")]
        ImageClassificationConfig(super::ImageClassificationConfig),
        #[prost(message, tag = "3")]
        BoundingPolyConfig(super::BoundingPolyConfig),
        #[prost(message, tag = "4")]
        PolylineConfig(super::PolylineConfig),
        #[prost(message, tag = "5")]
        SegmentationConfig(super::SegmentationConfig),
        #[prost(message, tag = "6")]
        VideoClassificationConfig(super::VideoClassificationConfig),
        #[prost(message, tag = "7")]
        ObjectDetectionConfig(super::ObjectDetectionConfig),
        #[prost(message, tag = "8")]
        ObjectTrackingConfig(super::ObjectTrackingConfig),
        #[prost(message, tag = "9")]
        EventConfig(super::EventConfig),
        #[prost(message, tag = "10")]
        TextClassificationConfig(super::TextClassificationConfig),
        #[prost(message, tag = "11")]
        TextEntityExtractionConfig(super::TextEntityExtractionConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Example {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(oneof = "example::Payload", tags = "2, 6, 7")]
    pub payload: ::core::option::Option<example::Payload>,
}
/// Nested message and enum types in `Example`.
pub mod example {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "2")]
        ImagePayload(super::ImagePayload),
        #[prost(message, tag = "6")]
        TextPayload(super::TextPayload),
        #[prost(message, tag = "7")]
        VideoPayload(super::VideoPayload),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataType {
    Unspecified = 0,
    Image = 1,
    Video = 2,
    Text = 4,
    GeneralData = 6,
}
impl DataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DataType::Unspecified => "DATA_TYPE_UNSPECIFIED",
            DataType::Image => "IMAGE",
            DataType::Video => "VIDEO",
            DataType::Text => "TEXT",
            DataType::GeneralData => "GENERAL_DATA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "IMAGE" => Some(Self::Image),
            "VIDEO" => Some(Self::Video),
            "TEXT" => Some(Self::Text),
            "GENERAL_DATA" => Some(Self::GeneralData),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataOperationResponse {
    #[prost(string, tag = "1")]
    pub dataset: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub total_count: i32,
    #[prost(int32, tag = "3")]
    pub import_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataOperationResponse {
    #[prost(string, tag = "1")]
    pub dataset: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub total_count: i32,
    #[prost(int32, tag = "3")]
    pub export_count: i32,
    #[prost(message, optional, tag = "4")]
    pub label_stats: ::core::option::Option<LabelStats>,
    #[prost(message, optional, tag = "5")]
    pub output_config: ::core::option::Option<OutputConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataOperationMetadata {
    #[prost(string, tag = "1")]
    pub dataset: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataOperationMetadata {
    #[prost(string, tag = "1")]
    pub dataset: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelOperationMetadata {
    #[prost(int32, tag = "1")]
    pub progress_percent: i32,
    #[prost(message, repeated, tag = "2")]
    pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "16")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(
        oneof = "label_operation_metadata::Details",
        tags = "3, 4, 11, 14, 12, 15, 5, 6, 7, 8, 9, 13"
    )]
    pub details: ::core::option::Option<label_operation_metadata::Details>,
}
/// Nested message and enum types in `LabelOperationMetadata`.
pub mod label_operation_metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag = "3")]
        ImageClassificationDetails(super::LabelImageClassificationOperationMetadata),
        #[prost(message, tag = "4")]
        ImageBoundingBoxDetails(super::LabelImageBoundingBoxOperationMetadata),
        #[prost(message, tag = "11")]
        ImageBoundingPolyDetails(super::LabelImageBoundingPolyOperationMetadata),
        #[prost(message, tag = "14")]
        ImageOrientedBoundingBoxDetails(
            super::LabelImageOrientedBoundingBoxOperationMetadata,
        ),
        #[prost(message, tag = "12")]
        ImagePolylineDetails(super::LabelImagePolylineOperationMetadata),
        #[prost(message, tag = "15")]
        ImageSegmentationDetails(super::LabelImageSegmentationOperationMetadata),
        #[prost(message, tag = "5")]
        VideoClassificationDetails(super::LabelVideoClassificationOperationMetadata),
        #[prost(message, tag = "6")]
        VideoObjectDetectionDetails(super::LabelVideoObjectDetectionOperationMetadata),
        #[prost(message, tag = "7")]
        VideoObjectTrackingDetails(super::LabelVideoObjectTrackingOperationMetadata),
        #[prost(message, tag = "8")]
        VideoEventDetails(super::LabelVideoEventOperationMetadata),
        #[prost(message, tag = "9")]
        TextClassificationDetails(super::LabelTextClassificationOperationMetadata),
        #[prost(message, tag = "13")]
        TextEntityExtractionDetails(super::LabelTextEntityExtractionOperationMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelImageClassificationOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelImageBoundingBoxOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelImageOrientedBoundingBoxOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelImageBoundingPolyOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelImagePolylineOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelImageSegmentationOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelVideoClassificationOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelVideoObjectDetectionOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelVideoObjectTrackingOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelVideoEventOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelTextClassificationOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelTextEntityExtractionOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstructionMetadata {
    #[prost(string, tag = "1")]
    pub instruction: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Evaluation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<EvaluationConfig>,
    #[prost(message, optional, tag = "3")]
    pub evaluation_job_run_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub evaluation_metrics: ::core::option::Option<EvaluationMetrics>,
    #[prost(enumeration = "AnnotationType", tag = "6")]
    pub annotation_type: i32,
    #[prost(int64, tag = "7")]
    pub evaluated_item_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvaluationConfig {
    #[prost(oneof = "evaluation_config::VerticalOption", tags = "1")]
    pub vertical_option: ::core::option::Option<evaluation_config::VerticalOption>,
}
/// Nested message and enum types in `EvaluationConfig`.
pub mod evaluation_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum VerticalOption {
        #[prost(message, tag = "1")]
        BoundingBoxEvaluationOptions(super::BoundingBoxEvaluationOptions),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BoundingBoxEvaluationOptions {
    #[prost(float, tag = "1")]
    pub iou_threshold: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluationMetrics {
    #[prost(oneof = "evaluation_metrics::Metrics", tags = "1, 2")]
    pub metrics: ::core::option::Option<evaluation_metrics::Metrics>,
}
/// Nested message and enum types in `EvaluationMetrics`.
pub mod evaluation_metrics {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Metrics {
        #[prost(message, tag = "1")]
        ClassificationMetrics(super::ClassificationMetrics),
        #[prost(message, tag = "2")]
        ObjectDetectionMetrics(super::ObjectDetectionMetrics),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassificationMetrics {
    #[prost(message, optional, tag = "1")]
    pub pr_curve: ::core::option::Option<PrCurve>,
    #[prost(message, optional, tag = "2")]
    pub confusion_matrix: ::core::option::Option<ConfusionMatrix>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectDetectionMetrics {
    #[prost(message, optional, tag = "1")]
    pub pr_curve: ::core::option::Option<PrCurve>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrCurve {
    #[prost(message, optional, tag = "1")]
    pub annotation_spec: ::core::option::Option<AnnotationSpec>,
    #[prost(float, tag = "2")]
    pub area_under_curve: f32,
    #[prost(message, repeated, tag = "3")]
    pub confidence_metrics_entries: ::prost::alloc::vec::Vec<
        pr_curve::ConfidenceMetricsEntry,
    >,
    #[prost(float, tag = "4")]
    pub mean_average_precision: f32,
}
/// Nested message and enum types in `PrCurve`.
pub mod pr_curve {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ConfidenceMetricsEntry {
        #[prost(float, tag = "1")]
        pub confidence_threshold: f32,
        #[prost(float, tag = "2")]
        pub recall: f32,
        #[prost(float, tag = "3")]
        pub precision: f32,
        #[prost(float, tag = "4")]
        pub f1_score: f32,
        #[prost(float, tag = "5")]
        pub recall_at1: f32,
        #[prost(float, tag = "6")]
        pub precision_at1: f32,
        #[prost(float, tag = "7")]
        pub f1_score_at1: f32,
        #[prost(float, tag = "8")]
        pub recall_at5: f32,
        #[prost(float, tag = "9")]
        pub precision_at5: f32,
        #[prost(float, tag = "10")]
        pub f1_score_at5: f32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfusionMatrix {
    #[prost(message, repeated, tag = "1")]
    pub row: ::prost::alloc::vec::Vec<confusion_matrix::Row>,
}
/// Nested message and enum types in `ConfusionMatrix`.
pub mod confusion_matrix {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfusionMatrixEntry {
        #[prost(message, optional, tag = "1")]
        pub annotation_spec: ::core::option::Option<super::AnnotationSpec>,
        #[prost(int32, tag = "2")]
        pub item_count: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Row {
        #[prost(message, optional, tag = "1")]
        pub annotation_spec: ::core::option::Option<super::AnnotationSpec>,
        #[prost(message, repeated, tag = "2")]
        pub entries: ::prost::alloc::vec::Vec<ConfusionMatrixEntry>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluationJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "evaluation_job::State", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "4")]
    pub schedule: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub model_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub evaluation_job_config: ::core::option::Option<EvaluationJobConfig>,
    #[prost(string, tag = "7")]
    pub annotation_spec_set: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub label_missing_ground_truth: bool,
    #[prost(message, repeated, tag = "9")]
    pub attempts: ::prost::alloc::vec::Vec<Attempt>,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `EvaluationJob`.
pub mod evaluation_job {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Scheduled = 1,
        Running = 2,
        Paused = 3,
        Stopped = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Scheduled => "SCHEDULED",
                State::Running => "RUNNING",
                State::Paused => "PAUSED",
                State::Stopped => "STOPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCHEDULED" => Some(Self::Scheduled),
                "RUNNING" => Some(Self::Running),
                "PAUSED" => Some(Self::Paused),
                "STOPPED" => Some(Self::Stopped),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluationJobConfig {
    #[prost(message, optional, tag = "1")]
    pub input_config: ::core::option::Option<InputConfig>,
    #[prost(message, optional, tag = "2")]
    pub evaluation_config: ::core::option::Option<EvaluationConfig>,
    #[prost(message, optional, tag = "3")]
    pub human_annotation_config: ::core::option::Option<HumanAnnotationConfig>,
    #[prost(btree_map = "string, string", tag = "9")]
    pub bigquery_import_keys: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "10")]
    pub example_count: i32,
    #[prost(double, tag = "11")]
    pub example_sample_percentage: f64,
    #[prost(message, optional, tag = "13")]
    pub evaluation_job_alert_config: ::core::option::Option<EvaluationJobAlertConfig>,
    #[prost(
        oneof = "evaluation_job_config::HumanAnnotationRequestConfig",
        tags = "4, 5, 8"
    )]
    pub human_annotation_request_config: ::core::option::Option<
        evaluation_job_config::HumanAnnotationRequestConfig,
    >,
}
/// Nested message and enum types in `EvaluationJobConfig`.
pub mod evaluation_job_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum HumanAnnotationRequestConfig {
        #[prost(message, tag = "4")]
        ImageClassificationConfig(super::ImageClassificationConfig),
        #[prost(message, tag = "5")]
        BoundingPolyConfig(super::BoundingPolyConfig),
        #[prost(message, tag = "8")]
        TextClassificationConfig(super::TextClassificationConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluationJobAlertConfig {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub min_acceptable_mean_average_precision: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attempt {
    #[prost(message, optional, tag = "1")]
    pub attempt_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "2")]
    pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instruction {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "DataType", tag = "6")]
    pub data_type: i32,
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub csv_instruction: ::core::option::Option<CsvInstruction>,
    #[prost(message, optional, tag = "9")]
    pub pdf_instruction: ::core::option::Option<PdfInstruction>,
    #[prost(string, repeated, tag = "10")]
    pub blocking_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvInstruction {
    #[prost(string, tag = "1")]
    pub gcs_file_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PdfInstruction {
    #[prost(string, tag = "1")]
    pub gcs_file_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub dataset: ::core::option::Option<Dataset>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub datasets: ::prost::alloc::vec::Vec<Dataset>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input_config: ::core::option::Option<InputConfig>,
    #[prost(string, tag = "3")]
    pub user_email_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub annotated_dataset: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub output_config: ::core::option::Option<OutputConfig>,
    #[prost(string, tag = "5")]
    pub user_email_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataItemRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataItemsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataItemsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_items: ::prost::alloc::vec::Vec<DataItem>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnnotatedDatasetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotatedDatasetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotatedDatasetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub annotated_datasets: ::prost::alloc::vec::Vec<AnnotatedDataset>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotatedDatasetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelImageRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
    #[prost(enumeration = "label_image_request::Feature", tag = "3")]
    pub feature: i32,
    #[prost(oneof = "label_image_request::RequestConfig", tags = "4, 5, 6, 7")]
    pub request_config: ::core::option::Option<label_image_request::RequestConfig>,
}
/// Nested message and enum types in `LabelImageRequest`.
pub mod label_image_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Feature {
        Unspecified = 0,
        Classification = 1,
        BoundingBox = 2,
        OrientedBoundingBox = 6,
        BoundingPoly = 3,
        Polyline = 4,
        Segmentation = 5,
    }
    impl Feature {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Feature::Unspecified => "FEATURE_UNSPECIFIED",
                Feature::Classification => "CLASSIFICATION",
                Feature::BoundingBox => "BOUNDING_BOX",
                Feature::OrientedBoundingBox => "ORIENTED_BOUNDING_BOX",
                Feature::BoundingPoly => "BOUNDING_POLY",
                Feature::Polyline => "POLYLINE",
                Feature::Segmentation => "SEGMENTATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FEATURE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLASSIFICATION" => Some(Self::Classification),
                "BOUNDING_BOX" => Some(Self::BoundingBox),
                "ORIENTED_BOUNDING_BOX" => Some(Self::OrientedBoundingBox),
                "BOUNDING_POLY" => Some(Self::BoundingPoly),
                "POLYLINE" => Some(Self::Polyline),
                "SEGMENTATION" => Some(Self::Segmentation),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestConfig {
        #[prost(message, tag = "4")]
        ImageClassificationConfig(super::ImageClassificationConfig),
        #[prost(message, tag = "5")]
        BoundingPolyConfig(super::BoundingPolyConfig),
        #[prost(message, tag = "6")]
        PolylineConfig(super::PolylineConfig),
        #[prost(message, tag = "7")]
        SegmentationConfig(super::SegmentationConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelVideoRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
    #[prost(enumeration = "label_video_request::Feature", tag = "3")]
    pub feature: i32,
    #[prost(oneof = "label_video_request::RequestConfig", tags = "4, 5, 6, 7")]
    pub request_config: ::core::option::Option<label_video_request::RequestConfig>,
}
/// Nested message and enum types in `LabelVideoRequest`.
pub mod label_video_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Feature {
        Unspecified = 0,
        Classification = 1,
        ObjectDetection = 2,
        ObjectTracking = 3,
        Event = 4,
    }
    impl Feature {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Feature::Unspecified => "FEATURE_UNSPECIFIED",
                Feature::Classification => "CLASSIFICATION",
                Feature::ObjectDetection => "OBJECT_DETECTION",
                Feature::ObjectTracking => "OBJECT_TRACKING",
                Feature::Event => "EVENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FEATURE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLASSIFICATION" => Some(Self::Classification),
                "OBJECT_DETECTION" => Some(Self::ObjectDetection),
                "OBJECT_TRACKING" => Some(Self::ObjectTracking),
                "EVENT" => Some(Self::Event),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestConfig {
        #[prost(message, tag = "4")]
        VideoClassificationConfig(super::VideoClassificationConfig),
        #[prost(message, tag = "5")]
        ObjectDetectionConfig(super::ObjectDetectionConfig),
        #[prost(message, tag = "6")]
        ObjectTrackingConfig(super::ObjectTrackingConfig),
        #[prost(message, tag = "7")]
        EventConfig(super::EventConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelTextRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub basic_config: ::core::option::Option<HumanAnnotationConfig>,
    #[prost(enumeration = "label_text_request::Feature", tag = "6")]
    pub feature: i32,
    #[prost(oneof = "label_text_request::RequestConfig", tags = "4, 5")]
    pub request_config: ::core::option::Option<label_text_request::RequestConfig>,
}
/// Nested message and enum types in `LabelTextRequest`.
pub mod label_text_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Feature {
        Unspecified = 0,
        TextClassification = 1,
        TextEntityExtraction = 2,
    }
    impl Feature {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Feature::Unspecified => "FEATURE_UNSPECIFIED",
                Feature::TextClassification => "TEXT_CLASSIFICATION",
                Feature::TextEntityExtraction => "TEXT_ENTITY_EXTRACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FEATURE_UNSPECIFIED" => Some(Self::Unspecified),
                "TEXT_CLASSIFICATION" => Some(Self::TextClassification),
                "TEXT_ENTITY_EXTRACTION" => Some(Self::TextEntityExtraction),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestConfig {
        #[prost(message, tag = "4")]
        TextClassificationConfig(super::TextClassificationConfig),
        #[prost(message, tag = "5")]
        TextEntityExtractionConfig(super::TextEntityExtractionConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExampleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExamplesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExamplesResponse {
    #[prost(message, repeated, tag = "1")]
    pub examples: ::prost::alloc::vec::Vec<Example>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnnotationSpecSetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub annotation_spec_set: ::core::option::Option<AnnotationSpecSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnnotationSpecSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationSpecSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationSpecSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub annotation_spec_sets: ::prost::alloc::vec::Vec<AnnotationSpecSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotationSpecSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstructionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub instruction: ::core::option::Option<Instruction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstructionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstructionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstructionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstructionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub instructions: ::prost::alloc::vec::Vec<Instruction>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEvaluationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEvaluationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEvaluationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub evaluations: ::prost::alloc::vec::Vec<Evaluation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchExampleComparisonsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchExampleComparisonsResponse {
    #[prost(message, repeated, tag = "1")]
    pub example_comparisons: ::prost::alloc::vec::Vec<
        search_example_comparisons_response::ExampleComparison,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SearchExampleComparisonsResponse`.
pub mod search_example_comparisons_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExampleComparison {
        #[prost(message, optional, tag = "1")]
        pub ground_truth_example: ::core::option::Option<super::Example>,
        #[prost(message, repeated, tag = "2")]
        pub model_created_examples: ::prost::alloc::vec::Vec<super::Example>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEvaluationJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub job: ::core::option::Option<EvaluationJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEvaluationJobRequest {
    #[prost(message, optional, tag = "1")]
    pub evaluation_job: ::core::option::Option<EvaluationJob>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEvaluationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseEvaluationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeEvaluationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEvaluationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEvaluationJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEvaluationJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub evaluation_jobs: ::prost::alloc::vec::Vec<EvaluationJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod data_labeling_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for the AI Platform Data Labeling API.
    #[derive(Debug, Clone)]
    pub struct DataLabelingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DataLabelingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataLabelingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DataLabelingServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates dataset. If success return a Dataset resource.
        pub async fn create_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/CreateDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "CreateDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets dataset by resource name.
        pub async fn get_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists datasets under a project. Pagination is supported.
        pub async fn list_datasets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDatasetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDatasetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ListDatasets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ListDatasets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a dataset by resource name.
        pub async fn delete_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDatasetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/DeleteDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "DeleteDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports data into dataset based on source locations defined in request.
        /// It can be called multiple times for the same dataset. Each dataset can
        /// only have one long running operation running on it. For example, no
        /// labeling task (also long running operation) can be started while
        /// importing is still ongoing. Vice versa.
        pub async fn import_data(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ImportData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ImportData",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports data and annotations from dataset.
        pub async fn export_data(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ExportData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ExportData",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a data item in a dataset by resource name. This API can be
        /// called after data are imported into dataset.
        pub async fn get_data_item(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataItemRequest>,
        ) -> std::result::Result<tonic::Response<super::DataItem>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetDataItem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetDataItem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists data items in a dataset. This API can be called after data
        /// are imported into dataset. Pagination is supported.
        pub async fn list_data_items(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ListDataItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ListDataItems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an annotated dataset by resource name.
        pub async fn get_annotated_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnnotatedDatasetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnnotatedDataset>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetAnnotatedDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetAnnotatedDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists annotated datasets for a dataset. Pagination is supported.
        pub async fn list_annotated_datasets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnnotatedDatasetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAnnotatedDatasetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ListAnnotatedDatasets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ListAnnotatedDatasets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an annotated dataset by resource name.
        pub async fn delete_annotated_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnnotatedDatasetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/DeleteAnnotatedDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "DeleteAnnotatedDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts a labeling task for image. The type of image labeling task is
        /// configured by feature in the request.
        pub async fn label_image(
            &mut self,
            request: impl tonic::IntoRequest<super::LabelImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/LabelImage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "LabelImage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts a labeling task for video. The type of video labeling task is
        /// configured by feature in the request.
        pub async fn label_video(
            &mut self,
            request: impl tonic::IntoRequest<super::LabelVideoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/LabelVideo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "LabelVideo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts a labeling task for text. The type of text labeling task is
        /// configured by feature in the request.
        pub async fn label_text(
            &mut self,
            request: impl tonic::IntoRequest<super::LabelTextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/LabelText",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "LabelText",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an example by resource name, including both data and annotation.
        pub async fn get_example(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExampleRequest>,
        ) -> std::result::Result<tonic::Response<super::Example>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetExample",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetExample",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists examples in an annotated dataset. Pagination is supported.
        pub async fn list_examples(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExamplesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExamplesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ListExamples",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ListExamples",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an annotation spec set by providing a set of labels.
        pub async fn create_annotation_spec_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnnotationSpecSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnnotationSpecSet>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/CreateAnnotationSpecSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "CreateAnnotationSpecSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an annotation spec set by resource name.
        pub async fn get_annotation_spec_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnnotationSpecSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnnotationSpecSet>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetAnnotationSpecSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetAnnotationSpecSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists annotation spec sets for a project. Pagination is supported.
        pub async fn list_annotation_spec_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnnotationSpecSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAnnotationSpecSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ListAnnotationSpecSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ListAnnotationSpecSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an annotation spec set by resource name.
        pub async fn delete_annotation_spec_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnnotationSpecSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/DeleteAnnotationSpecSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "DeleteAnnotationSpecSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instruction for how data should be labeled.
        pub async fn create_instruction(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInstructionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/CreateInstruction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "CreateInstruction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an instruction by resource name.
        pub async fn get_instruction(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstructionRequest>,
        ) -> std::result::Result<tonic::Response<super::Instruction>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetInstruction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetInstruction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists instructions for a project. Pagination is supported.
        pub async fn list_instructions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstructionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInstructionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ListInstructions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ListInstructions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an instruction object by resource name.
        pub async fn delete_instruction(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstructionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/DeleteInstruction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "DeleteInstruction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an evaluation by resource name (to search, use
        /// \[projects.evaluations.search\]\[google.cloud.datalabeling.v1beta1.DataLabelingService.SearchEvaluations\]).
        pub async fn get_evaluation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEvaluationRequest>,
        ) -> std::result::Result<tonic::Response<super::Evaluation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetEvaluation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetEvaluation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches \[evaluations\]\[google.cloud.datalabeling.v1beta1.Evaluation\] within a project.
        pub async fn search_evaluations(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchEvaluationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchEvaluationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/SearchEvaluations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "SearchEvaluations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches example comparisons from an evaluation. The return format is a
        /// list of example comparisons that show ground truth and prediction(s) for
        /// a single input. Search by providing an evaluation ID.
        pub async fn search_example_comparisons(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchExampleComparisonsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchExampleComparisonsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/SearchExampleComparisons",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "SearchExampleComparisons",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an evaluation job.
        pub async fn create_evaluation_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEvaluationJobRequest>,
        ) -> std::result::Result<tonic::Response<super::EvaluationJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/CreateEvaluationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "CreateEvaluationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an evaluation job. You can only update certain fields of the job's
        /// \[EvaluationJobConfig\]\[google.cloud.datalabeling.v1beta1.EvaluationJobConfig\]: `humanAnnotationConfig.instruction`,
        /// `exampleCount`, and `exampleSamplePercentage`.
        ///
        /// If you want to change any other aspect of the evaluation job, you must
        /// delete the job and create a new one.
        pub async fn update_evaluation_job(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEvaluationJobRequest>,
        ) -> std::result::Result<tonic::Response<super::EvaluationJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/UpdateEvaluationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "UpdateEvaluationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an evaluation job by resource name.
        pub async fn get_evaluation_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEvaluationJobRequest>,
        ) -> std::result::Result<tonic::Response<super::EvaluationJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/GetEvaluationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "GetEvaluationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Pauses an evaluation job. Pausing an evaluation job that is already in a
        /// `PAUSED` state is a no-op.
        pub async fn pause_evaluation_job(
            &mut self,
            request: impl tonic::IntoRequest<super::PauseEvaluationJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/PauseEvaluationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "PauseEvaluationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resumes a paused evaluation job. A deleted evaluation job can't be resumed.
        /// Resuming a running or scheduled evaluation job is a no-op.
        pub async fn resume_evaluation_job(
            &mut self,
            request: impl tonic::IntoRequest<super::ResumeEvaluationJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ResumeEvaluationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ResumeEvaluationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops and deletes an evaluation job.
        pub async fn delete_evaluation_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEvaluationJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/DeleteEvaluationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "DeleteEvaluationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all evaluation jobs within a project with possible filters.
        /// Pagination is supported.
        pub async fn list_evaluation_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEvaluationJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEvaluationJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.datalabeling.v1beta1.DataLabelingService/ListEvaluationJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.datalabeling.v1beta1.DataLabelingService",
                        "ListEvaluationJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
