// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<Asset>,
    #[prost(string, optional, tag = "3")]
    pub asset_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAssetRequest {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<Asset>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAssetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCorpusRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub corpus: ::core::option::Option<Corpus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateCorpusMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Corpus {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub default_ttl: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCorpusRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCorpusRequest {
    #[prost(message, optional, tag = "1")]
    pub corpus: ::core::option::Option<Corpus>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCorporaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCorporaResponse {
    #[prost(message, repeated, tag = "1")]
    pub corpora: ::prost::alloc::vec::Vec<Corpus>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCorpusRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub data_schema: ::core::option::Option<DataSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSchema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub schema_details: ::core::option::Option<DataSchemaDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSchemaDetails {
    #[prost(enumeration = "data_schema_details::DataType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "6")]
    pub proto_any_config: ::core::option::Option<data_schema_details::ProtoAnyConfig>,
    #[prost(enumeration = "data_schema_details::Granularity", tag = "5")]
    pub granularity: i32,
    #[prost(message, optional, tag = "7")]
    pub search_strategy: ::core::option::Option<data_schema_details::SearchStrategy>,
}
/// Nested message and enum types in `DataSchemaDetails`.
pub mod data_schema_details {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProtoAnyConfig {
        #[prost(string, tag = "1")]
        pub type_uri: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SearchStrategy {
        #[prost(enumeration = "search_strategy::SearchStrategyType", tag = "1")]
        pub search_strategy_type: i32,
    }
    /// Nested message and enum types in `SearchStrategy`.
    pub mod search_strategy {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SearchStrategyType {
            NoSearch = 0,
            ExactSearch = 1,
            SmartSearch = 2,
        }
        impl SearchStrategyType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    SearchStrategyType::NoSearch => "NO_SEARCH",
                    SearchStrategyType::ExactSearch => "EXACT_SEARCH",
                    SearchStrategyType::SmartSearch => "SMART_SEARCH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NO_SEARCH" => Some(Self::NoSearch),
                    "EXACT_SEARCH" => Some(Self::ExactSearch),
                    "SMART_SEARCH" => Some(Self::SmartSearch),
                    _ => None,
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Unspecified = 0,
        Integer = 1,
        Float = 2,
        String = 3,
        Datetime = 5,
        GeoCoordinate = 7,
        ProtoAny = 8,
        Boolean = 9,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataType::Unspecified => "DATA_TYPE_UNSPECIFIED",
                DataType::Integer => "INTEGER",
                DataType::Float => "FLOAT",
                DataType::String => "STRING",
                DataType::Datetime => "DATETIME",
                DataType::GeoCoordinate => "GEO_COORDINATE",
                DataType::ProtoAny => "PROTO_ANY",
                DataType::Boolean => "BOOLEAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INTEGER" => Some(Self::Integer),
                "FLOAT" => Some(Self::Float),
                "STRING" => Some(Self::String),
                "DATETIME" => Some(Self::Datetime),
                "GEO_COORDINATE" => Some(Self::GeoCoordinate),
                "PROTO_ANY" => Some(Self::ProtoAny),
                "BOOLEAN" => Some(Self::Boolean),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Granularity {
        Unspecified = 0,
        AssetLevel = 1,
        PartitionLevel = 2,
    }
    impl Granularity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Granularity::Unspecified => "GRANULARITY_UNSPECIFIED",
                Granularity::AssetLevel => "GRANULARITY_ASSET_LEVEL",
                Granularity::PartitionLevel => "GRANULARITY_PARTITION_LEVEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GRANULARITY_UNSPECIFIED" => Some(Self::Unspecified),
                "GRANULARITY_ASSET_LEVEL" => Some(Self::AssetLevel),
                "GRANULARITY_PARTITION_LEVEL" => Some(Self::PartitionLevel),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataSchemaRequest {
    #[prost(message, optional, tag = "1")]
    pub data_schema: ::core::option::Option<DataSchema>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_schemas: ::prost::alloc::vec::Vec<DataSchema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnnotationRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub annotation: ::core::option::Option<Annotation>,
    #[prost(string, optional, tag = "3")]
    pub annotation_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Annotation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub user_specified_annotation: ::core::option::Option<UserSpecifiedAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSpecifiedAnnotation {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<AnnotationValue>,
    #[prost(message, optional, tag = "3")]
    pub partition: ::core::option::Option<Partition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoCoordinate {
    #[prost(double, tag = "1")]
    pub latitude: f64,
    #[prost(double, tag = "2")]
    pub longitude: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationValue {
    #[prost(oneof = "annotation_value::Value", tags = "1, 2, 3, 5, 7, 8, 9, 10")]
    pub value: ::core::option::Option<annotation_value::Value>,
}
/// Nested message and enum types in `AnnotationValue`.
pub mod annotation_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "1")]
        IntValue(i64),
        #[prost(float, tag = "2")]
        FloatValue(f32),
        #[prost(string, tag = "3")]
        StrValue(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        DatetimeValue(::prost::alloc::string::String),
        #[prost(message, tag = "7")]
        GeoCoordinate(super::GeoCoordinate),
        #[prost(message, tag = "8")]
        ProtoAnyValue(::prost_types::Any),
        #[prost(bool, tag = "9")]
        BoolValue(bool),
        #[prost(message, tag = "10")]
        CustomizedStructDataValue(::prost_types::Struct),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnnotationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAnnotationRequest {
    #[prost(message, optional, tag = "1")]
    pub annotation: ::core::option::Option<Annotation>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSearchConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub search_config: ::core::option::Option<SearchConfig>,
    #[prost(string, tag = "3")]
    pub search_config_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSearchConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub search_config: ::core::option::Option<SearchConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSearchConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSearchConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSearchConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub search_configs: ::prost::alloc::vec::Vec<SearchConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub facet_property: ::core::option::Option<FacetProperty>,
    #[prost(message, optional, tag = "3")]
    pub search_criteria_property: ::core::option::Option<SearchCriteriaProperty>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetProperty {
    #[prost(string, repeated, tag = "1")]
    pub mapped_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub result_size: i64,
    #[prost(enumeration = "FacetBucketType", tag = "4")]
    pub bucket_type: i32,
    #[prost(oneof = "facet_property::RangeFacetConfig", tags = "5, 6, 7")]
    pub range_facet_config: ::core::option::Option<facet_property::RangeFacetConfig>,
}
/// Nested message and enum types in `FacetProperty`.
pub mod facet_property {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FixedRangeBucketSpec {
        #[prost(message, optional, tag = "1")]
        pub bucket_start: ::core::option::Option<super::FacetValue>,
        #[prost(message, optional, tag = "2")]
        pub bucket_granularity: ::core::option::Option<super::FacetValue>,
        #[prost(int32, tag = "3")]
        pub bucket_count: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomRangeBucketSpec {
        #[prost(message, repeated, tag = "1")]
        pub endpoints: ::prost::alloc::vec::Vec<super::FacetValue>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DateTimeBucketSpec {
        #[prost(enumeration = "date_time_bucket_spec::Granularity", tag = "1")]
        pub granularity: i32,
    }
    /// Nested message and enum types in `DateTimeBucketSpec`.
    pub mod date_time_bucket_spec {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Granularity {
            Unspecified = 0,
            Year = 1,
            Month = 2,
            Day = 3,
        }
        impl Granularity {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Granularity::Unspecified => "GRANULARITY_UNSPECIFIED",
                    Granularity::Year => "YEAR",
                    Granularity::Month => "MONTH",
                    Granularity::Day => "DAY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "GRANULARITY_UNSPECIFIED" => Some(Self::Unspecified),
                    "YEAR" => Some(Self::Year),
                    "MONTH" => Some(Self::Month),
                    "DAY" => Some(Self::Day),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RangeFacetConfig {
        #[prost(message, tag = "5")]
        FixedRangeBucketSpec(FixedRangeBucketSpec),
        #[prost(message, tag = "6")]
        CustomRangeBucketSpec(CustomRangeBucketSpec),
        #[prost(message, tag = "7")]
        DatetimeBucketSpec(DateTimeBucketSpec),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCriteriaProperty {
    #[prost(string, repeated, tag = "1")]
    pub mapped_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetValue {
    #[prost(oneof = "facet_value::Value", tags = "1, 2, 3")]
    pub value: ::core::option::Option<facet_value::Value>,
}
/// Nested message and enum types in `FacetValue`.
pub mod facet_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
        #[prost(int64, tag = "2")]
        IntegerValue(i64),
        #[prost(message, tag = "3")]
        DatetimeValue(super::super::super::super::r#type::DateTime),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetBucket {
    #[prost(bool, tag = "3")]
    pub selected: bool,
    #[prost(oneof = "facet_bucket::BucketValue", tags = "2, 4")]
    pub bucket_value: ::core::option::Option<facet_bucket::BucketValue>,
}
/// Nested message and enum types in `FacetBucket`.
pub mod facet_bucket {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Range {
        #[prost(message, optional, tag = "1")]
        pub start: ::core::option::Option<super::FacetValue>,
        #[prost(message, optional, tag = "2")]
        pub end: ::core::option::Option<super::FacetValue>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BucketValue {
        #[prost(message, tag = "2")]
        Value(super::FacetValue),
        #[prost(message, tag = "4")]
        Range(Range),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetGroup {
    #[prost(string, tag = "1")]
    pub facet_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub buckets: ::prost::alloc::vec::Vec<FacetBucket>,
    #[prost(enumeration = "FacetBucketType", tag = "4")]
    pub bucket_type: i32,
    #[prost(bool, tag = "5")]
    pub fetch_matched_annotations: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestAssetRequest {
    #[prost(oneof = "ingest_asset_request::StreamingRequest", tags = "1, 2")]
    pub streaming_request: ::core::option::Option<
        ingest_asset_request::StreamingRequest,
    >,
}
/// Nested message and enum types in `IngestAssetRequest`.
pub mod ingest_asset_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Config {
        #[prost(string, tag = "1")]
        pub asset: ::prost::alloc::string::String,
        #[prost(oneof = "config::DataType", tags = "2")]
        pub data_type: ::core::option::Option<config::DataType>,
    }
    /// Nested message and enum types in `Config`.
    pub mod config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct VideoType {
            #[prost(enumeration = "video_type::ContainerFormat", tag = "1")]
            pub container_format: i32,
        }
        /// Nested message and enum types in `VideoType`.
        pub mod video_type {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum ContainerFormat {
                Unspecified = 0,
                Mp4 = 1,
            }
            impl ContainerFormat {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        ContainerFormat::Unspecified => "CONTAINER_FORMAT_UNSPECIFIED",
                        ContainerFormat::Mp4 => "CONTAINER_FORMAT_MP4",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CONTAINER_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                        "CONTAINER_FORMAT_MP4" => Some(Self::Mp4),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum DataType {
            #[prost(message, tag = "2")]
            VideoType(VideoType),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimeIndexedData {
        #[prost(bytes = "vec", tag = "1")]
        pub data: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "2")]
        pub temporal_partition: ::core::option::Option<
            super::partition::TemporalPartition,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StreamingRequest {
        #[prost(message, tag = "1")]
        Config(Config),
        #[prost(message, tag = "2")]
        TimeIndexedData(TimeIndexedData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IngestAssetResponse {
    #[prost(message, optional, tag = "1")]
    pub successfully_ingested_partition: ::core::option::Option<
        partition::TemporalPartition,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClipAssetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub temporal_partition: ::core::option::Option<partition::TemporalPartition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClipAssetResponse {
    #[prost(message, repeated, tag = "1")]
    pub time_indexed_uris: ::prost::alloc::vec::Vec<clip_asset_response::TimeIndexedUri>,
}
/// Nested message and enum types in `ClipAssetResponse`.
pub mod clip_asset_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimeIndexedUri {
        #[prost(message, optional, tag = "1")]
        pub temporal_partition: ::core::option::Option<
            super::partition::TemporalPartition,
        >,
        #[prost(string, tag = "2")]
        pub uri: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateHlsUriRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub temporal_partitions: ::prost::alloc::vec::Vec<partition::TemporalPartition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateHlsUriResponse {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub temporal_partitions: ::prost::alloc::vec::Vec<partition::TemporalPartition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAssetsRequest {
    #[prost(string, tag = "1")]
    pub corpus: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub content_time_ranges: ::core::option::Option<DateTimeRangeArray>,
    #[prost(message, repeated, tag = "4")]
    pub criteria: ::prost::alloc::vec::Vec<Criteria>,
    #[prost(message, repeated, tag = "6")]
    pub facet_selections: ::prost::alloc::vec::Vec<FacetGroup>,
    #[prost(string, repeated, tag = "8")]
    pub result_annotation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteAssetMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationMatchingResult {
    #[prost(message, optional, tag = "1")]
    pub criteria: ::core::option::Option<Criteria>,
    #[prost(message, repeated, tag = "2")]
    pub matched_annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResultItem {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(message, repeated, tag = "2")]
    pub segments: ::prost::alloc::vec::Vec<partition::TemporalPartition>,
    #[prost(message, optional, tag = "5")]
    pub segment: ::core::option::Option<partition::TemporalPartition>,
    #[prost(message, repeated, tag = "3")]
    pub requested_annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "4")]
    pub annotation_matching_results: ::prost::alloc::vec::Vec<AnnotationMatchingResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAssetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub search_result_items: ::prost::alloc::vec::Vec<SearchResultItem>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub facet_results: ::prost::alloc::vec::Vec<FacetGroup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IntRange {
    #[prost(int64, optional, tag = "1")]
    pub start: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub end: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FloatRange {
    #[prost(float, optional, tag = "1")]
    pub start: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub end: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringArray {
    #[prost(string, repeated, tag = "1")]
    pub txt_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntRangeArray {
    #[prost(message, repeated, tag = "1")]
    pub int_ranges: ::prost::alloc::vec::Vec<IntRange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloatRangeArray {
    #[prost(message, repeated, tag = "1")]
    pub float_ranges: ::prost::alloc::vec::Vec<FloatRange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DateTimeRange {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<super::super::super::r#type::DateTime>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::super::r#type::DateTime>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DateTimeRangeArray {
    #[prost(message, repeated, tag = "1")]
    pub date_time_ranges: ::prost::alloc::vec::Vec<DateTimeRange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CircleArea {
    #[prost(double, tag = "1")]
    pub latitude: f64,
    #[prost(double, tag = "2")]
    pub longitude: f64,
    #[prost(double, tag = "3")]
    pub radius_meter: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoLocationArray {
    #[prost(message, repeated, tag = "1")]
    pub circle_areas: ::prost::alloc::vec::Vec<CircleArea>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BoolValue {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Criteria {
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub fetch_matched_annotations: bool,
    #[prost(oneof = "criteria::Value", tags = "2, 3, 4, 5, 6, 7")]
    pub value: ::core::option::Option<criteria::Value>,
}
/// Nested message and enum types in `Criteria`.
pub mod criteria {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "2")]
        TextArray(super::StringArray),
        #[prost(message, tag = "3")]
        IntRangeArray(super::IntRangeArray),
        #[prost(message, tag = "4")]
        FloatRangeArray(super::FloatRangeArray),
        #[prost(message, tag = "5")]
        DateTimeRangeArray(super::DateTimeRangeArray),
        #[prost(message, tag = "6")]
        GeoLocationArray(super::GeoLocationArray),
        #[prost(message, tag = "7")]
        BoolValue(super::BoolValue),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Partition {
    #[prost(message, optional, tag = "1")]
    pub temporal_partition: ::core::option::Option<partition::TemporalPartition>,
    #[prost(message, optional, tag = "2")]
    pub spatial_partition: ::core::option::Option<partition::SpatialPartition>,
}
/// Nested message and enum types in `Partition`.
pub mod partition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TemporalPartition {
        #[prost(message, optional, tag = "1")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SpatialPartition {
        #[prost(int64, optional, tag = "1")]
        pub x_min: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "2")]
        pub y_min: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "3")]
        pub x_max: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "4")]
        pub y_max: ::core::option::Option<i64>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FacetBucketType {
    Unspecified = 0,
    Value = 1,
    Datetime = 2,
    FixedRange = 3,
    CustomRange = 4,
}
impl FacetBucketType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FacetBucketType::Unspecified => "FACET_BUCKET_TYPE_UNSPECIFIED",
            FacetBucketType::Value => "FACET_BUCKET_TYPE_VALUE",
            FacetBucketType::Datetime => "FACET_BUCKET_TYPE_DATETIME",
            FacetBucketType::FixedRange => "FACET_BUCKET_TYPE_FIXED_RANGE",
            FacetBucketType::CustomRange => "FACET_BUCKET_TYPE_CUSTOM_RANGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FACET_BUCKET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FACET_BUCKET_TYPE_VALUE" => Some(Self::Value),
            "FACET_BUCKET_TYPE_DATETIME" => Some(Self::Datetime),
            "FACET_BUCKET_TYPE_FIXED_RANGE" => Some(Self::FixedRange),
            "FACET_BUCKET_TYPE_CUSTOM_RANGE" => Some(Self::CustomRange),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod warehouse_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service that manages media content + metadata for streaming.
    #[derive(Debug, Clone)]
    pub struct WarehouseClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> WarehouseClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WarehouseClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            WarehouseClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates an asset inside corpus.
        pub async fn create_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAssetRequest>,
        ) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/CreateAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "CreateAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an asset inside corpus.
        pub async fn update_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAssetRequest>,
        ) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/UpdateAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "UpdateAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reads an asset inside corpus.
        pub async fn get_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetRequest>,
        ) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/GetAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "GetAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists an list of assets inside corpus.
        pub async fn list_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/ListAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "ListAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes asset inside corpus.
        pub async fn delete_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/DeleteAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "DeleteAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a corpus inside a project.
        pub async fn create_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCorpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/CreateCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "CreateCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets corpus details inside a project.
        pub async fn get_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCorpusRequest>,
        ) -> std::result::Result<tonic::Response<super::Corpus>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/GetCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "GetCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a corpus in a project.
        pub async fn update_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCorpusRequest>,
        ) -> std::result::Result<tonic::Response<super::Corpus>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/UpdateCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "UpdateCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all corpora in a project.
        pub async fn list_corpora(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCorporaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCorporaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/ListCorpora",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "ListCorpora",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a corpus only if its empty.
        /// Returns empty response.
        pub async fn delete_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCorpusRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/DeleteCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "DeleteCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates data schema inside corpus.
        pub async fn create_data_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::DataSchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/CreateDataSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "CreateDataSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates data schema inside corpus.
        pub async fn update_data_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::DataSchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/UpdateDataSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "UpdateDataSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets data schema inside corpus.
        pub async fn get_data_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::DataSchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/GetDataSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "GetDataSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes data schema inside corpus.
        pub async fn delete_data_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataSchemaRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/DeleteDataSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "DeleteDataSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists a list of data schemas inside corpus.
        pub async fn list_data_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataSchemasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/ListDataSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "ListDataSchemas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates annotation inside asset.
        pub async fn create_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Annotation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/CreateAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "CreateAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reads annotation inside asset.
        pub async fn get_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Annotation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/GetAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "GetAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists a list of annotations inside asset.
        pub async fn list_annotations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnnotationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAnnotationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/ListAnnotations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "ListAnnotations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates annotation inside asset.
        pub async fn update_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Annotation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/UpdateAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "UpdateAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes annotation inside asset.
        pub async fn delete_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/DeleteAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "DeleteAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Ingests data for the asset. It is not allowed to ingest a data chunk which
        /// is already expired according to TTL.
        /// This method is only available via the gRPC API (not HTTP since
        /// bi-directional streaming is not supported via HTTP).
        pub async fn ingest_asset(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::IngestAssetRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::IngestAssetResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/IngestAsset",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "IngestAsset",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Generates clips for downloading. The api takes in a time range, and
        /// generates a clip of the first content available after start_time and
        /// before end_time, which may overflow beyond these bounds.
        /// Returned clips are truncated if the total size of the clips are larger
        /// than 100MB.
        pub async fn clip_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::ClipAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClipAssetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/ClipAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "ClipAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a uri for an HLS manifest. The api takes in a collection of time
        /// ranges, and generates a URI for an HLS manifest that covers all the
        /// requested time ranges.
        pub async fn generate_hls_uri(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateHlsUriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateHlsUriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/GenerateHlsUri",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "GenerateHlsUri",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a search configuration inside a corpus.
        ///
        /// Please follow the rules below to create a valid CreateSearchConfigRequest.
        /// --- General Rules ---
        ///
        /// 1. Request.search_config_id must not be associated with an existing
        ///   SearchConfig.
        /// 1. Request must contain at least one non-empty search_criteria_property or
        ///   facet_property.
        /// 1. mapped_fields must not be empty, and must map to existing UGA keys.
        /// 1. All mapped_fields must be of the same type.
        /// 1. All mapped_fields must share the same granularity.
        /// 1. All mapped_fields must share the same semantic SearchConfig match
        ///   options.
        ///   For property-specific rules, please reference the comments for
        ///   FacetProperty and SearchCriteriaProperty.
        pub async fn create_search_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSearchConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/CreateSearchConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "CreateSearchConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a search configuration inside a corpus.
        ///
        /// Please follow the rules below to create a valid UpdateSearchConfigRequest.
        /// --- General Rules ---
        ///
        /// 1. Request.search_configuration.name must already exist.
        /// 1. Request must contain at least one non-empty search_criteria_property or
        ///   facet_property.
        /// 1. mapped_fields must not be empty, and must map to existing UGA keys.
        /// 1. All mapped_fields must be of the same type.
        /// 1. All mapped_fields must share the same granularity.
        /// 1. All mapped_fields must share the same semantic SearchConfig match
        ///   options.
        ///   For property-specific rules, please reference the comments for
        ///   FacetProperty and SearchCriteriaProperty.
        pub async fn update_search_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSearchConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/UpdateSearchConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "UpdateSearchConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a search configuration inside a corpus.
        pub async fn get_search_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/GetSearchConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "GetSearchConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a search configuration inside a corpus.
        ///
        /// For a DeleteSearchConfigRequest to be valid,
        /// Request.search_configuration.name must already exist.
        pub async fn delete_search_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSearchConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/DeleteSearchConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "DeleteSearchConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all search configurations inside a corpus.
        pub async fn list_search_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSearchConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSearchConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/ListSearchConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "ListSearchConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Search media asset.
        pub async fn search_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.Warehouse/SearchAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.Warehouse",
                        "SearchAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeValue {
    #[prost(oneof = "attribute_value::Value", tags = "1, 2, 3, 4")]
    pub value: ::core::option::Option<attribute_value::Value>,
}
/// Nested message and enum types in `AttributeValue`.
pub mod attribute_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "1")]
        I(i64),
        #[prost(float, tag = "2")]
        F(f32),
        #[prost(bool, tag = "3")]
        B(bool),
        #[prost(bytes, tag = "4")]
        S(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerDefinition {
    #[prost(string, tag = "1")]
    pub analyzer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub operator: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub inputs: ::prost::alloc::vec::Vec<analyzer_definition::StreamInput>,
    #[prost(map = "string, message", tag = "4")]
    pub attrs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValue,
    >,
    #[prost(message, optional, tag = "5")]
    pub debug_options: ::core::option::Option<analyzer_definition::DebugOptions>,
}
/// Nested message and enum types in `AnalyzerDefinition`.
pub mod analyzer_definition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StreamInput {
        #[prost(string, tag = "1")]
        pub input: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DebugOptions {
        #[prost(map = "string, string", tag = "1")]
        pub environment_variables: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisDefinition {
    #[prost(message, repeated, tag = "1")]
    pub analyzers: ::prost::alloc::vec::Vec<AnalyzerDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalProtectiveEquipmentDetectionOutput {
    #[prost(message, optional, tag = "1")]
    pub current_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "2")]
    pub detected_persons: ::prost::alloc::vec::Vec<
        personal_protective_equipment_detection_output::DetectedPerson,
    >,
}
/// Nested message and enum types in `PersonalProtectiveEquipmentDetectionOutput`.
pub mod personal_protective_equipment_detection_output {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PersonEntity {
        #[prost(int64, tag = "1")]
        pub person_entity_id: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PpeEntity {
        #[prost(int64, tag = "1")]
        pub ppe_label_id: i64,
        #[prost(string, tag = "2")]
        pub ppe_label_string: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub ppe_supercategory_label_string: ::prost::alloc::string::String,
        #[prost(int64, tag = "4")]
        pub ppe_entity_id: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NormalizedBoundingBox {
        #[prost(float, tag = "1")]
        pub xmin: f32,
        #[prost(float, tag = "2")]
        pub ymin: f32,
        #[prost(float, tag = "3")]
        pub width: f32,
        #[prost(float, tag = "4")]
        pub height: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PersonIdentifiedBox {
        #[prost(int64, tag = "1")]
        pub box_id: i64,
        #[prost(message, optional, tag = "2")]
        pub normalized_bounding_box: ::core::option::Option<NormalizedBoundingBox>,
        #[prost(float, tag = "3")]
        pub confidence_score: f32,
        #[prost(message, optional, tag = "4")]
        pub person_entity: ::core::option::Option<PersonEntity>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PpeIdentifiedBox {
        #[prost(int64, tag = "1")]
        pub box_id: i64,
        #[prost(message, optional, tag = "2")]
        pub normalized_bounding_box: ::core::option::Option<NormalizedBoundingBox>,
        #[prost(float, tag = "3")]
        pub confidence_score: f32,
        #[prost(message, optional, tag = "4")]
        pub ppe_entity: ::core::option::Option<PpeEntity>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetectedPerson {
        #[prost(int64, tag = "1")]
        pub person_id: i64,
        #[prost(message, optional, tag = "2")]
        pub detected_person_identified_box: ::core::option::Option<PersonIdentifiedBox>,
        #[prost(message, repeated, tag = "3")]
        pub detected_ppe_identified_boxes: ::prost::alloc::vec::Vec<PpeIdentifiedBox>,
        #[prost(float, optional, tag = "4")]
        pub face_coverage_score: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "5")]
        pub eyes_coverage_score: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "6")]
        pub head_coverage_score: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "7")]
        pub hands_coverage_score: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "8")]
        pub body_coverage_score: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "9")]
        pub feet_coverage_score: ::core::option::Option<f32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectDetectionPredictionResult {
    #[prost(message, optional, tag = "1")]
    pub current_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "2")]
    pub identified_boxes: ::prost::alloc::vec::Vec<
        object_detection_prediction_result::IdentifiedBox,
    >,
}
/// Nested message and enum types in `ObjectDetectionPredictionResult`.
pub mod object_detection_prediction_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entity {
        #[prost(int64, tag = "1")]
        pub label_id: i64,
        #[prost(string, tag = "2")]
        pub label_string: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdentifiedBox {
        #[prost(int64, tag = "1")]
        pub box_id: i64,
        #[prost(message, optional, tag = "2")]
        pub normalized_bounding_box: ::core::option::Option<
            identified_box::NormalizedBoundingBox,
        >,
        #[prost(float, tag = "3")]
        pub confidence_score: f32,
        #[prost(message, optional, tag = "4")]
        pub entity: ::core::option::Option<Entity>,
    }
    /// Nested message and enum types in `IdentifiedBox`.
    pub mod identified_box {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NormalizedBoundingBox {
            #[prost(float, tag = "1")]
            pub xmin: f32,
            #[prost(float, tag = "2")]
            pub ymin: f32,
            #[prost(float, tag = "3")]
            pub width: f32,
            #[prost(float, tag = "4")]
            pub height: f32,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageObjectDetectionPredictionResult {
    #[prost(int64, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "2")]
    pub display_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(float, repeated, tag = "3")]
    pub confidences: ::prost::alloc::vec::Vec<f32>,
    #[prost(message, repeated, tag = "4")]
    pub bboxes: ::prost::alloc::vec::Vec<::prost_types::ListValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassificationPredictionResult {
    #[prost(int64, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "2")]
    pub display_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(float, repeated, tag = "3")]
    pub confidences: ::prost::alloc::vec::Vec<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSegmentationPredictionResult {
    #[prost(string, tag = "1")]
    pub category_mask: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub confidence_mask: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoActionRecognitionPredictionResult {
    #[prost(message, optional, tag = "1")]
    pub segment_start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub segment_end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "3")]
    pub actions: ::prost::alloc::vec::Vec<
        video_action_recognition_prediction_result::IdentifiedAction,
    >,
}
/// Nested message and enum types in `VideoActionRecognitionPredictionResult`.
pub mod video_action_recognition_prediction_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdentifiedAction {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(float, tag = "3")]
        pub confidence: f32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoObjectTrackingPredictionResult {
    #[prost(message, optional, tag = "1")]
    pub segment_start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub segment_end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "3")]
    pub objects: ::prost::alloc::vec::Vec<
        video_object_tracking_prediction_result::DetectedObject,
    >,
}
/// Nested message and enum types in `VideoObjectTrackingPredictionResult`.
pub mod video_object_tracking_prediction_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BoundingBox {
        #[prost(float, tag = "1")]
        pub x_min: f32,
        #[prost(float, tag = "2")]
        pub x_max: f32,
        #[prost(float, tag = "3")]
        pub y_min: f32,
        #[prost(float, tag = "4")]
        pub y_max: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetectedObject {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub bounding_box: ::core::option::Option<BoundingBox>,
        #[prost(float, tag = "4")]
        pub confidence: f32,
        #[prost(int64, tag = "5")]
        pub track_id: i64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoClassificationPredictionResult {
    #[prost(message, optional, tag = "1")]
    pub segment_start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub segment_end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "3")]
    pub classifications: ::prost::alloc::vec::Vec<
        video_classification_prediction_result::IdentifiedClassification,
    >,
}
/// Nested message and enum types in `VideoClassificationPredictionResult`.
pub mod video_classification_prediction_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdentifiedClassification {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(float, tag = "3")]
        pub confidence: f32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OccupancyCountingPredictionResult {
    #[prost(message, optional, tag = "1")]
    pub current_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "2")]
    pub identified_boxes: ::prost::alloc::vec::Vec<
        occupancy_counting_prediction_result::IdentifiedBox,
    >,
    #[prost(message, optional, tag = "3")]
    pub stats: ::core::option::Option<occupancy_counting_prediction_result::Stats>,
    #[prost(message, repeated, tag = "4")]
    pub track_info: ::prost::alloc::vec::Vec<
        occupancy_counting_prediction_result::TrackInfo,
    >,
    #[prost(message, repeated, tag = "5")]
    pub dwell_time_info: ::prost::alloc::vec::Vec<
        occupancy_counting_prediction_result::DwellTimeInfo,
    >,
}
/// Nested message and enum types in `OccupancyCountingPredictionResult`.
pub mod occupancy_counting_prediction_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entity {
        #[prost(int64, tag = "1")]
        pub label_id: i64,
        #[prost(string, tag = "2")]
        pub label_string: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdentifiedBox {
        #[prost(int64, tag = "1")]
        pub box_id: i64,
        #[prost(message, optional, tag = "2")]
        pub normalized_bounding_box: ::core::option::Option<
            identified_box::NormalizedBoundingBox,
        >,
        #[prost(float, tag = "3")]
        pub score: f32,
        #[prost(message, optional, tag = "4")]
        pub entity: ::core::option::Option<Entity>,
        #[prost(int64, tag = "5")]
        pub track_id: i64,
    }
    /// Nested message and enum types in `IdentifiedBox`.
    pub mod identified_box {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NormalizedBoundingBox {
            #[prost(float, tag = "1")]
            pub xmin: f32,
            #[prost(float, tag = "2")]
            pub ymin: f32,
            #[prost(float, tag = "3")]
            pub width: f32,
            #[prost(float, tag = "4")]
            pub height: f32,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Stats {
        #[prost(message, repeated, tag = "1")]
        pub full_frame_count: ::prost::alloc::vec::Vec<stats::ObjectCount>,
        #[prost(message, repeated, tag = "2")]
        pub crossing_line_counts: ::prost::alloc::vec::Vec<stats::CrossingLineCount>,
        #[prost(message, repeated, tag = "3")]
        pub active_zone_counts: ::prost::alloc::vec::Vec<stats::ActiveZoneCount>,
    }
    /// Nested message and enum types in `Stats`.
    pub mod stats {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ObjectCount {
            #[prost(message, optional, tag = "1")]
            pub entity: ::core::option::Option<super::Entity>,
            #[prost(int32, tag = "2")]
            pub count: i32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AccumulatedObjectCount {
            #[prost(message, optional, tag = "1")]
            pub start_time: ::core::option::Option<::prost_types::Timestamp>,
            #[prost(message, optional, tag = "2")]
            pub object_count: ::core::option::Option<ObjectCount>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CrossingLineCount {
            #[prost(message, optional, tag = "1")]
            pub annotation: ::core::option::Option<super::super::StreamAnnotation>,
            #[prost(message, repeated, tag = "2")]
            pub positive_direction_counts: ::prost::alloc::vec::Vec<ObjectCount>,
            #[prost(message, repeated, tag = "3")]
            pub negative_direction_counts: ::prost::alloc::vec::Vec<ObjectCount>,
            #[prost(message, repeated, tag = "4")]
            pub accumulated_positive_direction_counts: ::prost::alloc::vec::Vec<
                AccumulatedObjectCount,
            >,
            #[prost(message, repeated, tag = "5")]
            pub accumulated_negative_direction_counts: ::prost::alloc::vec::Vec<
                AccumulatedObjectCount,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ActiveZoneCount {
            #[prost(message, optional, tag = "1")]
            pub annotation: ::core::option::Option<super::super::StreamAnnotation>,
            #[prost(message, repeated, tag = "2")]
            pub counts: ::prost::alloc::vec::Vec<ObjectCount>,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TrackInfo {
        #[prost(string, tag = "1")]
        pub track_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DwellTimeInfo {
        #[prost(string, tag = "1")]
        pub track_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub zone_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub dwell_start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "4")]
        pub dwell_end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamAnnotation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_stream: ::prost::alloc::string::String,
    #[prost(enumeration = "StreamAnnotationType", tag = "4")]
    pub r#type: i32,
    #[prost(oneof = "stream_annotation::AnnotationPayload", tags = "5, 6")]
    pub annotation_payload: ::core::option::Option<stream_annotation::AnnotationPayload>,
}
/// Nested message and enum types in `StreamAnnotation`.
pub mod stream_annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AnnotationPayload {
        #[prost(message, tag = "5")]
        ActiveZone(super::NormalizedPolygon),
        #[prost(message, tag = "6")]
        CrossingLine(super::NormalizedPolyline),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamAnnotations {
    #[prost(message, repeated, tag = "1")]
    pub stream_annotations: ::prost::alloc::vec::Vec<StreamAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedPolygon {
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedPolyline {
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedVertex {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppPlatformMetadata {
    #[prost(string, tag = "1")]
    pub application: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub node: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub processor: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppPlatformCloudFunctionRequest {
    #[prost(message, optional, tag = "1")]
    pub app_platform_metadata: ::core::option::Option<AppPlatformMetadata>,
    #[prost(message, repeated, tag = "2")]
    pub annotations: ::prost::alloc::vec::Vec<
        app_platform_cloud_function_request::StructedInputAnnotation,
    >,
}
/// Nested message and enum types in `AppPlatformCloudFunctionRequest`.
pub mod app_platform_cloud_function_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StructedInputAnnotation {
        #[prost(int64, tag = "1")]
        pub ingestion_time_micros: i64,
        #[prost(message, optional, tag = "2")]
        pub annotation: ::core::option::Option<::prost_types::Struct>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppPlatformCloudFunctionResponse {
    #[prost(message, repeated, tag = "2")]
    pub annotations: ::prost::alloc::vec::Vec<
        app_platform_cloud_function_response::StructedOutputAnnotation,
    >,
    #[prost(bool, tag = "3")]
    pub annotation_passthrough: bool,
    #[prost(message, repeated, tag = "4")]
    pub events: ::prost::alloc::vec::Vec<AppPlatformEventBody>,
}
/// Nested message and enum types in `AppPlatformCloudFunctionResponse`.
pub mod app_platform_cloud_function_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StructedOutputAnnotation {
        #[prost(message, optional, tag = "1")]
        pub annotation: ::core::option::Option<::prost_types::Struct>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppPlatformEventBody {
    #[prost(string, tag = "1")]
    pub event_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub payload: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "3")]
    pub event_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamAnnotationType {
    Unspecified = 0,
    ActiveZone = 1,
    CrossingLine = 2,
}
impl StreamAnnotationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StreamAnnotationType::Unspecified => "STREAM_ANNOTATION_TYPE_UNSPECIFIED",
            StreamAnnotationType::ActiveZone => "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE",
            StreamAnnotationType::CrossingLine => "STREAM_ANNOTATION_TYPE_CROSSING_LINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_ANNOTATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE" => Some(Self::ActiveZone),
            "STREAM_ANNOTATION_TYPE_CROSSING_LINE" => Some(Self::CrossingLine),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub dataplane_service_endpoint: ::prost::alloc::string::String,
    #[prost(enumeration = "cluster::State", tag = "7")]
    pub state: i32,
    #[prost(string, tag = "8")]
    pub psc_target: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Provisioning = 1,
        Running = 2,
        Stopping = 3,
        Error = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Provisioning => "PROVISIONING",
                State::Running => "RUNNING",
                State::Stopping => "STOPPING",
                State::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "RUNNING" => Some(Self::Running),
                "STOPPING" => Some(Self::Stopping),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    #[prost(string, repeated, tag = "1")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteApplicationInstancesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateApplicationInstancesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateApplicationInstancesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApplicationInstancesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub application_instances: ::prost::alloc::vec::Vec<ApplicationInstance>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteApplicationInstancesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub instance_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeployApplicationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UndeployApplicationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveApplicationStreamInputResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddApplicationStreamInputResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateApplicationStreamInputResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApplicationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApplicationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub applications: ::prost::alloc::vec::Vec<Application>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApplicationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApplicationRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub application_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub application: ::core::option::Option<Application>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApplicationRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub application: ::core::option::Option<Application>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteApplicationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployApplicationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub validate_only: bool,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub enable_monitoring: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployApplicationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationStreamInput {
    #[prost(message, optional, tag = "1")]
    pub stream_with_annotation: ::core::option::Option<StreamWithAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddApplicationStreamInputRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub application_stream_inputs: ::prost::alloc::vec::Vec<ApplicationStreamInput>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApplicationStreamInputRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub application_stream_inputs: ::prost::alloc::vec::Vec<ApplicationStreamInput>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveApplicationStreamInputRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub target_stream_inputs: ::prost::alloc::vec::Vec<
        remove_application_stream_input_request::TargetStreamInput,
    >,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RemoveApplicationStreamInputRequest`.
pub mod remove_application_stream_input_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TargetStreamInput {
        #[prost(string, tag = "1")]
        pub stream: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesResponse {
    #[prost(message, repeated, tag = "1")]
    pub instances: ::prost::alloc::vec::Vec<Instance>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDraftsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDraftsResponse {
    #[prost(message, repeated, tag = "1")]
    pub drafts: ::prost::alloc::vec::Vec<Draft>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDraftRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDraftRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub draft_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub draft: ::core::option::Option<Draft>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDraftRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub draft: ::core::option::Option<Draft>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApplicationInstancesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub application_instances: ::prost::alloc::vec::Vec<
        update_application_instances_request::UpdateApplicationInstance,
    >,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
}
/// Nested message and enum types in `UpdateApplicationInstancesRequest`.
pub mod update_application_instances_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateApplicationInstance {
        #[prost(message, optional, tag = "1")]
        pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
        #[prost(message, optional, tag = "2")]
        pub instance: ::core::option::Option<super::Instance>,
        #[prost(string, tag = "3")]
        pub instance_id: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDraftRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProcessorsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProcessorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub processors: ::prost::alloc::vec::Vec<Processor>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrebuiltProcessorsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrebuiltProcessorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub processors: ::prost::alloc::vec::Vec<Processor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProcessorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProcessorRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub processor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub processor: ::core::option::Option<Processor>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProcessorRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub processor: ::core::option::Option<Processor>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteProcessorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Application {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub application_configs: ::core::option::Option<ApplicationConfigs>,
    #[prost(message, optional, tag = "8")]
    pub runtime_info: ::core::option::Option<application::ApplicationRuntimeInfo>,
    #[prost(enumeration = "application::State", tag = "9")]
    pub state: i32,
}
/// Nested message and enum types in `Application`.
pub mod application {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApplicationRuntimeInfo {
        #[prost(message, optional, tag = "1")]
        pub deploy_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, repeated, tag = "3")]
        pub global_output_resources: ::prost::alloc::vec::Vec<
            application_runtime_info::GlobalOutputResource,
        >,
        #[prost(message, optional, tag = "4")]
        pub monitoring_config: ::core::option::Option<
            application_runtime_info::MonitoringConfig,
        >,
    }
    /// Nested message and enum types in `ApplicationRuntimeInfo`.
    pub mod application_runtime_info {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GlobalOutputResource {
            #[prost(string, tag = "1")]
            pub output_resource: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub producer_node: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub key: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MonitoringConfig {
            #[prost(bool, tag = "1")]
            pub enabled: bool,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Created = 1,
        Deploying = 2,
        Deployed = 3,
        Undeploying = 4,
        Deleted = 5,
        Error = 6,
        Creating = 7,
        Updating = 8,
        Deleting = 9,
        Fixing = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Created => "CREATED",
                State::Deploying => "DEPLOYING",
                State::Deployed => "DEPLOYED",
                State::Undeploying => "UNDEPLOYING",
                State::Deleted => "DELETED",
                State::Error => "ERROR",
                State::Creating => "CREATING",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Fixing => "FIXING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATED" => Some(Self::Created),
                "DEPLOYING" => Some(Self::Deploying),
                "DEPLOYED" => Some(Self::Deployed),
                "UNDEPLOYING" => Some(Self::Undeploying),
                "DELETED" => Some(Self::Deleted),
                "ERROR" => Some(Self::Error),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FIXING" => Some(Self::Fixing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationConfigs {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, optional, tag = "3")]
    pub event_delivery_config: ::core::option::Option<
        application_configs::EventDeliveryConfig,
    >,
}
/// Nested message and enum types in `ApplicationConfigs`.
pub mod application_configs {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EventDeliveryConfig {
        #[prost(string, tag = "1")]
        pub channel: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub minimal_delivery_interval: ::core::option::Option<::prost_types::Duration>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub node_config: ::core::option::Option<ProcessorConfig>,
    #[prost(string, tag = "4")]
    pub processor: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub parents: ::prost::alloc::vec::Vec<node::InputEdge>,
    #[prost(oneof = "node::StreamOutputConfig", tags = "6")]
    pub stream_output_config: ::core::option::Option<node::StreamOutputConfig>,
}
/// Nested message and enum types in `Node`.
pub mod node {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputEdge {
        #[prost(string, tag = "1")]
        pub parent_node: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub parent_output_channel: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub connected_input_channel: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum StreamOutputConfig {
        #[prost(bool, tag = "6")]
        OutputAllOutputChannelsToStream(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Draft {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub draft_application_configs: ::core::option::Option<ApplicationConfigs>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub input_resources: ::prost::alloc::vec::Vec<instance::InputResource>,
    #[prost(message, repeated, tag = "7")]
    pub output_resources: ::prost::alloc::vec::Vec<instance::OutputResource>,
    #[prost(enumeration = "instance::State", tag = "9")]
    pub state: i32,
}
/// Nested message and enum types in `Instance`.
pub mod instance {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputResource {
        #[prost(string, tag = "2")]
        pub consumer_node: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub input_resource_binding: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub annotations: ::core::option::Option<super::ResourceAnnotations>,
        #[prost(oneof = "input_resource::InputResourceInformation", tags = "1, 4")]
        pub input_resource_information: ::core::option::Option<
            input_resource::InputResourceInformation,
        >,
    }
    /// Nested message and enum types in `InputResource`.
    pub mod input_resource {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum InputResourceInformation {
            #[prost(string, tag = "1")]
            InputResource(::prost::alloc::string::String),
            #[prost(message, tag = "4")]
            AnnotatedStream(super::super::StreamWithAnnotation),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OutputResource {
        #[prost(string, tag = "1")]
        pub output_resource: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub producer_node: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub output_resource_binding: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub is_temporary: bool,
        #[prost(bool, tag = "5")]
        pub autogen: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Created = 2,
        Deploying = 3,
        Deployed = 4,
        Undeploying = 5,
        Deleted = 6,
        Error = 7,
        Updating = 8,
        Deleting = 9,
        Fixing = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Created => "CREATED",
                State::Deploying => "DEPLOYING",
                State::Deployed => "DEPLOYED",
                State::Undeploying => "UNDEPLOYING",
                State::Deleted => "DELETED",
                State::Error => "ERROR",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Fixing => "FIXING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "CREATED" => Some(Self::Created),
                "DEPLOYING" => Some(Self::Deploying),
                "DEPLOYED" => Some(Self::Deployed),
                "UNDEPLOYING" => Some(Self::Undeploying),
                "DELETED" => Some(Self::Deleted),
                "ERROR" => Some(Self::Error),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FIXING" => Some(Self::Fixing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationInstance {
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<Instance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Processor {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "processor::ProcessorType", tag = "6")]
    pub processor_type: i32,
    #[prost(enumeration = "ModelType", tag = "13")]
    pub model_type: i32,
    #[prost(message, optional, tag = "7")]
    pub custom_processor_source_info: ::core::option::Option<CustomProcessorSourceInfo>,
    #[prost(enumeration = "processor::ProcessorState", tag = "8")]
    pub state: i32,
    #[prost(message, optional, tag = "11")]
    pub processor_io_spec: ::core::option::Option<ProcessorIoSpec>,
    #[prost(string, tag = "14")]
    pub configuration_typeurl: ::prost::alloc::string::String,
    #[prost(
        enumeration = "StreamAnnotationType",
        repeated,
        packed = "false",
        tag = "15"
    )]
    pub supported_annotation_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "17")]
    pub supports_post_processing: bool,
}
/// Nested message and enum types in `Processor`.
pub mod processor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessorType {
        Unspecified = 0,
        Pretrained = 1,
        Custom = 2,
        Connector = 3,
    }
    impl ProcessorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProcessorType::Unspecified => "PROCESSOR_TYPE_UNSPECIFIED",
                ProcessorType::Pretrained => "PRETRAINED",
                ProcessorType::Custom => "CUSTOM",
                ProcessorType::Connector => "CONNECTOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESSOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRETRAINED" => Some(Self::Pretrained),
                "CUSTOM" => Some(Self::Custom),
                "CONNECTOR" => Some(Self::Connector),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessorState {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Deleting = 3,
        Failed = 4,
    }
    impl ProcessorState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProcessorState::Unspecified => "PROCESSOR_STATE_UNSPECIFIED",
                ProcessorState::Creating => "CREATING",
                ProcessorState::Active => "ACTIVE",
                ProcessorState::Deleting => "DELETING",
                ProcessorState::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESSOR_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorIoSpec {
    #[prost(message, repeated, tag = "3")]
    pub graph_input_channel_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::GraphInputChannelSpec,
    >,
    #[prost(message, repeated, tag = "4")]
    pub graph_output_channel_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::GraphOutputChannelSpec,
    >,
    #[prost(message, repeated, tag = "5")]
    pub instance_resource_input_binding_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::InstanceResourceInputBindingSpec,
    >,
    #[prost(message, repeated, tag = "6")]
    pub instance_resource_output_binding_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::InstanceResourceOutputBindingSpec,
    >,
}
/// Nested message and enum types in `ProcessorIOSpec`.
pub mod processor_io_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GraphInputChannelSpec {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "DataType", tag = "2")]
        pub data_type: i32,
        #[prost(string, repeated, tag = "5")]
        pub accepted_data_type_uris: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(bool, tag = "3")]
        pub required: bool,
        #[prost(int64, tag = "4")]
        pub max_connection_allowed: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GraphOutputChannelSpec {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "DataType", tag = "2")]
        pub data_type: i32,
        #[prost(string, tag = "3")]
        pub data_type_uri: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstanceResourceInputBindingSpec {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(
            oneof = "instance_resource_input_binding_spec::ResourceType",
            tags = "2, 3"
        )]
        pub resource_type: ::core::option::Option<
            instance_resource_input_binding_spec::ResourceType,
        >,
    }
    /// Nested message and enum types in `InstanceResourceInputBindingSpec`.
    pub mod instance_resource_input_binding_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ResourceType {
            #[prost(string, tag = "2")]
            ConfigTypeUri(::prost::alloc::string::String),
            #[prost(string, tag = "3")]
            ResourceTypeUri(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstanceResourceOutputBindingSpec {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub resource_type_uri: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub explicit: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Unspecified = 0,
        Video = 1,
        Proto = 2,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataType::Unspecified => "DATA_TYPE_UNSPECIFIED",
                DataType::Video => "VIDEO",
                DataType::Proto => "PROTO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "VIDEO" => Some(Self::Video),
                "PROTO" => Some(Self::Proto),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomProcessorSourceInfo {
    #[prost(enumeration = "custom_processor_source_info::SourceType", tag = "1")]
    pub source_type: i32,
    #[prost(map = "string, string", tag = "4")]
    pub additional_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "5")]
    pub model_schema: ::core::option::Option<custom_processor_source_info::ModelSchema>,
    #[prost(oneof = "custom_processor_source_info::ArtifactPath", tags = "2")]
    pub artifact_path: ::core::option::Option<
        custom_processor_source_info::ArtifactPath,
    >,
}
/// Nested message and enum types in `CustomProcessorSourceInfo`.
pub mod custom_processor_source_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ModelSchema {
        #[prost(message, optional, tag = "1")]
        pub instances_schema: ::core::option::Option<super::GcsSource>,
        #[prost(message, optional, tag = "2")]
        pub parameters_schema: ::core::option::Option<super::GcsSource>,
        #[prost(message, optional, tag = "3")]
        pub predictions_schema: ::core::option::Option<super::GcsSource>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceType {
        Unspecified = 0,
        VertexAutoml = 1,
        VertexCustom = 2,
    }
    impl SourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceType::Unspecified => "SOURCE_TYPE_UNSPECIFIED",
                SourceType::VertexAutoml => "VERTEX_AUTOML",
                SourceType::VertexCustom => "VERTEX_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "VERTEX_AUTOML" => Some(Self::VertexAutoml),
                "VERTEX_CUSTOM" => Some(Self::VertexCustom),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ArtifactPath {
        #[prost(string, tag = "2")]
        VertexModel(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorConfig {
    #[prost(
        oneof = "processor_config::ProcessorConfig",
        tags = "9, 20, 10, 11, 12, 15, 13, 14, 17, 18, 19, 22"
    )]
    pub processor_config: ::core::option::Option<processor_config::ProcessorConfig>,
}
/// Nested message and enum types in `ProcessorConfig`.
pub mod processor_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ProcessorConfig {
        #[prost(message, tag = "9")]
        VideoStreamInputConfig(super::VideoStreamInputConfig),
        #[prost(message, tag = "20")]
        AiEnabledDevicesInputConfig(super::AiEnabledDevicesInputConfig),
        #[prost(message, tag = "10")]
        MediaWarehouseConfig(super::MediaWarehouseConfig),
        #[prost(message, tag = "11")]
        PersonBlurConfig(super::PersonBlurConfig),
        #[prost(message, tag = "12")]
        OccupancyCountConfig(super::OccupancyCountConfig),
        #[prost(message, tag = "15")]
        PersonVehicleDetectionConfig(super::PersonVehicleDetectionConfig),
        #[prost(message, tag = "13")]
        VertexAutomlVisionConfig(super::VertexAutoMlVisionConfig),
        #[prost(message, tag = "14")]
        VertexAutomlVideoConfig(super::VertexAutoMlVideoConfig),
        #[prost(message, tag = "17")]
        VertexCustomConfig(super::VertexCustomConfig),
        #[prost(message, tag = "18")]
        GeneralObjectDetectionConfig(super::GeneralObjectDetectionConfig),
        #[prost(message, tag = "19")]
        BigQueryConfig(super::BigQueryConfig),
        #[prost(message, tag = "22")]
        PersonalProtectiveEquipmentDetectionConfig(
            super::PersonalProtectiveEquipmentDetectionConfig,
        ),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamWithAnnotation {
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub application_annotations: ::prost::alloc::vec::Vec<StreamAnnotation>,
    #[prost(message, repeated, tag = "3")]
    pub node_annotations: ::prost::alloc::vec::Vec<
        stream_with_annotation::NodeAnnotation,
    >,
}
/// Nested message and enum types in `StreamWithAnnotation`.
pub mod stream_with_annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NodeAnnotation {
        #[prost(string, tag = "1")]
        pub node: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub annotations: ::prost::alloc::vec::Vec<super::StreamAnnotation>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationNodeAnnotation {
    #[prost(string, tag = "1")]
    pub node: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub annotations: ::prost::alloc::vec::Vec<StreamAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceAnnotations {
    #[prost(message, repeated, tag = "1")]
    pub application_annotations: ::prost::alloc::vec::Vec<StreamAnnotation>,
    #[prost(message, repeated, tag = "2")]
    pub node_annotations: ::prost::alloc::vec::Vec<ApplicationNodeAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoStreamInputConfig {
    #[deprecated]
    #[prost(string, repeated, tag = "1")]
    pub streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(message, repeated, tag = "2")]
    pub streams_with_annotation: ::prost::alloc::vec::Vec<StreamWithAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AiEnabledDevicesInputConfig {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaWarehouseConfig {
    #[prost(string, tag = "1")]
    pub corpus: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonBlurConfig {
    #[prost(enumeration = "person_blur_config::PersonBlurType", tag = "1")]
    pub person_blur_type: i32,
    #[prost(bool, tag = "2")]
    pub faces_only: bool,
}
/// Nested message and enum types in `PersonBlurConfig`.
pub mod person_blur_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PersonBlurType {
        Unspecified = 0,
        FullOcculusion = 1,
        BlurFilter = 2,
    }
    impl PersonBlurType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PersonBlurType::Unspecified => "PERSON_BLUR_TYPE_UNSPECIFIED",
                PersonBlurType::FullOcculusion => "FULL_OCCULUSION",
                PersonBlurType::BlurFilter => "BLUR_FILTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERSON_BLUR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL_OCCULUSION" => Some(Self::FullOcculusion),
                "BLUR_FILTER" => Some(Self::BlurFilter),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OccupancyCountConfig {
    #[prost(bool, tag = "1")]
    pub enable_people_counting: bool,
    #[prost(bool, tag = "2")]
    pub enable_vehicle_counting: bool,
    #[prost(bool, tag = "3")]
    pub enable_dwelling_time_tracking: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonVehicleDetectionConfig {
    #[prost(bool, tag = "1")]
    pub enable_people_counting: bool,
    #[prost(bool, tag = "2")]
    pub enable_vehicle_counting: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonalProtectiveEquipmentDetectionConfig {
    #[prost(bool, tag = "1")]
    pub enable_face_coverage_detection: bool,
    #[prost(bool, tag = "2")]
    pub enable_head_coverage_detection: bool,
    #[prost(bool, tag = "3")]
    pub enable_hands_coverage_detection: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeneralObjectDetectionConfig {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryConfig {
    #[prost(string, tag = "1")]
    pub table: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub cloud_function_mapping: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "3")]
    pub create_default_table_if_not_exists: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VertexAutoMlVisionConfig {
    #[prost(float, tag = "1")]
    pub confidence_threshold: f32,
    #[prost(int32, tag = "2")]
    pub max_predictions: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexAutoMlVideoConfig {
    #[prost(float, tag = "1")]
    pub confidence_threshold: f32,
    #[prost(string, repeated, tag = "2")]
    pub blocked_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub max_predictions: i32,
    #[prost(float, tag = "4")]
    pub bounding_box_size_limit: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexCustomConfig {
    #[prost(int32, tag = "1")]
    pub max_prediction_fps: i32,
    #[prost(message, optional, tag = "2")]
    pub dedicated_resources: ::core::option::Option<DedicatedResources>,
    #[prost(string, tag = "3")]
    pub post_processing_cloud_function: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub attach_application_metadata: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineSpec {
    #[prost(string, tag = "1")]
    pub machine_type: ::prost::alloc::string::String,
    #[prost(enumeration = "AcceleratorType", tag = "2")]
    pub accelerator_type: i32,
    #[prost(int32, tag = "3")]
    pub accelerator_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingMetricSpec {
    #[prost(string, tag = "1")]
    pub metric_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub target: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DedicatedResources {
    #[prost(message, optional, tag = "1")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    #[prost(int32, tag = "2")]
    pub min_replica_count: i32,
    #[prost(int32, tag = "3")]
    pub max_replica_count: i32,
    #[prost(message, repeated, tag = "4")]
    pub autoscaling_metric_specs: ::prost::alloc::vec::Vec<AutoscalingMetricSpec>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelType {
    Unspecified = 0,
    ImageClassification = 1,
    ObjectDetection = 2,
    VideoClassification = 3,
    VideoObjectTracking = 4,
    VideoActionRecognition = 5,
    OccupancyCounting = 6,
    PersonBlur = 7,
    VertexCustom = 8,
}
impl ModelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ModelType::Unspecified => "MODEL_TYPE_UNSPECIFIED",
            ModelType::ImageClassification => "IMAGE_CLASSIFICATION",
            ModelType::ObjectDetection => "OBJECT_DETECTION",
            ModelType::VideoClassification => "VIDEO_CLASSIFICATION",
            ModelType::VideoObjectTracking => "VIDEO_OBJECT_TRACKING",
            ModelType::VideoActionRecognition => "VIDEO_ACTION_RECOGNITION",
            ModelType::OccupancyCounting => "OCCUPANCY_COUNTING",
            ModelType::PersonBlur => "PERSON_BLUR",
            ModelType::VertexCustom => "VERTEX_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "IMAGE_CLASSIFICATION" => Some(Self::ImageClassification),
            "OBJECT_DETECTION" => Some(Self::ObjectDetection),
            "VIDEO_CLASSIFICATION" => Some(Self::VideoClassification),
            "VIDEO_OBJECT_TRACKING" => Some(Self::VideoObjectTracking),
            "VIDEO_ACTION_RECOGNITION" => Some(Self::VideoActionRecognition),
            "OCCUPANCY_COUNTING" => Some(Self::OccupancyCounting),
            "PERSON_BLUR" => Some(Self::PersonBlur),
            "VERTEX_CUSTOM" => Some(Self::VertexCustom),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AcceleratorType {
    Unspecified = 0,
    NvidiaTeslaK80 = 1,
    NvidiaTeslaP100 = 2,
    NvidiaTeslaV100 = 3,
    NvidiaTeslaP4 = 4,
    NvidiaTeslaT4 = 5,
    NvidiaTeslaA100 = 8,
    TpuV2 = 6,
    TpuV3 = 7,
}
impl AcceleratorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AcceleratorType::Unspecified => "ACCELERATOR_TYPE_UNSPECIFIED",
            AcceleratorType::NvidiaTeslaK80 => "NVIDIA_TESLA_K80",
            AcceleratorType::NvidiaTeslaP100 => "NVIDIA_TESLA_P100",
            AcceleratorType::NvidiaTeslaV100 => "NVIDIA_TESLA_V100",
            AcceleratorType::NvidiaTeslaP4 => "NVIDIA_TESLA_P4",
            AcceleratorType::NvidiaTeslaT4 => "NVIDIA_TESLA_T4",
            AcceleratorType::NvidiaTeslaA100 => "NVIDIA_TESLA_A100",
            AcceleratorType::TpuV2 => "TPU_V2",
            AcceleratorType::TpuV3 => "TPU_V3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACCELERATOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NVIDIA_TESLA_K80" => Some(Self::NvidiaTeslaK80),
            "NVIDIA_TESLA_P100" => Some(Self::NvidiaTeslaP100),
            "NVIDIA_TESLA_V100" => Some(Self::NvidiaTeslaV100),
            "NVIDIA_TESLA_P4" => Some(Self::NvidiaTeslaP4),
            "NVIDIA_TESLA_T4" => Some(Self::NvidiaTeslaT4),
            "NVIDIA_TESLA_A100" => Some(Self::NvidiaTeslaA100),
            "TPU_V2" => Some(Self::TpuV2),
            "TPU_V3" => Some(Self::TpuV3),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod app_platform_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct AppPlatformClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AppPlatformClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AppPlatformClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AppPlatformClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Applications in a given project and location.
        pub async fn list_applications(
            &mut self,
            request: impl tonic::IntoRequest<super::ListApplicationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListApplicationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/ListApplications",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "ListApplications",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Application.
        pub async fn get_application(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApplicationRequest>,
        ) -> std::result::Result<tonic::Response<super::Application>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/GetApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "GetApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Application in a given project and location.
        pub async fn create_application(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateApplicationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/CreateApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "CreateApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Application.
        pub async fn update_application(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateApplicationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/UpdateApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "UpdateApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Application.
        pub async fn delete_application(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteApplicationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/DeleteApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "DeleteApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deploys a single Application.
        pub async fn deploy_application(
            &mut self,
            request: impl tonic::IntoRequest<super::DeployApplicationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/DeployApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "DeployApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Undeploys a single Application.
        pub async fn undeploy_application(
            &mut self,
            request: impl tonic::IntoRequest<super::UndeployApplicationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/UndeployApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "UndeployApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds target stream input to the Application.
        /// If the Application is deployed, the corresponding new Application instance
        /// will be created. If the stream has already been in the Application, the RPC
        /// will fail.
        pub async fn add_application_stream_input(
            &mut self,
            request: impl tonic::IntoRequest<super::AddApplicationStreamInputRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/AddApplicationStreamInput",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "AddApplicationStreamInput",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Remove target stream input to the Application, if the Application is
        /// deployed, the corresponding instance based will be deleted. If the stream
        /// is not in the Application, the RPC will fail.
        pub async fn remove_application_stream_input(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveApplicationStreamInputRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/RemoveApplicationStreamInput",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "RemoveApplicationStreamInput",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update target stream input to the Application, if the Application is
        /// deployed, the corresponding instance based will be deployed. For
        /// CreateOrUpdate behavior, set allow_missing to true.
        pub async fn update_application_stream_input(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateApplicationStreamInputRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/UpdateApplicationStreamInput",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "UpdateApplicationStreamInput",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Instances in a given project and location.
        pub async fn list_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInstancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/ListInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "ListInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Instance.
        pub async fn get_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Instance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/GetInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "GetInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds target stream input to the Application.
        /// If the Application is deployed, the corresponding new Application instance
        /// will be created. If the stream has already been in the Application, the RPC
        /// will fail.
        pub async fn create_application_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateApplicationInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/CreateApplicationInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "CreateApplicationInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Remove target stream input to the Application, if the Application is
        /// deployed, the corresponding instance based will be deleted. If the stream
        /// is not in the Application, the RPC will fail.
        pub async fn delete_application_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteApplicationInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/DeleteApplicationInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "DeleteApplicationInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds target stream input to the Application.
        /// If the Application is deployed, the corresponding new Application instance
        /// will be created. If the stream has already been in the Application, the RPC
        /// will fail.
        pub async fn update_application_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateApplicationInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/UpdateApplicationInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "UpdateApplicationInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Drafts in a given project and location.
        pub async fn list_drafts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDraftsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDraftsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/ListDrafts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "ListDrafts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Draft.
        pub async fn get_draft(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDraftRequest>,
        ) -> std::result::Result<tonic::Response<super::Draft>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/GetDraft",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "GetDraft",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Draft in a given project and location.
        pub async fn create_draft(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDraftRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/CreateDraft",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "CreateDraft",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Draft.
        pub async fn update_draft(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDraftRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/UpdateDraft",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "UpdateDraft",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Draft.
        pub async fn delete_draft(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDraftRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/DeleteDraft",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "DeleteDraft",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Processors in a given project and location.
        pub async fn list_processors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProcessorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProcessorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/ListProcessors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "ListProcessors",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListPrebuiltProcessors is a custom pass-through verb that Lists Prebuilt
        /// Processors.
        pub async fn list_prebuilt_processors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPrebuiltProcessorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPrebuiltProcessorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/ListPrebuiltProcessors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "ListPrebuiltProcessors",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Processor.
        pub async fn get_processor(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProcessorRequest>,
        ) -> std::result::Result<tonic::Response<super::Processor>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/GetProcessor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "GetProcessor",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Processor in a given project and location.
        pub async fn create_processor(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProcessorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/CreateProcessor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "CreateProcessor",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Processor.
        pub async fn update_processor(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateProcessorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/UpdateProcessor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "UpdateProcessor",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Processor.
        pub async fn delete_processor(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteProcessorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.AppPlatform/DeleteProcessor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.AppPlatform",
                        "DeleteProcessor",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stream {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub enable_hls_playback: bool,
    #[prost(string, tag = "8")]
    pub media_warehouse_asset: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "event::Clock", tag = "6")]
    pub alignment_clock: i32,
    #[prost(message, optional, tag = "7")]
    pub grace_period: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Clock {
        Unspecified = 0,
        Capture = 1,
        Ingest = 2,
    }
    impl Clock {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Clock::Unspecified => "CLOCK_UNSPECIFIED",
                Clock::Capture => "CAPTURE",
                Clock::Ingest => "INGEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLOCK_UNSPECIFIED" => Some(Self::Unspecified),
                "CAPTURE" => Some(Self::Capture),
                "INGEST" => Some(Self::Ingest),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Series {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub stream: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub event: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Channel {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub stream: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub event: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersResponse {
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<Cluster>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClusterRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cluster_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub cluster: ::core::option::Option<Cluster>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClusterRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub cluster: ::core::option::Option<Cluster>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteClusterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStreamsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStreamsResponse {
    #[prost(message, repeated, tag = "1")]
    pub streams: ::prost::alloc::vec::Vec<Stream>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStreamRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStreamRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub stream: ::core::option::Option<Stream>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStreamRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub stream: ::core::option::Option<Stream>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStreamRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStreamThumbnailResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateStreamHlsTokenRequest {
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateStreamHlsTokenResponse {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEventRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub event: ::core::option::Option<Event>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEventRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub event: ::core::option::Option<Event>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEventRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSeriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSeriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub series: ::prost::alloc::vec::Vec<Series>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSeriesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSeriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub series_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub series: ::core::option::Option<Series>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSeriesRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub series: ::core::option::Option<Series>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSeriesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaterializeChannelRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub channel: ::core::option::Option<Channel>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod streams_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources.
    /// Vision API and Vision AI API are two independent APIs developed by the same
    /// team. Vision API is for people to annotate their image while Vision AI is an
    /// e2e solution for customer to build their own computer vision application.
    #[derive(Debug, Clone)]
    pub struct StreamsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> StreamsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StreamsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            StreamsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Clusters in a given project and location.
        pub async fn list_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/ListClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "ListClusters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Cluster.
        pub async fn get_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::Cluster>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/GetCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "GetCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Cluster in a given project and location.
        pub async fn create_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/CreateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "CreateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Cluster.
        pub async fn update_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/UpdateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "UpdateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Cluster.
        pub async fn delete_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/DeleteCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "DeleteCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Streams in a given project and location.
        pub async fn list_streams(
            &mut self,
            request: impl tonic::IntoRequest<super::ListStreamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListStreamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/ListStreams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "ListStreams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Stream.
        pub async fn get_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStreamRequest>,
        ) -> std::result::Result<tonic::Response<super::Stream>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/GetStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "GetStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Stream in a given project and location.
        pub async fn create_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/CreateStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "CreateStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Stream.
        pub async fn update_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/UpdateStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "UpdateStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Stream.
        pub async fn delete_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/DeleteStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "DeleteStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generate the JWT auth token required to get the stream HLS contents.
        pub async fn generate_stream_hls_token(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateStreamHlsTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateStreamHlsTokenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/GenerateStreamHlsToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "GenerateStreamHlsToken",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Events in a given project and location.
        pub async fn list_events(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/ListEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "ListEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Event.
        pub async fn get_event(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventRequest>,
        ) -> std::result::Result<tonic::Response<super::Event>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/GetEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "GetEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Event in a given project and location.
        pub async fn create_event(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/CreateEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "CreateEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Event.
        pub async fn update_event(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/UpdateEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "UpdateEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Event.
        pub async fn delete_event(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/DeleteEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "DeleteEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Series in a given project and location.
        pub async fn list_series(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSeriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSeriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/ListSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "ListSeries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Series.
        pub async fn get_series(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSeriesRequest>,
        ) -> std::result::Result<tonic::Response<super::Series>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/GetSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "GetSeries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Series in a given project and location.
        pub async fn create_series(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSeriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/CreateSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "CreateSeries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Event.
        pub async fn update_series(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSeriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/UpdateSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "UpdateSeries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Series.
        pub async fn delete_series(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSeriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/DeleteSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "DeleteSeries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Materialize a channel.
        pub async fn materialize_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::MaterializeChannelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamsService/MaterializeChannel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamsService",
                        "MaterializeChannel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GstreamerBufferDescriptor {
    #[prost(string, tag = "1")]
    pub caps_string: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_key_frame: bool,
    #[prost(message, optional, tag = "3")]
    pub pts_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub dts_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawImageDescriptor {
    #[prost(string, tag = "1")]
    pub format: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub height: i32,
    #[prost(int32, tag = "3")]
    pub width: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketType {
    #[prost(string, tag = "1")]
    pub type_class: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub type_descriptor: ::core::option::Option<packet_type::TypeDescriptor>,
}
/// Nested message and enum types in `PacketType`.
pub mod packet_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TypeDescriptor {
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(oneof = "type_descriptor::TypeDetails", tags = "2, 3")]
        pub type_details: ::core::option::Option<type_descriptor::TypeDetails>,
    }
    /// Nested message and enum types in `TypeDescriptor`.
    pub mod type_descriptor {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TypeDetails {
            #[prost(message, tag = "2")]
            GstreamerBufferDescriptor(super::super::GstreamerBufferDescriptor),
            #[prost(message, tag = "3")]
            RawImageDescriptor(super::super::RawImageDescriptor),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerMetadata {
    #[prost(int64, tag = "1")]
    pub offset: i64,
    #[prost(message, optional, tag = "2")]
    pub ingest_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeriesMetadata {
    #[prost(string, tag = "1")]
    pub series: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketHeader {
    #[prost(message, optional, tag = "1")]
    pub capture_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<PacketType>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, optional, tag = "4")]
    pub server_metadata: ::core::option::Option<ServerMetadata>,
    #[prost(message, optional, tag = "5")]
    pub series_metadata: ::core::option::Option<SeriesMetadata>,
    #[prost(int32, tag = "6")]
    pub flags: i32,
    #[prost(string, tag = "7")]
    pub trace_context: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Packet {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<PacketHeader>,
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiveEventsRequest {
    #[prost(oneof = "receive_events_request::Request", tags = "1, 2")]
    pub request: ::core::option::Option<receive_events_request::Request>,
}
/// Nested message and enum types in `ReceiveEventsRequest`.
pub mod receive_events_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetupRequest {
        #[prost(string, tag = "1")]
        pub cluster: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub stream: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub receiver: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub controlled_mode: ::core::option::Option<super::ControlledMode>,
        #[prost(message, optional, tag = "5")]
        pub heartbeat_interval: ::core::option::Option<::prost_types::Duration>,
        #[prost(message, optional, tag = "6")]
        pub writes_done_grace_period: ::core::option::Option<::prost_types::Duration>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        SetupRequest(SetupRequest),
        #[prost(message, tag = "2")]
        CommitRequest(super::CommitRequest),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdate {
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub event: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub series: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "5")]
    pub offset: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceiveEventsControlResponse {
    #[prost(oneof = "receive_events_control_response::Control", tags = "1, 2")]
    pub control: ::core::option::Option<receive_events_control_response::Control>,
}
/// Nested message and enum types in `ReceiveEventsControlResponse`.
pub mod receive_events_control_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Control {
        #[prost(bool, tag = "1")]
        Heartbeat(bool),
        #[prost(bool, tag = "2")]
        WritesDoneRequest(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiveEventsResponse {
    #[prost(oneof = "receive_events_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<receive_events_response::Response>,
}
/// Nested message and enum types in `ReceiveEventsResponse`.
pub mod receive_events_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        EventUpdate(super::EventUpdate),
        #[prost(message, tag = "2")]
        Control(super::ReceiveEventsControlResponse),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lease {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub series: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "LeaseType", tag = "5")]
    pub lease_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcquireLeaseRequest {
    #[prost(string, tag = "1")]
    pub series: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub term: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "LeaseType", tag = "4")]
    pub lease_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewLeaseRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub series: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub term: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseLeaseRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub series: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub owner: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReleaseLeaseResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestMetadata {
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub event: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub series: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub lease_term: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendPacketsRequest {
    #[prost(oneof = "send_packets_request::Request", tags = "1, 2")]
    pub request: ::core::option::Option<send_packets_request::Request>,
}
/// Nested message and enum types in `SendPacketsRequest`.
pub mod send_packets_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        Packet(super::Packet),
        #[prost(message, tag = "2")]
        Metadata(super::RequestMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendPacketsResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceivePacketsRequest {
    #[prost(oneof = "receive_packets_request::Request", tags = "6, 7")]
    pub request: ::core::option::Option<receive_packets_request::Request>,
}
/// Nested message and enum types in `ReceivePacketsRequest`.
pub mod receive_packets_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetupRequest {
        #[prost(message, optional, tag = "1")]
        pub metadata: ::core::option::Option<super::RequestMetadata>,
        #[prost(string, tag = "2")]
        pub receiver: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub heartbeat_interval: ::core::option::Option<::prost_types::Duration>,
        #[prost(message, optional, tag = "6")]
        pub writes_done_grace_period: ::core::option::Option<::prost_types::Duration>,
        #[prost(oneof = "setup_request::ConsumerMode", tags = "3, 4")]
        pub consumer_mode: ::core::option::Option<setup_request::ConsumerMode>,
    }
    /// Nested message and enum types in `SetupRequest`.
    pub mod setup_request {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ConsumerMode {
            #[prost(message, tag = "3")]
            EagerReceiveMode(super::super::EagerMode),
            #[prost(message, tag = "4")]
            ControlledReceiveMode(super::super::ControlledMode),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "6")]
        SetupRequest(SetupRequest),
        #[prost(message, tag = "7")]
        CommitRequest(super::CommitRequest),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceivePacketsControlResponse {
    #[prost(oneof = "receive_packets_control_response::Control", tags = "1, 2")]
    pub control: ::core::option::Option<receive_packets_control_response::Control>,
}
/// Nested message and enum types in `ReceivePacketsControlResponse`.
pub mod receive_packets_control_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Control {
        #[prost(bool, tag = "1")]
        Heartbeat(bool),
        #[prost(bool, tag = "2")]
        WritesDoneRequest(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceivePacketsResponse {
    #[prost(oneof = "receive_packets_response::Response", tags = "1, 3")]
    pub response: ::core::option::Option<receive_packets_response::Response>,
}
/// Nested message and enum types in `ReceivePacketsResponse`.
pub mod receive_packets_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Packet(super::Packet),
        #[prost(message, tag = "3")]
        Control(super::ReceivePacketsControlResponse),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EagerMode {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlledMode {
    #[prost(string, tag = "2")]
    pub fallback_starting_offset: ::prost::alloc::string::String,
    #[prost(oneof = "controlled_mode::StartingOffset", tags = "1")]
    pub starting_offset: ::core::option::Option<controlled_mode::StartingOffset>,
}
/// Nested message and enum types in `ControlledMode`.
pub mod controlled_mode {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StartingOffset {
        #[prost(string, tag = "1")]
        StartingLogicalOffset(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommitRequest {
    #[prost(int64, tag = "1")]
    pub offset: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LeaseType {
    Unspecified = 0,
    Reader = 1,
    Writer = 2,
}
impl LeaseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LeaseType::Unspecified => "LEASE_TYPE_UNSPECIFIED",
            LeaseType::Reader => "LEASE_TYPE_READER",
            LeaseType::Writer => "LEASE_TYPE_WRITER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LEASE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "LEASE_TYPE_READER" => Some(Self::Reader),
            "LEASE_TYPE_WRITER" => Some(Self::Writer),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod streaming_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Streaming service for receiving and sending packets.
    #[derive(Debug, Clone)]
    pub struct StreamingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> StreamingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StreamingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            StreamingServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Send packets to the series.
        pub async fn send_packets(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::SendPacketsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SendPacketsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamingService/SendPackets",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamingService",
                        "SendPackets",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Receive packets from the series.
        pub async fn receive_packets(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::ReceivePacketsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ReceivePacketsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamingService/ReceivePackets",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamingService",
                        "ReceivePackets",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Receive events given the stream name.
        pub async fn receive_events(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::ReceiveEventsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ReceiveEventsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamingService/ReceiveEvents",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamingService",
                        "ReceiveEvents",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// AcquireLease acquires a lease.
        pub async fn acquire_lease(
            &mut self,
            request: impl tonic::IntoRequest<super::AcquireLeaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Lease>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamingService/AcquireLease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamingService",
                        "AcquireLease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RenewLease renews a lease.
        pub async fn renew_lease(
            &mut self,
            request: impl tonic::IntoRequest<super::RenewLeaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Lease>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamingService/RenewLease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamingService",
                        "RenewLease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RleaseLease releases a lease.
        pub async fn release_lease(
            &mut self,
            request: impl tonic::IntoRequest<super::ReleaseLeaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReleaseLeaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.StreamingService/ReleaseLease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.StreamingService",
                        "ReleaseLease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Analysis {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "5")]
    pub analysis_definition: ::core::option::Option<AnalysisDefinition>,
    #[prost(map = "string, string", tag = "6")]
    pub input_streams_mapping: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "7")]
    pub output_streams_mapping: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysesResponse {
    #[prost(message, repeated, tag = "1")]
    pub analyses: ::prost::alloc::vec::Vec<Analysis>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalysisRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnalysisRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub analysis_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub analysis: ::core::option::Option<Analysis>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAnalysisRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub analysis: ::core::option::Option<Analysis>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnalysisRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod live_video_analytics_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources. The service enables clients to run
    /// Live Video Analytics (LVA) on the streaming inputs.
    #[derive(Debug, Clone)]
    pub struct LiveVideoAnalyticsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> LiveVideoAnalyticsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LiveVideoAnalyticsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            LiveVideoAnalyticsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Analyses in a given project and location.
        pub async fn list_analyses(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnalysesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAnalysesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.LiveVideoAnalytics/ListAnalyses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.LiveVideoAnalytics",
                        "ListAnalyses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Analysis.
        pub async fn get_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnalysisRequest>,
        ) -> std::result::Result<tonic::Response<super::Analysis>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.LiveVideoAnalytics/GetAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.LiveVideoAnalytics",
                        "GetAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Analysis in a given project and location.
        pub async fn create_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnalysisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.LiveVideoAnalytics/CreateAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.LiveVideoAnalytics",
                        "CreateAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Analysis.
        pub async fn update_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAnalysisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.LiveVideoAnalytics/UpdateAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.LiveVideoAnalytics",
                        "UpdateAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Analysis.
        pub async fn delete_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnalysisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visionai.v1alpha1.LiveVideoAnalytics/DeleteAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.visionai.v1alpha1.LiveVideoAnalytics",
                        "DeleteAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
