// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Api {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub documentation: ::core::option::Option<Documentation>,
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(string, repeated, tag = "6")]
    pub versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub target_user: ::core::option::Option<AttributeValues>,
    #[prost(message, optional, tag = "10")]
    pub team: ::core::option::Option<AttributeValues>,
    #[prost(message, optional, tag = "11")]
    pub business_unit: ::core::option::Option<AttributeValues>,
    #[prost(message, optional, tag = "12")]
    pub maturity_level: ::core::option::Option<AttributeValues>,
    #[prost(map = "string, message", tag = "13")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    #[prost(message, optional, tag = "14")]
    pub api_style: ::core::option::Option<AttributeValues>,
    #[prost(string, tag = "15")]
    pub selected_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub documentation: ::core::option::Option<Documentation>,
    #[prost(string, repeated, tag = "5")]
    pub specs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub api_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub definitions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub deployments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub lifecycle: ::core::option::Option<AttributeValues>,
    #[prost(message, optional, tag = "12")]
    pub compliance: ::core::option::Option<AttributeValues>,
    #[prost(message, optional, tag = "13")]
    pub accreditation: ::core::option::Option<AttributeValues>,
    #[prost(map = "string, message", tag = "14")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    #[prost(string, tag = "16")]
    pub selected_deployment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub spec_type: ::core::option::Option<AttributeValues>,
    #[prost(message, optional, tag = "4")]
    pub contents: ::core::option::Option<SpecContents>,
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<SpecDetails>,
    #[prost(string, tag = "6")]
    pub source_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub lint_response: ::core::option::Option<LintResponse>,
    #[prost(map = "string, message", tag = "10")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    #[prost(message, optional, tag = "11")]
    pub documentation: ::core::option::Option<Documentation>,
    #[prost(enumeration = "spec::ParsingMode", tag = "12")]
    pub parsing_mode: i32,
}
/// Nested message and enum types in `Spec`.
pub mod spec {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParsingMode {
        Unspecified = 0,
        Relaxed = 1,
        Strict = 2,
    }
    impl ParsingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ParsingMode::Unspecified => "PARSING_MODE_UNSPECIFIED",
                ParsingMode::Relaxed => "RELAXED",
                ParsingMode::Strict => "STRICT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARSING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "RELAXED" => Some(Self::Relaxed),
                "STRICT" => Some(Self::Strict),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deployment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub documentation: ::core::option::Option<Documentation>,
    #[prost(message, optional, tag = "5")]
    pub deployment_type: ::core::option::Option<AttributeValues>,
    #[prost(string, tag = "6")]
    pub resource_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub endpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub api_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub slo: ::core::option::Option<AttributeValues>,
    #[prost(message, optional, tag = "12")]
    pub environment: ::core::option::Option<AttributeValues>,
    #[prost(map = "string, message", tag = "13")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiOperation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub spec: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub details: ::core::option::Option<OperationDetails>,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, message", tag = "6")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Definition {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub spec: ::prost::alloc::string::String,
    #[prost(enumeration = "definition::Type", tag = "3")]
    pub r#type: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, message", tag = "7")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    #[prost(oneof = "definition::Value", tags = "4")]
    pub value: ::core::option::Option<definition::Value>,
}
/// Nested message and enum types in `Definition`.
pub mod definition {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Schema = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Schema => "SCHEMA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCHEMA" => Some(Self::Schema),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "4")]
        Schema(super::Schema),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attribute {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "attribute::DefinitionType", tag = "4")]
    pub definition_type: i32,
    #[prost(enumeration = "attribute::Scope", tag = "5")]
    pub scope: i32,
    #[prost(enumeration = "attribute::DataType", tag = "6")]
    pub data_type: i32,
    #[prost(message, repeated, tag = "7")]
    pub allowed_values: ::prost::alloc::vec::Vec<attribute::AllowedValue>,
    #[prost(int32, tag = "8")]
    pub cardinality: i32,
    #[prost(bool, tag = "9")]
    pub mandatory: bool,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Attribute`.
pub mod attribute {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AllowedValue {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        #[prost(bool, tag = "4")]
        pub immutable: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DefinitionType {
        Unspecified = 0,
        SystemDefined = 1,
        UserDefined = 2,
    }
    impl DefinitionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DefinitionType::Unspecified => "DEFINITION_TYPE_UNSPECIFIED",
                DefinitionType::SystemDefined => "SYSTEM_DEFINED",
                DefinitionType::UserDefined => "USER_DEFINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFINITION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SYSTEM_DEFINED" => Some(Self::SystemDefined),
                "USER_DEFINED" => Some(Self::UserDefined),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scope {
        Unspecified = 0,
        Api = 1,
        Version = 2,
        Spec = 3,
        ApiOperation = 4,
        Deployment = 5,
        Dependency = 6,
        Definition = 7,
        ExternalApi = 8,
        Plugin = 9,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Scope::Unspecified => "SCOPE_UNSPECIFIED",
                Scope::Api => "API",
                Scope::Version => "VERSION",
                Scope::Spec => "SPEC",
                Scope::ApiOperation => "API_OPERATION",
                Scope::Deployment => "DEPLOYMENT",
                Scope::Dependency => "DEPENDENCY",
                Scope::Definition => "DEFINITION",
                Scope::ExternalApi => "EXTERNAL_API",
                Scope::Plugin => "PLUGIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "API" => Some(Self::Api),
                "VERSION" => Some(Self::Version),
                "SPEC" => Some(Self::Spec),
                "API_OPERATION" => Some(Self::ApiOperation),
                "DEPLOYMENT" => Some(Self::Deployment),
                "DEPENDENCY" => Some(Self::Dependency),
                "DEFINITION" => Some(Self::Definition),
                "EXTERNAL_API" => Some(Self::ExternalApi),
                "PLUGIN" => Some(Self::Plugin),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Unspecified = 0,
        Enum = 1,
        Json = 2,
        String = 3,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataType::Unspecified => "DATA_TYPE_UNSPECIFIED",
                DataType::Enum => "ENUM",
                DataType::Json => "JSON",
                DataType::String => "STRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENUM" => Some(Self::Enum),
                "JSON" => Some(Self::Json),
                "STRING" => Some(Self::String),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecContents {
    #[prost(bytes = "bytes", tag = "1")]
    pub contents: ::prost::bytes::Bytes,
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecDetails {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(oneof = "spec_details::Details", tags = "2")]
    pub details: ::core::option::Option<spec_details::Details>,
}
/// Nested message and enum types in `SpecDetails`.
pub mod spec_details {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag = "2")]
        OpenApiSpecDetails(super::OpenApiSpecDetails),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenApiSpecDetails {
    #[prost(enumeration = "open_api_spec_details::Format", tag = "1")]
    pub format: i32,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
}
/// Nested message and enum types in `OpenApiSpecDetails`.
pub mod open_api_spec_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        Unspecified = 0,
        OpenApiSpec20 = 1,
        OpenApiSpec30 = 2,
        OpenApiSpec31 = 3,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Format::Unspecified => "FORMAT_UNSPECIFIED",
                Format::OpenApiSpec20 => "OPEN_API_SPEC_2_0",
                Format::OpenApiSpec30 => "OPEN_API_SPEC_3_0",
                Format::OpenApiSpec31 => "OPEN_API_SPEC_3_1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "OPEN_API_SPEC_2_0" => Some(Self::OpenApiSpec20),
                "OPEN_API_SPEC_3_0" => Some(Self::OpenApiSpec30),
                "OPEN_API_SPEC_3_1" => Some(Self::OpenApiSpec31),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationDetails {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub documentation: ::core::option::Option<Documentation>,
    #[prost(bool, tag = "3")]
    pub deprecated: bool,
    #[prost(oneof = "operation_details::Operation", tags = "4")]
    pub operation: ::core::option::Option<operation_details::Operation>,
}
/// Nested message and enum types in `OperationDetails`.
pub mod operation_details {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "4")]
        HttpOperation(super::HttpOperation),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpOperation {
    #[prost(message, optional, tag = "1")]
    pub path: ::core::option::Option<Path>,
    #[prost(enumeration = "http_operation::Method", tag = "2")]
    pub method: i32,
}
/// Nested message and enum types in `HttpOperation`.
pub mod http_operation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Method {
        Unspecified = 0,
        Get = 1,
        Put = 2,
        Post = 3,
        Delete = 4,
        Options = 5,
        Head = 6,
        Patch = 7,
        Trace = 8,
    }
    impl Method {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Method::Unspecified => "METHOD_UNSPECIFIED",
                Method::Get => "GET",
                Method::Put => "PUT",
                Method::Post => "POST",
                Method::Delete => "DELETE",
                Method::Options => "OPTIONS",
                Method::Head => "HEAD",
                Method::Patch => "PATCH",
                Method::Trace => "TRACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "GET" => Some(Self::Get),
                "PUT" => Some(Self::Put),
                "POST" => Some(Self::Post),
                "DELETE" => Some(Self::Delete),
                "OPTIONS" => Some(Self::Options),
                "HEAD" => Some(Self::Head),
                "PATCH" => Some(Self::Patch),
                "TRACE" => Some(Self::Trace),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Path {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub raw_value: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Documentation {
    #[prost(string, tag = "1")]
    pub external_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeValues {
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
    #[prost(oneof = "attribute_values::Value", tags = "2, 3, 4")]
    pub value: ::core::option::Option<attribute_values::Value>,
}
/// Nested message and enum types in `AttributeValues`.
pub mod attribute_values {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EnumAttributeValues {
        #[prost(message, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<super::attribute::AllowedValue>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringAttributeValues {
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "2")]
        EnumValues(EnumAttributeValues),
        #[prost(message, tag = "3")]
        StringValues(StringAttributeValues),
        #[prost(message, tag = "4")]
        JsonValues(StringAttributeValues),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dependency {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub consumer: ::core::option::Option<DependencyEntityReference>,
    #[prost(message, optional, tag = "3")]
    pub supplier: ::core::option::Option<DependencyEntityReference>,
    #[prost(enumeration = "dependency::State", tag = "4")]
    pub state: i32,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "dependency::DiscoveryMode", tag = "6")]
    pub discovery_mode: i32,
    #[prost(message, optional, tag = "7")]
    pub error_detail: ::core::option::Option<DependencyErrorDetail>,
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, message", tag = "10")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
}
/// Nested message and enum types in `Dependency`.
pub mod dependency {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Proposed = 1,
        Validated = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Proposed => "PROPOSED",
                State::Validated => "VALIDATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROPOSED" => Some(Self::Proposed),
                "VALIDATED" => Some(Self::Validated),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiscoveryMode {
        Unspecified = 0,
        Manual = 1,
    }
    impl DiscoveryMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DiscoveryMode::Unspecified => "DISCOVERY_MODE_UNSPECIFIED",
                DiscoveryMode::Manual => "MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISCOVERY_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MANUAL" => Some(Self::Manual),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DependencyEntityReference {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(oneof = "dependency_entity_reference::Identifier", tags = "2, 3")]
    pub identifier: ::core::option::Option<dependency_entity_reference::Identifier>,
}
/// Nested message and enum types in `DependencyEntityReference`.
pub mod dependency_entity_reference {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        #[prost(string, tag = "2")]
        OperationResourceName(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        ExternalApiResourceName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DependencyErrorDetail {
    #[prost(enumeration = "dependency_error_detail::Error", tag = "1")]
    pub error: i32,
    #[prost(message, optional, tag = "2")]
    pub error_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `DependencyErrorDetail`.
pub mod dependency_error_detail {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Error {
        Unspecified = 0,
        SupplierNotFound = 1,
        SupplierRecreated = 2,
    }
    impl Error {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Error::Unspecified => "ERROR_UNSPECIFIED",
                Error::SupplierNotFound => "SUPPLIER_NOT_FOUND",
                Error::SupplierRecreated => "SUPPLIER_RECREATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_UNSPECIFIED" => Some(Self::Unspecified),
                "SUPPLIER_NOT_FOUND" => Some(Self::SupplierNotFound),
                "SUPPLIER_RECREATED" => Some(Self::SupplierRecreated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LintResponse {
    #[prost(message, repeated, tag = "1")]
    pub issues: ::prost::alloc::vec::Vec<Issue>,
    #[prost(message, repeated, tag = "2")]
    pub summary: ::prost::alloc::vec::Vec<lint_response::SummaryEntry>,
    #[prost(enumeration = "LintState", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "4")]
    pub source: ::prost::alloc::string::String,
    #[prost(enumeration = "Linter", tag = "5")]
    pub linter: i32,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `LintResponse`.
pub mod lint_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SummaryEntry {
        #[prost(enumeration = "super::Severity", tag = "1")]
        pub severity: i32,
        #[prost(int32, tag = "2")]
        pub count: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Issue {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(enumeration = "Severity", tag = "4")]
    pub severity: i32,
    #[prost(message, optional, tag = "5")]
    pub range: ::core::option::Option<Range>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Range {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Point>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(int32, tag = "1")]
    pub line: i32,
    #[prost(int32, tag = "2")]
    pub character: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiHubInstance {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "api_hub_instance::State", tag = "4")]
    pub state: i32,
    #[prost(string, tag = "5")]
    pub state_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<api_hub_instance::Config>,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ApiHubInstance`.
pub mod api_hub_instance {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Config {
        #[prost(string, tag = "1")]
        pub cmek_key_name: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Inactive = 1,
        Creating = 2,
        Active = 3,
        Updating = 4,
        Deleting = 5,
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Inactive => "INACTIVE",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalApi {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub endpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub documentation: ::core::option::Option<Documentation>,
    #[prost(map = "string, message", tag = "7")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LintState {
    Unspecified = 0,
    Success = 1,
    Error = 2,
}
impl LintState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LintState::Unspecified => "LINT_STATE_UNSPECIFIED",
            LintState::Success => "LINT_STATE_SUCCESS",
            LintState::Error => "LINT_STATE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "LINT_STATE_SUCCESS" => Some(Self::Success),
            "LINT_STATE_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Linter {
    Unspecified = 0,
    Spectral = 1,
    Other = 2,
}
impl Linter {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Linter::Unspecified => "LINTER_UNSPECIFIED",
            Linter::Spectral => "SPECTRAL",
            Linter::Other => "OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINTER_UNSPECIFIED" => Some(Self::Unspecified),
            "SPECTRAL" => Some(Self::Spectral),
            "OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    Unspecified = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
    Hint = 4,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Severity::Unspecified => "SEVERITY_UNSPECIFIED",
            Severity::Error => "SEVERITY_ERROR",
            Severity::Warning => "SEVERITY_WARNING",
            Severity::Info => "SEVERITY_INFO",
            Severity::Hint => "SEVERITY_HINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "SEVERITY_ERROR" => Some(Self::Error),
            "SEVERITY_WARNING" => Some(Self::Warning),
            "SEVERITY_INFO" => Some(Self::Info),
            "SEVERITY_HINT" => Some(Self::Hint),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStyleGuideRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStyleGuideRequest {
    #[prost(message, optional, tag = "1")]
    pub style_guide: ::core::option::Option<StyleGuide>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStyleGuideContentsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LintSpecRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StyleGuideContents {
    #[prost(bytes = "bytes", tag = "1")]
    pub contents: ::prost::bytes::Bytes,
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StyleGuide {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "Linter", tag = "2")]
    pub linter: i32,
    #[prost(message, optional, tag = "3")]
    pub contents: ::core::option::Option<StyleGuideContents>,
}
/// Generated client implementations.
pub mod linting_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service provides all methods related to the 1p Linter.
    #[derive(Debug, Clone)]
    pub struct LintingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> LintingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LintingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            LintingServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get the style guide being used for linting.
        pub async fn get_style_guide(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStyleGuideRequest>,
        ) -> std::result::Result<tonic::Response<super::StyleGuide>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/GetStyleGuide",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.LintingService",
                        "GetStyleGuide",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the styleGuide to be used for liniting in by API hub.
        pub async fn update_style_guide(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateStyleGuideRequest>,
        ) -> std::result::Result<tonic::Response<super::StyleGuide>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/UpdateStyleGuide",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.LintingService",
                        "UpdateStyleGuide",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the contents of the style guide.
        pub async fn get_style_guide_contents(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStyleGuideContentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StyleGuideContents>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/GetStyleGuideContents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.LintingService",
                        "GetStyleGuideContents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lints the requested spec and updates the corresponding API Spec with the
        /// lint response. This lint response will be available in all subsequent
        /// Get and List Spec calls to Core service.
        pub async fn lint_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::LintSpecRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/LintSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.LintingService", "LintSpec"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHostProjectRegistrationRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub host_project_registration_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub host_project_registration: ::core::option::Option<HostProjectRegistration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHostProjectRegistrationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHostProjectRegistrationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHostProjectRegistrationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub host_project_registrations: ::prost::alloc::vec::Vec<HostProjectRegistration>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostProjectRegistration {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gcp_project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod host_project_registration_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing the host project registrations.
    #[derive(Debug, Clone)]
    pub struct HostProjectRegistrationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> HostProjectRegistrationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HostProjectRegistrationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            HostProjectRegistrationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a host project registration.
        /// A Google cloud project can be registered as a host project if it is not
        /// attached as a runtime project to another host project.
        /// A project can be registered as a host project only once. Subsequent
        /// register calls for the same project will fail.
        pub async fn create_host_project_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHostProjectRegistrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HostProjectRegistration>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.HostProjectRegistrationService/CreateHostProjectRegistration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.HostProjectRegistrationService",
                        "CreateHostProjectRegistration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a host project registration.
        pub async fn get_host_project_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHostProjectRegistrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HostProjectRegistration>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.HostProjectRegistrationService/GetHostProjectRegistration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.HostProjectRegistrationService",
                        "GetHostProjectRegistration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists host project registrations.
        pub async fn list_host_project_registrations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHostProjectRegistrationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHostProjectRegistrationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.HostProjectRegistrationService/ListHostProjectRegistrations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.HostProjectRegistrationService",
                        "ListHostProjectRegistrations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApiRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub api: ::core::option::Option<Api>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApiRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApiRequest {
    #[prost(message, optional, tag = "1")]
    pub api: ::core::option::Option<Api>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteApiRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApisRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApisResponse {
    #[prost(message, repeated, tag = "1")]
    pub apis: ::prost::alloc::vec::Vec<Api>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVersionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub version: ::core::option::Option<Version>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVersionRequest {
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<Version>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub versions: ::prost::alloc::vec::Vec<Version>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub spec_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub spec: ::core::option::Option<Spec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecRequest {
    #[prost(message, optional, tag = "1")]
    pub spec: ::core::option::Option<Spec>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSpecRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecsResponse {
    #[prost(message, repeated, tag = "1")]
    pub specs: ::prost::alloc::vec::Vec<Spec>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecContentsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApiOperationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApiOperationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApiOperationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub api_operations: ::prost::alloc::vec::Vec<ApiOperation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDefinitionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub deployment: ::core::option::Option<Deployment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentRequest {
    #[prost(message, optional, tag = "1")]
    pub deployment: ::core::option::Option<Deployment>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAttributeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub attribute_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub attribute: ::core::option::Option<Attribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAttributeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAttributeRequest {
    #[prost(message, optional, tag = "1")]
    pub attribute: ::core::option::Option<Attribute>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAttributeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAttributesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAttributesResponse {
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<Attribute>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResourcesRequest {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiHubResource {
    #[prost(oneof = "api_hub_resource::Resource", tags = "1, 2, 3, 4, 5, 6")]
    pub resource: ::core::option::Option<api_hub_resource::Resource>,
}
/// Nested message and enum types in `ApiHubResource`.
pub mod api_hub_resource {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Resource {
        #[prost(message, tag = "1")]
        Api(super::Api),
        #[prost(message, tag = "2")]
        Operation(super::ApiOperation),
        #[prost(message, tag = "3")]
        Deployment(super::Deployment),
        #[prost(message, tag = "4")]
        Spec(super::Spec),
        #[prost(message, tag = "5")]
        Definition(super::Definition),
        #[prost(message, tag = "6")]
        Version(super::Version),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(message, optional, tag = "1")]
    pub resource: ::core::option::Option<ApiHubResource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub search_results: ::prost::alloc::vec::Vec<SearchResult>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDependencyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub dependency_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub dependency: ::core::option::Option<Dependency>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDependencyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDependencyRequest {
    #[prost(message, optional, tag = "1")]
    pub dependency: ::core::option::Option<Dependency>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDependencyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDependenciesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDependenciesResponse {
    #[prost(message, repeated, tag = "1")]
    pub dependencies: ::prost::alloc::vec::Vec<Dependency>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExternalApiRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub external_api_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub external_api: ::core::option::Option<ExternalApi>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExternalApiRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExternalApiRequest {
    #[prost(message, optional, tag = "1")]
    pub external_api: ::core::option::Option<ExternalApi>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExternalApiRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalApisRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalApisResponse {
    #[prost(message, repeated, tag = "1")]
    pub external_apis: ::prost::alloc::vec::Vec<ExternalApi>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod api_hub_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service provides all methods related to the API hub.
    #[derive(Debug, Clone)]
    pub struct ApiHubClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ApiHubClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApiHubClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ApiHubClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create an API resource in the API hub.
        /// Once an API resource is created, versions can be added to it.
        pub async fn create_api(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateApiRequest>,
        ) -> std::result::Result<tonic::Response<super::Api>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateApi"));
            self.inner.unary(req, path, codec).await
        }
        /// Get API resource details including the API versions contained in it.
        pub async fn get_api(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApiRequest>,
        ) -> std::result::Result<tonic::Response<super::Api>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetApi"));
            self.inner.unary(req, path, codec).await
        }
        /// List API resources in the API hub.
        pub async fn list_apis(
            &mut self,
            request: impl tonic::IntoRequest<super::ListApisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListApisResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListApis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListApis"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an API resource in the API hub. The following fields in the
        /// \[API\]\[\] can be updated:
        ///
        /// * \[display_name\]\[google.cloud.apihub.v1.Api.display_name\]
        /// * \[description\]\[google.cloud.apihub.v1.Api.description\]
        /// * \[owner\]\[google.cloud.apihub.v1.Api.owner\]
        /// * \[documentation\]\[google.cloud.apihub.v1.Api.documentation\]
        /// * \[target_user\]\[google.cloud.apihub.v1.Api.target_user\]
        /// * \[team\]\[google.cloud.apihub.v1.Api.team\]
        /// * \[business_unit\]\[google.cloud.apihub.v1.Api.business_unit\]
        /// * \[maturity_level\]\[google.cloud.apihub.v1.Api.maturity_level\]
        /// * \[attributes\]\[google.cloud.apihub.v1.Api.attributes\]
        ///
        /// The
        /// \[update_mask\]\[google.cloud.apihub.v1.UpdateApiRequest.update_mask\]
        /// should be used to specify the fields being updated.
        ///
        /// Updating the owner field requires complete owner message
        /// and updates both owner and email fields.
        pub async fn update_api(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateApiRequest>,
        ) -> std::result::Result<tonic::Response<super::Api>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateApi"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete an API resource in the API hub. API can only be deleted if all
        /// underlying versions are deleted.
        pub async fn delete_api(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteApiRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteApi"));
            self.inner.unary(req, path, codec).await
        }
        /// Create an API version for an API resource in the API hub.
        pub async fn create_version(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about the API version of an API resource. This will include
        /// information about the specs and operations present in the API
        /// version as well as the deployments linked to it.
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetVersion"));
            self.inner.unary(req, path, codec).await
        }
        /// List API versions of an API resource in the API hub.
        pub async fn list_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListVersions"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update API version. The following fields in the
        /// \[version\]\[google.cloud.apihub.v1.Version\] can be updated currently:
        ///
        /// * \[display_name\]\[google.cloud.apihub.v1.Version.display_name\]
        /// * \[description\]\[google.cloud.apihub.v1.Version.description\]
        /// * \[documentation\]\[google.cloud.apihub.v1.Version.documentation\]
        /// * \[deployments\]\[google.cloud.apihub.v1.Version.deployments\]
        /// * \[lifecycle\]\[google.cloud.apihub.v1.Version.lifecycle\]
        /// * \[compliance\]\[google.cloud.apihub.v1.Version.compliance\]
        /// * \[accreditation\]\[google.cloud.apihub.v1.Version.accreditation\]
        /// * \[attributes\]\[google.cloud.apihub.v1.Version.attributes\]
        ///
        /// The
        /// \[update_mask\]\[google.cloud.apihub.v1.UpdateVersionRequest.update_mask\]
        /// should be used to specify the fields being updated.
        pub async fn update_version(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an API version. Version can only be deleted if all underlying specs,
        /// operations, definitions and linked deployments are deleted.
        pub async fn delete_version(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVersionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a spec to an API version in the API hub.
        /// Multiple specs can be added to an API version.
        /// Note, while adding a spec, at least one of `contents` or `source_uri` must
        /// be provided. If `contents` is provided, then `spec_type` must also be
        /// provided.
        ///
        /// On adding a spec with contents to the version, the operations present in it
        /// will be added to the version.Note that the file contents in the spec should
        /// be of the same type as defined in the
        /// `projects/{project}/locations/{location}/attributes/system-spec-type`
        /// attribute associated with spec resource. Note that specs of various types
        /// can be uploaded, however parsing of details is supported for OpenAPI spec
        /// currently.
        ///
        /// In order to access the information parsed from the spec, use the
        /// \[GetSpec\]\[google.cloud.apihub.v1.ApiHub.GetSpec\] method.
        /// In order to access the raw contents for a particular spec, use the
        /// \[GetSpecContents\]\[google.cloud.apihub.v1.ApiHub.GetSpecContents\] method.
        /// In order to access the operations parsed from the spec, use the
        /// \[ListAPIOperations\]\[google.cloud.apihub.v1.ApiHub.ListApiOperations\]
        /// method.
        pub async fn create_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSpecRequest>,
        ) -> std::result::Result<tonic::Response<super::Spec>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Get details about the information parsed from a spec.
        /// Note that this method does not return the raw spec contents.
        /// Use \[GetSpecContents\]\[google.cloud.apihub.v1.ApiHub.GetSpecContents\] method
        /// to retrieve the same.
        pub async fn get_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSpecRequest>,
        ) -> std::result::Result<tonic::Response<super::Spec>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Get spec contents.
        pub async fn get_spec_contents(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSpecContentsRequest>,
        ) -> std::result::Result<tonic::Response<super::SpecContents>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetSpecContents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetSpecContents"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List specs corresponding to a particular API resource.
        pub async fn list_specs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSpecsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSpecsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListSpecs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListSpecs"));
            self.inner.unary(req, path, codec).await
        }
        /// Update spec. The following fields in the
        /// \[spec\]\[google.cloud.apihub.v1.Spec\] can be updated:
        ///
        /// * \[display_name\]\[google.cloud.apihub.v1.Spec.display_name\]
        /// * \[source_uri\]\[google.cloud.apihub.v1.Spec.source_uri\]
        /// * \[lint_response\]\[google.cloud.apihub.v1.Spec.lint_response\]
        /// * \[attributes\]\[google.cloud.apihub.v1.Spec.attributes\]
        /// * \[contents\]\[google.cloud.apihub.v1.Spec.contents\]
        /// * \[spec_type\]\[google.cloud.apihub.v1.Spec.spec_type\]
        ///
        /// In case of an OAS spec, updating spec contents can lead to:
        ///
        /// 1. Creation, deletion and update of operations.
        /// 1. Creation, deletion and update of definitions.
        /// 1. Update of other info parsed out from the new spec.
        ///
        /// In case of contents or source_uri being present in update mask, spec_type
        /// must also be present. Also, spec_type can not be present in update mask if
        /// contents or source_uri is not present.
        ///
        /// The
        /// \[update_mask\]\[google.cloud.apihub.v1.UpdateSpecRequest.update_mask\]
        /// should be used to specify the fields being updated.
        pub async fn update_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSpecRequest>,
        ) -> std::result::Result<tonic::Response<super::Spec>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a spec.
        /// Deleting a spec will also delete the associated operations from the
        /// version.
        pub async fn delete_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSpecRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a particular operation in API version.
        pub async fn get_api_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApiOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::ApiOperation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetApiOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetApiOperation"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List operations in an API version.
        pub async fn list_api_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListApiOperationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListApiOperationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListApiOperations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListApiOperations"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a definition in an API version.
        pub async fn get_definition(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDefinitionRequest>,
        ) -> std::result::Result<tonic::Response<super::Definition>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetDefinition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetDefinition"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a deployment resource in the API hub.
        /// Once a deployment resource is created, it can be associated with API
        /// versions.
        pub async fn create_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a deployment and the API versions linked to it.
        pub async fn get_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List deployment resources in the API hub.
        pub async fn list_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListDeployments"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a deployment resource in the API hub. The following fields in the
        /// \[deployment resource\]\[google.cloud.apihub.v1.Deployment\] can be
        /// updated:
        ///
        /// * \[display_name\]\[google.cloud.apihub.v1.Deployment.display_name\]
        /// * \[description\]\[google.cloud.apihub.v1.Deployment.description\]
        /// * \[documentation\]\[google.cloud.apihub.v1.Deployment.documentation\]
        /// * \[deployment_type\]\[google.cloud.apihub.v1.Deployment.deployment_type\]
        /// * \[resource_uri\]\[google.cloud.apihub.v1.Deployment.resource_uri\]
        /// * \[endpoints\]\[google.cloud.apihub.v1.Deployment.endpoints\]
        /// * \[slo\]\[google.cloud.apihub.v1.Deployment.slo\]
        /// * \[environment\]\[google.cloud.apihub.v1.Deployment.environment\]
        /// * \[attributes\]\[google.cloud.apihub.v1.Deployment.attributes\]
        ///
        /// The
        /// \[update_mask\]\[google.cloud.apihub.v1.UpdateDeploymentRequest.update_mask\]
        /// should be used to specify the fields being updated.
        pub async fn update_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a deployment resource in the API hub.
        pub async fn delete_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a user defined attribute.
        ///
        /// Certain pre defined attributes are already created by the API hub. These
        /// attributes will have type as `SYSTEM_DEFINED` and can be listed via
        /// \[ListAttributes\]\[google.cloud.apihub.v1.ApiHub.ListAttributes\] method.
        /// Allowed values for the same can be updated via
        /// \[UpdateAttribute\]\[google.cloud.apihub.v1.ApiHub.UpdateAttribute\] method.
        pub async fn create_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::Attribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about the attribute.
        pub async fn get_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::Attribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the attribute.  The following fields in the
        /// \[Attribute resource\]\[google.cloud.apihub.v1.Attribute\] can be updated:
        ///
        /// * \[display_name\]\[google.cloud.apihub.v1.Attribute.display_name\]
        ///  The display name can be updated for user defined attributes only.
        /// * \[description\]\[google.cloud.apihub.v1.Attribute.description\]
        ///  The description can be updated for user defined attributes only.
        /// * \[allowed_values\]\[google.cloud.apihub.v1.Attribute.allowed_values\]
        ///  To update the list of allowed values, clients need to use the fetched list
        ///  of allowed values and add or remove values to or from the same list.
        ///  The mutable allowed values can be updated for both user defined and System
        ///  defined attributes. The immutable allowed values cannot be updated or
        ///  deleted. The updated list of allowed values cannot be empty. If an allowed
        ///  value that is already used by some resource's attribute is deleted, then
        ///  the association between the resource and the attribute value will also be
        ///  deleted.
        /// * \[cardinality\]\[google.cloud.apihub.v1.Attribute.cardinality\]
        ///  The cardinality can be updated for user defined attributes only.
        ///  Cardinality can only be increased during an update.
        ///
        /// The
        /// \[update_mask\]\[google.cloud.apihub.v1.UpdateAttributeRequest.update_mask\]
        /// should be used to specify the fields being updated.
        pub async fn update_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::Attribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an attribute.
        ///
        /// Note: System defined attributes cannot be deleted. All
        /// associations of the attribute being deleted with any API hub resource will
        /// also get deleted.
        pub async fn delete_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAttributeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all attributes.
        pub async fn list_attributes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAttributesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAttributesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListAttributes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListAttributes"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Search across API-Hub resources.
        pub async fn search_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchResourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/SearchResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "SearchResources"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create an External API resource in the API hub.
        pub async fn create_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<super::ExternalApi>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about an External API resource in the API hub.
        pub async fn get_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<super::ExternalApi>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update an External API resource in the API hub. The following fields can be
        /// updated:
        ///
        /// * \[display_name\]\[google.cloud.apihub.v1.ExternalApi.display_name\]
        /// * \[description\]\[google.cloud.apihub.v1.ExternalApi.description\]
        /// * \[documentation\]\[google.cloud.apihub.v1.ExternalApi.documentation\]
        /// * \[endpoints\]\[google.cloud.apihub.v1.ExternalApi.endpoints\]
        /// * \[paths\]\[google.cloud.apihub.v1.ExternalApi.paths\]
        ///
        /// The
        /// \[update_mask\]\[google.cloud.apihub.v1.UpdateExternalApiRequest.update_mask\]
        /// should be used to specify the fields being updated.
        pub async fn update_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<super::ExternalApi>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an External API resource in the API hub.
        pub async fn delete_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List External API resources in the API hub.
        pub async fn list_external_apis(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExternalApisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExternalApisResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListExternalApis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListExternalApis"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod api_hub_dependencies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service provides methods for various operations related to a
    /// \[Dependency\]\[google.cloud.apihub.v1.Dependency\] in the API hub.
    #[derive(Debug, Clone)]
    pub struct ApiHubDependenciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ApiHubDependenciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApiHubDependenciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ApiHubDependenciesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a dependency between two entities in the API hub.
        pub async fn create_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDependencyRequest>,
        ) -> std::result::Result<tonic::Response<super::Dependency>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/CreateDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "CreateDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a dependency resource in the API hub.
        pub async fn get_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDependencyRequest>,
        ) -> std::result::Result<tonic::Response<super::Dependency>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/GetDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "GetDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a dependency based on the
        /// \[update_mask\]\[google.cloud.apihub.v1.UpdateDependencyRequest.update_mask\]
        /// provided in the request.
        ///
        /// The following fields in the \[dependency\]\[google.cloud.apihub.v1.Dependency\]
        /// can be updated:
        ///
        /// * \[description\]\[google.cloud.apihub.v1.Dependency.description\]
        pub async fn update_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDependencyRequest>,
        ) -> std::result::Result<tonic::Response<super::Dependency>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/UpdateDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "UpdateDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete the dependency resource.
        pub async fn delete_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDependencyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/DeleteDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "DeleteDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List dependencies based on the provided filter and pagination parameters.
        pub async fn list_dependencies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDependenciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDependenciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/ListDependencies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "ListDependencies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Plugin {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<AttributeValues>,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "plugin::State", tag = "5")]
    pub state: i32,
}
/// Nested message and enum types in `Plugin`.
pub mod plugin {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Enabled = 1,
        Disabled = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Enabled => "ENABLED",
                State::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPluginRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnablePluginRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisablePluginRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod api_hub_plugin_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing plugins inside the API Hub.
    #[derive(Debug, Clone)]
    pub struct ApiHubPluginClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ApiHubPluginClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApiHubPluginClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ApiHubPluginClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get details about an API Hub plugin.
        pub async fn get_plugin(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPluginRequest>,
        ) -> std::result::Result<tonic::Response<super::Plugin>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubPlugin/GetPlugin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHubPlugin", "GetPlugin"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enables a plugin.
        /// The `state` of the plugin after enabling is `ENABLED`
        pub async fn enable_plugin(
            &mut self,
            request: impl tonic::IntoRequest<super::EnablePluginRequest>,
        ) -> std::result::Result<tonic::Response<super::Plugin>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubPlugin/EnablePlugin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubPlugin",
                        "EnablePlugin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Disables a plugin.
        /// The `state` of the plugin after disabling is `DISABLED`
        pub async fn disable_plugin(
            &mut self,
            request: impl tonic::IntoRequest<super::DisablePluginRequest>,
        ) -> std::result::Result<tonic::Response<super::Plugin>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubPlugin/DisablePlugin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubPlugin",
                        "DisablePlugin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApiHubInstanceRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_hub_instance_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub api_hub_instance: ::core::option::Option<ApiHubInstance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApiHubInstanceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupApiHubInstanceRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupApiHubInstanceResponse {
    #[prost(message, optional, tag = "1")]
    pub api_hub_instance: ::core::option::Option<ApiHubInstance>,
}
/// Generated client implementations.
pub mod provisioning_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing the data plane provisioning of the API hub.
    #[derive(Debug, Clone)]
    pub struct ProvisioningClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ProvisioningClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProvisioningClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ProvisioningClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Provisions instance resources for the API Hub.
        pub async fn create_api_hub_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateApiHubInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.Provisioning/CreateApiHubInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.Provisioning",
                        "CreateApiHubInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single API Hub instance.
        pub async fn get_api_hub_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApiHubInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::ApiHubInstance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.Provisioning/GetApiHubInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.Provisioning",
                        "GetApiHubInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Looks up an Api Hub instance in a given GCP project. There will always be
        /// only one Api Hub instance for a GCP project across all locations.
        pub async fn lookup_api_hub_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupApiHubInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupApiHubInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.Provisioning/LookupApiHubInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.Provisioning",
                        "LookupApiHubInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRuntimeProjectAttachmentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub runtime_project_attachment_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub runtime_project_attachment: ::core::option::Option<RuntimeProjectAttachment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuntimeProjectAttachmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeProjectAttachmentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeProjectAttachmentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub runtime_project_attachments: ::prost::alloc::vec::Vec<RuntimeProjectAttachment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRuntimeProjectAttachmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupRuntimeProjectAttachmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupRuntimeProjectAttachmentResponse {
    #[prost(message, optional, tag = "1")]
    pub runtime_project_attachment: ::core::option::Option<RuntimeProjectAttachment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeProjectAttachment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub runtime_project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod runtime_project_attachment_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing the runtime project attachments.
    #[derive(Debug, Clone)]
    pub struct RuntimeProjectAttachmentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RuntimeProjectAttachmentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RuntimeProjectAttachmentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RuntimeProjectAttachmentServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Attaches a runtime project to the host project.
        pub async fn create_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateRuntimeProjectAttachmentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeProjectAttachment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/CreateRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "CreateRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a runtime project attachment.
        pub async fn get_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuntimeProjectAttachmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeProjectAttachment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/GetRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "GetRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List runtime projects attached to the host project.
        pub async fn list_runtime_project_attachments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRuntimeProjectAttachmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRuntimeProjectAttachmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/ListRuntimeProjectAttachments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "ListRuntimeProjectAttachments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a runtime project attachment in the API Hub. This call will detach
        /// the runtime project from the host project.
        pub async fn delete_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRuntimeProjectAttachmentRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/DeleteRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "DeleteRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Look up a runtime project attachment. This API can be called in the context
        /// of any project.
        pub async fn lookup_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<
                super::LookupRuntimeProjectAttachmentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::LookupRuntimeProjectAttachmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/LookupRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "LookupRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
