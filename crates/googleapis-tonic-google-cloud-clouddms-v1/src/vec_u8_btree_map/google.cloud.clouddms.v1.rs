// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslConfig {
    #[prost(enumeration = "ssl_config::SslType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub client_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub client_certificate: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ca_certificate: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SslConfig`.
pub mod ssl_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SslType {
        Unspecified = 0,
        ServerOnly = 1,
        ServerClient = 2,
    }
    impl SslType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SslType::Unspecified => "SSL_TYPE_UNSPECIFIED",
                SslType::ServerOnly => "SERVER_ONLY",
                SslType::ServerClient => "SERVER_CLIENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SSL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SERVER_ONLY" => Some(Self::ServerOnly),
                "SERVER_CLIENT" => Some(Self::ServerClient),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlConnectionProfile {
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub port: i32,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub password_set: bool,
    #[prost(message, optional, tag = "6")]
    pub ssl: ::core::option::Option<SslConfig>,
    #[prost(string, tag = "7")]
    pub cloud_sql_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgreSqlConnectionProfile {
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub port: i32,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub password_set: bool,
    #[prost(message, optional, tag = "6")]
    pub ssl: ::core::option::Option<SslConfig>,
    #[prost(string, tag = "7")]
    pub cloud_sql_id: ::prost::alloc::string::String,
    #[prost(enumeration = "NetworkArchitecture", tag = "8")]
    pub network_architecture: i32,
    #[prost(oneof = "postgre_sql_connection_profile::Connectivity", tags = "100, 101")]
    pub connectivity: ::core::option::Option<
        postgre_sql_connection_profile::Connectivity,
    >,
}
/// Nested message and enum types in `PostgreSqlConnectionProfile`.
pub mod postgre_sql_connection_profile {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Connectivity {
        #[prost(message, tag = "100")]
        StaticIpConnectivity(super::StaticIpConnectivity),
        #[prost(message, tag = "101")]
        PrivateServiceConnectConnectivity(super::PrivateServiceConnectConnectivity),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OracleConnectionProfile {
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub port: i32,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub password_set: bool,
    #[prost(string, tag = "6")]
    pub database_service: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub ssl: ::core::option::Option<SslConfig>,
    #[prost(oneof = "oracle_connection_profile::Connectivity", tags = "100, 101, 102")]
    pub connectivity: ::core::option::Option<oracle_connection_profile::Connectivity>,
}
/// Nested message and enum types in `OracleConnectionProfile`.
pub mod oracle_connection_profile {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Connectivity {
        #[prost(message, tag = "100")]
        StaticServiceIpConnectivity(super::StaticServiceIpConnectivity),
        #[prost(message, tag = "101")]
        ForwardSshConnectivity(super::ForwardSshTunnelConnectivity),
        #[prost(message, tag = "102")]
        PrivateConnectivity(super::PrivateConnectivity),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudSqlConnectionProfile {
    #[prost(string, tag = "1")]
    pub cloud_sql_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<CloudSqlSettings>,
    #[prost(string, tag = "3")]
    pub private_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub public_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub additional_public_ip: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlloyDbConnectionProfile {
    #[prost(string, tag = "1")]
    pub cluster_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<AlloyDbSettings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlAclEntry {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub label: ::prost::alloc::string::String,
    #[prost(oneof = "sql_acl_entry::Expiration", tags = "10, 11")]
    pub expiration: ::core::option::Option<sql_acl_entry::Expiration>,
}
/// Nested message and enum types in `SqlAclEntry`.
pub mod sql_acl_entry {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        #[prost(message, tag = "10")]
        ExpireTime(::prost_types::Timestamp),
        #[prost(message, tag = "11")]
        Ttl(::prost_types::Duration),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlIpConfig {
    #[prost(message, optional, tag = "1")]
    pub enable_ipv4: ::core::option::Option<bool>,
    #[prost(string, tag = "2")]
    pub private_network: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub allocated_ip_range: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub require_ssl: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "4")]
    pub authorized_networks: ::prost::alloc::vec::Vec<SqlAclEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudSqlSettings {
    #[prost(enumeration = "cloud_sql_settings::SqlDatabaseVersion", tag = "1")]
    pub database_version: i32,
    #[prost(btree_map = "string, string", tag = "2")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "3")]
    pub tier: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub storage_auto_resize_limit: ::core::option::Option<i64>,
    #[prost(enumeration = "cloud_sql_settings::SqlActivationPolicy", tag = "5")]
    pub activation_policy: i32,
    #[prost(message, optional, tag = "6")]
    pub ip_config: ::core::option::Option<SqlIpConfig>,
    #[prost(message, optional, tag = "7")]
    pub auto_storage_increase: ::core::option::Option<bool>,
    #[prost(btree_map = "string, string", tag = "8")]
    pub database_flags: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "cloud_sql_settings::SqlDataDiskType", tag = "9")]
    pub data_disk_type: i32,
    #[prost(message, optional, tag = "10")]
    pub data_disk_size_gb: ::core::option::Option<i64>,
    #[prost(string, tag = "11")]
    pub zone: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub secondary_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub source_id: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub root_password: ::prost::alloc::string::String,
    #[prost(bool, tag = "14")]
    pub root_password_set: bool,
    #[prost(string, tag = "15")]
    pub collation: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub cmek_key_name: ::prost::alloc::string::String,
    #[prost(enumeration = "cloud_sql_settings::SqlAvailabilityType", tag = "17")]
    pub availability_type: i32,
    #[prost(enumeration = "cloud_sql_settings::Edition", tag = "19")]
    pub edition: i32,
}
/// Nested message and enum types in `CloudSqlSettings`.
pub mod cloud_sql_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlActivationPolicy {
        Unspecified = 0,
        Always = 1,
        Never = 2,
    }
    impl SqlActivationPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SqlActivationPolicy::Unspecified => "SQL_ACTIVATION_POLICY_UNSPECIFIED",
                SqlActivationPolicy::Always => "ALWAYS",
                SqlActivationPolicy::Never => "NEVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "ALWAYS" => Some(Self::Always),
                "NEVER" => Some(Self::Never),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlDataDiskType {
        Unspecified = 0,
        PdSsd = 1,
        PdHdd = 2,
    }
    impl SqlDataDiskType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SqlDataDiskType::Unspecified => "SQL_DATA_DISK_TYPE_UNSPECIFIED",
                SqlDataDiskType::PdSsd => "PD_SSD",
                SqlDataDiskType::PdHdd => "PD_HDD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_DATA_DISK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PD_SSD" => Some(Self::PdSsd),
                "PD_HDD" => Some(Self::PdHdd),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlDatabaseVersion {
        Unspecified = 0,
        Mysql56 = 1,
        Mysql57 = 2,
        Postgres96 = 3,
        Postgres11 = 4,
        Postgres10 = 5,
        Mysql80 = 6,
        Postgres12 = 7,
        Postgres13 = 8,
        Postgres14 = 17,
        Postgres15 = 18,
    }
    impl SqlDatabaseVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SqlDatabaseVersion::Unspecified => "SQL_DATABASE_VERSION_UNSPECIFIED",
                SqlDatabaseVersion::Mysql56 => "MYSQL_5_6",
                SqlDatabaseVersion::Mysql57 => "MYSQL_5_7",
                SqlDatabaseVersion::Postgres96 => "POSTGRES_9_6",
                SqlDatabaseVersion::Postgres11 => "POSTGRES_11",
                SqlDatabaseVersion::Postgres10 => "POSTGRES_10",
                SqlDatabaseVersion::Mysql80 => "MYSQL_8_0",
                SqlDatabaseVersion::Postgres12 => "POSTGRES_12",
                SqlDatabaseVersion::Postgres13 => "POSTGRES_13",
                SqlDatabaseVersion::Postgres14 => "POSTGRES_14",
                SqlDatabaseVersion::Postgres15 => "POSTGRES_15",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_DATABASE_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "MYSQL_5_6" => Some(Self::Mysql56),
                "MYSQL_5_7" => Some(Self::Mysql57),
                "POSTGRES_9_6" => Some(Self::Postgres96),
                "POSTGRES_11" => Some(Self::Postgres11),
                "POSTGRES_10" => Some(Self::Postgres10),
                "MYSQL_8_0" => Some(Self::Mysql80),
                "POSTGRES_12" => Some(Self::Postgres12),
                "POSTGRES_13" => Some(Self::Postgres13),
                "POSTGRES_14" => Some(Self::Postgres14),
                "POSTGRES_15" => Some(Self::Postgres15),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlAvailabilityType {
        Unspecified = 0,
        Zonal = 1,
        Regional = 2,
    }
    impl SqlAvailabilityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SqlAvailabilityType::Unspecified => "SQL_AVAILABILITY_TYPE_UNSPECIFIED",
                SqlAvailabilityType::Zonal => "ZONAL",
                SqlAvailabilityType::Regional => "REGIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ZONAL" => Some(Self::Zonal),
                "REGIONAL" => Some(Self::Regional),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Edition {
        Unspecified = 0,
        Enterprise = 2,
        EnterprisePlus = 3,
    }
    impl Edition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Edition::Unspecified => "EDITION_UNSPECIFIED",
                Edition::Enterprise => "ENTERPRISE",
                Edition::EnterprisePlus => "ENTERPRISE_PLUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "ENTERPRISE" => Some(Self::Enterprise),
                "ENTERPRISE_PLUS" => Some(Self::EnterprisePlus),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlloyDbSettings {
    #[prost(message, optional, tag = "1")]
    pub initial_user: ::core::option::Option<alloy_db_settings::UserPassword>,
    #[prost(string, tag = "2")]
    pub vpc_network: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "3")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "4")]
    pub primary_instance_settings: ::core::option::Option<
        alloy_db_settings::PrimaryInstanceSettings,
    >,
    #[prost(message, optional, tag = "5")]
    pub encryption_config: ::core::option::Option<alloy_db_settings::EncryptionConfig>,
}
/// Nested message and enum types in `AlloyDbSettings`.
pub mod alloy_db_settings {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserPassword {
        #[prost(string, tag = "1")]
        pub user: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub password: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub password_set: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PrimaryInstanceSettings {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub machine_config: ::core::option::Option<
            primary_instance_settings::MachineConfig,
        >,
        #[prost(btree_map = "string, string", tag = "6")]
        pub database_flags: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(btree_map = "string, string", tag = "7")]
        pub labels: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "8")]
        pub private_ip: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `PrimaryInstanceSettings`.
    pub mod primary_instance_settings {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MachineConfig {
            #[prost(int32, tag = "1")]
            pub cpu_count: i32,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EncryptionConfig {
        #[prost(string, tag = "1")]
        pub kms_key_name: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StaticIpConnectivity {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateServiceConnectConnectivity {
    #[prost(string, tag = "1")]
    pub service_attachment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReverseSshConnectivity {
    #[prost(string, tag = "1")]
    pub vm_ip: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub vm_port: i32,
    #[prost(string, tag = "3")]
    pub vm: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub vpc: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpcPeeringConnectivity {
    #[prost(string, tag = "1")]
    pub vpc: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardSshTunnelConnectivity {
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub port: i32,
    #[prost(
        oneof = "forward_ssh_tunnel_connectivity::AuthenticationMethod",
        tags = "100, 101"
    )]
    pub authentication_method: ::core::option::Option<
        forward_ssh_tunnel_connectivity::AuthenticationMethod,
    >,
}
/// Nested message and enum types in `ForwardSshTunnelConnectivity`.
pub mod forward_ssh_tunnel_connectivity {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AuthenticationMethod {
        #[prost(string, tag = "100")]
        Password(::prost::alloc::string::String),
        #[prost(string, tag = "101")]
        PrivateKey(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StaticServiceIpConnectivity {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateConnectivity {
    #[prost(string, tag = "1")]
    pub private_connection: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatabaseType {
    #[prost(enumeration = "DatabaseProvider", tag = "1")]
    pub provider: i32,
    #[prost(enumeration = "DatabaseEngine", tag = "2")]
    pub engine: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(btree_map = "string, string", tag = "4")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "migration_job::State", tag = "6")]
    pub state: i32,
    #[prost(enumeration = "migration_job::Phase", tag = "7")]
    pub phase: i32,
    #[prost(enumeration = "migration_job::Type", tag = "8")]
    pub r#type: i32,
    #[prost(string, tag = "9")]
    pub dump_path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "17")]
    pub dump_flags: ::core::option::Option<migration_job::DumpFlags>,
    #[prost(string, tag = "10")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub destination: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "13")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "14")]
    pub source_database: ::core::option::Option<DatabaseType>,
    #[prost(message, optional, tag = "15")]
    pub destination_database: ::core::option::Option<DatabaseType>,
    #[prost(message, optional, tag = "16")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "18")]
    pub conversion_workspace: ::core::option::Option<ConversionWorkspaceInfo>,
    #[prost(string, tag = "20")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub cmek_key_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "22")]
    pub performance_config: ::core::option::Option<migration_job::PerformanceConfig>,
    #[prost(oneof = "migration_job::Connectivity", tags = "101, 102, 103")]
    pub connectivity: ::core::option::Option<migration_job::Connectivity>,
}
/// Nested message and enum types in `MigrationJob`.
pub mod migration_job {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DumpFlag {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DumpFlags {
        #[prost(message, repeated, tag = "1")]
        pub dump_flags: ::prost::alloc::vec::Vec<DumpFlag>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PerformanceConfig {
        #[prost(enumeration = "performance_config::DumpParallelLevel", tag = "1")]
        pub dump_parallel_level: i32,
    }
    /// Nested message and enum types in `PerformanceConfig`.
    pub mod performance_config {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DumpParallelLevel {
            Unspecified = 0,
            Min = 1,
            Optimal = 2,
            Max = 3,
        }
        impl DumpParallelLevel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    DumpParallelLevel::Unspecified => "DUMP_PARALLEL_LEVEL_UNSPECIFIED",
                    DumpParallelLevel::Min => "MIN",
                    DumpParallelLevel::Optimal => "OPTIMAL",
                    DumpParallelLevel::Max => "MAX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DUMP_PARALLEL_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                    "MIN" => Some(Self::Min),
                    "OPTIMAL" => Some(Self::Optimal),
                    "MAX" => Some(Self::Max),
                    _ => None,
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Maintenance = 1,
        Draft = 2,
        Creating = 3,
        NotStarted = 4,
        Running = 5,
        Failed = 6,
        Completed = 7,
        Deleting = 8,
        Stopping = 9,
        Stopped = 10,
        Deleted = 11,
        Updating = 12,
        Starting = 13,
        Restarting = 14,
        Resuming = 15,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Maintenance => "MAINTENANCE",
                State::Draft => "DRAFT",
                State::Creating => "CREATING",
                State::NotStarted => "NOT_STARTED",
                State::Running => "RUNNING",
                State::Failed => "FAILED",
                State::Completed => "COMPLETED",
                State::Deleting => "DELETING",
                State::Stopping => "STOPPING",
                State::Stopped => "STOPPED",
                State::Deleted => "DELETED",
                State::Updating => "UPDATING",
                State::Starting => "STARTING",
                State::Restarting => "RESTARTING",
                State::Resuming => "RESUMING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "MAINTENANCE" => Some(Self::Maintenance),
                "DRAFT" => Some(Self::Draft),
                "CREATING" => Some(Self::Creating),
                "NOT_STARTED" => Some(Self::NotStarted),
                "RUNNING" => Some(Self::Running),
                "FAILED" => Some(Self::Failed),
                "COMPLETED" => Some(Self::Completed),
                "DELETING" => Some(Self::Deleting),
                "STOPPING" => Some(Self::Stopping),
                "STOPPED" => Some(Self::Stopped),
                "DELETED" => Some(Self::Deleted),
                "UPDATING" => Some(Self::Updating),
                "STARTING" => Some(Self::Starting),
                "RESTARTING" => Some(Self::Restarting),
                "RESUMING" => Some(Self::Resuming),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Phase {
        Unspecified = 0,
        FullDump = 1,
        Cdc = 2,
        PromoteInProgress = 3,
        WaitingForSourceWritesToStop = 4,
        PreparingTheDump = 5,
    }
    impl Phase {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Phase::Unspecified => "PHASE_UNSPECIFIED",
                Phase::FullDump => "FULL_DUMP",
                Phase::Cdc => "CDC",
                Phase::PromoteInProgress => "PROMOTE_IN_PROGRESS",
                Phase::WaitingForSourceWritesToStop => {
                    "WAITING_FOR_SOURCE_WRITES_TO_STOP"
                }
                Phase::PreparingTheDump => "PREPARING_THE_DUMP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PHASE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL_DUMP" => Some(Self::FullDump),
                "CDC" => Some(Self::Cdc),
                "PROMOTE_IN_PROGRESS" => Some(Self::PromoteInProgress),
                "WAITING_FOR_SOURCE_WRITES_TO_STOP" => {
                    Some(Self::WaitingForSourceWritesToStop)
                }
                "PREPARING_THE_DUMP" => Some(Self::PreparingTheDump),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        OneTime = 1,
        Continuous = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::OneTime => "ONE_TIME",
                Type::Continuous => "CONTINUOUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ONE_TIME" => Some(Self::OneTime),
                "CONTINUOUS" => Some(Self::Continuous),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Connectivity {
        #[prost(message, tag = "101")]
        ReverseSshConnectivity(super::ReverseSshConnectivity),
        #[prost(message, tag = "102")]
        VpcPeeringConnectivity(super::VpcPeeringConnectivity),
        #[prost(message, tag = "103")]
        StaticIpConnectivity(super::StaticIpConnectivity),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionWorkspaceInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commit_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(btree_map = "string, string", tag = "4")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "connection_profile::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(enumeration = "DatabaseProvider", tag = "8")]
    pub provider: i32,
    #[prost(
        oneof = "connection_profile::ConnectionProfile",
        tags = "100, 101, 104, 102, 105"
    )]
    pub connection_profile: ::core::option::Option<
        connection_profile::ConnectionProfile,
    >,
}
/// Nested message and enum types in `ConnectionProfile`.
pub mod connection_profile {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Draft = 1,
        Creating = 2,
        Ready = 3,
        Updating = 4,
        Deleting = 5,
        Deleted = 6,
        Failed = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Draft => "DRAFT",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Deleted => "DELETED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConnectionProfile {
        #[prost(message, tag = "100")]
        Mysql(super::MySqlConnectionProfile),
        #[prost(message, tag = "101")]
        Postgresql(super::PostgreSqlConnectionProfile),
        #[prost(message, tag = "104")]
        Oracle(super::OracleConnectionProfile),
        #[prost(message, tag = "102")]
        Cloudsql(super::CloudSqlConnectionProfile),
        #[prost(message, tag = "105")]
        Alloydb(super::AlloyDbConnectionProfile),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationJobVerificationError {
    #[prost(enumeration = "migration_job_verification_error::ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub error_detail_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MigrationJobVerificationError`.
pub mod migration_job_verification_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        Unspecified = 0,
        ConnectionFailure = 1,
        AuthenticationFailure = 2,
        InvalidConnectionProfileConfig = 3,
        VersionIncompatibility = 4,
        ConnectionProfileTypesIncompatibility = 5,
        NoPglogicalInstalled = 7,
        PglogicalNodeAlreadyExists = 8,
        InvalidWalLevel = 9,
        InvalidSharedPreloadLibrary = 10,
        InsufficientMaxReplicationSlots = 11,
        InsufficientMaxWalSenders = 12,
        InsufficientMaxWorkerProcesses = 13,
        UnsupportedExtensions = 14,
        UnsupportedMigrationType = 15,
        InvalidRdsLogicalReplication = 16,
        UnsupportedGtidMode = 17,
        UnsupportedTableDefinition = 18,
        UnsupportedDefiner = 19,
        CantRestartRunningMigration = 21,
        SourceAlreadySetup = 23,
        TablesWithLimitedSupport = 24,
        UnsupportedDatabaseLocale = 25,
        UnsupportedDatabaseFdwConfig = 26,
        ErrorRdbms = 27,
        SourceSizeExceedsThreshold = 28,
        ExistingConflictingDatabases = 29,
        ParallelImportInsufficientPrivilege = 30,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorCode::Unspecified => "ERROR_CODE_UNSPECIFIED",
                ErrorCode::ConnectionFailure => "CONNECTION_FAILURE",
                ErrorCode::AuthenticationFailure => "AUTHENTICATION_FAILURE",
                ErrorCode::InvalidConnectionProfileConfig => {
                    "INVALID_CONNECTION_PROFILE_CONFIG"
                }
                ErrorCode::VersionIncompatibility => "VERSION_INCOMPATIBILITY",
                ErrorCode::ConnectionProfileTypesIncompatibility => {
                    "CONNECTION_PROFILE_TYPES_INCOMPATIBILITY"
                }
                ErrorCode::NoPglogicalInstalled => "NO_PGLOGICAL_INSTALLED",
                ErrorCode::PglogicalNodeAlreadyExists => "PGLOGICAL_NODE_ALREADY_EXISTS",
                ErrorCode::InvalidWalLevel => "INVALID_WAL_LEVEL",
                ErrorCode::InvalidSharedPreloadLibrary => {
                    "INVALID_SHARED_PRELOAD_LIBRARY"
                }
                ErrorCode::InsufficientMaxReplicationSlots => {
                    "INSUFFICIENT_MAX_REPLICATION_SLOTS"
                }
                ErrorCode::InsufficientMaxWalSenders => "INSUFFICIENT_MAX_WAL_SENDERS",
                ErrorCode::InsufficientMaxWorkerProcesses => {
                    "INSUFFICIENT_MAX_WORKER_PROCESSES"
                }
                ErrorCode::UnsupportedExtensions => "UNSUPPORTED_EXTENSIONS",
                ErrorCode::UnsupportedMigrationType => "UNSUPPORTED_MIGRATION_TYPE",
                ErrorCode::InvalidRdsLogicalReplication => {
                    "INVALID_RDS_LOGICAL_REPLICATION"
                }
                ErrorCode::UnsupportedGtidMode => "UNSUPPORTED_GTID_MODE",
                ErrorCode::UnsupportedTableDefinition => "UNSUPPORTED_TABLE_DEFINITION",
                ErrorCode::UnsupportedDefiner => "UNSUPPORTED_DEFINER",
                ErrorCode::CantRestartRunningMigration => {
                    "CANT_RESTART_RUNNING_MIGRATION"
                }
                ErrorCode::SourceAlreadySetup => "SOURCE_ALREADY_SETUP",
                ErrorCode::TablesWithLimitedSupport => "TABLES_WITH_LIMITED_SUPPORT",
                ErrorCode::UnsupportedDatabaseLocale => "UNSUPPORTED_DATABASE_LOCALE",
                ErrorCode::UnsupportedDatabaseFdwConfig => {
                    "UNSUPPORTED_DATABASE_FDW_CONFIG"
                }
                ErrorCode::ErrorRdbms => "ERROR_RDBMS",
                ErrorCode::SourceSizeExceedsThreshold => "SOURCE_SIZE_EXCEEDS_THRESHOLD",
                ErrorCode::ExistingConflictingDatabases => {
                    "EXISTING_CONFLICTING_DATABASES"
                }
                ErrorCode::ParallelImportInsufficientPrivilege => {
                    "PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONNECTION_FAILURE" => Some(Self::ConnectionFailure),
                "AUTHENTICATION_FAILURE" => Some(Self::AuthenticationFailure),
                "INVALID_CONNECTION_PROFILE_CONFIG" => {
                    Some(Self::InvalidConnectionProfileConfig)
                }
                "VERSION_INCOMPATIBILITY" => Some(Self::VersionIncompatibility),
                "CONNECTION_PROFILE_TYPES_INCOMPATIBILITY" => {
                    Some(Self::ConnectionProfileTypesIncompatibility)
                }
                "NO_PGLOGICAL_INSTALLED" => Some(Self::NoPglogicalInstalled),
                "PGLOGICAL_NODE_ALREADY_EXISTS" => Some(Self::PglogicalNodeAlreadyExists),
                "INVALID_WAL_LEVEL" => Some(Self::InvalidWalLevel),
                "INVALID_SHARED_PRELOAD_LIBRARY" => {
                    Some(Self::InvalidSharedPreloadLibrary)
                }
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => {
                    Some(Self::InsufficientMaxReplicationSlots)
                }
                "INSUFFICIENT_MAX_WAL_SENDERS" => Some(Self::InsufficientMaxWalSenders),
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => {
                    Some(Self::InsufficientMaxWorkerProcesses)
                }
                "UNSUPPORTED_EXTENSIONS" => Some(Self::UnsupportedExtensions),
                "UNSUPPORTED_MIGRATION_TYPE" => Some(Self::UnsupportedMigrationType),
                "INVALID_RDS_LOGICAL_REPLICATION" => {
                    Some(Self::InvalidRdsLogicalReplication)
                }
                "UNSUPPORTED_GTID_MODE" => Some(Self::UnsupportedGtidMode),
                "UNSUPPORTED_TABLE_DEFINITION" => Some(Self::UnsupportedTableDefinition),
                "UNSUPPORTED_DEFINER" => Some(Self::UnsupportedDefiner),
                "CANT_RESTART_RUNNING_MIGRATION" => {
                    Some(Self::CantRestartRunningMigration)
                }
                "SOURCE_ALREADY_SETUP" => Some(Self::SourceAlreadySetup),
                "TABLES_WITH_LIMITED_SUPPORT" => Some(Self::TablesWithLimitedSupport),
                "UNSUPPORTED_DATABASE_LOCALE" => Some(Self::UnsupportedDatabaseLocale),
                "UNSUPPORTED_DATABASE_FDW_CONFIG" => {
                    Some(Self::UnsupportedDatabaseFdwConfig)
                }
                "ERROR_RDBMS" => Some(Self::ErrorRdbms),
                "SOURCE_SIZE_EXCEEDS_THRESHOLD" => Some(Self::SourceSizeExceedsThreshold),
                "EXISTING_CONFLICTING_DATABASES" => {
                    Some(Self::ExistingConflictingDatabases)
                }
                "PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => {
                    Some(Self::ParallelImportInsufficientPrivilege)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateConnection {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(btree_map = "string, string", tag = "4")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "private_connection::State", tag = "6")]
    pub state: i32,
    #[prost(message, optional, tag = "7")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(oneof = "private_connection::Connectivity", tags = "100")]
    pub connectivity: ::core::option::Option<private_connection::Connectivity>,
}
/// Nested message and enum types in `PrivateConnection`.
pub mod private_connection {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Created = 2,
        Failed = 3,
        Deleting = 4,
        FailedToDelete = 5,
        Deleted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Created => "CREATED",
                State::Failed => "FAILED",
                State::Deleting => "DELETING",
                State::FailedToDelete => "FAILED_TO_DELETE",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "CREATED" => Some(Self::Created),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                "FAILED_TO_DELETE" => Some(Self::FailedToDelete),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Connectivity {
        #[prost(message, tag = "100")]
        VpcPeeringConfig(super::VpcPeeringConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpcPeeringConfig {
    #[prost(string, tag = "1")]
    pub vpc_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subnet: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkArchitecture {
    Unspecified = 0,
    OldCsqlProducer = 1,
    NewCsqlProducer = 2,
}
impl NetworkArchitecture {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NetworkArchitecture::Unspecified => "NETWORK_ARCHITECTURE_UNSPECIFIED",
            NetworkArchitecture::OldCsqlProducer => {
                "NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER"
            }
            NetworkArchitecture::NewCsqlProducer => {
                "NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NETWORK_ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
            "NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER" => Some(Self::OldCsqlProducer),
            "NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER" => Some(Self::NewCsqlProducer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseEngine {
    Unspecified = 0,
    Mysql = 1,
    Postgresql = 2,
    Oracle = 4,
}
impl DatabaseEngine {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseEngine::Unspecified => "DATABASE_ENGINE_UNSPECIFIED",
            DatabaseEngine::Mysql => "MYSQL",
            DatabaseEngine::Postgresql => "POSTGRESQL",
            DatabaseEngine::Oracle => "ORACLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_ENGINE_UNSPECIFIED" => Some(Self::Unspecified),
            "MYSQL" => Some(Self::Mysql),
            "POSTGRESQL" => Some(Self::Postgresql),
            "ORACLE" => Some(Self::Oracle),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseProvider {
    Unspecified = 0,
    Cloudsql = 1,
    Rds = 2,
    Aurora = 3,
    Alloydb = 4,
}
impl DatabaseProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseProvider::Unspecified => "DATABASE_PROVIDER_UNSPECIFIED",
            DatabaseProvider::Cloudsql => "CLOUDSQL",
            DatabaseProvider::Rds => "RDS",
            DatabaseProvider::Aurora => "AURORA",
            DatabaseProvider::Alloydb => "ALLOYDB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOUDSQL" => Some(Self::Cloudsql),
            "RDS" => Some(Self::Rds),
            "AURORA" => Some(Self::Aurora),
            "ALLOYDB" => Some(Self::Alloydb),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseEngineInfo {
    #[prost(enumeration = "DatabaseEngine", tag = "1")]
    pub engine: i32,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionWorkspace {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub source: ::core::option::Option<DatabaseEngineInfo>,
    #[prost(message, optional, tag = "3")]
    pub destination: ::core::option::Option<DatabaseEngineInfo>,
    #[prost(btree_map = "string, string", tag = "4")]
    pub global_settings: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "5")]
    pub has_uncommitted_changes: bool,
    #[prost(string, tag = "6")]
    pub latest_commit_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub latest_commit_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "11")]
    pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackgroundJobLogEntry {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "BackgroundJobType", tag = "2")]
    pub job_type: i32,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub finish_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "background_job_log_entry::JobCompletionState", tag = "5")]
    pub completion_state: i32,
    #[prost(string, tag = "6")]
    pub completion_comment: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub request_autocommit: bool,
    #[prost(oneof = "background_job_log_entry::JobDetails", tags = "100, 101, 102, 103")]
    pub job_details: ::core::option::Option<background_job_log_entry::JobDetails>,
}
/// Nested message and enum types in `BackgroundJobLogEntry`.
pub mod background_job_log_entry {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SeedJobDetails {
        #[prost(string, tag = "1")]
        pub connection_profile: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImportRulesJobDetails {
        #[prost(string, repeated, tag = "1")]
        pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(enumeration = "super::ImportRulesFileFormat", tag = "2")]
        pub file_format: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConvertJobDetails {
        #[prost(string, tag = "1")]
        pub filter: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApplyJobDetails {
        #[prost(string, tag = "1")]
        pub connection_profile: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub filter: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JobCompletionState {
        Unspecified = 0,
        Succeeded = 1,
        Failed = 2,
    }
    impl JobCompletionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                JobCompletionState::Unspecified => "JOB_COMPLETION_STATE_UNSPECIFIED",
                JobCompletionState::Succeeded => "SUCCEEDED",
                JobCompletionState::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JOB_COMPLETION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum JobDetails {
        #[prost(message, tag = "100")]
        SeedJobDetails(SeedJobDetails),
        #[prost(message, tag = "101")]
        ImportRulesJobDetails(ImportRulesJobDetails),
        #[prost(message, tag = "102")]
        ConvertJobDetails(ConvertJobDetails),
        #[prost(message, tag = "103")]
        ApplyJobDetails(ApplyJobDetails),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingRuleFilter {
    #[prost(string, tag = "1")]
    pub parent_entity: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entity_name_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub entity_name_suffix: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub entity_name_contains: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub entities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingRule {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "mapping_rule::State", tag = "3")]
    pub state: i32,
    #[prost(enumeration = "DatabaseEntityType", tag = "4")]
    pub rule_scope: i32,
    #[prost(message, optional, tag = "5")]
    pub filter: ::core::option::Option<MappingRuleFilter>,
    #[prost(int64, tag = "6")]
    pub rule_order: i64,
    #[prost(string, tag = "7")]
    pub revision_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(
        oneof = "mapping_rule::Details",
        tags = "102, 103, 105, 106, 107, 108, 114, 115, 116, 117, 118"
    )]
    pub details: ::core::option::Option<mapping_rule::Details>,
}
/// Nested message and enum types in `MappingRule`.
pub mod mapping_rule {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Enabled = 1,
        Disabled = 2,
        Deleted = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Enabled => "ENABLED",
                State::Disabled => "DISABLED",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag = "102")]
        SingleEntityRename(super::SingleEntityRename),
        #[prost(message, tag = "103")]
        MultiEntityRename(super::MultiEntityRename),
        #[prost(message, tag = "105")]
        EntityMove(super::EntityMove),
        #[prost(message, tag = "106")]
        SingleColumnChange(super::SingleColumnChange),
        #[prost(message, tag = "107")]
        MultiColumnDataTypeChange(super::MultiColumnDatatypeChange),
        #[prost(message, tag = "108")]
        ConditionalColumnSetValue(super::ConditionalColumnSetValue),
        #[prost(message, tag = "114")]
        ConvertRowidColumn(super::ConvertRowIdToColumn),
        #[prost(message, tag = "115")]
        SetTablePrimaryKey(super::SetTablePrimaryKey),
        #[prost(message, tag = "116")]
        SinglePackageChange(super::SinglePackageChange),
        #[prost(message, tag = "117")]
        SourceSqlChange(super::SourceSqlChange),
        #[prost(message, tag = "118")]
        FilterTableColumns(super::FilterTableColumns),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleEntityRename {
    #[prost(string, tag = "1")]
    pub new_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiEntityRename {
    #[prost(string, tag = "1")]
    pub new_name_pattern: ::prost::alloc::string::String,
    #[prost(enumeration = "EntityNameTransformation", tag = "2")]
    pub source_name_transformation: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMove {
    #[prost(string, tag = "1")]
    pub new_schema: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleColumnChange {
    #[prost(string, tag = "1")]
    pub data_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub charset: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub collation: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub length: i64,
    #[prost(int32, tag = "5")]
    pub precision: i32,
    #[prost(int32, tag = "6")]
    pub scale: i32,
    #[prost(int32, tag = "7")]
    pub fractional_seconds_precision: i32,
    #[prost(bool, tag = "8")]
    pub array: bool,
    #[prost(int32, tag = "9")]
    pub array_length: i32,
    #[prost(bool, tag = "10")]
    pub nullable: bool,
    #[prost(bool, tag = "11")]
    pub auto_generated: bool,
    #[prost(bool, tag = "12")]
    pub udt: bool,
    #[prost(message, optional, tag = "13")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, repeated, tag = "14")]
    pub set_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "15")]
    pub comment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiColumnDatatypeChange {
    #[prost(string, tag = "1")]
    pub source_data_type_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_data_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub override_length: i64,
    #[prost(int32, tag = "4")]
    pub override_scale: i32,
    #[prost(int32, tag = "5")]
    pub override_precision: i32,
    #[prost(int32, tag = "6")]
    pub override_fractional_seconds_precision: i32,
    #[prost(message, optional, tag = "7")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
    #[prost(oneof = "multi_column_datatype_change::SourceFilter", tags = "100, 101")]
    pub source_filter: ::core::option::Option<
        multi_column_datatype_change::SourceFilter,
    >,
}
/// Nested message and enum types in `MultiColumnDatatypeChange`.
pub mod multi_column_datatype_change {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum SourceFilter {
        #[prost(message, tag = "100")]
        SourceTextFilter(super::SourceTextFilter),
        #[prost(message, tag = "101")]
        SourceNumericFilter(super::SourceNumericFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SourceTextFilter {
    #[prost(int64, tag = "1")]
    pub source_min_length_filter: i64,
    #[prost(int64, tag = "2")]
    pub source_max_length_filter: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SourceNumericFilter {
    #[prost(int32, tag = "1")]
    pub source_min_scale_filter: i32,
    #[prost(int32, tag = "2")]
    pub source_max_scale_filter: i32,
    #[prost(int32, tag = "3")]
    pub source_min_precision_filter: i32,
    #[prost(int32, tag = "4")]
    pub source_max_precision_filter: i32,
    #[prost(enumeration = "NumericFilterOption", tag = "5")]
    pub numeric_filter_option: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionalColumnSetValue {
    #[prost(message, optional, tag = "1")]
    pub value_transformation: ::core::option::Option<ValueTransformation>,
    #[prost(message, optional, tag = "2")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
    #[prost(oneof = "conditional_column_set_value::SourceFilter", tags = "100, 101")]
    pub source_filter: ::core::option::Option<
        conditional_column_set_value::SourceFilter,
    >,
}
/// Nested message and enum types in `ConditionalColumnSetValue`.
pub mod conditional_column_set_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum SourceFilter {
        #[prost(message, tag = "100")]
        SourceTextFilter(super::SourceTextFilter),
        #[prost(message, tag = "101")]
        SourceNumericFilter(super::SourceNumericFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueTransformation {
    #[prost(oneof = "value_transformation::Filter", tags = "100, 101, 102, 103")]
    pub filter: ::core::option::Option<value_transformation::Filter>,
    #[prost(
        oneof = "value_transformation::Action",
        tags = "200, 201, 202, 203, 204, 205"
    )]
    pub action: ::core::option::Option<value_transformation::Action>,
}
/// Nested message and enum types in `ValueTransformation`.
pub mod value_transformation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        #[prost(message, tag = "100")]
        IsNull(()),
        #[prost(message, tag = "101")]
        ValueList(super::ValueListFilter),
        #[prost(message, tag = "102")]
        IntComparison(super::IntComparisonFilter),
        #[prost(message, tag = "103")]
        DoubleComparison(super::DoubleComparisonFilter),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "200")]
        AssignNull(()),
        #[prost(message, tag = "201")]
        AssignSpecificValue(super::AssignSpecificValue),
        #[prost(message, tag = "202")]
        AssignMinValue(()),
        #[prost(message, tag = "203")]
        AssignMaxValue(()),
        #[prost(message, tag = "204")]
        RoundScale(super::RoundToScale),
        #[prost(message, tag = "205")]
        ApplyHash(super::ApplyHash),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConvertRowIdToColumn {
    #[prost(bool, tag = "1")]
    pub only_if_no_primary_key: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTablePrimaryKey {
    #[prost(string, repeated, tag = "1")]
    pub primary_key_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub primary_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SinglePackageChange {
    #[prost(string, tag = "1")]
    pub package_description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub package_body: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceSqlChange {
    #[prost(string, tag = "1")]
    pub sql_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterTableColumns {
    #[prost(string, repeated, tag = "1")]
    pub include_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub exclude_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueListFilter {
    #[prost(enumeration = "ValuePresentInList", tag = "1")]
    pub value_present_list: i32,
    #[prost(string, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "3")]
    pub ignore_case: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IntComparisonFilter {
    #[prost(enumeration = "ValueComparison", tag = "1")]
    pub value_comparison: i32,
    #[prost(int64, tag = "2")]
    pub value: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoubleComparisonFilter {
    #[prost(enumeration = "ValueComparison", tag = "1")]
    pub value_comparison: i32,
    #[prost(double, tag = "2")]
    pub value: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignSpecificValue {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApplyHash {
    #[prost(oneof = "apply_hash::HashFunction", tags = "100")]
    pub hash_function: ::core::option::Option<apply_hash::HashFunction>,
}
/// Nested message and enum types in `ApplyHash`.
pub mod apply_hash {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum HashFunction {
        #[prost(message, tag = "100")]
        UuidFromBytes(()),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoundToScale {
    #[prost(int32, tag = "1")]
    pub scale: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseEntity {
    #[prost(string, tag = "1")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parent_entity: ::prost::alloc::string::String,
    #[prost(enumeration = "database_entity::TreeType", tag = "3")]
    pub tree: i32,
    #[prost(enumeration = "DatabaseEntityType", tag = "4")]
    pub entity_type: i32,
    #[prost(message, repeated, tag = "5")]
    pub mappings: ::prost::alloc::vec::Vec<EntityMapping>,
    #[prost(message, repeated, tag = "6")]
    pub entity_ddl: ::prost::alloc::vec::Vec<EntityDdl>,
    #[prost(message, repeated, tag = "7")]
    pub issues: ::prost::alloc::vec::Vec<EntityIssue>,
    #[prost(
        oneof = "database_entity::EntityBody",
        tags = "101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111"
    )]
    pub entity_body: ::core::option::Option<database_entity::EntityBody>,
}
/// Nested message and enum types in `DatabaseEntity`.
pub mod database_entity {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TreeType {
        Unspecified = 0,
        Source = 1,
        Draft = 2,
        Destination = 3,
    }
    impl TreeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TreeType::Unspecified => "TREE_TYPE_UNSPECIFIED",
                TreeType::Source => "SOURCE",
                TreeType::Draft => "DRAFT",
                TreeType::Destination => "DESTINATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TREE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SOURCE" => Some(Self::Source),
                "DRAFT" => Some(Self::Draft),
                "DESTINATION" => Some(Self::Destination),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EntityBody {
        #[prost(message, tag = "101")]
        Database(super::DatabaseInstanceEntity),
        #[prost(message, tag = "102")]
        Schema(super::SchemaEntity),
        #[prost(message, tag = "103")]
        Table(super::TableEntity),
        #[prost(message, tag = "104")]
        View(super::ViewEntity),
        #[prost(message, tag = "105")]
        Sequence(super::SequenceEntity),
        #[prost(message, tag = "106")]
        StoredProcedure(super::StoredProcedureEntity),
        #[prost(message, tag = "107")]
        DatabaseFunction(super::FunctionEntity),
        #[prost(message, tag = "108")]
        Synonym(super::SynonymEntity),
        #[prost(message, tag = "109")]
        DatabasePackage(super::PackageEntity),
        #[prost(message, tag = "110")]
        Udt(super::UdtEntity),
        #[prost(message, tag = "111")]
        MaterializedView(super::MaterializedViewEntity),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseInstanceEntity {
    #[prost(message, optional, tag = "1")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaEntity {
    #[prost(message, optional, tag = "1")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableEntity {
    #[prost(message, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<ColumnEntity>,
    #[prost(message, repeated, tag = "2")]
    pub constraints: ::prost::alloc::vec::Vec<ConstraintEntity>,
    #[prost(message, repeated, tag = "3")]
    pub indices: ::prost::alloc::vec::Vec<IndexEntity>,
    #[prost(message, repeated, tag = "4")]
    pub triggers: ::prost::alloc::vec::Vec<TriggerEntity>,
    #[prost(message, optional, tag = "5")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "6")]
    pub comment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnEntity {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub data_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub charset: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub collation: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub length: i64,
    #[prost(int32, tag = "6")]
    pub precision: i32,
    #[prost(int32, tag = "7")]
    pub scale: i32,
    #[prost(int32, tag = "8")]
    pub fractional_seconds_precision: i32,
    #[prost(bool, tag = "9")]
    pub array: bool,
    #[prost(int32, tag = "10")]
    pub array_length: i32,
    #[prost(bool, tag = "11")]
    pub nullable: bool,
    #[prost(bool, tag = "12")]
    pub auto_generated: bool,
    #[prost(bool, tag = "13")]
    pub udt: bool,
    #[prost(message, optional, tag = "14")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, repeated, tag = "15")]
    pub set_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "16")]
    pub comment: ::prost::alloc::string::String,
    #[prost(int32, tag = "17")]
    pub ordinal_position: i32,
    #[prost(string, tag = "18")]
    pub default_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstraintEntity {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub table_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, repeated, tag = "5")]
    pub reference_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub reference_table: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub table_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexEntity {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub table_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub unique: bool,
    #[prost(message, optional, tag = "5")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerEntity {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub triggering_events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub trigger_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub sql_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewEntity {
    #[prost(string, tag = "1")]
    pub sql_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, repeated, tag = "3")]
    pub constraints: ::prost::alloc::vec::Vec<ConstraintEntity>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequenceEntity {
    #[prost(int64, tag = "1")]
    pub increment: i64,
    #[prost(bytes = "vec", tag = "2")]
    pub start_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub max_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub min_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "5")]
    pub cycle: bool,
    #[prost(int64, tag = "6")]
    pub cache: i64,
    #[prost(message, optional, tag = "7")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoredProcedureEntity {
    #[prost(string, tag = "1")]
    pub sql_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionEntity {
    #[prost(string, tag = "1")]
    pub sql_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaterializedViewEntity {
    #[prost(string, tag = "1")]
    pub sql_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynonymEntity {
    #[prost(string, tag = "1")]
    pub source_entity: ::prost::alloc::string::String,
    #[prost(enumeration = "DatabaseEntityType", tag = "2")]
    pub source_type: i32,
    #[prost(message, optional, tag = "3")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageEntity {
    #[prost(string, tag = "1")]
    pub package_sql_code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub package_body: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UdtEntity {
    #[prost(string, tag = "1")]
    pub udt_sql_code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub udt_body: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub custom_features: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMapping {
    #[prost(string, tag = "1")]
    pub source_entity: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub draft_entity: ::prost::alloc::string::String,
    #[prost(enumeration = "DatabaseEntityType", tag = "4")]
    pub source_type: i32,
    #[prost(enumeration = "DatabaseEntityType", tag = "5")]
    pub draft_type: i32,
    #[prost(message, repeated, tag = "3")]
    pub mapping_log: ::prost::alloc::vec::Vec<EntityMappingLogEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMappingLogEntry {
    #[prost(string, tag = "1")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rule_revision_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub mapping_comment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityDdl {
    #[prost(string, tag = "1")]
    pub ddl_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entity: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ddl: ::prost::alloc::string::String,
    #[prost(enumeration = "DatabaseEntityType", tag = "4")]
    pub entity_type: i32,
    #[prost(string, repeated, tag = "100")]
    pub issue_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityIssue {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "entity_issue::IssueType", tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "entity_issue::IssueSeverity", tag = "3")]
    pub severity: i32,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "6")]
    pub ddl: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub position: ::core::option::Option<entity_issue::Position>,
    #[prost(enumeration = "DatabaseEntityType", tag = "8")]
    pub entity_type: i32,
}
/// Nested message and enum types in `EntityIssue`.
pub mod entity_issue {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Position {
        #[prost(int32, tag = "1")]
        pub line: i32,
        #[prost(int32, tag = "2")]
        pub column: i32,
        #[prost(int32, tag = "3")]
        pub offset: i32,
        #[prost(int32, tag = "4")]
        pub length: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IssueType {
        Unspecified = 0,
        Ddl = 1,
        Apply = 2,
        Convert = 3,
    }
    impl IssueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IssueType::Unspecified => "ISSUE_TYPE_UNSPECIFIED",
                IssueType::Ddl => "ISSUE_TYPE_DDL",
                IssueType::Apply => "ISSUE_TYPE_APPLY",
                IssueType::Convert => "ISSUE_TYPE_CONVERT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ISSUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ISSUE_TYPE_DDL" => Some(Self::Ddl),
                "ISSUE_TYPE_APPLY" => Some(Self::Apply),
                "ISSUE_TYPE_CONVERT" => Some(Self::Convert),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IssueSeverity {
        Unspecified = 0,
        Info = 1,
        Warning = 2,
        Error = 3,
    }
    impl IssueSeverity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IssueSeverity::Unspecified => "ISSUE_SEVERITY_UNSPECIFIED",
                IssueSeverity::Info => "ISSUE_SEVERITY_INFO",
                IssueSeverity::Warning => "ISSUE_SEVERITY_WARNING",
                IssueSeverity::Error => "ISSUE_SEVERITY_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ISSUE_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "ISSUE_SEVERITY_INFO" => Some(Self::Info),
                "ISSUE_SEVERITY_WARNING" => Some(Self::Warning),
                "ISSUE_SEVERITY_ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValuePresentInList {
    Unspecified = 0,
    IfValueList = 1,
    IfValueNotList = 2,
}
impl ValuePresentInList {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ValuePresentInList::Unspecified => "VALUE_PRESENT_IN_LIST_UNSPECIFIED",
            ValuePresentInList::IfValueList => "VALUE_PRESENT_IN_LIST_IF_VALUE_LIST",
            ValuePresentInList::IfValueNotList => {
                "VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALUE_PRESENT_IN_LIST_UNSPECIFIED" => Some(Self::Unspecified),
            "VALUE_PRESENT_IN_LIST_IF_VALUE_LIST" => Some(Self::IfValueList),
            "VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST" => Some(Self::IfValueNotList),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseEntityType {
    Unspecified = 0,
    Schema = 1,
    Table = 2,
    Column = 3,
    Constraint = 4,
    Index = 5,
    Trigger = 6,
    View = 7,
    Sequence = 8,
    StoredProcedure = 9,
    Function = 10,
    Synonym = 11,
    DatabasePackage = 12,
    Udt = 13,
    MaterializedView = 14,
    Database = 15,
}
impl DatabaseEntityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseEntityType::Unspecified => "DATABASE_ENTITY_TYPE_UNSPECIFIED",
            DatabaseEntityType::Schema => "DATABASE_ENTITY_TYPE_SCHEMA",
            DatabaseEntityType::Table => "DATABASE_ENTITY_TYPE_TABLE",
            DatabaseEntityType::Column => "DATABASE_ENTITY_TYPE_COLUMN",
            DatabaseEntityType::Constraint => "DATABASE_ENTITY_TYPE_CONSTRAINT",
            DatabaseEntityType::Index => "DATABASE_ENTITY_TYPE_INDEX",
            DatabaseEntityType::Trigger => "DATABASE_ENTITY_TYPE_TRIGGER",
            DatabaseEntityType::View => "DATABASE_ENTITY_TYPE_VIEW",
            DatabaseEntityType::Sequence => "DATABASE_ENTITY_TYPE_SEQUENCE",
            DatabaseEntityType::StoredProcedure => {
                "DATABASE_ENTITY_TYPE_STORED_PROCEDURE"
            }
            DatabaseEntityType::Function => "DATABASE_ENTITY_TYPE_FUNCTION",
            DatabaseEntityType::Synonym => "DATABASE_ENTITY_TYPE_SYNONYM",
            DatabaseEntityType::DatabasePackage => {
                "DATABASE_ENTITY_TYPE_DATABASE_PACKAGE"
            }
            DatabaseEntityType::Udt => "DATABASE_ENTITY_TYPE_UDT",
            DatabaseEntityType::MaterializedView => {
                "DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW"
            }
            DatabaseEntityType::Database => "DATABASE_ENTITY_TYPE_DATABASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DATABASE_ENTITY_TYPE_SCHEMA" => Some(Self::Schema),
            "DATABASE_ENTITY_TYPE_TABLE" => Some(Self::Table),
            "DATABASE_ENTITY_TYPE_COLUMN" => Some(Self::Column),
            "DATABASE_ENTITY_TYPE_CONSTRAINT" => Some(Self::Constraint),
            "DATABASE_ENTITY_TYPE_INDEX" => Some(Self::Index),
            "DATABASE_ENTITY_TYPE_TRIGGER" => Some(Self::Trigger),
            "DATABASE_ENTITY_TYPE_VIEW" => Some(Self::View),
            "DATABASE_ENTITY_TYPE_SEQUENCE" => Some(Self::Sequence),
            "DATABASE_ENTITY_TYPE_STORED_PROCEDURE" => Some(Self::StoredProcedure),
            "DATABASE_ENTITY_TYPE_FUNCTION" => Some(Self::Function),
            "DATABASE_ENTITY_TYPE_SYNONYM" => Some(Self::Synonym),
            "DATABASE_ENTITY_TYPE_DATABASE_PACKAGE" => Some(Self::DatabasePackage),
            "DATABASE_ENTITY_TYPE_UDT" => Some(Self::Udt),
            "DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW" => Some(Self::MaterializedView),
            "DATABASE_ENTITY_TYPE_DATABASE" => Some(Self::Database),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntityNameTransformation {
    Unspecified = 0,
    NoTransformation = 1,
    LowerCase = 2,
    UpperCase = 3,
    CapitalizedCase = 4,
}
impl EntityNameTransformation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EntityNameTransformation::Unspecified => {
                "ENTITY_NAME_TRANSFORMATION_UNSPECIFIED"
            }
            EntityNameTransformation::NoTransformation => {
                "ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION"
            }
            EntityNameTransformation::LowerCase => {
                "ENTITY_NAME_TRANSFORMATION_LOWER_CASE"
            }
            EntityNameTransformation::UpperCase => {
                "ENTITY_NAME_TRANSFORMATION_UPPER_CASE"
            }
            EntityNameTransformation::CapitalizedCase => {
                "ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTITY_NAME_TRANSFORMATION_UNSPECIFIED" => Some(Self::Unspecified),
            "ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION" => {
                Some(Self::NoTransformation)
            }
            "ENTITY_NAME_TRANSFORMATION_LOWER_CASE" => Some(Self::LowerCase),
            "ENTITY_NAME_TRANSFORMATION_UPPER_CASE" => Some(Self::UpperCase),
            "ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE" => Some(Self::CapitalizedCase),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackgroundJobType {
    Unspecified = 0,
    SourceSeed = 1,
    Convert = 2,
    ApplyDestination = 3,
    ImportRulesFile = 5,
}
impl BackgroundJobType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BackgroundJobType::Unspecified => "BACKGROUND_JOB_TYPE_UNSPECIFIED",
            BackgroundJobType::SourceSeed => "BACKGROUND_JOB_TYPE_SOURCE_SEED",
            BackgroundJobType::Convert => "BACKGROUND_JOB_TYPE_CONVERT",
            BackgroundJobType::ApplyDestination => {
                "BACKGROUND_JOB_TYPE_APPLY_DESTINATION"
            }
            BackgroundJobType::ImportRulesFile => "BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKGROUND_JOB_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BACKGROUND_JOB_TYPE_SOURCE_SEED" => Some(Self::SourceSeed),
            "BACKGROUND_JOB_TYPE_CONVERT" => Some(Self::Convert),
            "BACKGROUND_JOB_TYPE_APPLY_DESTINATION" => Some(Self::ApplyDestination),
            "BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE" => Some(Self::ImportRulesFile),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImportRulesFileFormat {
    Unspecified = 0,
    HarbourBridgeSessionFile = 1,
    OratopgConfigFile = 2,
}
impl ImportRulesFileFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ImportRulesFileFormat::Unspecified => "IMPORT_RULES_FILE_FORMAT_UNSPECIFIED",
            ImportRulesFileFormat::HarbourBridgeSessionFile => {
                "IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE"
            }
            ImportRulesFileFormat::OratopgConfigFile => {
                "IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMPORT_RULES_FILE_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE" => {
                Some(Self::HarbourBridgeSessionFile)
            }
            "IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE" => {
                Some(Self::OratopgConfigFile)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValueComparison {
    Unspecified = 0,
    IfValueSmallerThan = 1,
    IfValueSmallerEqualThan = 2,
    IfValueLargerThan = 3,
    IfValueLargerEqualThan = 4,
}
impl ValueComparison {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ValueComparison::Unspecified => "VALUE_COMPARISON_UNSPECIFIED",
            ValueComparison::IfValueSmallerThan => {
                "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN"
            }
            ValueComparison::IfValueSmallerEqualThan => {
                "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN"
            }
            ValueComparison::IfValueLargerThan => "VALUE_COMPARISON_IF_VALUE_LARGER_THAN",
            ValueComparison::IfValueLargerEqualThan => {
                "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALUE_COMPARISON_UNSPECIFIED" => Some(Self::Unspecified),
            "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN" => Some(Self::IfValueSmallerThan),
            "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN" => {
                Some(Self::IfValueSmallerEqualThan)
            }
            "VALUE_COMPARISON_IF_VALUE_LARGER_THAN" => Some(Self::IfValueLargerThan),
            "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN" => {
                Some(Self::IfValueLargerEqualThan)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NumericFilterOption {
    Unspecified = 0,
    All = 1,
    Limit = 2,
    Limitless = 3,
}
impl NumericFilterOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NumericFilterOption::Unspecified => "NUMERIC_FILTER_OPTION_UNSPECIFIED",
            NumericFilterOption::All => "NUMERIC_FILTER_OPTION_ALL",
            NumericFilterOption::Limit => "NUMERIC_FILTER_OPTION_LIMIT",
            NumericFilterOption::Limitless => "NUMERIC_FILTER_OPTION_LIMITLESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NUMERIC_FILTER_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
            "NUMERIC_FILTER_OPTION_ALL" => Some(Self::All),
            "NUMERIC_FILTER_OPTION_LIMIT" => Some(Self::Limit),
            "NUMERIC_FILTER_OPTION_LIMITLESS" => Some(Self::Limitless),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMigrationJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMigrationJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub migration_jobs: ::prost::alloc::vec::Vec<MigrationJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub migration_job_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub migration_job: ::core::option::Option<MigrationJob>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMigrationJobRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub migration_job: ::core::option::Option<MigrationJob>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub skip_validation: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "3")]
    pub migration_job: ::core::option::Option<MigrationJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartMigrationJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub skip_validation: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateSshScriptRequest {
    #[prost(string, tag = "1")]
    pub migration_job: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vm: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub vm_port: i32,
    #[prost(oneof = "generate_ssh_script_request::VmConfig", tags = "100, 101")]
    pub vm_config: ::core::option::Option<generate_ssh_script_request::VmConfig>,
}
/// Nested message and enum types in `GenerateSshScriptRequest`.
pub mod generate_ssh_script_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VmConfig {
        #[prost(message, tag = "100")]
        VmCreationConfig(super::VmCreationConfig),
        #[prost(message, tag = "101")]
        VmSelectionConfig(super::VmSelectionConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmCreationConfig {
    #[prost(string, tag = "1")]
    pub vm_machine_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vm_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub subnet: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmSelectionConfig {
    #[prost(string, tag = "1")]
    pub vm_zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SshScript {
    #[prost(string, tag = "1")]
    pub script: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateTcpProxyScriptRequest {
    #[prost(string, tag = "1")]
    pub migration_job: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vm_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub vm_machine_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub vm_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub vm_subnet: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TcpProxyScript {
    #[prost(string, tag = "1")]
    pub script: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectionProfilesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectionProfilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub connection_profiles: ::prost::alloc::vec::Vec<ConnectionProfile>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectionProfileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConnectionProfileRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub connection_profile_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub connection_profile: ::core::option::Option<ConnectionProfile>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    #[prost(bool, tag = "6")]
    pub skip_validation: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConnectionProfileRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub connection_profile: ::core::option::Option<ConnectionProfile>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    #[prost(bool, tag = "5")]
    pub skip_validation: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConnectionProfileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePrivateConnectionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub private_connection_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub private_connection: ::core::option::Option<PrivateConnection>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub skip_validation: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateConnectionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateConnectionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub private_connections: ::prost::alloc::vec::Vec<PrivateConnection>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePrivateConnectionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPrivateConnectionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversionWorkspacesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversionWorkspacesResponse {
    #[prost(message, repeated, tag = "1")]
    pub conversion_workspaces: ::prost::alloc::vec::Vec<ConversionWorkspace>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub conversion_workspace_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub conversion_workspace: ::core::option::Option<ConversionWorkspace>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversionWorkspaceRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub conversion_workspace: ::core::option::Option<ConversionWorkspace>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commit_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub dry_run: bool,
    #[prost(bool, tag = "4")]
    pub auto_commit: bool,
    #[prost(oneof = "apply_conversion_workspace_request::Destination", tags = "100")]
    pub destination: ::core::option::Option<
        apply_conversion_workspace_request::Destination,
    >,
}
/// Nested message and enum types in `ApplyConversionWorkspaceRequest`.
pub mod apply_conversion_workspace_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(string, tag = "100")]
        ConnectionProfile(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMappingRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMappingRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub mapping_rules: ::prost::alloc::vec::Vec<MappingRule>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeedConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub auto_commit: bool,
    #[prost(oneof = "seed_conversion_workspace_request::SeedFrom", tags = "100, 101")]
    pub seed_from: ::core::option::Option<seed_conversion_workspace_request::SeedFrom>,
}
/// Nested message and enum types in `SeedConversionWorkspaceRequest`.
pub mod seed_conversion_workspace_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SeedFrom {
        #[prost(string, tag = "100")]
        SourceConnectionProfile(::prost::alloc::string::String),
        #[prost(string, tag = "101")]
        DestinationConnectionProfile(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertConversionWorkspaceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub auto_commit: bool,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub convert_full_path: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportMappingRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "ImportRulesFileFormat", tag = "2")]
    pub rules_format: i32,
    #[prost(message, repeated, tag = "3")]
    pub rules_files: ::prost::alloc::vec::Vec<import_mapping_rules_request::RulesFile>,
    #[prost(bool, tag = "6")]
    pub auto_commit: bool,
}
/// Nested message and enum types in `ImportMappingRulesRequest`.
pub mod import_mapping_rules_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RulesFile {
        #[prost(string, tag = "1")]
        pub rules_source_filename: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub rules_content: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeDatabaseEntitiesRequest {
    #[prost(string, tag = "1")]
    pub conversion_workspace: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "describe_database_entities_request::DbTreeType", tag = "6")]
    pub tree: i32,
    #[prost(bool, tag = "11")]
    pub uncommitted: bool,
    #[prost(string, tag = "12")]
    pub commit_id: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub filter: ::prost::alloc::string::String,
    #[prost(enumeration = "DatabaseEntityView", tag = "14")]
    pub view: i32,
}
/// Nested message and enum types in `DescribeDatabaseEntitiesRequest`.
pub mod describe_database_entities_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DbTreeType {
        Unspecified = 0,
        SourceTree = 1,
        DraftTree = 2,
        DestinationTree = 3,
    }
    impl DbTreeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DbTreeType::Unspecified => "DB_TREE_TYPE_UNSPECIFIED",
                DbTreeType::SourceTree => "SOURCE_TREE",
                DbTreeType::DraftTree => "DRAFT_TREE",
                DbTreeType::DestinationTree => "DESTINATION_TREE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DB_TREE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SOURCE_TREE" => Some(Self::SourceTree),
                "DRAFT_TREE" => Some(Self::DraftTree),
                "DESTINATION_TREE" => Some(Self::DestinationTree),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeDatabaseEntitiesResponse {
    #[prost(message, repeated, tag = "1")]
    pub database_entities: ::prost::alloc::vec::Vec<DatabaseEntity>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchBackgroundJobsRequest {
    #[prost(string, tag = "1")]
    pub conversion_workspace: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub return_most_recent_per_job_type: bool,
    #[prost(int32, tag = "3")]
    pub max_size: i32,
    #[prost(message, optional, tag = "4")]
    pub completed_until_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchBackgroundJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub jobs: ::prost::alloc::vec::Vec<BackgroundJobLogEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeConversionWorkspaceRevisionsRequest {
    #[prost(string, tag = "1")]
    pub conversion_workspace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commit_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeConversionWorkspaceRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub revisions: ::prost::alloc::vec::Vec<ConversionWorkspace>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMappingRuleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mapping_rule_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub mapping_rule: ::core::option::Option<MappingRule>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMappingRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchStaticIpsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchStaticIpsResponse {
    #[prost(string, repeated, tag = "1")]
    pub static_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseEntityView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
    RootSummary = 3,
}
impl DatabaseEntityView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseEntityView::Unspecified => "DATABASE_ENTITY_VIEW_UNSPECIFIED",
            DatabaseEntityView::Basic => "DATABASE_ENTITY_VIEW_BASIC",
            DatabaseEntityView::Full => "DATABASE_ENTITY_VIEW_FULL",
            DatabaseEntityView::RootSummary => "DATABASE_ENTITY_VIEW_ROOT_SUMMARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_ENTITY_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "DATABASE_ENTITY_VIEW_BASIC" => Some(Self::Basic),
            "DATABASE_ENTITY_VIEW_FULL" => Some(Self::Full),
            "DATABASE_ENTITY_VIEW_ROOT_SUMMARY" => Some(Self::RootSummary),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod data_migration_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Database Migration service
    #[derive(Debug, Clone)]
    pub struct DataMigrationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DataMigrationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataMigrationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DataMigrationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists migration jobs in a given project and location.
        pub async fn list_migration_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMigrationJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMigrationJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ListMigrationJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ListMigrationJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single migration job.
        pub async fn get_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMigrationJobRequest>,
        ) -> std::result::Result<tonic::Response<super::MigrationJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/GetMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "GetMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new migration job in a given project and location.
        pub async fn create_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/CreateMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "CreateMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single migration job.
        pub async fn update_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/UpdateMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "UpdateMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single migration job.
        pub async fn delete_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/DeleteMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "DeleteMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Start an already created migration job.
        pub async fn start_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::StartMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/StartMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "StartMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops a running migration job.
        pub async fn stop_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::StopMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/StopMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "StopMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resume a migration job that is currently stopped and is resumable (was
        /// stopped during CDC phase).
        pub async fn resume_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::ResumeMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ResumeMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ResumeMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Promote a migration job, stopping replication to the destination and
        /// promoting the destination to be a standalone database.
        pub async fn promote_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::PromoteMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/PromoteMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "PromoteMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Verify a migration job, making sure the destination can reach the source
        /// and that all configuration and prerequisites are met.
        pub async fn verify_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifyMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/VerifyMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "VerifyMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restart a stopped or failed migration job, resetting the destination
        /// instance to its original state and starting the migration process from
        /// scratch.
        pub async fn restart_migration_job(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartMigrationJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/RestartMigrationJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "RestartMigrationJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generate a SSH configuration script to configure the reverse SSH
        /// connectivity.
        pub async fn generate_ssh_script(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateSshScriptRequest>,
        ) -> std::result::Result<tonic::Response<super::SshScript>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/GenerateSshScript",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "GenerateSshScript",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generate a TCP Proxy configuration script to configure a cloud-hosted VM
        /// running a TCP Proxy.
        pub async fn generate_tcp_proxy_script(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateTcpProxyScriptRequest>,
        ) -> std::result::Result<tonic::Response<super::TcpProxyScript>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/GenerateTcpProxyScript",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "GenerateTcpProxyScript",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of all connection profiles in a given project and
        /// location.
        pub async fn list_connection_profiles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConnectionProfilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectionProfilesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ListConnectionProfiles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ListConnectionProfiles",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single connection profile.
        pub async fn get_connection_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectionProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectionProfile>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/GetConnectionProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "GetConnectionProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new connection profile in a given project and location.
        pub async fn create_connection_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConnectionProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/CreateConnectionProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "CreateConnectionProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the configuration of a single connection profile.
        pub async fn update_connection_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConnectionProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/UpdateConnectionProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "UpdateConnectionProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Database Migration Service connection profile.
        /// A connection profile can only be deleted if it is not in use by any
        /// active migration jobs.
        pub async fn delete_connection_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConnectionProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/DeleteConnectionProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "DeleteConnectionProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new private connection in a given project and location.
        pub async fn create_private_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePrivateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/CreatePrivateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "CreatePrivateConnection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single private connection.
        pub async fn get_private_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPrivateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PrivateConnection>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/GetPrivateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "GetPrivateConnection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of private connections in a given project and location.
        pub async fn list_private_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPrivateConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPrivateConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ListPrivateConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ListPrivateConnections",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Database Migration Service private connection.
        pub async fn delete_private_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePrivateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/DeletePrivateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "DeletePrivateConnection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single conversion workspace.
        pub async fn get_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConversionWorkspace>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/GetConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "GetConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists conversion workspaces in a given project and location.
        pub async fn list_conversion_workspaces(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversionWorkspacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConversionWorkspacesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ListConversionWorkspaces",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ListConversionWorkspaces",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new conversion workspace in a given project and location.
        pub async fn create_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/CreateConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "CreateConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single conversion workspace.
        pub async fn update_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/UpdateConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "UpdateConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single conversion workspace.
        pub async fn delete_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/DeleteConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "DeleteConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new mapping rule for a given conversion workspace.
        pub async fn create_mapping_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMappingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::MappingRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/CreateMappingRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "CreateMappingRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single mapping rule.
        pub async fn delete_mapping_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMappingRuleRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/DeleteMappingRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "DeleteMappingRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the mapping rules for a specific conversion workspace.
        pub async fn list_mapping_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMappingRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMappingRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ListMappingRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ListMappingRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a mapping rule.
        pub async fn get_mapping_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMappingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::MappingRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/GetMappingRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "GetMappingRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports a snapshot of the source database into the
        /// conversion workspace.
        pub async fn seed_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::SeedConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/SeedConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "SeedConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports the mapping rules for a given conversion workspace.
        /// Supports various formats of external rules files.
        pub async fn import_mapping_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportMappingRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ImportMappingRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ImportMappingRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a draft tree schema for the destination database.
        pub async fn convert_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::ConvertConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ConvertConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ConvertConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Marks all the data in the conversion workspace as committed.
        pub async fn commit_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::CommitConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/CommitConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "CommitConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rolls back a conversion workspace to the last committed snapshot.
        pub async fn rollback_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/RollbackConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "RollbackConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies draft tree onto a specific destination database.
        pub async fn apply_conversion_workspace(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyConversionWorkspaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/ApplyConversionWorkspace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "ApplyConversionWorkspace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Describes the database entities tree for a specific conversion workspace
        /// and a specific tree type.
        ///
        /// Database entities are not resources like conversion workspaces or mapping
        /// rules, and they can't be created, updated or deleted. Instead, they are
        /// simple data objects describing the structure of the client database.
        pub async fn describe_database_entities(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeDatabaseEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeDatabaseEntitiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/DescribeDatabaseEntities",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "DescribeDatabaseEntities",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches/lists the background jobs for a specific
        /// conversion workspace.
        ///
        /// The background jobs are not resources like conversion workspaces or
        /// mapping rules, and they can't be created, updated or deleted.
        /// Instead, they are a way to expose the data plane jobs log.
        pub async fn search_background_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchBackgroundJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchBackgroundJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/SearchBackgroundJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "SearchBackgroundJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of committed revisions of a specific conversion
        /// workspace.
        pub async fn describe_conversion_workspace_revisions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DescribeConversionWorkspaceRevisionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DescribeConversionWorkspaceRevisionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/DescribeConversionWorkspaceRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "DescribeConversionWorkspaceRevisions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches a set of static IP addresses that need to be allowlisted by the
        /// customer when using the static-IP connectivity method.
        pub async fn fetch_static_ips(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchStaticIpsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchStaticIpsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.clouddms.v1.DataMigrationService/FetchStaticIps",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.clouddms.v1.DataMigrationService",
                        "FetchStaticIps",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
