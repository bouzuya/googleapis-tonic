// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessLevel {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "access_level::Level", tags = "4, 5")]
    pub level: ::core::option::Option<access_level::Level>,
}
/// Nested message and enum types in `AccessLevel`.
pub mod access_level {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Level {
        #[prost(message, tag = "4")]
        Basic(super::BasicLevel),
        #[prost(message, tag = "5")]
        Custom(super::CustomLevel),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BasicLevel {
    #[prost(message, repeated, tag = "1")]
    pub conditions: ::prost::alloc::vec::Vec<Condition>,
    #[prost(enumeration = "basic_level::ConditionCombiningFunction", tag = "2")]
    pub combining_function: i32,
}
/// Nested message and enum types in `BasicLevel`.
pub mod basic_level {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConditionCombiningFunction {
        And = 0,
        Or = 1,
    }
    impl ConditionCombiningFunction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConditionCombiningFunction::And => "AND",
                ConditionCombiningFunction::Or => "OR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AND" => Some(Self::And),
                "OR" => Some(Self::Or),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    #[prost(string, repeated, tag = "1")]
    pub ip_subnetworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub device_policy: ::core::option::Option<DevicePolicy>,
    #[prost(string, repeated, tag = "3")]
    pub required_access_levels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "5")]
    pub negate: bool,
    #[prost(string, repeated, tag = "6")]
    pub members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomLevel {
    #[prost(message, optional, tag = "1")]
    pub expr: ::core::option::Option<super::super::super::r#type::Expr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DevicePolicy {
    #[prost(bool, tag = "1")]
    pub require_screenlock: bool,
    #[prost(enumeration = "super::r#type::DeviceEncryptionStatus", repeated, tag = "2")]
    pub allowed_encryption_statuses: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "3")]
    pub os_constraints: ::prost::alloc::vec::Vec<OsConstraint>,
    #[prost(enumeration = "super::r#type::DeviceManagementLevel", repeated, tag = "6")]
    pub allowed_device_management_levels: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "7")]
    pub require_admin_approval: bool,
    #[prost(bool, tag = "8")]
    pub require_corp_owned: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OsConstraint {
    #[prost(enumeration = "super::r#type::OsType", tag = "1")]
    pub os_type: i32,
    #[prost(string, tag = "2")]
    pub minimum_version: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub require_verified_chrome_os: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPolicy {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcpUserAccessBinding {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_key: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub access_levels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServicePerimeter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "service_perimeter::PerimeterType", tag = "6")]
    pub perimeter_type: i32,
    #[prost(message, optional, tag = "7")]
    pub status: ::core::option::Option<ServicePerimeterConfig>,
    #[prost(message, optional, tag = "8")]
    pub spec: ::core::option::Option<ServicePerimeterConfig>,
    #[prost(bool, tag = "9")]
    pub use_explicit_dry_run_spec: bool,
}
/// Nested message and enum types in `ServicePerimeter`.
pub mod service_perimeter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PerimeterType {
        Regular = 0,
        Bridge = 1,
    }
    impl PerimeterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PerimeterType::Regular => "PERIMETER_TYPE_REGULAR",
                PerimeterType::Bridge => "PERIMETER_TYPE_BRIDGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERIMETER_TYPE_REGULAR" => Some(Self::Regular),
                "PERIMETER_TYPE_BRIDGE" => Some(Self::Bridge),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServicePerimeterConfig {
    #[prost(string, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub access_levels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub restricted_services: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "10")]
    pub vpc_accessible_services: ::core::option::Option<
        service_perimeter_config::VpcAccessibleServices,
    >,
    #[prost(message, repeated, tag = "8")]
    pub ingress_policies: ::prost::alloc::vec::Vec<
        service_perimeter_config::IngressPolicy,
    >,
    #[prost(message, repeated, tag = "9")]
    pub egress_policies: ::prost::alloc::vec::Vec<
        service_perimeter_config::EgressPolicy,
    >,
}
/// Nested message and enum types in `ServicePerimeterConfig`.
pub mod service_perimeter_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VpcAccessibleServices {
        #[prost(bool, tag = "1")]
        pub enable_restriction: bool,
        #[prost(string, repeated, tag = "2")]
        pub allowed_services: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MethodSelector {
        #[prost(oneof = "method_selector::Kind", tags = "1, 2")]
        pub kind: ::core::option::Option<method_selector::Kind>,
    }
    /// Nested message and enum types in `MethodSelector`.
    pub mod method_selector {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Kind {
            #[prost(string, tag = "1")]
            Method(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            Permission(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApiOperation {
        #[prost(string, tag = "1")]
        pub service_name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub method_selectors: ::prost::alloc::vec::Vec<MethodSelector>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IngressSource {
        #[prost(oneof = "ingress_source::Source", tags = "1, 2")]
        pub source: ::core::option::Option<ingress_source::Source>,
    }
    /// Nested message and enum types in `IngressSource`.
    pub mod ingress_source {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Source {
            #[prost(string, tag = "1")]
            AccessLevel(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            Resource(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IngressFrom {
        #[prost(message, repeated, tag = "1")]
        pub sources: ::prost::alloc::vec::Vec<IngressSource>,
        #[prost(string, repeated, tag = "2")]
        pub identities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(enumeration = "IdentityType", tag = "3")]
        pub identity_type: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IngressTo {
        #[prost(message, repeated, tag = "1")]
        pub operations: ::prost::alloc::vec::Vec<ApiOperation>,
        #[prost(string, repeated, tag = "2")]
        pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IngressPolicy {
        #[prost(message, optional, tag = "1")]
        pub ingress_from: ::core::option::Option<IngressFrom>,
        #[prost(message, optional, tag = "2")]
        pub ingress_to: ::core::option::Option<IngressTo>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EgressFrom {
        #[prost(string, repeated, tag = "1")]
        pub identities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(enumeration = "IdentityType", tag = "2")]
        pub identity_type: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EgressTo {
        #[prost(string, repeated, tag = "1")]
        pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub operations: ::prost::alloc::vec::Vec<ApiOperation>,
        #[prost(string, repeated, tag = "3")]
        pub external_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EgressPolicy {
        #[prost(message, optional, tag = "1")]
        pub egress_from: ::core::option::Option<EgressFrom>,
        #[prost(message, optional, tag = "2")]
        pub egress_to: ::core::option::Option<EgressTo>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdentityType {
        Unspecified = 0,
        AnyIdentity = 1,
        AnyUserAccount = 2,
        AnyServiceAccount = 3,
    }
    impl IdentityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IdentityType::Unspecified => "IDENTITY_TYPE_UNSPECIFIED",
                IdentityType::AnyIdentity => "ANY_IDENTITY",
                IdentityType::AnyUserAccount => "ANY_USER_ACCOUNT",
                IdentityType::AnyServiceAccount => "ANY_SERVICE_ACCOUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IDENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ANY_IDENTITY" => Some(Self::AnyIdentity),
                "ANY_USER_ACCOUNT" => Some(Self::AnyUserAccount),
                "ANY_SERVICE_ACCOUNT" => Some(Self::AnyServiceAccount),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessPoliciesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessPoliciesResponse {
    #[prost(message, repeated, tag = "1")]
    pub access_policies: ::prost::alloc::vec::Vec<AccessPolicy>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccessPolicyRequest {
    #[prost(message, optional, tag = "1")]
    pub policy: ::core::option::Option<AccessPolicy>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccessPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessLevelsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "LevelFormat", tag = "4")]
    pub access_level_format: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessLevelsResponse {
    #[prost(message, repeated, tag = "1")]
    pub access_levels: ::prost::alloc::vec::Vec<AccessLevel>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessLevelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "LevelFormat", tag = "2")]
    pub access_level_format: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccessLevelRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub access_level: ::core::option::Option<AccessLevel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccessLevelRequest {
    #[prost(message, optional, tag = "1")]
    pub access_level: ::core::option::Option<AccessLevel>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccessLevelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplaceAccessLevelsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub access_levels: ::prost::alloc::vec::Vec<AccessLevel>,
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplaceAccessLevelsResponse {
    #[prost(message, repeated, tag = "1")]
    pub access_levels: ::prost::alloc::vec::Vec<AccessLevel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicePerimetersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicePerimetersResponse {
    #[prost(message, repeated, tag = "1")]
    pub service_perimeters: ::prost::alloc::vec::Vec<ServicePerimeter>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServicePerimeterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServicePerimeterRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub service_perimeter: ::core::option::Option<ServicePerimeter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServicePerimeterRequest {
    #[prost(message, optional, tag = "1")]
    pub service_perimeter: ::core::option::Option<ServicePerimeter>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServicePerimeterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplaceServicePerimetersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub service_perimeters: ::prost::alloc::vec::Vec<ServicePerimeter>,
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplaceServicePerimetersResponse {
    #[prost(message, repeated, tag = "1")]
    pub service_perimeters: ::prost::alloc::vec::Vec<ServicePerimeter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitServicePerimetersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitServicePerimetersResponse {
    #[prost(message, repeated, tag = "1")]
    pub service_perimeters: ::prost::alloc::vec::Vec<ServicePerimeter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGcpUserAccessBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGcpUserAccessBindingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub gcp_user_access_bindings: ::prost::alloc::vec::Vec<GcpUserAccessBinding>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGcpUserAccessBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGcpUserAccessBindingRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub gcp_user_access_binding: ::core::option::Option<GcpUserAccessBinding>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGcpUserAccessBindingRequest {
    #[prost(message, optional, tag = "1")]
    pub gcp_user_access_binding: ::core::option::Option<GcpUserAccessBinding>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGcpUserAccessBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcpUserAccessBindingOperationMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessContextManagerOperationMetadata {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LevelFormat {
    Unspecified = 0,
    AsDefined = 1,
    Cel = 2,
}
impl LevelFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LevelFormat::Unspecified => "LEVEL_FORMAT_UNSPECIFIED",
            LevelFormat::AsDefined => "AS_DEFINED",
            LevelFormat::Cel => "CEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LEVEL_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "AS_DEFINED" => Some(Self::AsDefined),
            "CEL" => Some(Self::Cel),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod access_context_manager_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// API for setting \[access levels\]
    /// \[google.identity.accesscontextmanager.v1.AccessLevel\] and \[service
    /// perimeters\] \[google.identity.accesscontextmanager.v1.ServicePerimeter\]
    /// for Google Cloud projects. Each organization has one \[access policy\]
    /// \[google.identity.accesscontextmanager.v1.AccessPolicy\] that contains the
    /// \[access levels\] \[google.identity.accesscontextmanager.v1.AccessLevel\]
    /// and \[service perimeters\]
    /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\]. This
    /// \[access policy\] \[google.identity.accesscontextmanager.v1.AccessPolicy\] is
    /// applicable to all resources in the organization.
    /// AccessPolicies
    #[derive(Debug, Clone)]
    pub struct AccessContextManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AccessContextManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AccessContextManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AccessContextManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all \[access policies\]
        /// \[google.identity.accesscontextmanager.v1.AccessPolicy\] in an
        /// organization.
        pub async fn list_access_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccessPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccessPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/ListAccessPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "ListAccessPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns an \[access policy\]
        /// \[google.identity.accesscontextmanager.v1.AccessPolicy\] based on the name.
        pub async fn get_access_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccessPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::AccessPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/GetAccessPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "GetAccessPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an access policy. This method fails if the organization already has
        /// an access policy. The long-running operation has a successful status
        /// after the access policy propagates to long-lasting storage.
        /// Syntactic and basic semantic errors are returned in `metadata` as a
        /// BadRequest proto.
        pub async fn create_access_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::AccessPolicy>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/CreateAccessPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "CreateAccessPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an \[access policy\]
        /// \[google.identity.accesscontextmanager.v1.AccessPolicy\]. The
        /// long-running operation from this RPC has a successful status after the
        /// changes to the \[access policy\]
        /// \[google.identity.accesscontextmanager.v1.AccessPolicy\] propagate
        /// to long-lasting storage.
        pub async fn update_access_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccessPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/UpdateAccessPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "UpdateAccessPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an \[access policy\]
        /// \[google.identity.accesscontextmanager.v1.AccessPolicy\] based on the
        /// resource name. The long-running operation has a successful status after the
        /// \[access policy\] \[google.identity.accesscontextmanager.v1.AccessPolicy\]
        /// is removed from long-lasting storage.
        pub async fn delete_access_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAccessPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/DeleteAccessPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "DeleteAccessPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all \[access levels\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] for an access
        /// policy.
        pub async fn list_access_levels(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccessLevelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccessLevelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/ListAccessLevels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "ListAccessLevels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an \[access level\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] based on the resource
        /// name.
        pub async fn get_access_level(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccessLevelRequest>,
        ) -> std::result::Result<tonic::Response<super::AccessLevel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/GetAccessLevel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "GetAccessLevel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an \[access level\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\]. The long-running
        /// operation from this RPC has a successful status after the \[access
        /// level\] \[google.identity.accesscontextmanager.v1.AccessLevel\]
        /// propagates to long-lasting storage. If \[access levels\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] contain
        /// errors, an error response is returned for the first error encountered.
        pub async fn create_access_level(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAccessLevelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/CreateAccessLevel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "CreateAccessLevel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an \[access level\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\]. The long-running
        /// operation from this RPC has a successful status after the changes to
        /// the \[access level\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] propagate
        /// to long-lasting storage. If \[access levels\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] contain
        /// errors, an error response is returned for the first error encountered.
        pub async fn update_access_level(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccessLevelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/UpdateAccessLevel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "UpdateAccessLevel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an \[access level\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] based on the resource
        /// name. The long-running operation from this RPC has a successful status
        /// after the \[access level\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] has been removed
        /// from long-lasting storage.
        pub async fn delete_access_level(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAccessLevelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/DeleteAccessLevel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "DeleteAccessLevel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Replaces all existing \[access levels\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] in an \[access
        /// policy\] \[google.identity.accesscontextmanager.v1.AccessPolicy\] with
        /// the \[access levels\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] provided. This
        /// is done atomically. The long-running operation from this RPC has a
        /// successful status after all replacements propagate to long-lasting
        /// storage. If the replacement contains errors, an error response is returned
        /// for the first error encountered.  Upon error, the replacement is cancelled,
        /// and existing \[access levels\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] are not
        /// affected. The Operation.response field contains
        /// ReplaceAccessLevelsResponse. Removing \[access levels\]
        /// \[google.identity.accesscontextmanager.v1.AccessLevel\] contained in existing
        /// \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] result in an
        /// error.
        pub async fn replace_access_levels(
            &mut self,
            request: impl tonic::IntoRequest<super::ReplaceAccessLevelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/ReplaceAccessLevels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "ReplaceAccessLevels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] for an
        /// access policy.
        pub async fn list_service_perimeters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListServicePerimetersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListServicePerimetersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/ListServicePerimeters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "ListServicePerimeters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] based on the
        /// resource name.
        pub async fn get_service_perimeter(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServicePerimeterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServicePerimeter>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/GetServicePerimeter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "GetServicePerimeter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\]. The
        /// long-running operation from this RPC has a successful status after the
        /// \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\]
        /// propagates to long-lasting storage. If a \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] contains
        /// errors, an error response is returned for the first error encountered.
        pub async fn create_service_perimeter(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateServicePerimeterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/CreateServicePerimeter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "CreateServicePerimeter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\]. The
        /// long-running operation from this RPC has a successful status after the
        /// \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\]
        /// propagates to long-lasting storage. If a \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] contains
        /// errors, an error response is returned for the first error encountered.
        pub async fn update_service_perimeter(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServicePerimeterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/UpdateServicePerimeter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "UpdateServicePerimeter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] based on the
        /// resource name. The long-running operation from this RPC has a successful
        /// status after the \[service perimeter\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] is removed from
        /// long-lasting storage.
        pub async fn delete_service_perimeter(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServicePerimeterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/DeleteServicePerimeter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "DeleteServicePerimeter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Replace all existing \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] in an \[access
        /// policy\] \[google.identity.accesscontextmanager.v1.AccessPolicy\] with the
        /// \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] provided. This
        /// is done atomically. The long-running operation from this RPC has a
        /// successful status after all replacements propagate to long-lasting storage.
        /// Replacements containing errors result in an error response for the first
        /// error encountered. Upon an error, replacement are cancelled and existing
        /// \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] are not
        /// affected. The Operation.response field contains
        /// ReplaceServicePerimetersResponse.
        pub async fn replace_service_perimeters(
            &mut self,
            request: impl tonic::IntoRequest<super::ReplaceServicePerimetersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/ReplaceServicePerimeters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "ReplaceServicePerimeters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Commits the dry-run specification for all the \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] in an
        /// \[access policy\]\[google.identity.accesscontextmanager.v1.AccessPolicy\].
        /// A commit operation on a service perimeter involves copying its `spec` field
        /// to the `status` field of the service perimeter. Only \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] with
        /// `use_explicit_dry_run_spec` field set to true are affected by a commit
        /// operation. The long-running operation from this RPC has a successful
        /// status after the dry-run specifications for all the \[service perimeters\]
        /// \[google.identity.accesscontextmanager.v1.ServicePerimeter\] have been
        /// committed. If a commit fails, it causes the long-running operation to
        /// return an error response and the entire commit operation is cancelled.
        /// When successful, the Operation.response field contains
        /// CommitServicePerimetersResponse. The `dry_run` and the `spec` fields are
        /// cleared after a successful commit operation.
        pub async fn commit_service_perimeters(
            &mut self,
            request: impl tonic::IntoRequest<super::CommitServicePerimetersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/CommitServicePerimeters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "CommitServicePerimeters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all \[GcpUserAccessBindings\]
        /// \[google.identity.accesscontextmanager.v1.GcpUserAccessBinding\] for a
        /// Google Cloud organization.
        pub async fn list_gcp_user_access_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGcpUserAccessBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGcpUserAccessBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/ListGcpUserAccessBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "ListGcpUserAccessBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the \[GcpUserAccessBinding\]
        /// \[google.identity.accesscontextmanager.v1.GcpUserAccessBinding\] with
        /// the given name.
        pub async fn get_gcp_user_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGcpUserAccessBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GcpUserAccessBinding>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/GetGcpUserAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "GetGcpUserAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[GcpUserAccessBinding\]
        /// \[google.identity.accesscontextmanager.v1.GcpUserAccessBinding\]. If the
        /// client specifies a \[name\]
        /// \[google.identity.accesscontextmanager.v1.GcpUserAccessBinding.name\],
        /// the server ignores it. Fails if a resource already exists with the same
        /// \[group_key\]
        /// \[google.identity.accesscontextmanager.v1.GcpUserAccessBinding.group_key\].
        /// Completion of this long-running operation does not necessarily signify that
        /// the new binding is deployed onto all affected users, which may take more
        /// time.
        pub async fn create_gcp_user_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateGcpUserAccessBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/CreateGcpUserAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "CreateGcpUserAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[GcpUserAccessBinding\]
        /// \[google.identity.accesscontextmanager.v1.GcpUserAccessBinding\].
        /// Completion of this long-running operation does not necessarily signify that
        /// the changed binding is deployed onto all affected users, which may take
        /// more time.
        pub async fn update_gcp_user_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateGcpUserAccessBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/UpdateGcpUserAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "UpdateGcpUserAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[GcpUserAccessBinding\]
        /// \[google.identity.accesscontextmanager.v1.GcpUserAccessBinding\].
        /// Completion of this long-running operation does not necessarily signify that
        /// the binding deletion is deployed onto all affected users, which may take
        /// more time.
        pub async fn delete_gcp_user_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGcpUserAccessBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/DeleteGcpUserAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "DeleteGcpUserAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the IAM policy for the specified Access Context Manager
        /// \[access policy\]\[google.identity.accesscontextmanager.v1.AccessPolicy\].
        /// This method replaces the existing IAM policy on the access policy. The IAM
        /// policy controls the set of users who can perform specific operations on the
        /// Access Context Manager \[access
        /// policy\]\[google.identity.accesscontextmanager.v1.AccessPolicy\].
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the IAM policy for the specified Access Context Manager
        /// \[access policy\]\[google.identity.accesscontextmanager.v1.AccessPolicy\].
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the IAM permissions that the caller has on the specified Access
        /// Context Manager resource. The resource can be an
        /// \[AccessPolicy\]\[google.identity.accesscontextmanager.v1.AccessPolicy\],
        /// \[AccessLevel\]\[google.identity.accesscontextmanager.v1.AccessLevel\], or
        /// \[ServicePerimeter\]\[google.identity.accesscontextmanager.v1.ServicePerimeter
        /// \]. This method does not support other resources.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::TestIamPermissionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::super::super::iam::v1::TestIamPermissionsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.identity.accesscontextmanager.v1.AccessContextManager/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.identity.accesscontextmanager.v1.AccessContextManager",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
