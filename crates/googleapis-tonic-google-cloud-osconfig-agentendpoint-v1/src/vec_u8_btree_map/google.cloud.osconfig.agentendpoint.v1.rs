// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OsPolicy {}
/// Nested message and enum types in `OSPolicy`.
pub mod os_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Resource {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(oneof = "resource::ResourceType", tags = "2, 3, 4, 5")]
        pub resource_type: ::core::option::Option<resource::ResourceType>,
    }
    /// Nested message and enum types in `Resource`.
    pub mod resource {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct File {
            #[prost(bool, tag = "4")]
            pub allow_insecure: bool,
            #[prost(oneof = "file::Type", tags = "1, 2, 3")]
            pub r#type: ::core::option::Option<file::Type>,
        }
        /// Nested message and enum types in `File`.
        pub mod file {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Remote {
                #[prost(string, tag = "1")]
                pub uri: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub sha256_checksum: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Gcs {
                #[prost(string, tag = "1")]
                pub bucket: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object: ::prost::alloc::string::String,
                #[prost(int64, tag = "3")]
                pub generation: i64,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Type {
                #[prost(message, tag = "1")]
                Remote(Remote),
                #[prost(message, tag = "2")]
                Gcs(Gcs),
                #[prost(string, tag = "3")]
                LocalPath(::prost::alloc::string::String),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PackageResource {
            #[prost(enumeration = "package_resource::DesiredState", tag = "1")]
            pub desired_state: i32,
            #[prost(
                oneof = "package_resource::SystemPackage",
                tags = "2, 3, 4, 5, 6, 7, 8"
            )]
            pub system_package: ::core::option::Option<package_resource::SystemPackage>,
        }
        /// Nested message and enum types in `PackageResource`.
        pub mod package_resource {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Deb {
                #[prost(message, optional, tag = "1")]
                pub source: ::core::option::Option<super::File>,
                #[prost(bool, tag = "2")]
                pub pull_deps: bool,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Apt {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Rpm {
                #[prost(message, optional, tag = "1")]
                pub source: ::core::option::Option<super::File>,
                #[prost(bool, tag = "2")]
                pub pull_deps: bool,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Yum {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Zypper {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GooGet {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Msi {
                #[prost(message, optional, tag = "1")]
                pub source: ::core::option::Option<super::File>,
                #[prost(string, repeated, tag = "2")]
                pub properties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum DesiredState {
                Unspecified = 0,
                Installed = 1,
                Removed = 2,
            }
            impl DesiredState {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        DesiredState::Unspecified => "DESIRED_STATE_UNSPECIFIED",
                        DesiredState::Installed => "INSTALLED",
                        DesiredState::Removed => "REMOVED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "DESIRED_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "INSTALLED" => Some(Self::Installed),
                        "REMOVED" => Some(Self::Removed),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum SystemPackage {
                #[prost(message, tag = "2")]
                Apt(Apt),
                #[prost(message, tag = "3")]
                Deb(Deb),
                #[prost(message, tag = "4")]
                Yum(Yum),
                #[prost(message, tag = "5")]
                Zypper(Zypper),
                #[prost(message, tag = "6")]
                Rpm(Rpm),
                #[prost(message, tag = "7")]
                Googet(GooGet),
                #[prost(message, tag = "8")]
                Msi(Msi),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RepositoryResource {
            #[prost(oneof = "repository_resource::Repository", tags = "1, 2, 3, 4")]
            pub repository: ::core::option::Option<repository_resource::Repository>,
        }
        /// Nested message and enum types in `RepositoryResource`.
        pub mod repository_resource {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AptRepository {
                #[prost(enumeration = "apt_repository::ArchiveType", tag = "1")]
                pub archive_type: i32,
                #[prost(string, tag = "2")]
                pub uri: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub distribution: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "4")]
                pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "5")]
                pub gpg_key: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `AptRepository`.
            pub mod apt_repository {
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum ArchiveType {
                    Unspecified = 0,
                    Deb = 1,
                    DebSrc = 2,
                }
                impl ArchiveType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            ArchiveType::Unspecified => "ARCHIVE_TYPE_UNSPECIFIED",
                            ArchiveType::Deb => "DEB",
                            ArchiveType::DebSrc => "DEB_SRC",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "ARCHIVE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                            "DEB" => Some(Self::Deb),
                            "DEB_SRC" => Some(Self::DebSrc),
                            _ => None,
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct YumRepository {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub display_name: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub base_url: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "4")]
                pub gpg_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ZypperRepository {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub display_name: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub base_url: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "4")]
                pub gpg_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GooRepository {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub url: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Repository {
                #[prost(message, tag = "1")]
                Apt(AptRepository),
                #[prost(message, tag = "2")]
                Yum(YumRepository),
                #[prost(message, tag = "3")]
                Zypper(ZypperRepository),
                #[prost(message, tag = "4")]
                Goo(GooRepository),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ExecResource {
            #[prost(message, optional, tag = "1")]
            pub validate: ::core::option::Option<exec_resource::Exec>,
            #[prost(message, optional, tag = "2")]
            pub enforce: ::core::option::Option<exec_resource::Exec>,
        }
        /// Nested message and enum types in `ExecResource`.
        pub mod exec_resource {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Exec {
                #[prost(string, repeated, tag = "3")]
                pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "exec::Interpreter", tag = "4")]
                pub interpreter: i32,
                #[prost(string, tag = "5")]
                pub output_file_path: ::prost::alloc::string::String,
                #[prost(oneof = "exec::Source", tags = "1, 2")]
                pub source: ::core::option::Option<exec::Source>,
            }
            /// Nested message and enum types in `Exec`.
            pub mod exec {
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Interpreter {
                    Unspecified = 0,
                    None = 1,
                    Shell = 2,
                    Powershell = 3,
                }
                impl Interpreter {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Interpreter::Unspecified => "INTERPRETER_UNSPECIFIED",
                            Interpreter::None => "NONE",
                            Interpreter::Shell => "SHELL",
                            Interpreter::Powershell => "POWERSHELL",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "INTERPRETER_UNSPECIFIED" => Some(Self::Unspecified),
                            "NONE" => Some(Self::None),
                            "SHELL" => Some(Self::Shell),
                            "POWERSHELL" => Some(Self::Powershell),
                            _ => None,
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Source {
                    #[prost(message, tag = "1")]
                    File(super::super::File),
                    #[prost(string, tag = "2")]
                    Script(::prost::alloc::string::String),
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FileResource {
            #[prost(string, tag = "3")]
            pub path: ::prost::alloc::string::String,
            #[prost(enumeration = "file_resource::DesiredState", tag = "4")]
            pub state: i32,
            #[prost(string, tag = "5")]
            pub permissions: ::prost::alloc::string::String,
            #[prost(oneof = "file_resource::Source", tags = "1, 2")]
            pub source: ::core::option::Option<file_resource::Source>,
        }
        /// Nested message and enum types in `FileResource`.
        pub mod file_resource {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum DesiredState {
                Unspecified = 0,
                Present = 1,
                Absent = 2,
                ContentsMatch = 3,
            }
            impl DesiredState {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        DesiredState::Unspecified => "DESIRED_STATE_UNSPECIFIED",
                        DesiredState::Present => "PRESENT",
                        DesiredState::Absent => "ABSENT",
                        DesiredState::ContentsMatch => "CONTENTS_MATCH",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "DESIRED_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "PRESENT" => Some(Self::Present),
                        "ABSENT" => Some(Self::Absent),
                        "CONTENTS_MATCH" => Some(Self::ContentsMatch),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Source {
                #[prost(message, tag = "1")]
                File(super::File),
                #[prost(string, tag = "2")]
                Content(::prost::alloc::string::String),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ResourceType {
            #[prost(message, tag = "2")]
            Pkg(PackageResource),
            #[prost(message, tag = "3")]
            Repository(RepositoryResource),
            #[prost(message, tag = "4")]
            Exec(ExecResource),
            #[prost(message, tag = "5")]
            File(FileResource),
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        Validation = 1,
        Enforcement = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::Unspecified => "MODE_UNSPECIFIED",
                Mode::Validation => "VALIDATION",
                Mode::Enforcement => "ENFORCEMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "VALIDATION" => Some(Self::Validation),
                "ENFORCEMENT" => Some(Self::Enforcement),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Inventory {
    #[prost(message, optional, tag = "1")]
    pub os_info: ::core::option::Option<inventory::OsInfo>,
    #[prost(message, repeated, tag = "2")]
    pub installed_packages: ::prost::alloc::vec::Vec<inventory::SoftwarePackage>,
    #[prost(message, repeated, tag = "3")]
    pub available_packages: ::prost::alloc::vec::Vec<inventory::SoftwarePackage>,
}
/// Nested message and enum types in `Inventory`.
pub mod inventory {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OsInfo {
        #[prost(string, tag = "1")]
        pub hostname: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub long_name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub short_name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub version: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub architecture: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub kernel_version: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub kernel_release: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub osconfig_agent_version: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SoftwarePackage {
        #[prost(oneof = "software_package::Details", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
        pub details: ::core::option::Option<software_package::Details>,
    }
    /// Nested message and enum types in `SoftwarePackage`.
    pub mod software_package {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Details {
            #[prost(message, tag = "1")]
            YumPackage(super::VersionedPackage),
            #[prost(message, tag = "2")]
            AptPackage(super::VersionedPackage),
            #[prost(message, tag = "3")]
            ZypperPackage(super::VersionedPackage),
            #[prost(message, tag = "4")]
            GoogetPackage(super::VersionedPackage),
            #[prost(message, tag = "5")]
            ZypperPatch(super::ZypperPatch),
            #[prost(message, tag = "6")]
            WuaPackage(super::WindowsUpdatePackage),
            #[prost(message, tag = "7")]
            QfePackage(super::WindowsQuickFixEngineeringPackage),
            #[prost(message, tag = "8")]
            CosPackage(super::VersionedPackage),
            #[prost(message, tag = "9")]
            WindowsApplication(super::WindowsApplication),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VersionedPackage {
        #[prost(string, tag = "1")]
        pub package_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub architecture: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub version: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub source: ::core::option::Option<versioned_package::Source>,
    }
    /// Nested message and enum types in `VersionedPackage`.
    pub mod versioned_package {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Source {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub version: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ZypperPatch {
        #[prost(string, tag = "1")]
        pub patch_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub category: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub severity: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub summary: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsUpdatePackage {
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub categories: ::prost::alloc::vec::Vec<
            windows_update_package::WindowsUpdateCategory,
        >,
        #[prost(string, repeated, tag = "4")]
        pub kb_article_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "5")]
        pub support_url: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "6")]
        pub more_info_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "7")]
        pub update_id: ::prost::alloc::string::String,
        #[prost(int32, tag = "8")]
        pub revision_number: i32,
        #[prost(message, optional, tag = "9")]
        pub last_deployment_change_time: ::core::option::Option<
            ::prost_types::Timestamp,
        >,
    }
    /// Nested message and enum types in `WindowsUpdatePackage`.
    pub mod windows_update_package {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct WindowsUpdateCategory {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub name: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsQuickFixEngineeringPackage {
        #[prost(string, tag = "1")]
        pub caption: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub hot_fix_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub install_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsApplication {
        #[prost(string, tag = "1")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub display_version: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub publisher: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub install_date: ::core::option::Option<
            super::super::super::super::super::r#type::Date,
        >,
        #[prost(string, tag = "5")]
        pub help_link: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OsPolicyResourceConfigStep {
    #[prost(enumeration = "os_policy_resource_config_step::Type", tag = "1")]
    pub r#type: i32,
    #[prost(enumeration = "os_policy_resource_config_step::Outcome", tag = "2")]
    pub outcome: i32,
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OSPolicyResourceConfigStep`.
pub mod os_policy_resource_config_step {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Validation = 1,
        DesiredStateCheck = 2,
        DesiredStateEnforcement = 3,
        DesiredStateCheckPostEnforcement = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Validation => "VALIDATION",
                Type::DesiredStateCheck => "DESIRED_STATE_CHECK",
                Type::DesiredStateEnforcement => "DESIRED_STATE_ENFORCEMENT",
                Type::DesiredStateCheckPostEnforcement => {
                    "DESIRED_STATE_CHECK_POST_ENFORCEMENT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "VALIDATION" => Some(Self::Validation),
                "DESIRED_STATE_CHECK" => Some(Self::DesiredStateCheck),
                "DESIRED_STATE_ENFORCEMENT" => Some(Self::DesiredStateEnforcement),
                "DESIRED_STATE_CHECK_POST_ENFORCEMENT" => {
                    Some(Self::DesiredStateCheckPostEnforcement)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Outcome {
        Unspecified = 0,
        Succeeded = 1,
        Failed = 2,
    }
    impl Outcome {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Outcome::Unspecified => "OUTCOME_UNSPECIFIED",
                Outcome::Succeeded => "SUCCEEDED",
                Outcome::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OsPolicyResourceCompliance {
    #[prost(string, tag = "1")]
    pub os_policy_resource_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub config_steps: ::prost::alloc::vec::Vec<OsPolicyResourceConfigStep>,
    #[prost(enumeration = "OsPolicyComplianceState", tag = "3")]
    pub state: i32,
    #[prost(oneof = "os_policy_resource_compliance::Output", tags = "4")]
    pub output: ::core::option::Option<os_policy_resource_compliance::Output>,
}
/// Nested message and enum types in `OSPolicyResourceCompliance`.
pub mod os_policy_resource_compliance {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecResourceOutput {
        #[prost(bytes = "vec", tag = "2")]
        pub enforcement_output: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Output {
        #[prost(message, tag = "4")]
        ExecResourceOutput(ExecResourceOutput),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OsPolicyComplianceState {
    Unspecified = 0,
    Compliant = 1,
    NonCompliant = 2,
    Unknown = 3,
    NoOsPoliciesApplicable = 4,
}
impl OsPolicyComplianceState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OsPolicyComplianceState::Unspecified => {
                "OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED"
            }
            OsPolicyComplianceState::Compliant => "COMPLIANT",
            OsPolicyComplianceState::NonCompliant => "NON_COMPLIANT",
            OsPolicyComplianceState::Unknown => "UNKNOWN",
            OsPolicyComplianceState::NoOsPoliciesApplicable => {
                "NO_OS_POLICIES_APPLICABLE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPLIANT" => Some(Self::Compliant),
            "NON_COMPLIANT" => Some(Self::NonCompliant),
            "UNKNOWN" => Some(Self::Unknown),
            "NO_OS_POLICIES_APPLICABLE" => Some(Self::NoOsPoliciesApplicable),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchConfig {
    #[prost(enumeration = "patch_config::RebootConfig", tag = "1")]
    pub reboot_config: i32,
    #[prost(message, optional, tag = "2")]
    pub retry_strategy: ::core::option::Option<RetryStrategy>,
    #[prost(message, optional, tag = "3")]
    pub apt: ::core::option::Option<AptSettings>,
    #[prost(message, optional, tag = "4")]
    pub yum: ::core::option::Option<YumSettings>,
    #[prost(message, optional, tag = "5")]
    pub goo: ::core::option::Option<GooSettings>,
    #[prost(message, optional, tag = "6")]
    pub zypper: ::core::option::Option<ZypperSettings>,
    #[prost(message, optional, tag = "7")]
    pub windows_update: ::core::option::Option<WindowsUpdateSettings>,
    #[prost(message, optional, tag = "8")]
    pub pre_step: ::core::option::Option<ExecStep>,
    #[prost(message, optional, tag = "9")]
    pub post_step: ::core::option::Option<ExecStep>,
    #[prost(bool, tag = "10")]
    pub mig_instances_allowed: bool,
}
/// Nested message and enum types in `PatchConfig`.
pub mod patch_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RebootConfig {
        Unspecified = 0,
        Default = 1,
        Always = 2,
        Never = 3,
    }
    impl RebootConfig {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RebootConfig::Unspecified => "REBOOT_CONFIG_UNSPECIFIED",
                RebootConfig::Default => "DEFAULT",
                RebootConfig::Always => "ALWAYS",
                RebootConfig::Never => "NEVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REBOOT_CONFIG_UNSPECIFIED" => Some(Self::Unspecified),
                "DEFAULT" => Some(Self::Default),
                "ALWAYS" => Some(Self::Always),
                "NEVER" => Some(Self::Never),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AptSettings {
    #[prost(enumeration = "apt_settings::Type", tag = "1")]
    pub r#type: i32,
    #[prost(string, repeated, tag = "2")]
    pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub exclusive_packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AptSettings`.
pub mod apt_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Dist = 1,
        Upgrade = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Dist => "DIST",
                Type::Upgrade => "UPGRADE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DIST" => Some(Self::Dist),
                "UPGRADE" => Some(Self::Upgrade),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YumSettings {
    #[prost(bool, tag = "1")]
    pub security: bool,
    #[prost(bool, tag = "2")]
    pub minimal: bool,
    #[prost(string, repeated, tag = "3")]
    pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub exclusive_packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GooSettings {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZypperSettings {
    #[prost(bool, tag = "1")]
    pub with_optional: bool,
    #[prost(bool, tag = "2")]
    pub with_update: bool,
    #[prost(string, repeated, tag = "3")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub severities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub exclusive_patches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowsUpdateSettings {
    #[prost(
        enumeration = "windows_update_settings::Classification",
        repeated,
        tag = "1"
    )]
    pub classifications: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "2")]
    pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub exclusive_patches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `WindowsUpdateSettings`.
pub mod windows_update_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Classification {
        Unspecified = 0,
        Critical = 1,
        Security = 2,
        Definition = 3,
        Driver = 4,
        FeaturePack = 5,
        ServicePack = 6,
        Tool = 7,
        UpdateRollup = 8,
        Update = 9,
    }
    impl Classification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Classification::Unspecified => "CLASSIFICATION_UNSPECIFIED",
                Classification::Critical => "CRITICAL",
                Classification::Security => "SECURITY",
                Classification::Definition => "DEFINITION",
                Classification::Driver => "DRIVER",
                Classification::FeaturePack => "FEATURE_PACK",
                Classification::ServicePack => "SERVICE_PACK",
                Classification::Tool => "TOOL",
                Classification::UpdateRollup => "UPDATE_ROLLUP",
                Classification::Update => "UPDATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLASSIFICATION_UNSPECIFIED" => Some(Self::Unspecified),
                "CRITICAL" => Some(Self::Critical),
                "SECURITY" => Some(Self::Security),
                "DEFINITION" => Some(Self::Definition),
                "DRIVER" => Some(Self::Driver),
                "FEATURE_PACK" => Some(Self::FeaturePack),
                "SERVICE_PACK" => Some(Self::ServicePack),
                "TOOL" => Some(Self::Tool),
                "UPDATE_ROLLUP" => Some(Self::UpdateRollup),
                "UPDATE" => Some(Self::Update),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetryStrategy {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecStep {
    #[prost(message, optional, tag = "1")]
    pub linux_exec_step_config: ::core::option::Option<ExecStepConfig>,
    #[prost(message, optional, tag = "2")]
    pub windows_exec_step_config: ::core::option::Option<ExecStepConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecStepConfig {
    #[prost(int32, repeated, tag = "3")]
    pub allowed_success_codes: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "exec_step_config::Interpreter", tag = "4")]
    pub interpreter: i32,
    #[prost(oneof = "exec_step_config::Executable", tags = "1, 2")]
    pub executable: ::core::option::Option<exec_step_config::Executable>,
}
/// Nested message and enum types in `ExecStepConfig`.
pub mod exec_step_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Interpreter {
        Unspecified = 0,
        None = 3,
        Shell = 1,
        Powershell = 2,
    }
    impl Interpreter {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Interpreter::Unspecified => "INTERPRETER_UNSPECIFIED",
                Interpreter::None => "NONE",
                Interpreter::Shell => "SHELL",
                Interpreter::Powershell => "POWERSHELL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INTERPRETER_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "SHELL" => Some(Self::Shell),
                "POWERSHELL" => Some(Self::Powershell),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Executable {
        #[prost(string, tag = "1")]
        LocalPath(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        GcsObject(super::GcsObject),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsObject {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub generation_number: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(enumeration = "TaskType", tag = "2")]
    pub task_type: i32,
    #[prost(enumeration = "TaskDirective", tag = "3")]
    pub task_directive: i32,
    #[prost(btree_map = "string, string", tag = "6")]
    pub service_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "task::TaskDetails", tags = "4, 5, 7")]
    pub task_details: ::core::option::Option<task::TaskDetails>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TaskDetails {
        #[prost(message, tag = "4")]
        ApplyPatchesTask(super::ApplyPatchesTask),
        #[prost(message, tag = "5")]
        ExecStepTask(super::ExecStepTask),
        #[prost(message, tag = "7")]
        ApplyConfigTask(super::ApplyConfigTask),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyPatchesTask {
    #[prost(message, optional, tag = "1")]
    pub patch_config: ::core::option::Option<PatchConfig>,
    #[prost(bool, tag = "3")]
    pub dry_run: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApplyPatchesTaskProgress {
    #[prost(enumeration = "apply_patches_task_progress::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `ApplyPatchesTaskProgress`.
pub mod apply_patches_task_progress {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Started = 4,
        DownloadingPatches = 1,
        ApplyingPatches = 2,
        Rebooting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Started => "STARTED",
                State::DownloadingPatches => "DOWNLOADING_PATCHES",
                State::ApplyingPatches => "APPLYING_PATCHES",
                State::Rebooting => "REBOOTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STARTED" => Some(Self::Started),
                "DOWNLOADING_PATCHES" => Some(Self::DownloadingPatches),
                "APPLYING_PATCHES" => Some(Self::ApplyingPatches),
                "REBOOTING" => Some(Self::Rebooting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApplyPatchesTaskOutput {
    #[prost(enumeration = "apply_patches_task_output::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `ApplyPatchesTaskOutput`.
pub mod apply_patches_task_output {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Succeeded = 1,
        SucceededRebootRequired = 2,
        Failed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Succeeded => "SUCCEEDED",
                State::SucceededRebootRequired => "SUCCEEDED_REBOOT_REQUIRED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "SUCCEEDED_REBOOT_REQUIRED" => Some(Self::SucceededRebootRequired),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecStepTask {
    #[prost(message, optional, tag = "1")]
    pub exec_step: ::core::option::Option<ExecStep>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecStepTaskProgress {
    #[prost(enumeration = "exec_step_task_progress::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `ExecStepTaskProgress`.
pub mod exec_step_task_progress {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Started = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Started => "STARTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STARTED" => Some(Self::Started),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecStepTaskOutput {
    #[prost(enumeration = "exec_step_task_output::State", tag = "1")]
    pub state: i32,
    #[prost(int32, tag = "2")]
    pub exit_code: i32,
}
/// Nested message and enum types in `ExecStepTaskOutput`.
pub mod exec_step_task_output {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Completed = 1,
        TimedOut = 2,
        Cancelled = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Completed => "COMPLETED",
                State::TimedOut => "TIMED_OUT",
                State::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPLETED" => Some(Self::Completed),
                "TIMED_OUT" => Some(Self::TimedOut),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConfigTask {
    #[prost(message, repeated, tag = "1")]
    pub os_policies: ::prost::alloc::vec::Vec<apply_config_task::OsPolicy>,
}
/// Nested message and enum types in `ApplyConfigTask`.
pub mod apply_config_task {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OsPolicy {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::os_policy::Mode", tag = "2")]
        pub mode: i32,
        #[prost(string, tag = "3")]
        pub os_policy_assignment: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub resources: ::prost::alloc::vec::Vec<super::os_policy::Resource>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApplyConfigTaskProgress {
    #[prost(enumeration = "apply_config_task_progress::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `ApplyConfigTaskProgress`.
pub mod apply_config_task_progress {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Started = 1,
        ApplyingConfig = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Started => "STARTED",
                State::ApplyingConfig => "APPLYING_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STARTED" => Some(Self::Started),
                "APPLYING_CONFIG" => Some(Self::ApplyingConfig),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConfigTaskOutput {
    #[prost(enumeration = "apply_config_task_output::State", tag = "1")]
    pub state: i32,
    #[prost(message, repeated, tag = "2")]
    pub os_policy_results: ::prost::alloc::vec::Vec<
        apply_config_task_output::OsPolicyResult,
    >,
}
/// Nested message and enum types in `ApplyConfigTaskOutput`.
pub mod apply_config_task_output {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OsPolicyResult {
        #[prost(string, tag = "1")]
        pub os_policy_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub os_policy_assignment: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub os_policy_resource_compliances: ::prost::alloc::vec::Vec<
            super::OsPolicyResourceCompliance,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Succeeded = 1,
        Failed = 2,
        Cancelled = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskDirective {
    Unspecified = 0,
    Continue = 1,
    Stop = 2,
}
impl TaskDirective {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TaskDirective::Unspecified => "TASK_DIRECTIVE_UNSPECIFIED",
            TaskDirective::Continue => "CONTINUE",
            TaskDirective::Stop => "STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_DIRECTIVE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTINUE" => Some(Self::Continue),
            "STOP" => Some(Self::Stop),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskType {
    Unspecified = 0,
    ApplyPatches = 1,
    ExecStepTask = 2,
    ApplyConfigTask = 3,
}
impl TaskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TaskType::Unspecified => "TASK_TYPE_UNSPECIFIED",
            TaskType::ApplyPatches => "APPLY_PATCHES",
            TaskType::ExecStepTask => "EXEC_STEP_TASK",
            TaskType::ApplyConfigTask => "APPLY_CONFIG_TASK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "APPLY_PATCHES" => Some(Self::ApplyPatches),
            "EXEC_STEP_TASK" => Some(Self::ExecStepTask),
            "APPLY_CONFIG_TASK" => Some(Self::ApplyConfigTask),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiveTaskNotificationRequest {
    #[prost(string, tag = "1")]
    pub instance_id_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceiveTaskNotificationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNextTaskRequest {
    #[prost(string, tag = "1")]
    pub instance_id_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNextTaskResponse {
    #[prost(message, optional, tag = "1")]
    pub task: ::core::option::Option<Task>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportTaskProgressRequest {
    #[prost(string, tag = "1")]
    pub instance_id_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(enumeration = "TaskType", tag = "3")]
    pub task_type: i32,
    #[prost(oneof = "report_task_progress_request::Progress", tags = "4, 5, 6")]
    pub progress: ::core::option::Option<report_task_progress_request::Progress>,
}
/// Nested message and enum types in `ReportTaskProgressRequest`.
pub mod report_task_progress_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Progress {
        #[prost(message, tag = "4")]
        ApplyPatchesTaskProgress(super::ApplyPatchesTaskProgress),
        #[prost(message, tag = "5")]
        ExecStepTaskProgress(super::ExecStepTaskProgress),
        #[prost(message, tag = "6")]
        ApplyConfigTaskProgress(super::ApplyConfigTaskProgress),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportTaskProgressResponse {
    #[prost(enumeration = "TaskDirective", tag = "1")]
    pub task_directive: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportTaskCompleteRequest {
    #[prost(string, tag = "1")]
    pub instance_id_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(enumeration = "TaskType", tag = "3")]
    pub task_type: i32,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(oneof = "report_task_complete_request::Output", tags = "5, 6, 7")]
    pub output: ::core::option::Option<report_task_complete_request::Output>,
}
/// Nested message and enum types in `ReportTaskCompleteRequest`.
pub mod report_task_complete_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Output {
        #[prost(message, tag = "5")]
        ApplyPatchesTaskOutput(super::ApplyPatchesTaskOutput),
        #[prost(message, tag = "6")]
        ExecStepTaskOutput(super::ExecStepTaskOutput),
        #[prost(message, tag = "7")]
        ApplyConfigTaskOutput(super::ApplyConfigTaskOutput),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportTaskCompleteResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterAgentRequest {
    #[prost(string, tag = "1")]
    pub instance_id_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub supported_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub os_long_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub os_short_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub os_version: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub os_architecture: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegisterAgentResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportInventoryRequest {
    #[prost(string, tag = "1")]
    pub instance_id_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub inventory_checksum: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub inventory: ::core::option::Option<Inventory>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportInventoryResponse {
    #[prost(bool, tag = "1")]
    pub report_full_inventory: bool,
}
/// Generated client implementations.
pub mod agent_endpoint_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// OS Config agent endpoint API.
    #[derive(Debug, Clone)]
    pub struct AgentEndpointServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AgentEndpointServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AgentEndpointServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AgentEndpointServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Stream established by client to receive Task notifications.
        pub async fn receive_task_notification(
            &mut self,
            request: impl tonic::IntoRequest<super::ReceiveTaskNotificationRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::ReceiveTaskNotificationResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.osconfig.agentendpoint.v1.AgentEndpointService/ReceiveTaskNotification",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.osconfig.agentendpoint.v1.AgentEndpointService",
                        "ReceiveTaskNotification",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Signals the start of a task execution and returns the task info.
        pub async fn start_next_task(
            &mut self,
            request: impl tonic::IntoRequest<super::StartNextTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartNextTaskResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.osconfig.agentendpoint.v1.AgentEndpointService/StartNextTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.osconfig.agentendpoint.v1.AgentEndpointService",
                        "StartNextTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Signals an intermediary progress checkpoint in task execution.
        pub async fn report_task_progress(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportTaskProgressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportTaskProgressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.osconfig.agentendpoint.v1.AgentEndpointService/ReportTaskProgress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.osconfig.agentendpoint.v1.AgentEndpointService",
                        "ReportTaskProgress",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Signals that the task execution is complete and optionally returns the next
        /// task.
        pub async fn report_task_complete(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportTaskCompleteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportTaskCompleteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.osconfig.agentendpoint.v1.AgentEndpointService/ReportTaskComplete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.osconfig.agentendpoint.v1.AgentEndpointService",
                        "ReportTaskComplete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Registers the agent running on the VM.
        pub async fn register_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterAgentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.osconfig.agentendpoint.v1.AgentEndpointService/RegisterAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.osconfig.agentendpoint.v1.AgentEndpointService",
                        "RegisterAgent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reports the VMs current inventory.
        pub async fn report_inventory(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportInventoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportInventoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.osconfig.agentendpoint.v1.AgentEndpointService/ReportInventory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.osconfig.agentendpoint.v1.AgentEndpointService",
                        "ReportInventory",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
