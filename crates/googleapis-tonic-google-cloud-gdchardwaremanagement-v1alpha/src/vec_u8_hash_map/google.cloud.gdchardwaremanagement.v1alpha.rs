// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "order::State", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "6")]
    pub organization_contact: ::core::option::Option<OrganizationContact>,
    #[prost(string, repeated, tag = "7")]
    pub target_workloads: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub customer_motivation: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub fulfillment_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "10")]
    pub region_code: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub order_form_uri: ::prost::alloc::string::String,
    #[prost(enumeration = "order::Type", tag = "12")]
    pub r#type: i32,
    #[prost(message, optional, tag = "14")]
    pub submit_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "15")]
    pub billing_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "16")]
    pub existing_hardware: ::prost::alloc::vec::Vec<HardwareLocation>,
}
/// Nested message and enum types in `Order`.
pub mod order {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Draft = 1,
        Submitted = 2,
        Accepted = 3,
        AdditionalInfoNeeded = 4,
        Building = 5,
        Shipping = 6,
        Installing = 7,
        Failed = 8,
        PartiallyCompleted = 9,
        Completed = 10,
        Cancelled = 11,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Draft => "DRAFT",
                State::Submitted => "SUBMITTED",
                State::Accepted => "ACCEPTED",
                State::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                State::Building => "BUILDING",
                State::Shipping => "SHIPPING",
                State::Installing => "INSTALLING",
                State::Failed => "FAILED",
                State::PartiallyCompleted => "PARTIALLY_COMPLETED",
                State::Completed => "COMPLETED",
                State::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "SUBMITTED" => Some(Self::Submitted),
                "ACCEPTED" => Some(Self::Accepted),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "FAILED" => Some(Self::Failed),
                "PARTIALLY_COMPLETED" => Some(Self::PartiallyCompleted),
                "COMPLETED" => Some(Self::Completed),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Paid = 1,
        Poc = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Paid => "PAID",
                Type::Poc => "POC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PAID" => Some(Self::Paid),
                "POC" => Some(Self::Poc),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Site {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "24")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "25")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "5")]
    pub organization_contact: ::core::option::Option<OrganizationContact>,
    #[prost(string, tag = "6")]
    pub google_maps_pin_uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "26")]
    pub access_times: ::prost::alloc::vec::Vec<TimePeriod>,
    #[prost(string, tag = "27")]
    pub notes: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "5")]
    pub hardware_count: i32,
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<HardwareConfig>,
    #[prost(string, tag = "7")]
    pub site: ::prost::alloc::string::String,
    #[prost(enumeration = "hardware_group::State", tag = "8")]
    pub state: i32,
    #[prost(string, tag = "9")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub requested_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
}
/// Nested message and enum types in `HardwareGroup`.
pub mod hardware_group {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        AdditionalInfoNeeded = 1,
        Building = 2,
        Shipping = 3,
        Installing = 4,
        PartiallyInstalled = 5,
        Installed = 6,
        Failed = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                State::Building => "BUILDING",
                State::Shipping => "SHIPPING",
                State::Installing => "INSTALLING",
                State::PartiallyInstalled => "PARTIALLY_INSTALLED",
                State::Installed => "INSTALLED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "PARTIALLY_INSTALLED" => Some(Self::PartiallyInstalled),
                "INSTALLED" => Some(Self::Installed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hardware {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub order: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub hardware_group: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub site: ::prost::alloc::string::String,
    #[prost(enumeration = "hardware::State", tag = "9")]
    pub state: i32,
    #[prost(string, tag = "10")]
    pub ciq_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub config: ::core::option::Option<HardwareConfig>,
    #[prost(message, optional, tag = "12")]
    pub estimated_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    #[prost(message, optional, tag = "13")]
    pub physical_info: ::core::option::Option<HardwarePhysicalInfo>,
    #[prost(message, optional, tag = "14")]
    pub installation_info: ::core::option::Option<HardwareInstallationInfo>,
    #[prost(string, tag = "15")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub requested_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    #[prost(message, optional, tag = "17")]
    pub actual_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
}
/// Nested message and enum types in `Hardware`.
pub mod hardware {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        AdditionalInfoNeeded = 1,
        Building = 2,
        Shipping = 3,
        Installing = 4,
        Installed = 5,
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                State::Building => "BUILDING",
                State::Shipping => "SHIPPING",
                State::Installing => "INSTALLING",
                State::Installed => "INSTALLED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "INSTALLED" => Some(Self::Installed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Comment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub text: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeLogEntry {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "4")]
    pub log: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sku {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<SkuConfig>,
    #[prost(message, repeated, tag = "7")]
    pub instances: ::prost::alloc::vec::Vec<SkuInstance>,
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub revision_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub is_active: bool,
    #[prost(enumeration = "sku::Type", tag = "11")]
    pub r#type: i32,
    #[prost(int32, tag = "12")]
    pub vcpu_count: i32,
}
/// Nested message and enum types in `Sku`.
pub mod sku {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Rack = 1,
        Server = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Rack => "RACK",
                Type::Server => "SERVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RACK" => Some(Self::Rack),
                "SERVER" => Some(Self::Server),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "zone::State", tag = "8")]
    pub state: i32,
    #[prost(message, repeated, tag = "9")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
    #[prost(string, tag = "10")]
    pub ciq_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub network_config: ::core::option::Option<ZoneNetworkConfig>,
    #[prost(string, tag = "12")]
    pub globally_unique_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        AdditionalInfoNeeded = 1,
        Preparing = 2,
        ReadyForCustomerFactoryTurnupChecks = 5,
        ReadyForSiteTurnup = 6,
        CustomerFactoryTurnupChecksFailed = 7,
        Active = 3,
        Cancelled = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                State::Preparing => "PREPARING",
                State::ReadyForCustomerFactoryTurnupChecks => {
                    "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS"
                }
                State::ReadyForSiteTurnup => "READY_FOR_SITE_TURNUP",
                State::CustomerFactoryTurnupChecksFailed => {
                    "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED"
                }
                State::Active => "ACTIVE",
                State::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "PREPARING" => Some(Self::Preparing),
                "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS" => {
                    Some(Self::ReadyForCustomerFactoryTurnupChecks)
                }
                "READY_FOR_SITE_TURNUP" => Some(Self::ReadyForSiteTurnup),
                "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED" => {
                    Some(Self::CustomerFactoryTurnupChecksFailed)
                }
                "ACTIVE" => Some(Self::Active),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationContact {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<super::super::super::r#type::PostalAddress>,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub phone: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    #[prost(string, tag = "1")]
    pub given_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub family_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub phone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    #[prost(message, repeated, tag = "6")]
    pub reachable_times: ::prost::alloc::vec::Vec<TimePeriod>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareConfig {
    #[prost(string, tag = "1")]
    pub sku: ::prost::alloc::string::String,
    #[prost(enumeration = "PowerSupply", tag = "2")]
    pub power_supply: i32,
    #[prost(int32, tag = "3")]
    pub subscription_duration_months: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuConfig {
    #[prost(string, tag = "1")]
    pub cpu: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gpu: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ram: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub storage: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuInstance {
    #[prost(string, tag = "1")]
    pub region_code: ::prost::alloc::string::String,
    #[prost(enumeration = "PowerSupply", tag = "2")]
    pub power_supply: i32,
    #[prost(string, tag = "3")]
    pub billing_sku: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub billing_sku_per_vcpu: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub subscription_duration_months: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HardwarePhysicalInfo {
    #[prost(enumeration = "hardware_physical_info::PowerReceptacleType", tag = "1")]
    pub power_receptacle: i32,
    #[prost(enumeration = "hardware_physical_info::NetworkUplinkType", tag = "2")]
    pub network_uplink: i32,
    #[prost(enumeration = "hardware_physical_info::Voltage", tag = "3")]
    pub voltage: i32,
    #[prost(enumeration = "hardware_physical_info::Amperes", tag = "4")]
    pub amperes: i32,
}
/// Nested message and enum types in `HardwarePhysicalInfo`.
pub mod hardware_physical_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PowerReceptacleType {
        Unspecified = 0,
        Nema515 = 1,
        C13 = 2,
        StandardEu = 3,
    }
    impl PowerReceptacleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PowerReceptacleType::Unspecified => "POWER_RECEPTACLE_TYPE_UNSPECIFIED",
                PowerReceptacleType::Nema515 => "NEMA_5_15",
                PowerReceptacleType::C13 => "C_13",
                PowerReceptacleType::StandardEu => "STANDARD_EU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POWER_RECEPTACLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEMA_5_15" => Some(Self::Nema515),
                "C_13" => Some(Self::C13),
                "STANDARD_EU" => Some(Self::StandardEu),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkUplinkType {
        Unspecified = 0,
        Rj45 = 1,
    }
    impl NetworkUplinkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkUplinkType::Unspecified => "NETWORK_UPLINK_TYPE_UNSPECIFIED",
                NetworkUplinkType::Rj45 => "RJ_45",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NETWORK_UPLINK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RJ_45" => Some(Self::Rj45),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Voltage {
        Unspecified = 0,
        Voltage110 = 1,
        Voltage220 = 3,
    }
    impl Voltage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Voltage::Unspecified => "VOLTAGE_UNSPECIFIED",
                Voltage::Voltage110 => "VOLTAGE_110",
                Voltage::Voltage220 => "VOLTAGE_220",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VOLTAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "VOLTAGE_110" => Some(Self::Voltage110),
                "VOLTAGE_220" => Some(Self::Voltage220),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Amperes {
        Unspecified = 0,
        Amperes15 = 1,
    }
    impl Amperes {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Amperes::Unspecified => "AMPERES_UNSPECIFIED",
                Amperes::Amperes15 => "AMPERES_15",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AMPERES_UNSPECIFIED" => Some(Self::Unspecified),
                "AMPERES_15" => Some(Self::Amperes15),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareInstallationInfo {
    #[prost(string, tag = "1")]
    pub rack_location: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub power_distance_meters: i32,
    #[prost(int32, tag = "3")]
    pub switch_distance_meters: i32,
    #[prost(message, optional, tag = "4")]
    pub rack_unit_dimensions: ::core::option::Option<Dimensions>,
    #[prost(message, optional, tag = "5")]
    pub rack_space: ::core::option::Option<RackSpace>,
    #[prost(enumeration = "hardware_installation_info::RackType", tag = "6")]
    pub rack_type: i32,
}
/// Nested message and enum types in `HardwareInstallationInfo`.
pub mod hardware_installation_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RackType {
        Unspecified = 0,
        TwoPost = 1,
        FourPost = 2,
    }
    impl RackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RackType::Unspecified => "RACK_TYPE_UNSPECIFIED",
                RackType::TwoPost => "TWO_POST",
                RackType::FourPost => "FOUR_POST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RACK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TWO_POST" => Some(Self::TwoPost),
                "FOUR_POST" => Some(Self::FourPost),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneNetworkConfig {
    #[prost(string, tag = "1")]
    pub machine_mgmt_ipv4_range: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub kubernetes_node_ipv4_range: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub kubernetes_control_plane_ipv4_range: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub management_ipv4_subnet: ::core::option::Option<Subnet>,
    #[prost(message, optional, tag = "5")]
    pub kubernetes_ipv4_subnet: ::core::option::Option<Subnet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subnet {
    #[prost(string, tag = "1")]
    pub address_range: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub default_gateway_ip_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimePeriod {
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    #[prost(
        enumeration = "super::super::super::r#type::DayOfWeek",
        repeated,
        packed = "false",
        tag = "3"
    )]
    pub days: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dimensions {
    #[prost(float, tag = "1")]
    pub width_inches: f32,
    #[prost(float, tag = "2")]
    pub height_inches: f32,
    #[prost(float, tag = "3")]
    pub depth_inches: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RackSpace {
    #[prost(int32, tag = "1")]
    pub start_rack_unit: i32,
    #[prost(int32, tag = "2")]
    pub end_rack_unit: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareLocation {
    #[prost(string, tag = "1")]
    pub site: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rack_location: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub rack_space: ::prost::alloc::vec::Vec<RackSpace>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PowerSupply {
    Unspecified = 0,
    Ac = 1,
    Dc = 2,
}
impl PowerSupply {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PowerSupply::Unspecified => "POWER_SUPPLY_UNSPECIFIED",
            PowerSupply::Ac => "POWER_SUPPLY_AC",
            PowerSupply::Dc => "POWER_SUPPLY_DC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POWER_SUPPLY_UNSPECIFIED" => Some(Self::Unspecified),
            "POWER_SUPPLY_AC" => Some(Self::Ac),
            "POWER_SUPPLY_DC" => Some(Self::Dc),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersResponse {
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrderRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOrderRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub order: ::core::option::Option<Order>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOrderRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub order: ::core::option::Option<Order>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOrderRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitOrderRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesResponse {
    #[prost(message, repeated, tag = "1")]
    pub sites: ::prost::alloc::vec::Vec<Site>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSiteRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSiteRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub site_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub site: ::core::option::Option<Site>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSiteRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub site: ::core::option::Option<Site>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareGroupsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub hardware_groups: ::prost::alloc::vec::Vec<HardwareGroup>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHardwareGroupRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub hardware_group_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub hardware_group: ::core::option::Option<HardwareGroup>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHardwareGroupRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub hardware_group: ::core::option::Option<HardwareGroup>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHardwareGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareResponse {
    #[prost(message, repeated, tag = "1")]
    pub hardware: ::prost::alloc::vec::Vec<Hardware>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHardwareRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub hardware_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub hardware: ::core::option::Option<Hardware>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHardwareRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub hardware: ::core::option::Option<Hardware>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHardwareRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCommentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCommentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub comments: ::prost::alloc::vec::Vec<Comment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCommentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub comment_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub comment: ::core::option::Option<Comment>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChangeLogEntriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChangeLogEntriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub change_log_entries: ::prost::alloc::vec::Vec<ChangeLogEntry>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChangeLogEntryRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusResponse {
    #[prost(message, repeated, tag = "1")]
    pub skus: ::prost::alloc::vec::Vec<Sku>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSkuRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesResponse {
    #[prost(message, repeated, tag = "1")]
    pub zones: ::prost::alloc::vec::Vec<Zone>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateZoneRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub zone: ::core::option::Option<Zone>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateZoneRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub zone: ::core::option::Option<Zone>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteZoneRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalZoneStateRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(enumeration = "signal_zone_state_request::StateSignal", tag = "3")]
    pub state_signal: i32,
}
/// Nested message and enum types in `SignalZoneStateRequest`.
pub mod signal_zone_state_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StateSignal {
        Unspecified = 0,
        ReadyForSiteTurnup = 1,
        FactoryTurnupChecksFailed = 2,
    }
    impl StateSignal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StateSignal::Unspecified => "STATE_SIGNAL_UNSPECIFIED",
                StateSignal::ReadyForSiteTurnup => "READY_FOR_SITE_TURNUP",
                StateSignal::FactoryTurnupChecksFailed => "FACTORY_TURNUP_CHECKS_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_SIGNAL_UNSPECIFIED" => Some(Self::Unspecified),
                "READY_FOR_SITE_TURNUP" => Some(Self::ReadyForSiteTurnup),
                "FACTORY_TURNUP_CHECKS_FAILED" => Some(Self::FactoryTurnupChecksFailed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod gdc_hardware_management_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GDC Hardware Management service.
    #[derive(Debug, Clone)]
    pub struct GdcHardwareManagementClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GdcHardwareManagementClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GdcHardwareManagementClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GdcHardwareManagementClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists orders in a given project and location.
        pub async fn list_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrdersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListOrders",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of an order.
        pub async fn get_order(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::Order>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new order in a given project and location.
        pub async fn create_order(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of an order.
        pub async fn update_order(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an order.
        pub async fn delete_order(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submits an order.
        pub async fn submit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SubmitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "SubmitOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists sites in a given project and location.
        pub async fn list_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a site.
        pub async fn get_site(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::Site>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new site in a given project and location.
        pub async fn create_site(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a site.
        pub async fn update_site(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists hardware groups in a given order.
        pub async fn list_hardware_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHardwareGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardwareGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListHardwareGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a hardware group.
        pub async fn get_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHardwareGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::HardwareGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new hardware group in a given order.
        pub async fn create_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a hardware group.
        pub async fn update_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a hardware group.
        pub async fn delete_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists hardware in a given project and location.
        pub async fn list_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets hardware details.
        pub async fn get_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHardwareRequest>,
        ) -> std::result::Result<tonic::Response<super::Hardware>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates new hardware in a given project and location.
        pub async fn create_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates hardware parameters.
        pub async fn update_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes hardware.
        pub async fn delete_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the comments on an order.
        pub async fn list_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCommentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the content of a comment.
        pub async fn get_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::Comment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new comment on an order.
        pub async fn create_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the changes made to an order.
        pub async fn list_change_log_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChangeLogEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChangeLogEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListChangeLogEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListChangeLogEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a change to an order.
        pub async fn get_change_log_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChangeLogEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ChangeLogEntry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetChangeLogEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetChangeLogEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists SKUs for a given project and location.
        pub async fn list_skus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSkusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSkus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListSkus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of an SKU.
        pub async fn get_sku(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSkuRequest>,
        ) -> std::result::Result<tonic::Response<super::Sku>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSku",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetSku",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists zones in a given project and location.
        pub async fn list_zones(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZonesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListZonesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListZones",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListZones",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a zone.
        pub async fn get_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::GetZoneRequest>,
        ) -> std::result::Result<tonic::Response<super::Zone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new zone in a given project and location.
        pub async fn create_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a zone.
        pub async fn update_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a zone.
        pub async fn delete_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Signals the state of a zone.
        pub async fn signal_zone_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalZoneStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SignalZoneState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "SignalZoneState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
