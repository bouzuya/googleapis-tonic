// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    #[prost(string, tag = "4")]
    pub management_cidr: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub vmware_engine_network: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub vmware_engine_network_canonical: ::prost::alloc::string::String,
    #[prost(int32, tag = "8")]
    pub management_ip_address_layout_version: i32,
    #[prost(string, tag = "9")]
    pub dns_server_ip: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodeTypeConfig {
    #[prost(int32, tag = "1")]
    pub node_count: i32,
    #[prost(int32, tag = "2")]
    pub custom_core_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StretchedClusterConfig {
    #[prost(string, tag = "1")]
    pub preferred_location: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub secondary_location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateCloud {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "private_cloud::State", tag = "8")]
    pub state: i32,
    #[prost(message, optional, tag = "9")]
    pub network_config: ::core::option::Option<NetworkConfig>,
    #[prost(message, optional, tag = "10")]
    pub management_cluster: ::core::option::Option<private_cloud::ManagementCluster>,
    #[prost(string, tag = "11")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "17")]
    pub hcx: ::core::option::Option<Hcx>,
    #[prost(message, optional, tag = "18")]
    pub nsx: ::core::option::Option<Nsx>,
    #[prost(message, optional, tag = "19")]
    pub vcenter: ::core::option::Option<Vcenter>,
    #[prost(string, tag = "20")]
    pub uid: ::prost::alloc::string::String,
    #[prost(enumeration = "private_cloud::Type", tag = "22")]
    pub r#type: i32,
}
/// Nested message and enum types in `PrivateCloud`.
pub mod private_cloud {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ManagementCluster {
        #[prost(string, tag = "1")]
        pub cluster_id: ::prost::alloc::string::String,
        #[prost(btree_map = "string, message", tag = "7")]
        pub node_type_configs: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            super::NodeTypeConfig,
        >,
        #[prost(message, optional, tag = "8")]
        pub stretched_cluster_config: ::core::option::Option<
            super::StretchedClusterConfig,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Updating = 3,
        Failed = 5,
        Deleted = 6,
        Purging = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Updating => "UPDATING",
                State::Failed => "FAILED",
                State::Deleted => "DELETED",
                State::Purging => "PURGING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "FAILED" => Some(Self::Failed),
                "DELETED" => Some(Self::Deleted),
                "PURGING" => Some(Self::Purging),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Standard = 0,
        TimeLimited = 1,
        Stretched = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Standard => "STANDARD",
                Type::TimeLimited => "TIME_LIMITED",
                Type::Stretched => "STRETCHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STANDARD" => Some(Self::Standard),
                "TIME_LIMITED" => Some(Self::TimeLimited),
                "STRETCHED" => Some(Self::Stretched),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "cluster::State", tag = "6")]
    pub state: i32,
    #[prost(bool, tag = "7")]
    pub management: bool,
    #[prost(message, optional, tag = "18")]
    pub autoscaling_settings: ::core::option::Option<AutoscalingSettings>,
    #[prost(string, tag = "14")]
    pub uid: ::prost::alloc::string::String,
    #[prost(btree_map = "string, message", tag = "16")]
    pub node_type_configs: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        NodeTypeConfig,
    >,
    #[prost(message, optional, tag = "17")]
    pub stretched_cluster_config: ::core::option::Option<StretchedClusterConfig>,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Updating = 3,
        Deleting = 4,
        Repairing = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Repairing => "REPAIRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "REPAIRING" => Some(Self::Repairing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub fqdn: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub node_type_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub custom_core_count: i64,
    #[prost(enumeration = "node::State", tag = "7")]
    pub state: i32,
}
/// Nested message and enum types in `Node`.
pub mod node {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Failed = 3,
        Upgrading = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Failed => "FAILED",
                State::Upgrading => "UPGRADING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "FAILED" => Some(Self::Failed),
                "UPGRADING" => Some(Self::Upgrading),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalAddress {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub external_ip: ::prost::alloc::string::String,
    #[prost(enumeration = "external_address::State", tag = "8")]
    pub state: i32,
    #[prost(string, tag = "9")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExternalAddress`.
pub mod external_address {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Updating = 3,
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subnet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub ip_cidr_range: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub gateway_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(enumeration = "subnet::State", tag = "13")]
    pub state: i32,
    #[prost(int32, tag = "16")]
    pub vlan_id: i32,
}
/// Nested message and enum types in `Subnet`.
pub mod subnet {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Updating = 3,
        Deleting = 4,
        Reconciling = 5,
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Reconciling => "RECONCILING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "RECONCILING" => Some(Self::Reconciling),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalAccessRule {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub priority: i32,
    #[prost(enumeration = "external_access_rule::Action", tag = "7")]
    pub action: i32,
    #[prost(string, tag = "8")]
    pub ip_protocol: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub source_ip_ranges: ::prost::alloc::vec::Vec<external_access_rule::IpRange>,
    #[prost(string, repeated, tag = "10")]
    pub source_ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "11")]
    pub destination_ip_ranges: ::prost::alloc::vec::Vec<external_access_rule::IpRange>,
    #[prost(string, repeated, tag = "12")]
    pub destination_ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "external_access_rule::State", tag = "13")]
    pub state: i32,
    #[prost(string, tag = "14")]
    pub uid: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExternalAccessRule`.
pub mod external_access_rule {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IpRange {
        #[prost(oneof = "ip_range::IpRange", tags = "1, 2, 3")]
        pub ip_range: ::core::option::Option<ip_range::IpRange>,
    }
    /// Nested message and enum types in `IpRange`.
    pub mod ip_range {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum IpRange {
            #[prost(string, tag = "1")]
            IpAddress(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            IpAddressRange(::prost::alloc::string::String),
            #[prost(string, tag = "3")]
            ExternalAddress(::prost::alloc::string::String),
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Unspecified = 0,
        Allow = 1,
        Deny = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Unspecified => "ACTION_UNSPECIFIED",
                Action::Allow => "ALLOW",
                Action::Deny => "DENY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Updating = 3,
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggingServer {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub port: i32,
    #[prost(enumeration = "logging_server::Protocol", tag = "6")]
    pub protocol: i32,
    #[prost(enumeration = "logging_server::SourceType", tag = "10")]
    pub source_type: i32,
    #[prost(string, tag = "8")]
    pub uid: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LoggingServer`.
pub mod logging_server {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        Unspecified = 0,
        Udp = 1,
        Tcp = 2,
        Tls = 3,
        Ssl = 4,
        Relp = 5,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Protocol::Unspecified => "PROTOCOL_UNSPECIFIED",
                Protocol::Udp => "UDP",
                Protocol::Tcp => "TCP",
                Protocol::Tls => "TLS",
                Protocol::Ssl => "SSL",
                Protocol::Relp => "RELP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
                "UDP" => Some(Self::Udp),
                "TCP" => Some(Self::Tcp),
                "TLS" => Some(Self::Tls),
                "SSL" => Some(Self::Ssl),
                "RELP" => Some(Self::Relp),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceType {
        Unspecified = 0,
        Esxi = 1,
        Vcsa = 2,
    }
    impl SourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceType::Unspecified => "SOURCE_TYPE_UNSPECIFIED",
                SourceType::Esxi => "ESXI",
                SourceType::Vcsa => "VCSA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ESXI" => Some(Self::Esxi),
                "VCSA" => Some(Self::Vcsa),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub node_type_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub virtual_cpu_count: i32,
    #[prost(int32, tag = "5")]
    pub total_core_count: i32,
    #[prost(int32, tag = "7")]
    pub memory_gb: i32,
    #[prost(int32, tag = "8")]
    pub disk_size_gb: i32,
    #[prost(int32, repeated, packed = "false", tag = "11")]
    pub available_custom_core_counts: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "node_type::Kind", tag = "12")]
    pub kind: i32,
    #[prost(string, repeated, tag = "13")]
    pub families: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(
        enumeration = "node_type::Capability",
        repeated,
        packed = "false",
        tag = "14"
    )]
    pub capabilities: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `NodeType`.
pub mod node_type {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        Standard = 1,
        StorageOnly = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Kind::Unspecified => "KIND_UNSPECIFIED",
                Kind::Standard => "STANDARD",
                Kind::StorageOnly => "STORAGE_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "STORAGE_ONLY" => Some(Self::StorageOnly),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Capability {
        Unspecified = 0,
        StretchedClusters = 1,
    }
    impl Capability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Capability::Unspecified => "CAPABILITY_UNSPECIFIED",
                Capability::StretchedClusters => "STRETCHED_CLUSTERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CAPABILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "STRETCHED_CLUSTERS" => Some(Self::StretchedClusters),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Credentials {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HcxActivationKey {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "hcx_activation_key::State", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "4")]
    pub activation_key: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub uid: ::prost::alloc::string::String,
}
/// Nested message and enum types in `HcxActivationKey`.
pub mod hcx_activation_key {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Available = 1,
        Consumed = 2,
        Creating = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Available => "AVAILABLE",
                State::Consumed => "CONSUMED",
                State::Creating => "CREATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "AVAILABLE" => Some(Self::Available),
                "CONSUMED" => Some(Self::Consumed),
                "CREATING" => Some(Self::Creating),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hcx {
    #[prost(string, tag = "2")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration = "hcx::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub fqdn: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Hcx`.
pub mod hcx {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Activating = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Activating => "ACTIVATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "ACTIVATING" => Some(Self::Activating),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nsx {
    #[prost(string, tag = "2")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration = "nsx::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub fqdn: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Nsx`.
pub mod nsx {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vcenter {
    #[prost(string, tag = "2")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration = "vcenter::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub fqdn: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Vcenter`.
pub mod vcenter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingSettings {
    #[prost(btree_map = "string, message", tag = "1")]
    pub autoscaling_policies: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        autoscaling_settings::AutoscalingPolicy,
    >,
    #[prost(int32, tag = "2")]
    pub min_cluster_node_count: i32,
    #[prost(int32, tag = "3")]
    pub max_cluster_node_count: i32,
    #[prost(message, optional, tag = "4")]
    pub cool_down_period: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `AutoscalingSettings`.
pub mod autoscaling_settings {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Thresholds {
        #[prost(int32, tag = "1")]
        pub scale_out: i32,
        #[prost(int32, tag = "2")]
        pub scale_in: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AutoscalingPolicy {
        #[prost(string, tag = "1")]
        pub node_type_id: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub scale_out_size: i32,
        #[prost(message, optional, tag = "11")]
        pub cpu_thresholds: ::core::option::Option<Thresholds>,
        #[prost(message, optional, tag = "12")]
        pub granted_memory_thresholds: ::core::option::Option<Thresholds>,
        #[prost(message, optional, tag = "13")]
        pub consumed_memory_thresholds: ::core::option::Option<Thresholds>,
        #[prost(message, optional, tag = "14")]
        pub storage_thresholds: ::core::option::Option<Thresholds>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsForwarding {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "4")]
    pub forwarding_rules: ::prost::alloc::vec::Vec<dns_forwarding::ForwardingRule>,
}
/// Nested message and enum types in `DnsForwarding`.
pub mod dns_forwarding {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ForwardingRule {
        #[prost(string, tag = "1")]
        pub domain: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub name_servers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPeering {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub peer_network: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "8")]
    pub export_custom_routes: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub import_custom_routes: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub exchange_subnet_routes: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub export_custom_routes_with_public_ip: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "12")]
    pub import_custom_routes_with_public_ip: ::core::option::Option<bool>,
    #[prost(enumeration = "network_peering::State", tag = "13")]
    pub state: i32,
    #[prost(string, tag = "7")]
    pub state_details: ::prost::alloc::string::String,
    #[prost(int32, tag = "14")]
    pub peer_mtu: i32,
    #[prost(enumeration = "network_peering::PeerNetworkType", tag = "16")]
    pub peer_network_type: i32,
    #[prost(string, tag = "17")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub vmware_engine_network: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NetworkPeering`.
pub mod network_peering {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Inactive = 1,
        Active = 2,
        Creating = 3,
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Inactive => "INACTIVE",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PeerNetworkType {
        Unspecified = 0,
        Standard = 1,
        VmwareEngineNetwork = 2,
        PrivateServicesAccess = 3,
        NetappCloudVolumes = 4,
        ThirdPartyService = 5,
        DellPowerscale = 6,
        GoogleCloudNetappVolumes = 7,
    }
    impl PeerNetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PeerNetworkType::Unspecified => "PEER_NETWORK_TYPE_UNSPECIFIED",
                PeerNetworkType::Standard => "STANDARD",
                PeerNetworkType::VmwareEngineNetwork => "VMWARE_ENGINE_NETWORK",
                PeerNetworkType::PrivateServicesAccess => "PRIVATE_SERVICES_ACCESS",
                PeerNetworkType::NetappCloudVolumes => "NETAPP_CLOUD_VOLUMES",
                PeerNetworkType::ThirdPartyService => "THIRD_PARTY_SERVICE",
                PeerNetworkType::DellPowerscale => "DELL_POWERSCALE",
                PeerNetworkType::GoogleCloudNetappVolumes => {
                    "GOOGLE_CLOUD_NETAPP_VOLUMES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PEER_NETWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "VMWARE_ENGINE_NETWORK" => Some(Self::VmwareEngineNetwork),
                "PRIVATE_SERVICES_ACCESS" => Some(Self::PrivateServicesAccess),
                "NETAPP_CLOUD_VOLUMES" => Some(Self::NetappCloudVolumes),
                "THIRD_PARTY_SERVICE" => Some(Self::ThirdPartyService),
                "DELL_POWERSCALE" => Some(Self::DellPowerscale),
                "GOOGLE_CLOUD_NETAPP_VOLUMES" => Some(Self::GoogleCloudNetappVolumes),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeeringRoute {
    #[prost(string, tag = "1")]
    pub dest_range: ::prost::alloc::string::String,
    #[prost(enumeration = "peering_route::Type", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub next_hop_region: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub priority: i64,
    #[prost(bool, tag = "5")]
    pub imported: bool,
    #[prost(enumeration = "peering_route::Direction", tag = "6")]
    pub direction: i32,
}
/// Nested message and enum types in `PeeringRoute`.
pub mod peering_route {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        DynamicPeeringRoute = 1,
        StaticPeeringRoute = 2,
        SubnetPeeringRoute = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::DynamicPeeringRoute => "DYNAMIC_PEERING_ROUTE",
                Type::StaticPeeringRoute => "STATIC_PEERING_ROUTE",
                Type::SubnetPeeringRoute => "SUBNET_PEERING_ROUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DYNAMIC_PEERING_ROUTE" => Some(Self::DynamicPeeringRoute),
                "STATIC_PEERING_ROUTE" => Some(Self::StaticPeeringRoute),
                "SUBNET_PEERING_ROUTE" => Some(Self::SubnetPeeringRoute),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        Unspecified = 0,
        Incoming = 1,
        Outgoing = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Direction::Unspecified => "DIRECTION_UNSPECIFIED",
                Direction::Incoming => "INCOMING",
                Direction::Outgoing => "OUTGOING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                "INCOMING" => Some(Self::Incoming),
                "OUTGOING" => Some(Self::Outgoing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPolicy {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub internet_access: ::core::option::Option<network_policy::NetworkService>,
    #[prost(message, optional, tag = "7")]
    pub external_ip: ::core::option::Option<network_policy::NetworkService>,
    #[prost(string, tag = "9")]
    pub edge_services_cidr: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub vmware_engine_network: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub vmware_engine_network_canonical: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NetworkPolicy`.
pub mod network_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NetworkService {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        #[prost(enumeration = "network_service::State", tag = "2")]
        pub state: i32,
    }
    /// Nested message and enum types in `NetworkService`.
    pub mod network_service {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Unprovisioned = 1,
            Reconciling = 2,
            Active = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::Unprovisioned => "UNPROVISIONED",
                    State::Reconciling => "RECONCILING",
                    State::Active => "ACTIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "UNPROVISIONED" => Some(Self::Unprovisioned),
                    "RECONCILING" => Some(Self::Reconciling),
                    "ACTIVE" => Some(Self::Active),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagementDnsZoneBinding {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "management_dns_zone_binding::State", tag = "8")]
    pub state: i32,
    #[prost(string, tag = "13")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub uid: ::prost::alloc::string::String,
    #[prost(oneof = "management_dns_zone_binding::BindNetwork", tags = "14, 15")]
    pub bind_network: ::core::option::Option<management_dns_zone_binding::BindNetwork>,
}
/// Nested message and enum types in `ManagementDnsZoneBinding`.
pub mod management_dns_zone_binding {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Creating = 2,
        Updating = 3,
        Deleting = 4,
        Failed = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BindNetwork {
        #[prost(string, tag = "14")]
        VpcNetwork(::prost::alloc::string::String),
        #[prost(string, tag = "15")]
        VmwareEngineNetwork(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmwareEngineNetwork {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub vpc_networks: ::prost::alloc::vec::Vec<vmware_engine_network::VpcNetwork>,
    #[prost(enumeration = "vmware_engine_network::State", tag = "7")]
    pub state: i32,
    #[prost(enumeration = "vmware_engine_network::Type", tag = "8")]
    pub r#type: i32,
    #[prost(string, tag = "9")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `VmwareEngineNetwork`.
pub mod vmware_engine_network {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VpcNetwork {
        #[prost(enumeration = "vpc_network::Type", tag = "1")]
        pub r#type: i32,
        #[prost(string, tag = "2")]
        pub network: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `VpcNetwork`.
    pub mod vpc_network {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            Intranet = 1,
            Internet = 2,
            GoogleCloud = 3,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::Intranet => "INTRANET",
                    Type::Internet => "INTERNET",
                    Type::GoogleCloud => "GOOGLE_CLOUD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "INTRANET" => Some(Self::Intranet),
                    "INTERNET" => Some(Self::Internet),
                    "GOOGLE_CLOUD" => Some(Self::GoogleCloud),
                    _ => None,
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Updating = 3,
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Legacy = 1,
        Standard = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Legacy => "LEGACY",
                Type::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LEGACY" => Some(Self::Legacy),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateConnection {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "private_connection::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "8")]
    pub vmware_engine_network: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub vmware_engine_network_canonical: ::prost::alloc::string::String,
    #[prost(enumeration = "private_connection::Type", tag = "10")]
    pub r#type: i32,
    #[prost(string, tag = "12")]
    pub peering_id: ::prost::alloc::string::String,
    #[prost(enumeration = "private_connection::RoutingMode", tag = "13")]
    pub routing_mode: i32,
    #[prost(string, tag = "14")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub service_network: ::prost::alloc::string::String,
    #[prost(enumeration = "private_connection::PeeringState", tag = "17")]
    pub peering_state: i32,
}
/// Nested message and enum types in `PrivateConnection`.
pub mod private_connection {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Updating = 3,
        Deleting = 4,
        Unprovisioned = 5,
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Unprovisioned => "UNPROVISIONED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "UNPROVISIONED" => Some(Self::Unprovisioned),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        PrivateServiceAccess = 1,
        NetappCloudVolumes = 2,
        DellPowerscale = 3,
        ThirdPartyService = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::PrivateServiceAccess => "PRIVATE_SERVICE_ACCESS",
                Type::NetappCloudVolumes => "NETAPP_CLOUD_VOLUMES",
                Type::DellPowerscale => "DELL_POWERSCALE",
                Type::ThirdPartyService => "THIRD_PARTY_SERVICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIVATE_SERVICE_ACCESS" => Some(Self::PrivateServiceAccess),
                "NETAPP_CLOUD_VOLUMES" => Some(Self::NetappCloudVolumes),
                "DELL_POWERSCALE" => Some(Self::DellPowerscale),
                "THIRD_PARTY_SERVICE" => Some(Self::ThirdPartyService),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RoutingMode {
        Unspecified = 0,
        Global = 1,
        Regional = 2,
    }
    impl RoutingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RoutingMode::Unspecified => "ROUTING_MODE_UNSPECIFIED",
                RoutingMode::Global => "GLOBAL",
                RoutingMode::Regional => "REGIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROUTING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "GLOBAL" => Some(Self::Global),
                "REGIONAL" => Some(Self::Regional),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PeeringState {
        Unspecified = 0,
        PeeringActive = 1,
        PeeringInactive = 2,
    }
    impl PeeringState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PeeringState::Unspecified => "PEERING_STATE_UNSPECIFIED",
                PeeringState::PeeringActive => "PEERING_ACTIVE",
                PeeringState::PeeringInactive => "PEERING_INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PEERING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PEERING_ACTIVE" => Some(Self::PeeringActive),
                "PEERING_INACTIVE" => Some(Self::PeeringInactive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationMetadata {
    #[prost(
        enumeration = "location_metadata::Capability",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub capabilities: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `LocationMetadata`.
pub mod location_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Capability {
        Unspecified = 0,
        StretchedClusters = 1,
    }
    impl Capability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Capability::Unspecified => "CAPABILITY_UNSPECIFIED",
                Capability::StretchedClusters => "STRETCHED_CLUSTERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CAPABILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "STRETCHED_CLUSTERS" => Some(Self::StretchedClusters),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsBindPermission {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub principals: ::prost::alloc::vec::Vec<Principal>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Principal {
    #[prost(oneof = "principal::Principal", tags = "1, 2")]
    pub principal: ::core::option::Option<principal::Principal>,
}
/// Nested message and enum types in `Principal`.
pub mod principal {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Principal {
        #[prost(string, tag = "1")]
        User(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        ServiceAccount(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateCloudsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateCloudsResponse {
    #[prost(message, repeated, tag = "1")]
    pub private_clouds: ::prost::alloc::vec::Vec<PrivateCloud>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPrivateCloudRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePrivateCloudRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub private_cloud_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub private_cloud: ::core::option::Option<PrivateCloud>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePrivateCloudRequest {
    #[prost(message, optional, tag = "1")]
    pub private_cloud: ::core::option::Option<PrivateCloud>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePrivateCloudRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
    #[prost(int32, optional, tag = "4")]
    pub delay_hours: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeletePrivateCloudRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersResponse {
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<Cluster>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClusterRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cluster_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub cluster: ::core::option::Option<Cluster>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClusterRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub cluster: ::core::option::Option<Cluster>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteClusterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodesResponse {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalAddressesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalAddressesResponse {
    #[prost(message, repeated, tag = "1")]
    pub external_addresses: ::prost::alloc::vec::Vec<ExternalAddress>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchNetworkPolicyExternalAddressesRequest {
    #[prost(string, tag = "1")]
    pub network_policy: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchNetworkPolicyExternalAddressesResponse {
    #[prost(message, repeated, tag = "1")]
    pub external_addresses: ::prost::alloc::vec::Vec<ExternalAddress>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExternalAddressRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExternalAddressRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub external_address: ::core::option::Option<ExternalAddress>,
    #[prost(string, tag = "3")]
    pub external_address_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExternalAddressRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub external_address: ::core::option::Option<ExternalAddress>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExternalAddressRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub subnets: ::prost::alloc::vec::Vec<Subnet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSubnetRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub subnet: ::core::option::Option<Subnet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalAccessRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalAccessRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub external_access_rules: ::prost::alloc::vec::Vec<ExternalAccessRule>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExternalAccessRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExternalAccessRuleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub external_access_rule: ::core::option::Option<ExternalAccessRule>,
    #[prost(string, tag = "3")]
    pub external_access_rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExternalAccessRuleRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub external_access_rule: ::core::option::Option<ExternalAccessRule>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExternalAccessRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLoggingServersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLoggingServersResponse {
    #[prost(message, repeated, tag = "1")]
    pub logging_servers: ::prost::alloc::vec::Vec<LoggingServer>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLoggingServerRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLoggingServerRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub logging_server: ::core::option::Option<LoggingServer>,
    #[prost(string, tag = "3")]
    pub logging_server_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateLoggingServerRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub logging_server: ::core::option::Option<LoggingServer>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLoggingServerRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub node_types: ::prost::alloc::vec::Vec<NodeType>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowNsxCredentialsRequest {
    #[prost(string, tag = "1")]
    pub private_cloud: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowVcenterCredentialsRequest {
    #[prost(string, tag = "1")]
    pub private_cloud: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetNsxCredentialsRequest {
    #[prost(string, tag = "1")]
    pub private_cloud: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetVcenterCredentialsRequest {
    #[prost(string, tag = "1")]
    pub private_cloud: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHcxActivationKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub hcx_activation_keys: ::prost::alloc::vec::Vec<HcxActivationKey>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHcxActivationKeysRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHcxActivationKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHcxActivationKeyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub hcx_activation_key: ::core::option::Option<HcxActivationKey>,
    #[prost(string, tag = "3")]
    pub hcx_activation_key_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDnsForwardingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDnsForwardingRequest {
    #[prost(message, optional, tag = "1")]
    pub dns_forwarding: ::core::option::Option<DnsForwarding>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNetworkPeeringRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub network_peering_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub network_peering: ::core::option::Option<NetworkPeering>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkPeeringRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkPeeringRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkPeeringsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNetworkPeeringRequest {
    #[prost(message, optional, tag = "1")]
    pub network_peering: ::core::option::Option<NetworkPeering>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkPeeringsResponse {
    #[prost(message, repeated, tag = "1")]
    pub network_peerings: ::prost::alloc::vec::Vec<NetworkPeering>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPeeringRoutesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPeeringRoutesResponse {
    #[prost(message, repeated, tag = "1")]
    pub peering_routes: ::prost::alloc::vec::Vec<PeeringRoute>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkPoliciesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkPoliciesResponse {
    #[prost(message, repeated, tag = "1")]
    pub network_policies: ::prost::alloc::vec::Vec<NetworkPolicy>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNetworkPolicyRequest {
    #[prost(message, optional, tag = "1")]
    pub network_policy: ::core::option::Option<NetworkPolicy>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNetworkPolicyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub network_policy_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub network_policy: ::core::option::Option<NetworkPolicy>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListManagementDnsZoneBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListManagementDnsZoneBindingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub management_dns_zone_bindings: ::prost::alloc::vec::Vec<ManagementDnsZoneBinding>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetManagementDnsZoneBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateManagementDnsZoneBindingRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub management_dns_zone_binding: ::core::option::Option<ManagementDnsZoneBinding>,
    #[prost(string, tag = "3")]
    pub management_dns_zone_binding_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateManagementDnsZoneBindingRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub management_dns_zone_binding: ::core::option::Option<ManagementDnsZoneBinding>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteManagementDnsZoneBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepairManagementDnsZoneBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVmwareEngineNetworkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vmware_engine_network_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub vmware_engine_network: ::core::option::Option<VmwareEngineNetwork>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVmwareEngineNetworkRequest {
    #[prost(message, optional, tag = "1")]
    pub vmware_engine_network: ::core::option::Option<VmwareEngineNetwork>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVmwareEngineNetworkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVmwareEngineNetworkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVmwareEngineNetworksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVmwareEngineNetworksResponse {
    #[prost(message, repeated, tag = "1")]
    pub vmware_engine_networks: ::prost::alloc::vec::Vec<VmwareEngineNetwork>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePrivateConnectionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub private_connection_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub private_connection: ::core::option::Option<PrivateConnection>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPrivateConnectionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateConnectionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateConnectionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub private_connections: ::prost::alloc::vec::Vec<PrivateConnection>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePrivateConnectionRequest {
    #[prost(message, optional, tag = "1")]
    pub private_connection: ::core::option::Option<PrivateConnection>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePrivateConnectionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateConnectionPeeringRoutesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateConnectionPeeringRoutesResponse {
    #[prost(message, repeated, tag = "1")]
    pub peering_routes: ::prost::alloc::vec::Vec<PeeringRoute>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantDnsBindPermissionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub principal: ::core::option::Option<Principal>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeDnsBindPermissionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub principal: ::core::option::Option<Principal>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDnsBindPermissionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod vmware_engine_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// VMwareEngine manages VMware's private clusters in the Cloud.
    #[derive(Debug, Clone)]
    pub struct VmwareEngineClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VmwareEngineClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VmwareEngineClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            VmwareEngineClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists `PrivateCloud` resources in a given project and location.
        pub async fn list_private_clouds(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPrivateCloudsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPrivateCloudsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListPrivateClouds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListPrivateClouds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `PrivateCloud` resource by its resource name.
        pub async fn get_private_cloud(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPrivateCloudRequest>,
        ) -> std::result::Result<tonic::Response<super::PrivateCloud>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetPrivateCloud",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetPrivateCloud",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new `PrivateCloud` resource in a given project and location.
        /// Private clouds of type `STANDARD` and
        /// `TIME_LIMITED` are zonal resources, `STRETCHED` private clouds are
        /// regional.
        /// Creating a private cloud also creates a [management
        /// cluster](https://cloud.google.com/vmware-engine/docs/concepts-vmware-components)
        /// for that private cloud.
        pub async fn create_private_cloud(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePrivateCloudRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreatePrivateCloud",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreatePrivateCloud",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies a `PrivateCloud` resource. Only the following fields can be
        /// updated: `description`.
        /// Only fields specified in `updateMask` are applied.
        ///
        /// During operation processing, the resource is temporarily in the `ACTIVE`
        /// state before the operation fully completes. For that period of time, you
        /// can't update the resource. Use the operation status to determine when the
        /// processing fully completes.
        pub async fn update_private_cloud(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePrivateCloudRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdatePrivateCloud",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdatePrivateCloud",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Schedules a `PrivateCloud` resource for deletion.
        ///
        /// A `PrivateCloud` resource scheduled for deletion has `PrivateCloud.state`
        /// set to `DELETED` and `expireTime` set to the time when deletion is final
        /// and can no longer be reversed. The delete operation is marked as done
        /// as soon as the `PrivateCloud` is successfully scheduled for deletion
        /// (this also applies when `delayHours` is set to zero), and the operation is
        /// not kept in pending state until `PrivateCloud` is purged.
        /// `PrivateCloud` can be restored using `UndeletePrivateCloud` method before
        /// the `expireTime` elapses. When `expireTime` is reached, deletion is final
        /// and all private cloud resources are irreversibly removed and billing stops.
        /// During the final removal process, `PrivateCloud.state` is set to `PURGING`.
        /// `PrivateCloud` can be polled using standard `GET` method for the whole
        /// period of deletion and purging. It will not be returned only
        /// when it is completely purged.
        pub async fn delete_private_cloud(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePrivateCloudRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeletePrivateCloud",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeletePrivateCloud",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restores a private cloud that was previously scheduled for deletion by
        /// `DeletePrivateCloud`. A `PrivateCloud` resource scheduled for deletion has
        /// `PrivateCloud.state` set to `DELETED` and `PrivateCloud.expireTime` set to
        /// the time when deletion can no longer be reversed.
        pub async fn undelete_private_cloud(
            &mut self,
            request: impl tonic::IntoRequest<super::UndeletePrivateCloudRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UndeletePrivateCloud",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UndeletePrivateCloud",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `Cluster` resources in a given private cloud.
        pub async fn list_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListClusters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `Cluster` resource by its resource name.
        pub async fn get_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::Cluster>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new cluster in a given private cloud.
        /// Creating a new cluster provides additional nodes for
        /// use in the parent private cloud and requires sufficient [node
        /// quota](https://cloud.google.com/vmware-engine/quotas).
        pub async fn create_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies a `Cluster` resource. Only fields specified in `updateMask` are
        /// applied.
        ///
        /// During operation processing, the resource is temporarily in the `ACTIVE`
        /// state before the operation fully completes. For that period of time, you
        /// can't update the resource. Use the operation status to determine when the
        /// processing fully completes.
        pub async fn update_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `Cluster` resource. To avoid unintended data loss, migrate or
        /// gracefully shut down any workloads running on the cluster before deletion.
        /// You cannot delete the management cluster of a private cloud using this
        /// method.
        pub async fn delete_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists nodes in a given cluster.
        pub async fn list_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNodesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListNodes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single node.
        pub async fn get_node(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeRequest>,
        ) -> std::result::Result<tonic::Response<super::Node>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetNode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetNode",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists external IP addresses assigned to VMware workload VMs in a given
        /// private cloud.
        pub async fn list_external_addresses(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExternalAddressesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExternalAddressesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListExternalAddresses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListExternalAddresses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists external IP addresses assigned to VMware workload VMs within the
        /// scope of the given network policy.
        pub async fn fetch_network_policy_external_addresses(
            &mut self,
            request: impl tonic::IntoRequest<
                super::FetchNetworkPolicyExternalAddressesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FetchNetworkPolicyExternalAddressesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/FetchNetworkPolicyExternalAddresses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "FetchNetworkPolicyExternalAddresses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single external IP address.
        pub async fn get_external_address(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExternalAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExternalAddress>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetExternalAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetExternalAddress",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new `ExternalAddress` resource in a given private cloud. The
        /// network policy that corresponds to the private cloud must have the external
        /// IP address network service enabled (`NetworkPolicy.external_ip`).
        pub async fn create_external_address(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateExternalAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateExternalAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateExternalAddress",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single external IP address.
        /// Only fields specified in `update_mask` are applied.
        ///
        /// During operation processing, the resource is temporarily in the `ACTIVE`
        /// state before the operation fully completes. For that period of time, you
        /// can't update the resource. Use the operation status to determine when the
        /// processing fully completes.
        pub async fn update_external_address(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateExternalAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateExternalAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateExternalAddress",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single external IP address. When you delete an external IP
        /// address, connectivity between the external IP address and the corresponding
        /// internal IP address is lost.
        pub async fn delete_external_address(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExternalAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteExternalAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteExternalAddress",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists subnets in a given private cloud.
        pub async fn list_subnets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubnetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubnetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListSubnets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListSubnets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single subnet.
        pub async fn get_subnet(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubnetRequest>,
        ) -> std::result::Result<tonic::Response<super::Subnet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetSubnet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetSubnet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single subnet. Only fields specified in
        /// `update_mask` are applied.
        ///
        /// *Note*: This API is synchronous and always returns a successful
        /// `google.longrunning.Operation` (LRO). The returned LRO will only have
        /// `done` and `response` fields.
        pub async fn update_subnet(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSubnetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateSubnet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateSubnet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `ExternalAccessRule` resources in the specified network policy.
        pub async fn list_external_access_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExternalAccessRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExternalAccessRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListExternalAccessRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListExternalAccessRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single external access rule.
        pub async fn get_external_access_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExternalAccessRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExternalAccessRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetExternalAccessRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetExternalAccessRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new external access rule in a given network policy.
        pub async fn create_external_access_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateExternalAccessRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateExternalAccessRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateExternalAccessRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single external access rule.
        /// Only fields specified in `update_mask` are applied.
        pub async fn update_external_access_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateExternalAccessRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateExternalAccessRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateExternalAccessRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single external access rule.
        pub async fn delete_external_access_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExternalAccessRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteExternalAccessRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteExternalAccessRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists logging servers configured for a given private
        /// cloud.
        pub async fn list_logging_servers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLoggingServersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLoggingServersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListLoggingServers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListLoggingServers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a logging server.
        pub async fn get_logging_server(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLoggingServerRequest>,
        ) -> std::result::Result<tonic::Response<super::LoggingServer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetLoggingServer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetLoggingServer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new logging server for a given private cloud.
        pub async fn create_logging_server(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateLoggingServerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateLoggingServer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateLoggingServer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single logging server.
        /// Only fields specified in `update_mask` are applied.
        pub async fn update_logging_server(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateLoggingServerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateLoggingServer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateLoggingServer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single logging server.
        pub async fn delete_logging_server(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteLoggingServerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteLoggingServer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteLoggingServer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists node types
        pub async fn list_node_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodeTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNodeTypesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListNodeTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListNodeTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single `NodeType`.
        pub async fn get_node_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::NodeType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetNodeType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetNodeType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of credentials for NSX appliance.
        pub async fn show_nsx_credentials(
            &mut self,
            request: impl tonic::IntoRequest<super::ShowNsxCredentialsRequest>,
        ) -> std::result::Result<tonic::Response<super::Credentials>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ShowNsxCredentials",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ShowNsxCredentials",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of credentials for Vcenter appliance.
        pub async fn show_vcenter_credentials(
            &mut self,
            request: impl tonic::IntoRequest<super::ShowVcenterCredentialsRequest>,
        ) -> std::result::Result<tonic::Response<super::Credentials>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ShowVcenterCredentials",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ShowVcenterCredentials",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resets credentials of the NSX appliance.
        pub async fn reset_nsx_credentials(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetNsxCredentialsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ResetNsxCredentials",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ResetNsxCredentials",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resets credentials of the Vcenter appliance.
        pub async fn reset_vcenter_credentials(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetVcenterCredentialsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ResetVcenterCredentials",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ResetVcenterCredentials",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of the `DnsForwarding` config.
        pub async fn get_dns_forwarding(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDnsForwardingRequest>,
        ) -> std::result::Result<tonic::Response<super::DnsForwarding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetDnsForwarding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetDnsForwarding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of the `DnsForwarding` config, like associated
        /// domains. Only fields specified in `update_mask` are applied.
        pub async fn update_dns_forwarding(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDnsForwardingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateDnsForwarding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateDnsForwarding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `NetworkPeering` resource by its resource name. The resource
        /// contains details of the network peering, such as peered
        /// networks, import and export custom route configurations, and peering state.
        /// NetworkPeering is a global resource and location can only be global.
        pub async fn get_network_peering(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkPeeringRequest>,
        ) -> std::result::Result<tonic::Response<super::NetworkPeering>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetNetworkPeering",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetNetworkPeering",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `NetworkPeering` resources in a given project. NetworkPeering is a
        /// global resource and location can only be global.
        pub async fn list_network_peerings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNetworkPeeringsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNetworkPeeringsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListNetworkPeerings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListNetworkPeerings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new network peering between the peer network and VMware Engine
        /// network provided in a `NetworkPeering` resource. NetworkPeering is a
        /// global resource and location can only be global.
        pub async fn create_network_peering(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNetworkPeeringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateNetworkPeering",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateNetworkPeering",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `NetworkPeering` resource. When a network peering is deleted for
        /// a VMware Engine network, the peer network becomes inaccessible to that
        /// VMware Engine network. NetworkPeering is a global resource and location can
        /// only be global.
        pub async fn delete_network_peering(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNetworkPeeringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteNetworkPeering",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteNetworkPeering",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies a `NetworkPeering` resource. Only the `description` field can be
        /// updated. Only fields specified in `updateMask` are applied. NetworkPeering
        /// is a global resource and location can only be global.
        pub async fn update_network_peering(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNetworkPeeringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateNetworkPeering",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateNetworkPeering",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the network peering routes exchanged over a peering connection.
        /// NetworkPeering is a global resource and location can only be global.
        pub async fn list_peering_routes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPeeringRoutesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPeeringRoutesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListPeeringRoutes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListPeeringRoutes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new HCX activation key in a given private cloud.
        pub async fn create_hcx_activation_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHcxActivationKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateHcxActivationKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateHcxActivationKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `HcxActivationKey` resources in a given private cloud.
        pub async fn list_hcx_activation_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHcxActivationKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHcxActivationKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListHcxActivationKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListHcxActivationKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `HcxActivationKey` resource by its resource name.
        pub async fn get_hcx_activation_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHcxActivationKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HcxActivationKey>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetHcxActivationKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetHcxActivationKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `NetworkPolicy` resource by its resource name.
        pub async fn get_network_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::NetworkPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetNetworkPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetNetworkPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `NetworkPolicy` resources in a specified project and location.
        pub async fn list_network_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNetworkPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNetworkPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListNetworkPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListNetworkPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new network policy in a given VMware Engine network of a
        /// project and location (region). A new network policy cannot be created if
        /// another network policy already exists in the same scope.
        pub async fn create_network_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNetworkPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateNetworkPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateNetworkPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies a `NetworkPolicy` resource. Only the following fields can be
        /// updated: `internet_access`, `external_ip`, `edge_services_cidr`.
        /// Only fields specified in `updateMask` are applied. When updating a network
        /// policy, the external IP network service can only be disabled if there are
        /// no external IP addresses present in the scope of the policy. Also, a
        /// `NetworkService` cannot be updated when `NetworkService.state` is set
        /// to `RECONCILING`.
        ///
        /// During operation processing, the resource is temporarily in the `ACTIVE`
        /// state before the operation fully completes. For that period of time, you
        /// can't update the resource. Use the operation status to determine when the
        /// processing fully completes.
        pub async fn update_network_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNetworkPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateNetworkPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateNetworkPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `NetworkPolicy` resource. A network policy cannot be deleted
        /// when `NetworkService.state` is set to `RECONCILING` for either its external
        /// IP or internet access service.
        pub async fn delete_network_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNetworkPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteNetworkPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteNetworkPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Consumer VPCs bound to Management DNS Zone of a given private cloud.
        pub async fn list_management_dns_zone_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListManagementDnsZoneBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListManagementDnsZoneBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListManagementDnsZoneBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListManagementDnsZoneBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a 'ManagementDnsZoneBinding' resource by its resource name.
        pub async fn get_management_dns_zone_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::GetManagementDnsZoneBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ManagementDnsZoneBinding>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetManagementDnsZoneBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetManagementDnsZoneBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new `ManagementDnsZoneBinding` resource in a private cloud.
        /// This RPC creates the DNS binding and the resource that represents the
        /// DNS binding of the consumer VPC network to the management DNS zone. A
        /// management DNS zone is the Cloud DNS cross-project binding zone that
        /// VMware Engine creates for each private cloud. It contains FQDNs and
        /// corresponding IP addresses for the private cloud's ESXi hosts and
        /// management VM appliances like vCenter and NSX Manager.
        pub async fn create_management_dns_zone_binding(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateManagementDnsZoneBindingRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateManagementDnsZoneBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateManagementDnsZoneBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `ManagementDnsZoneBinding` resource.
        /// Only fields specified in `update_mask` are applied.
        pub async fn update_management_dns_zone_binding(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateManagementDnsZoneBindingRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateManagementDnsZoneBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateManagementDnsZoneBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `ManagementDnsZoneBinding` resource. When a management DNS zone
        /// binding is deleted, the corresponding consumer VPC network is no longer
        /// bound to the management DNS zone.
        pub async fn delete_management_dns_zone_binding(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteManagementDnsZoneBindingRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteManagementDnsZoneBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteManagementDnsZoneBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retries to create a `ManagementDnsZoneBinding` resource that is
        /// in failed state.
        pub async fn repair_management_dns_zone_binding(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RepairManagementDnsZoneBindingRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/RepairManagementDnsZoneBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "RepairManagementDnsZoneBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new VMware Engine network that can be used by a private cloud.
        pub async fn create_vmware_engine_network(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVmwareEngineNetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreateVmwareEngineNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreateVmwareEngineNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies a VMware Engine network resource. Only the following fields can be
        /// updated: `description`. Only fields specified in `updateMask` are
        /// applied.
        pub async fn update_vmware_engine_network(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVmwareEngineNetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdateVmwareEngineNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdateVmwareEngineNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `VmwareEngineNetwork` resource. You can only delete a VMware
        /// Engine network after all resources that refer to it are deleted. For
        /// example, a private cloud, a network peering, and a network policy can all
        /// refer to the same VMware Engine network.
        pub async fn delete_vmware_engine_network(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVmwareEngineNetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeleteVmwareEngineNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeleteVmwareEngineNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `VmwareEngineNetwork` resource by its resource name. The
        /// resource contains details of the VMware Engine network, such as its VMware
        /// Engine network type, peered networks in a service project, and state
        /// (for example, `CREATING`, `ACTIVE`, `DELETING`).
        pub async fn get_vmware_engine_network(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVmwareEngineNetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VmwareEngineNetwork>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetVmwareEngineNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetVmwareEngineNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `VmwareEngineNetwork` resources in a given project and location.
        pub async fn list_vmware_engine_networks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVmwareEngineNetworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListVmwareEngineNetworksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListVmwareEngineNetworks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListVmwareEngineNetworks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new private connection that can be used for accessing private
        /// Clouds.
        pub async fn create_private_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePrivateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/CreatePrivateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "CreatePrivateConnection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `PrivateConnection` resource by its resource name. The resource
        /// contains details of the private connection, such as connected
        /// network, routing mode and state.
        pub async fn get_private_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPrivateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PrivateConnection>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetPrivateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetPrivateConnection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `PrivateConnection` resources in a given project and location.
        pub async fn list_private_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPrivateConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPrivateConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListPrivateConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListPrivateConnections",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies a `PrivateConnection` resource. Only `description` and
        /// `routing_mode` fields can be updated. Only fields specified in `updateMask`
        /// are applied.
        pub async fn update_private_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePrivateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/UpdatePrivateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "UpdatePrivateConnection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `PrivateConnection` resource. When a private connection is
        /// deleted for a VMware Engine network, the connected network becomes
        /// inaccessible to that VMware Engine network.
        pub async fn delete_private_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePrivateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/DeletePrivateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "DeletePrivateConnection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the private connection routes exchanged over a peering connection.
        pub async fn list_private_connection_peering_routes(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListPrivateConnectionPeeringRoutesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListPrivateConnectionPeeringRoutesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/ListPrivateConnectionPeeringRoutes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "ListPrivateConnectionPeeringRoutes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Grants the bind permission to the customer provided principal(user /
        /// service account) to bind their DNS zone with the intranet VPC associated
        /// with the project. DnsBindPermission is a global resource and location can
        /// only be global.
        pub async fn grant_dns_bind_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::GrantDnsBindPermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GrantDnsBindPermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GrantDnsBindPermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets all the principals having bind permission on the intranet VPC
        /// associated with the consumer project granted by the Grant API.
        /// DnsBindPermission is a global resource and location can only be global.
        pub async fn get_dns_bind_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDnsBindPermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DnsBindPermission>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/GetDnsBindPermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "GetDnsBindPermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Revokes the bind permission from the customer provided principal(user /
        /// service account) on the intranet VPC associated with the consumer project.
        /// DnsBindPermission is a global resource and location can only be global.
        pub async fn revoke_dns_bind_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeDnsBindPermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vmwareengine.v1.VmwareEngine/RevokeDnsBindPermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vmwareengine.v1.VmwareEngine",
                        "RevokeDnsBindPermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
