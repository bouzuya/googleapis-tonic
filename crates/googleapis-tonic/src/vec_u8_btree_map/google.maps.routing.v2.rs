// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FallbackInfo {
    #[prost(enumeration = "FallbackRoutingMode", tag = "1")]
    pub routing_mode: i32,
    #[prost(enumeration = "FallbackReason", tag = "2")]
    pub reason: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FallbackReason {
    Unspecified = 0,
    ServerError = 1,
    LatencyExceeded = 2,
}
impl FallbackReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FallbackReason::Unspecified => "FALLBACK_REASON_UNSPECIFIED",
            FallbackReason::ServerError => "SERVER_ERROR",
            FallbackReason::LatencyExceeded => "LATENCY_EXCEEDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FALLBACK_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "SERVER_ERROR" => Some(Self::ServerError),
            "LATENCY_EXCEEDED" => Some(Self::LatencyExceeded),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FallbackRoutingMode {
    Unspecified = 0,
    FallbackTrafficUnaware = 1,
    FallbackTrafficAware = 2,
}
impl FallbackRoutingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FallbackRoutingMode::Unspecified => "FALLBACK_ROUTING_MODE_UNSPECIFIED",
            FallbackRoutingMode::FallbackTrafficUnaware => "FALLBACK_TRAFFIC_UNAWARE",
            FallbackRoutingMode::FallbackTrafficAware => "FALLBACK_TRAFFIC_AWARE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FALLBACK_ROUTING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "FALLBACK_TRAFFIC_UNAWARE" => Some(Self::FallbackTrafficUnaware),
            "FALLBACK_TRAFFIC_AWARE" => Some(Self::FallbackTrafficAware),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Polyline {
    #[prost(oneof = "polyline::PolylineType", tags = "1, 2")]
    pub polyline_type: ::core::option::Option<polyline::PolylineType>,
}
/// Nested message and enum types in `Polyline`.
pub mod polyline {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PolylineType {
        #[prost(string, tag = "1")]
        EncodedPolyline(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        GeoJsonLinestring(::prost_types::Struct),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PolylineQuality {
    Unspecified = 0,
    HighQuality = 1,
    Overview = 2,
}
impl PolylineQuality {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PolylineQuality::Unspecified => "POLYLINE_QUALITY_UNSPECIFIED",
            PolylineQuality::HighQuality => "HIGH_QUALITY",
            PolylineQuality::Overview => "OVERVIEW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLYLINE_QUALITY_UNSPECIFIED" => Some(Self::Unspecified),
            "HIGH_QUALITY" => Some(Self::HighQuality),
            "OVERVIEW" => Some(Self::Overview),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PolylineEncoding {
    Unspecified = 0,
    EncodedPolyline = 1,
    GeoJsonLinestring = 2,
}
impl PolylineEncoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PolylineEncoding::Unspecified => "POLYLINE_ENCODING_UNSPECIFIED",
            PolylineEncoding::EncodedPolyline => "ENCODED_POLYLINE",
            PolylineEncoding::GeoJsonLinestring => "GEO_JSON_LINESTRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLYLINE_ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "ENCODED_POLYLINE" => Some(Self::EncodedPolyline),
            "GEO_JSON_LINESTRING" => Some(Self::GeoJsonLinestring),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpeedReadingInterval {
    #[prost(int32, optional, tag = "1")]
    pub start_polyline_point_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub end_polyline_point_index: ::core::option::Option<i32>,
    #[prost(oneof = "speed_reading_interval::SpeedType", tags = "3")]
    pub speed_type: ::core::option::Option<speed_reading_interval::SpeedType>,
}
/// Nested message and enum types in `SpeedReadingInterval`.
pub mod speed_reading_interval {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Speed {
        Unspecified = 0,
        Normal = 1,
        Slow = 2,
        TrafficJam = 3,
    }
    impl Speed {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Speed::Unspecified => "SPEED_UNSPECIFIED",
                Speed::Normal => "NORMAL",
                Speed::Slow => "SLOW",
                Speed::TrafficJam => "TRAFFIC_JAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SPEED_UNSPECIFIED" => Some(Self::Unspecified),
                "NORMAL" => Some(Self::Normal),
                "SLOW" => Some(Self::Slow),
                "TRAFFIC_JAM" => Some(Self::TrafficJam),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum SpeedType {
        #[prost(enumeration = "Speed", tag = "3")]
        Speed(i32),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TrafficModel {
    Unspecified = 0,
    BestGuess = 1,
    Pessimistic = 2,
    Optimistic = 3,
}
impl TrafficModel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TrafficModel::Unspecified => "TRAFFIC_MODEL_UNSPECIFIED",
            TrafficModel::BestGuess => "BEST_GUESS",
            TrafficModel::Pessimistic => "PESSIMISTIC",
            TrafficModel::Optimistic => "OPTIMISTIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRAFFIC_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
            "BEST_GUESS" => Some(Self::BestGuess),
            "PESSIMISTIC" => Some(Self::Pessimistic),
            "OPTIMISTIC" => Some(Self::Optimistic),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TollInfo {
    #[prost(message, repeated, tag = "1")]
    pub estimated_price: ::prost::alloc::vec::Vec<super::super::super::r#type::Money>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizedTime {
    #[prost(message, optional, tag = "1")]
    pub time: ::core::option::Option<super::super::super::r#type::LocalizedText>,
    #[prost(string, tag = "2")]
    pub time_zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Location {
    #[prost(message, optional, tag = "1")]
    pub lat_lng: ::core::option::Option<super::super::super::r#type::LatLng>,
    #[prost(message, optional, tag = "2")]
    pub heading: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Maneuver {
    Unspecified = 0,
    TurnSlightLeft = 1,
    TurnSharpLeft = 2,
    UturnLeft = 3,
    TurnLeft = 4,
    TurnSlightRight = 5,
    TurnSharpRight = 6,
    UturnRight = 7,
    TurnRight = 8,
    Straight = 9,
    RampLeft = 10,
    RampRight = 11,
    Merge = 12,
    ForkLeft = 13,
    ForkRight = 14,
    Ferry = 15,
    FerryTrain = 16,
    RoundaboutLeft = 17,
    RoundaboutRight = 18,
    Depart = 19,
    NameChange = 20,
}
impl Maneuver {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Maneuver::Unspecified => "MANEUVER_UNSPECIFIED",
            Maneuver::TurnSlightLeft => "TURN_SLIGHT_LEFT",
            Maneuver::TurnSharpLeft => "TURN_SHARP_LEFT",
            Maneuver::UturnLeft => "UTURN_LEFT",
            Maneuver::TurnLeft => "TURN_LEFT",
            Maneuver::TurnSlightRight => "TURN_SLIGHT_RIGHT",
            Maneuver::TurnSharpRight => "TURN_SHARP_RIGHT",
            Maneuver::UturnRight => "UTURN_RIGHT",
            Maneuver::TurnRight => "TURN_RIGHT",
            Maneuver::Straight => "STRAIGHT",
            Maneuver::RampLeft => "RAMP_LEFT",
            Maneuver::RampRight => "RAMP_RIGHT",
            Maneuver::Merge => "MERGE",
            Maneuver::ForkLeft => "FORK_LEFT",
            Maneuver::ForkRight => "FORK_RIGHT",
            Maneuver::Ferry => "FERRY",
            Maneuver::FerryTrain => "FERRY_TRAIN",
            Maneuver::RoundaboutLeft => "ROUNDABOUT_LEFT",
            Maneuver::RoundaboutRight => "ROUNDABOUT_RIGHT",
            Maneuver::Depart => "DEPART",
            Maneuver::NameChange => "NAME_CHANGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MANEUVER_UNSPECIFIED" => Some(Self::Unspecified),
            "TURN_SLIGHT_LEFT" => Some(Self::TurnSlightLeft),
            "TURN_SHARP_LEFT" => Some(Self::TurnSharpLeft),
            "UTURN_LEFT" => Some(Self::UturnLeft),
            "TURN_LEFT" => Some(Self::TurnLeft),
            "TURN_SLIGHT_RIGHT" => Some(Self::TurnSlightRight),
            "TURN_SHARP_RIGHT" => Some(Self::TurnSharpRight),
            "UTURN_RIGHT" => Some(Self::UturnRight),
            "TURN_RIGHT" => Some(Self::TurnRight),
            "STRAIGHT" => Some(Self::Straight),
            "RAMP_LEFT" => Some(Self::RampLeft),
            "RAMP_RIGHT" => Some(Self::RampRight),
            "MERGE" => Some(Self::Merge),
            "FORK_LEFT" => Some(Self::ForkLeft),
            "FORK_RIGHT" => Some(Self::ForkRight),
            "FERRY" => Some(Self::Ferry),
            "FERRY_TRAIN" => Some(Self::FerryTrain),
            "ROUNDABOUT_LEFT" => Some(Self::RoundaboutLeft),
            "ROUNDABOUT_RIGHT" => Some(Self::RoundaboutRight),
            "DEPART" => Some(Self::Depart),
            "NAME_CHANGE" => Some(Self::NameChange),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NavigationInstruction {
    #[prost(enumeration = "Maneuver", tag = "1")]
    pub maneuver: i32,
    #[prost(string, tag = "2")]
    pub instructions: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RouteLabel {
    Unspecified = 0,
    DefaultRoute = 1,
    DefaultRouteAlternate = 2,
    FuelEfficient = 3,
}
impl RouteLabel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RouteLabel::Unspecified => "ROUTE_LABEL_UNSPECIFIED",
            RouteLabel::DefaultRoute => "DEFAULT_ROUTE",
            RouteLabel::DefaultRouteAlternate => "DEFAULT_ROUTE_ALTERNATE",
            RouteLabel::FuelEfficient => "FUEL_EFFICIENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROUTE_LABEL_UNSPECIFIED" => Some(Self::Unspecified),
            "DEFAULT_ROUTE" => Some(Self::DefaultRoute),
            "DEFAULT_ROUTE_ALTERNATE" => Some(Self::DefaultRouteAlternate),
            "FUEL_EFFICIENT" => Some(Self::FuelEfficient),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RouteTravelMode {
    TravelModeUnspecified = 0,
    Drive = 1,
    Bicycle = 2,
    Walk = 3,
    TwoWheeler = 4,
    Transit = 7,
}
impl RouteTravelMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RouteTravelMode::TravelModeUnspecified => "TRAVEL_MODE_UNSPECIFIED",
            RouteTravelMode::Drive => "DRIVE",
            RouteTravelMode::Bicycle => "BICYCLE",
            RouteTravelMode::Walk => "WALK",
            RouteTravelMode::TwoWheeler => "TWO_WHEELER",
            RouteTravelMode::Transit => "TRANSIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRAVEL_MODE_UNSPECIFIED" => Some(Self::TravelModeUnspecified),
            "DRIVE" => Some(Self::Drive),
            "BICYCLE" => Some(Self::Bicycle),
            "WALK" => Some(Self::Walk),
            "TWO_WHEELER" => Some(Self::TwoWheeler),
            "TRANSIT" => Some(Self::Transit),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransitAgency {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub phone_number: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransitLine {
    #[prost(message, repeated, tag = "1")]
    pub agencies: ::prost::alloc::vec::Vec<TransitAgency>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub color: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub icon_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub name_short: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub text_color: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub vehicle: ::core::option::Option<TransitVehicle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransitStop {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub location: ::core::option::Option<Location>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransitVehicle {
    #[prost(message, optional, tag = "1")]
    pub name: ::core::option::Option<super::super::super::r#type::LocalizedText>,
    #[prost(enumeration = "transit_vehicle::TransitVehicleType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub icon_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub local_icon_uri: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TransitVehicle`.
pub mod transit_vehicle {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransitVehicleType {
        Unspecified = 0,
        Bus = 1,
        CableCar = 2,
        CommuterTrain = 3,
        Ferry = 4,
        Funicular = 5,
        GondolaLift = 6,
        HeavyRail = 7,
        HighSpeedTrain = 8,
        IntercityBus = 9,
        LongDistanceTrain = 10,
        MetroRail = 11,
        Monorail = 12,
        Other = 13,
        Rail = 14,
        ShareTaxi = 15,
        Subway = 16,
        Tram = 17,
        Trolleybus = 18,
    }
    impl TransitVehicleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TransitVehicleType::Unspecified => "TRANSIT_VEHICLE_TYPE_UNSPECIFIED",
                TransitVehicleType::Bus => "BUS",
                TransitVehicleType::CableCar => "CABLE_CAR",
                TransitVehicleType::CommuterTrain => "COMMUTER_TRAIN",
                TransitVehicleType::Ferry => "FERRY",
                TransitVehicleType::Funicular => "FUNICULAR",
                TransitVehicleType::GondolaLift => "GONDOLA_LIFT",
                TransitVehicleType::HeavyRail => "HEAVY_RAIL",
                TransitVehicleType::HighSpeedTrain => "HIGH_SPEED_TRAIN",
                TransitVehicleType::IntercityBus => "INTERCITY_BUS",
                TransitVehicleType::LongDistanceTrain => "LONG_DISTANCE_TRAIN",
                TransitVehicleType::MetroRail => "METRO_RAIL",
                TransitVehicleType::Monorail => "MONORAIL",
                TransitVehicleType::Other => "OTHER",
                TransitVehicleType::Rail => "RAIL",
                TransitVehicleType::ShareTaxi => "SHARE_TAXI",
                TransitVehicleType::Subway => "SUBWAY",
                TransitVehicleType::Tram => "TRAM",
                TransitVehicleType::Trolleybus => "TROLLEYBUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSIT_VEHICLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BUS" => Some(Self::Bus),
                "CABLE_CAR" => Some(Self::CableCar),
                "COMMUTER_TRAIN" => Some(Self::CommuterTrain),
                "FERRY" => Some(Self::Ferry),
                "FUNICULAR" => Some(Self::Funicular),
                "GONDOLA_LIFT" => Some(Self::GondolaLift),
                "HEAVY_RAIL" => Some(Self::HeavyRail),
                "HIGH_SPEED_TRAIN" => Some(Self::HighSpeedTrain),
                "INTERCITY_BUS" => Some(Self::IntercityBus),
                "LONG_DISTANCE_TRAIN" => Some(Self::LongDistanceTrain),
                "METRO_RAIL" => Some(Self::MetroRail),
                "MONORAIL" => Some(Self::Monorail),
                "OTHER" => Some(Self::Other),
                "RAIL" => Some(Self::Rail),
                "SHARE_TAXI" => Some(Self::ShareTaxi),
                "SUBWAY" => Some(Self::Subway),
                "TRAM" => Some(Self::Tram),
                "TROLLEYBUS" => Some(Self::Trolleybus),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    #[prost(enumeration = "RouteLabel", repeated, tag = "13")]
    pub route_labels: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "1")]
    pub legs: ::prost::alloc::vec::Vec<RouteLeg>,
    #[prost(int32, tag = "2")]
    pub distance_meters: i32,
    #[prost(message, optional, tag = "3")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub static_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "5")]
    pub polyline: ::core::option::Option<Polyline>,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub viewport: ::core::option::Option<super::super::super::geo::r#type::Viewport>,
    #[prost(message, optional, tag = "9")]
    pub travel_advisory: ::core::option::Option<RouteTravelAdvisory>,
    #[prost(int32, repeated, tag = "10")]
    pub optimized_intermediate_waypoint_index: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "11")]
    pub localized_values: ::core::option::Option<route::RouteLocalizedValues>,
    #[prost(string, tag = "12")]
    pub route_token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Route`.
pub mod route {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RouteLocalizedValues {
        #[prost(message, optional, tag = "1")]
        pub distance: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "2")]
        pub duration: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "3")]
        pub static_duration: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "4")]
        pub transit_fare: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteTravelAdvisory {
    #[prost(message, optional, tag = "2")]
    pub toll_info: ::core::option::Option<TollInfo>,
    #[prost(message, repeated, tag = "3")]
    pub speed_reading_intervals: ::prost::alloc::vec::Vec<SpeedReadingInterval>,
    #[prost(int64, tag = "5")]
    pub fuel_consumption_microliters: i64,
    #[prost(bool, tag = "6")]
    pub route_restrictions_partially_ignored: bool,
    #[prost(message, optional, tag = "7")]
    pub transit_fare: ::core::option::Option<super::super::super::r#type::Money>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteLegTravelAdvisory {
    #[prost(message, optional, tag = "1")]
    pub toll_info: ::core::option::Option<TollInfo>,
    #[prost(message, repeated, tag = "2")]
    pub speed_reading_intervals: ::prost::alloc::vec::Vec<SpeedReadingInterval>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteLegStepTravelAdvisory {
    #[prost(message, repeated, tag = "1")]
    pub speed_reading_intervals: ::prost::alloc::vec::Vec<SpeedReadingInterval>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteLeg {
    #[prost(int32, tag = "1")]
    pub distance_meters: i32,
    #[prost(message, optional, tag = "2")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "3")]
    pub static_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub polyline: ::core::option::Option<Polyline>,
    #[prost(message, optional, tag = "5")]
    pub start_location: ::core::option::Option<Location>,
    #[prost(message, optional, tag = "6")]
    pub end_location: ::core::option::Option<Location>,
    #[prost(message, repeated, tag = "7")]
    pub steps: ::prost::alloc::vec::Vec<RouteLegStep>,
    #[prost(message, optional, tag = "8")]
    pub travel_advisory: ::core::option::Option<RouteLegTravelAdvisory>,
    #[prost(message, optional, tag = "9")]
    pub localized_values: ::core::option::Option<route_leg::RouteLegLocalizedValues>,
    #[prost(message, optional, tag = "10")]
    pub steps_overview: ::core::option::Option<route_leg::StepsOverview>,
}
/// Nested message and enum types in `RouteLeg`.
pub mod route_leg {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RouteLegLocalizedValues {
        #[prost(message, optional, tag = "1")]
        pub distance: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "2")]
        pub duration: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "3")]
        pub static_duration: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StepsOverview {
        #[prost(message, repeated, tag = "1")]
        pub multi_modal_segments: ::prost::alloc::vec::Vec<
            steps_overview::MultiModalSegment,
        >,
    }
    /// Nested message and enum types in `StepsOverview`.
    pub mod steps_overview {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MultiModalSegment {
            #[prost(int32, optional, tag = "1")]
            pub step_start_index: ::core::option::Option<i32>,
            #[prost(int32, optional, tag = "2")]
            pub step_end_index: ::core::option::Option<i32>,
            #[prost(message, optional, tag = "3")]
            pub navigation_instruction: ::core::option::Option<
                super::super::NavigationInstruction,
            >,
            #[prost(enumeration = "super::super::RouteTravelMode", tag = "4")]
            pub travel_mode: i32,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteLegStep {
    #[prost(int32, tag = "1")]
    pub distance_meters: i32,
    #[prost(message, optional, tag = "2")]
    pub static_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "3")]
    pub polyline: ::core::option::Option<Polyline>,
    #[prost(message, optional, tag = "4")]
    pub start_location: ::core::option::Option<Location>,
    #[prost(message, optional, tag = "5")]
    pub end_location: ::core::option::Option<Location>,
    #[prost(message, optional, tag = "6")]
    pub navigation_instruction: ::core::option::Option<NavigationInstruction>,
    #[prost(message, optional, tag = "7")]
    pub travel_advisory: ::core::option::Option<RouteLegStepTravelAdvisory>,
    #[prost(message, optional, tag = "8")]
    pub localized_values: ::core::option::Option<
        route_leg_step::RouteLegStepLocalizedValues,
    >,
    #[prost(message, optional, tag = "9")]
    pub transit_details: ::core::option::Option<RouteLegStepTransitDetails>,
    #[prost(enumeration = "RouteTravelMode", tag = "10")]
    pub travel_mode: i32,
}
/// Nested message and enum types in `RouteLegStep`.
pub mod route_leg_step {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RouteLegStepLocalizedValues {
        #[prost(message, optional, tag = "1")]
        pub distance: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "3")]
        pub static_duration: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteLegStepTransitDetails {
    #[prost(message, optional, tag = "1")]
    pub stop_details: ::core::option::Option<
        route_leg_step_transit_details::TransitStopDetails,
    >,
    #[prost(message, optional, tag = "2")]
    pub localized_values: ::core::option::Option<
        route_leg_step_transit_details::TransitDetailsLocalizedValues,
    >,
    #[prost(string, tag = "3")]
    pub headsign: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub headway: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "5")]
    pub transit_line: ::core::option::Option<TransitLine>,
    #[prost(int32, tag = "6")]
    pub stop_count: i32,
    #[prost(string, tag = "7")]
    pub trip_short_text: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RouteLegStepTransitDetails`.
pub mod route_leg_step_transit_details {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransitStopDetails {
        #[prost(message, optional, tag = "1")]
        pub arrival_stop: ::core::option::Option<super::TransitStop>,
        #[prost(message, optional, tag = "2")]
        pub arrival_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "3")]
        pub departure_stop: ::core::option::Option<super::TransitStop>,
        #[prost(message, optional, tag = "4")]
        pub departure_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransitDetailsLocalizedValues {
        #[prost(message, optional, tag = "1")]
        pub arrival_time: ::core::option::Option<super::LocalizedTime>,
        #[prost(message, optional, tag = "2")]
        pub departure_time: ::core::option::Option<super::LocalizedTime>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VehicleEmissionType {
    Unspecified = 0,
    Gasoline = 1,
    Electric = 2,
    Hybrid = 3,
    Diesel = 4,
}
impl VehicleEmissionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VehicleEmissionType::Unspecified => "VEHICLE_EMISSION_TYPE_UNSPECIFIED",
            VehicleEmissionType::Gasoline => "GASOLINE",
            VehicleEmissionType::Electric => "ELECTRIC",
            VehicleEmissionType::Hybrid => "HYBRID",
            VehicleEmissionType::Diesel => "DIESEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VEHICLE_EMISSION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "GASOLINE" => Some(Self::Gasoline),
            "ELECTRIC" => Some(Self::Electric),
            "HYBRID" => Some(Self::Hybrid),
            "DIESEL" => Some(Self::Diesel),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VehicleInfo {
    #[prost(enumeration = "VehicleEmissionType", tag = "2")]
    pub emission_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransitPreferences {
    #[prost(enumeration = "transit_preferences::TransitTravelMode", repeated, tag = "1")]
    pub allowed_travel_modes: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "transit_preferences::TransitRoutingPreference", tag = "2")]
    pub routing_preference: i32,
}
/// Nested message and enum types in `TransitPreferences`.
pub mod transit_preferences {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransitTravelMode {
        Unspecified = 0,
        Bus = 1,
        Subway = 2,
        Train = 3,
        LightRail = 4,
        Rail = 5,
    }
    impl TransitTravelMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TransitTravelMode::Unspecified => "TRANSIT_TRAVEL_MODE_UNSPECIFIED",
                TransitTravelMode::Bus => "BUS",
                TransitTravelMode::Subway => "SUBWAY",
                TransitTravelMode::Train => "TRAIN",
                TransitTravelMode::LightRail => "LIGHT_RAIL",
                TransitTravelMode::Rail => "RAIL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSIT_TRAVEL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "BUS" => Some(Self::Bus),
                "SUBWAY" => Some(Self::Subway),
                "TRAIN" => Some(Self::Train),
                "LIGHT_RAIL" => Some(Self::LightRail),
                "RAIL" => Some(Self::Rail),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransitRoutingPreference {
        Unspecified = 0,
        LessWalking = 1,
        FewerTransfers = 2,
    }
    impl TransitRoutingPreference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TransitRoutingPreference::Unspecified => {
                    "TRANSIT_ROUTING_PREFERENCE_UNSPECIFIED"
                }
                TransitRoutingPreference::LessWalking => "LESS_WALKING",
                TransitRoutingPreference::FewerTransfers => "FEWER_TRANSFERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSIT_ROUTING_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                "LESS_WALKING" => Some(Self::LessWalking),
                "FEWER_TRANSFERS" => Some(Self::FewerTransfers),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeocodingResults {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<GeocodedWaypoint>,
    #[prost(message, optional, tag = "2")]
    pub destination: ::core::option::Option<GeocodedWaypoint>,
    #[prost(message, repeated, tag = "3")]
    pub intermediates: ::prost::alloc::vec::Vec<GeocodedWaypoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeocodedWaypoint {
    #[prost(message, optional, tag = "1")]
    pub geocoder_status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(int32, optional, tag = "2")]
    pub intermediate_waypoint_request_index: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "3")]
    pub r#type: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub partial_match: bool,
    #[prost(string, tag = "5")]
    pub place_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TollPass {
    Unspecified = 0,
    AuEtollTag = 82,
    AuEwayTag = 83,
    AuLinkt = 2,
    ArTelepase = 3,
    BrAutoExpreso = 81,
    BrConectcar = 7,
    BrMoveMais = 8,
    BrPassaRapido = 88,
    BrSemParar = 9,
    BrTaggy = 10,
    BrVeloe = 11,
    CaUsAkwasasneSeawayCorporateCard = 84,
    CaUsAkwasasneSeawayTransitCard = 85,
    CaUsBlueWaterEdgePass = 18,
    CaUsConnexion = 19,
    CaUsNexusCard = 20,
    IdEToll = 16,
    InFastag = 78,
    InLocalHpPlateExempt = 79,
    JpEtc = 98,
    JpEtc2 = 99,
    MxIave = 90,
    MxPase = 91,
    MxQuickpass = 93,
    MxSistemaTelepeajeChihuahua = 89,
    MxTagIave = 12,
    MxTagTelevia = 13,
    MxTelevia = 92,
    MxViapass = 14,
    UsAlFreedomPass = 21,
    UsAkAntonAndersonTunnelBookOf10Tickets = 22,
    UsCaFastrak = 4,
    UsCaFastrakCavSticker = 86,
    UsCoExpresstoll = 23,
    UsCoGoPass = 24,
    UsDeEzpassde = 25,
    UsFlBobSikesTollBridgePass = 65,
    UsFlDunesCommunityDevelopmentDistrictExpresscard = 66,
    UsFlEpass = 67,
    UsFlGibaTollPass = 68,
    UsFlLeeway = 69,
    UsFlSunpass = 70,
    UsFlSunpassPro = 71,
    UsIlEzpassil = 73,
    UsIlIpass = 72,
    UsInEzpassin = 26,
    UsKsBestpassHorizon = 27,
    UsKsKtag = 28,
    UsKsNationalpass = 29,
    UsKsPrepassElitepass = 30,
    UsKyRiverlink = 31,
    UsLaGeauxpass = 32,
    UsLaTollTag = 33,
    UsMaEzpassma = 6,
    UsMdEzpassmd = 34,
    UsMeEzpassme = 35,
    UsMiAmbassadorBridgePremierCommuterCard = 36,
    UsMiBcpass = 94,
    UsMiGrosseIleTollBridgePassTag = 37,
    UsMiIqProxCard = 38,
    UsMiIqTag = 95,
    UsMiMackinacBridgeMacPass = 39,
    UsMiNexpressToll = 40,
    UsMnEzpassmn = 41,
    UsNcEzpassnc = 42,
    UsNcPeachPass = 87,
    UsNcQuickPass = 43,
    UsNhEzpassnh = 80,
    UsNjDownbeachExpressPass = 75,
    UsNjEzpassnj = 74,
    UsNyExpresspass = 76,
    UsNyEzpassny = 77,
    UsOhEzpassoh = 44,
    UsPaEzpasspa = 45,
    UsRiEzpassri = 46,
    UsScPalpass = 47,
    UsTxAviTag = 97,
    UsTxBancpass = 48,
    UsTxDelRioPass = 49,
    UsTxEfastPass = 50,
    UsTxEaglePassExpressCard = 51,
    UsTxEptoll = 52,
    UsTxEzCross = 53,
    UsTxEztag = 54,
    UsTxFuegoTag = 96,
    UsTxLaredoTradeTag = 55,
    UsTxPluspass = 56,
    UsTxTolltag = 57,
    UsTxTxtag = 58,
    UsTxXpressCard = 59,
    UsUtAdamsAveParkwayExpresscard = 60,
    UsVaEzpassva = 61,
    UsWaBreezeby = 17,
    UsWaGoodToGo = 1,
    UsWvEzpasswv = 62,
    UsWvMemorialBridgeTickets = 63,
    UsWvMovPass = 100,
    UsWvNewellTollBridgeTicket = 64,
}
impl TollPass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TollPass::Unspecified => "TOLL_PASS_UNSPECIFIED",
            TollPass::AuEtollTag => "AU_ETOLL_TAG",
            TollPass::AuEwayTag => "AU_EWAY_TAG",
            TollPass::AuLinkt => "AU_LINKT",
            TollPass::ArTelepase => "AR_TELEPASE",
            TollPass::BrAutoExpreso => "BR_AUTO_EXPRESO",
            TollPass::BrConectcar => "BR_CONECTCAR",
            TollPass::BrMoveMais => "BR_MOVE_MAIS",
            TollPass::BrPassaRapido => "BR_PASSA_RAPIDO",
            TollPass::BrSemParar => "BR_SEM_PARAR",
            TollPass::BrTaggy => "BR_TAGGY",
            TollPass::BrVeloe => "BR_VELOE",
            TollPass::CaUsAkwasasneSeawayCorporateCard => {
                "CA_US_AKWASASNE_SEAWAY_CORPORATE_CARD"
            }
            TollPass::CaUsAkwasasneSeawayTransitCard => {
                "CA_US_AKWASASNE_SEAWAY_TRANSIT_CARD"
            }
            TollPass::CaUsBlueWaterEdgePass => "CA_US_BLUE_WATER_EDGE_PASS",
            TollPass::CaUsConnexion => "CA_US_CONNEXION",
            TollPass::CaUsNexusCard => "CA_US_NEXUS_CARD",
            TollPass::IdEToll => "ID_E_TOLL",
            TollPass::InFastag => "IN_FASTAG",
            TollPass::InLocalHpPlateExempt => "IN_LOCAL_HP_PLATE_EXEMPT",
            TollPass::JpEtc => "JP_ETC",
            TollPass::JpEtc2 => "JP_ETC2",
            TollPass::MxIave => "MX_IAVE",
            TollPass::MxPase => "MX_PASE",
            TollPass::MxQuickpass => "MX_QUICKPASS",
            TollPass::MxSistemaTelepeajeChihuahua => "MX_SISTEMA_TELEPEAJE_CHIHUAHUA",
            TollPass::MxTagIave => "MX_TAG_IAVE",
            TollPass::MxTagTelevia => "MX_TAG_TELEVIA",
            TollPass::MxTelevia => "MX_TELEVIA",
            TollPass::MxViapass => "MX_VIAPASS",
            TollPass::UsAlFreedomPass => "US_AL_FREEDOM_PASS",
            TollPass::UsAkAntonAndersonTunnelBookOf10Tickets => {
                "US_AK_ANTON_ANDERSON_TUNNEL_BOOK_OF_10_TICKETS"
            }
            TollPass::UsCaFastrak => "US_CA_FASTRAK",
            TollPass::UsCaFastrakCavSticker => "US_CA_FASTRAK_CAV_STICKER",
            TollPass::UsCoExpresstoll => "US_CO_EXPRESSTOLL",
            TollPass::UsCoGoPass => "US_CO_GO_PASS",
            TollPass::UsDeEzpassde => "US_DE_EZPASSDE",
            TollPass::UsFlBobSikesTollBridgePass => "US_FL_BOB_SIKES_TOLL_BRIDGE_PASS",
            TollPass::UsFlDunesCommunityDevelopmentDistrictExpresscard => {
                "US_FL_DUNES_COMMUNITY_DEVELOPMENT_DISTRICT_EXPRESSCARD"
            }
            TollPass::UsFlEpass => "US_FL_EPASS",
            TollPass::UsFlGibaTollPass => "US_FL_GIBA_TOLL_PASS",
            TollPass::UsFlLeeway => "US_FL_LEEWAY",
            TollPass::UsFlSunpass => "US_FL_SUNPASS",
            TollPass::UsFlSunpassPro => "US_FL_SUNPASS_PRO",
            TollPass::UsIlEzpassil => "US_IL_EZPASSIL",
            TollPass::UsIlIpass => "US_IL_IPASS",
            TollPass::UsInEzpassin => "US_IN_EZPASSIN",
            TollPass::UsKsBestpassHorizon => "US_KS_BESTPASS_HORIZON",
            TollPass::UsKsKtag => "US_KS_KTAG",
            TollPass::UsKsNationalpass => "US_KS_NATIONALPASS",
            TollPass::UsKsPrepassElitepass => "US_KS_PREPASS_ELITEPASS",
            TollPass::UsKyRiverlink => "US_KY_RIVERLINK",
            TollPass::UsLaGeauxpass => "US_LA_GEAUXPASS",
            TollPass::UsLaTollTag => "US_LA_TOLL_TAG",
            TollPass::UsMaEzpassma => "US_MA_EZPASSMA",
            TollPass::UsMdEzpassmd => "US_MD_EZPASSMD",
            TollPass::UsMeEzpassme => "US_ME_EZPASSME",
            TollPass::UsMiAmbassadorBridgePremierCommuterCard => {
                "US_MI_AMBASSADOR_BRIDGE_PREMIER_COMMUTER_CARD"
            }
            TollPass::UsMiBcpass => "US_MI_BCPASS",
            TollPass::UsMiGrosseIleTollBridgePassTag => {
                "US_MI_GROSSE_ILE_TOLL_BRIDGE_PASS_TAG"
            }
            TollPass::UsMiIqProxCard => "US_MI_IQ_PROX_CARD",
            TollPass::UsMiIqTag => "US_MI_IQ_TAG",
            TollPass::UsMiMackinacBridgeMacPass => "US_MI_MACKINAC_BRIDGE_MAC_PASS",
            TollPass::UsMiNexpressToll => "US_MI_NEXPRESS_TOLL",
            TollPass::UsMnEzpassmn => "US_MN_EZPASSMN",
            TollPass::UsNcEzpassnc => "US_NC_EZPASSNC",
            TollPass::UsNcPeachPass => "US_NC_PEACH_PASS",
            TollPass::UsNcQuickPass => "US_NC_QUICK_PASS",
            TollPass::UsNhEzpassnh => "US_NH_EZPASSNH",
            TollPass::UsNjDownbeachExpressPass => "US_NJ_DOWNBEACH_EXPRESS_PASS",
            TollPass::UsNjEzpassnj => "US_NJ_EZPASSNJ",
            TollPass::UsNyExpresspass => "US_NY_EXPRESSPASS",
            TollPass::UsNyEzpassny => "US_NY_EZPASSNY",
            TollPass::UsOhEzpassoh => "US_OH_EZPASSOH",
            TollPass::UsPaEzpasspa => "US_PA_EZPASSPA",
            TollPass::UsRiEzpassri => "US_RI_EZPASSRI",
            TollPass::UsScPalpass => "US_SC_PALPASS",
            TollPass::UsTxAviTag => "US_TX_AVI_TAG",
            TollPass::UsTxBancpass => "US_TX_BANCPASS",
            TollPass::UsTxDelRioPass => "US_TX_DEL_RIO_PASS",
            TollPass::UsTxEfastPass => "US_TX_EFAST_PASS",
            TollPass::UsTxEaglePassExpressCard => "US_TX_EAGLE_PASS_EXPRESS_CARD",
            TollPass::UsTxEptoll => "US_TX_EPTOLL",
            TollPass::UsTxEzCross => "US_TX_EZ_CROSS",
            TollPass::UsTxEztag => "US_TX_EZTAG",
            TollPass::UsTxFuegoTag => "US_TX_FUEGO_TAG",
            TollPass::UsTxLaredoTradeTag => "US_TX_LAREDO_TRADE_TAG",
            TollPass::UsTxPluspass => "US_TX_PLUSPASS",
            TollPass::UsTxTolltag => "US_TX_TOLLTAG",
            TollPass::UsTxTxtag => "US_TX_TXTAG",
            TollPass::UsTxXpressCard => "US_TX_XPRESS_CARD",
            TollPass::UsUtAdamsAveParkwayExpresscard => {
                "US_UT_ADAMS_AVE_PARKWAY_EXPRESSCARD"
            }
            TollPass::UsVaEzpassva => "US_VA_EZPASSVA",
            TollPass::UsWaBreezeby => "US_WA_BREEZEBY",
            TollPass::UsWaGoodToGo => "US_WA_GOOD_TO_GO",
            TollPass::UsWvEzpasswv => "US_WV_EZPASSWV",
            TollPass::UsWvMemorialBridgeTickets => "US_WV_MEMORIAL_BRIDGE_TICKETS",
            TollPass::UsWvMovPass => "US_WV_MOV_PASS",
            TollPass::UsWvNewellTollBridgeTicket => "US_WV_NEWELL_TOLL_BRIDGE_TICKET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TOLL_PASS_UNSPECIFIED" => Some(Self::Unspecified),
            "AU_ETOLL_TAG" => Some(Self::AuEtollTag),
            "AU_EWAY_TAG" => Some(Self::AuEwayTag),
            "AU_LINKT" => Some(Self::AuLinkt),
            "AR_TELEPASE" => Some(Self::ArTelepase),
            "BR_AUTO_EXPRESO" => Some(Self::BrAutoExpreso),
            "BR_CONECTCAR" => Some(Self::BrConectcar),
            "BR_MOVE_MAIS" => Some(Self::BrMoveMais),
            "BR_PASSA_RAPIDO" => Some(Self::BrPassaRapido),
            "BR_SEM_PARAR" => Some(Self::BrSemParar),
            "BR_TAGGY" => Some(Self::BrTaggy),
            "BR_VELOE" => Some(Self::BrVeloe),
            "CA_US_AKWASASNE_SEAWAY_CORPORATE_CARD" => {
                Some(Self::CaUsAkwasasneSeawayCorporateCard)
            }
            "CA_US_AKWASASNE_SEAWAY_TRANSIT_CARD" => {
                Some(Self::CaUsAkwasasneSeawayTransitCard)
            }
            "CA_US_BLUE_WATER_EDGE_PASS" => Some(Self::CaUsBlueWaterEdgePass),
            "CA_US_CONNEXION" => Some(Self::CaUsConnexion),
            "CA_US_NEXUS_CARD" => Some(Self::CaUsNexusCard),
            "ID_E_TOLL" => Some(Self::IdEToll),
            "IN_FASTAG" => Some(Self::InFastag),
            "IN_LOCAL_HP_PLATE_EXEMPT" => Some(Self::InLocalHpPlateExempt),
            "JP_ETC" => Some(Self::JpEtc),
            "JP_ETC2" => Some(Self::JpEtc2),
            "MX_IAVE" => Some(Self::MxIave),
            "MX_PASE" => Some(Self::MxPase),
            "MX_QUICKPASS" => Some(Self::MxQuickpass),
            "MX_SISTEMA_TELEPEAJE_CHIHUAHUA" => Some(Self::MxSistemaTelepeajeChihuahua),
            "MX_TAG_IAVE" => Some(Self::MxTagIave),
            "MX_TAG_TELEVIA" => Some(Self::MxTagTelevia),
            "MX_TELEVIA" => Some(Self::MxTelevia),
            "MX_VIAPASS" => Some(Self::MxViapass),
            "US_AL_FREEDOM_PASS" => Some(Self::UsAlFreedomPass),
            "US_AK_ANTON_ANDERSON_TUNNEL_BOOK_OF_10_TICKETS" => {
                Some(Self::UsAkAntonAndersonTunnelBookOf10Tickets)
            }
            "US_CA_FASTRAK" => Some(Self::UsCaFastrak),
            "US_CA_FASTRAK_CAV_STICKER" => Some(Self::UsCaFastrakCavSticker),
            "US_CO_EXPRESSTOLL" => Some(Self::UsCoExpresstoll),
            "US_CO_GO_PASS" => Some(Self::UsCoGoPass),
            "US_DE_EZPASSDE" => Some(Self::UsDeEzpassde),
            "US_FL_BOB_SIKES_TOLL_BRIDGE_PASS" => Some(Self::UsFlBobSikesTollBridgePass),
            "US_FL_DUNES_COMMUNITY_DEVELOPMENT_DISTRICT_EXPRESSCARD" => {
                Some(Self::UsFlDunesCommunityDevelopmentDistrictExpresscard)
            }
            "US_FL_EPASS" => Some(Self::UsFlEpass),
            "US_FL_GIBA_TOLL_PASS" => Some(Self::UsFlGibaTollPass),
            "US_FL_LEEWAY" => Some(Self::UsFlLeeway),
            "US_FL_SUNPASS" => Some(Self::UsFlSunpass),
            "US_FL_SUNPASS_PRO" => Some(Self::UsFlSunpassPro),
            "US_IL_EZPASSIL" => Some(Self::UsIlEzpassil),
            "US_IL_IPASS" => Some(Self::UsIlIpass),
            "US_IN_EZPASSIN" => Some(Self::UsInEzpassin),
            "US_KS_BESTPASS_HORIZON" => Some(Self::UsKsBestpassHorizon),
            "US_KS_KTAG" => Some(Self::UsKsKtag),
            "US_KS_NATIONALPASS" => Some(Self::UsKsNationalpass),
            "US_KS_PREPASS_ELITEPASS" => Some(Self::UsKsPrepassElitepass),
            "US_KY_RIVERLINK" => Some(Self::UsKyRiverlink),
            "US_LA_GEAUXPASS" => Some(Self::UsLaGeauxpass),
            "US_LA_TOLL_TAG" => Some(Self::UsLaTollTag),
            "US_MA_EZPASSMA" => Some(Self::UsMaEzpassma),
            "US_MD_EZPASSMD" => Some(Self::UsMdEzpassmd),
            "US_ME_EZPASSME" => Some(Self::UsMeEzpassme),
            "US_MI_AMBASSADOR_BRIDGE_PREMIER_COMMUTER_CARD" => {
                Some(Self::UsMiAmbassadorBridgePremierCommuterCard)
            }
            "US_MI_BCPASS" => Some(Self::UsMiBcpass),
            "US_MI_GROSSE_ILE_TOLL_BRIDGE_PASS_TAG" => {
                Some(Self::UsMiGrosseIleTollBridgePassTag)
            }
            "US_MI_IQ_PROX_CARD" => Some(Self::UsMiIqProxCard),
            "US_MI_IQ_TAG" => Some(Self::UsMiIqTag),
            "US_MI_MACKINAC_BRIDGE_MAC_PASS" => Some(Self::UsMiMackinacBridgeMacPass),
            "US_MI_NEXPRESS_TOLL" => Some(Self::UsMiNexpressToll),
            "US_MN_EZPASSMN" => Some(Self::UsMnEzpassmn),
            "US_NC_EZPASSNC" => Some(Self::UsNcEzpassnc),
            "US_NC_PEACH_PASS" => Some(Self::UsNcPeachPass),
            "US_NC_QUICK_PASS" => Some(Self::UsNcQuickPass),
            "US_NH_EZPASSNH" => Some(Self::UsNhEzpassnh),
            "US_NJ_DOWNBEACH_EXPRESS_PASS" => Some(Self::UsNjDownbeachExpressPass),
            "US_NJ_EZPASSNJ" => Some(Self::UsNjEzpassnj),
            "US_NY_EXPRESSPASS" => Some(Self::UsNyExpresspass),
            "US_NY_EZPASSNY" => Some(Self::UsNyEzpassny),
            "US_OH_EZPASSOH" => Some(Self::UsOhEzpassoh),
            "US_PA_EZPASSPA" => Some(Self::UsPaEzpasspa),
            "US_RI_EZPASSRI" => Some(Self::UsRiEzpassri),
            "US_SC_PALPASS" => Some(Self::UsScPalpass),
            "US_TX_AVI_TAG" => Some(Self::UsTxAviTag),
            "US_TX_BANCPASS" => Some(Self::UsTxBancpass),
            "US_TX_DEL_RIO_PASS" => Some(Self::UsTxDelRioPass),
            "US_TX_EFAST_PASS" => Some(Self::UsTxEfastPass),
            "US_TX_EAGLE_PASS_EXPRESS_CARD" => Some(Self::UsTxEaglePassExpressCard),
            "US_TX_EPTOLL" => Some(Self::UsTxEptoll),
            "US_TX_EZ_CROSS" => Some(Self::UsTxEzCross),
            "US_TX_EZTAG" => Some(Self::UsTxEztag),
            "US_TX_FUEGO_TAG" => Some(Self::UsTxFuegoTag),
            "US_TX_LAREDO_TRADE_TAG" => Some(Self::UsTxLaredoTradeTag),
            "US_TX_PLUSPASS" => Some(Self::UsTxPluspass),
            "US_TX_TOLLTAG" => Some(Self::UsTxTolltag),
            "US_TX_TXTAG" => Some(Self::UsTxTxtag),
            "US_TX_XPRESS_CARD" => Some(Self::UsTxXpressCard),
            "US_UT_ADAMS_AVE_PARKWAY_EXPRESSCARD" => {
                Some(Self::UsUtAdamsAveParkwayExpresscard)
            }
            "US_VA_EZPASSVA" => Some(Self::UsVaEzpassva),
            "US_WA_BREEZEBY" => Some(Self::UsWaBreezeby),
            "US_WA_GOOD_TO_GO" => Some(Self::UsWaGoodToGo),
            "US_WV_EZPASSWV" => Some(Self::UsWvEzpasswv),
            "US_WV_MEMORIAL_BRIDGE_TICKETS" => Some(Self::UsWvMemorialBridgeTickets),
            "US_WV_MOV_PASS" => Some(Self::UsWvMovPass),
            "US_WV_NEWELL_TOLL_BRIDGE_TICKET" => Some(Self::UsWvNewellTollBridgeTicket),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteModifiers {
    #[prost(bool, tag = "1")]
    pub avoid_tolls: bool,
    #[prost(bool, tag = "2")]
    pub avoid_highways: bool,
    #[prost(bool, tag = "3")]
    pub avoid_ferries: bool,
    #[prost(bool, tag = "4")]
    pub avoid_indoor: bool,
    #[prost(message, optional, tag = "5")]
    pub vehicle_info: ::core::option::Option<VehicleInfo>,
    #[prost(enumeration = "TollPass", repeated, tag = "6")]
    pub toll_passes: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoutingPreference {
    Unspecified = 0,
    TrafficUnaware = 1,
    TrafficAware = 2,
    TrafficAwareOptimal = 3,
}
impl RoutingPreference {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RoutingPreference::Unspecified => "ROUTING_PREFERENCE_UNSPECIFIED",
            RoutingPreference::TrafficUnaware => "TRAFFIC_UNAWARE",
            RoutingPreference::TrafficAware => "TRAFFIC_AWARE",
            RoutingPreference::TrafficAwareOptimal => "TRAFFIC_AWARE_OPTIMAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROUTING_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRAFFIC_UNAWARE" => Some(Self::TrafficUnaware),
            "TRAFFIC_AWARE" => Some(Self::TrafficAware),
            "TRAFFIC_AWARE_OPTIMAL" => Some(Self::TrafficAwareOptimal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Units {
    Unspecified = 0,
    Metric = 1,
    Imperial = 2,
}
impl Units {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Units::Unspecified => "UNITS_UNSPECIFIED",
            Units::Metric => "METRIC",
            Units::Imperial => "IMPERIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNITS_UNSPECIFIED" => Some(Self::Unspecified),
            "METRIC" => Some(Self::Metric),
            "IMPERIAL" => Some(Self::Imperial),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Waypoint {
    #[prost(bool, tag = "3")]
    pub via: bool,
    #[prost(bool, tag = "4")]
    pub vehicle_stopover: bool,
    #[prost(bool, tag = "5")]
    pub side_of_road: bool,
    #[prost(oneof = "waypoint::LocationType", tags = "1, 2, 7")]
    pub location_type: ::core::option::Option<waypoint::LocationType>,
}
/// Nested message and enum types in `Waypoint`.
pub mod waypoint {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LocationType {
        #[prost(message, tag = "1")]
        Location(super::Location),
        #[prost(string, tag = "2")]
        PlaceId(::prost::alloc::string::String),
        #[prost(string, tag = "7")]
        Address(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeRoutesRequest {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<Waypoint>,
    #[prost(message, optional, tag = "2")]
    pub destination: ::core::option::Option<Waypoint>,
    #[prost(message, repeated, tag = "3")]
    pub intermediates: ::prost::alloc::vec::Vec<Waypoint>,
    #[prost(enumeration = "RouteTravelMode", tag = "4")]
    pub travel_mode: i32,
    #[prost(enumeration = "RoutingPreference", tag = "5")]
    pub routing_preference: i32,
    #[prost(enumeration = "PolylineQuality", tag = "6")]
    pub polyline_quality: i32,
    #[prost(enumeration = "PolylineEncoding", tag = "12")]
    pub polyline_encoding: i32,
    #[prost(message, optional, tag = "7")]
    pub departure_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "19")]
    pub arrival_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "8")]
    pub compute_alternative_routes: bool,
    #[prost(message, optional, tag = "9")]
    pub route_modifiers: ::core::option::Option<RouteModifiers>,
    #[prost(string, tag = "10")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub region_code: ::prost::alloc::string::String,
    #[prost(enumeration = "Units", tag = "11")]
    pub units: i32,
    #[prost(bool, tag = "13")]
    pub optimize_waypoint_order: bool,
    #[prost(
        enumeration = "compute_routes_request::ReferenceRoute",
        repeated,
        packed = "false",
        tag = "14"
    )]
    pub requested_reference_routes: ::prost::alloc::vec::Vec<i32>,
    #[prost(
        enumeration = "compute_routes_request::ExtraComputation",
        repeated,
        packed = "false",
        tag = "15"
    )]
    pub extra_computations: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "TrafficModel", tag = "18")]
    pub traffic_model: i32,
    #[prost(message, optional, tag = "20")]
    pub transit_preferences: ::core::option::Option<TransitPreferences>,
}
/// Nested message and enum types in `ComputeRoutesRequest`.
pub mod compute_routes_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReferenceRoute {
        Unspecified = 0,
        FuelEfficient = 1,
    }
    impl ReferenceRoute {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReferenceRoute::Unspecified => "REFERENCE_ROUTE_UNSPECIFIED",
                ReferenceRoute::FuelEfficient => "FUEL_EFFICIENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFERENCE_ROUTE_UNSPECIFIED" => Some(Self::Unspecified),
                "FUEL_EFFICIENT" => Some(Self::FuelEfficient),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtraComputation {
        Unspecified = 0,
        Tolls = 1,
        FuelConsumption = 2,
        TrafficOnPolyline = 3,
        HtmlFormattedNavigationInstructions = 4,
    }
    impl ExtraComputation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExtraComputation::Unspecified => "EXTRA_COMPUTATION_UNSPECIFIED",
                ExtraComputation::Tolls => "TOLLS",
                ExtraComputation::FuelConsumption => "FUEL_CONSUMPTION",
                ExtraComputation::TrafficOnPolyline => "TRAFFIC_ON_POLYLINE",
                ExtraComputation::HtmlFormattedNavigationInstructions => {
                    "HTML_FORMATTED_NAVIGATION_INSTRUCTIONS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXTRA_COMPUTATION_UNSPECIFIED" => Some(Self::Unspecified),
                "TOLLS" => Some(Self::Tolls),
                "FUEL_CONSUMPTION" => Some(Self::FuelConsumption),
                "TRAFFIC_ON_POLYLINE" => Some(Self::TrafficOnPolyline),
                "HTML_FORMATTED_NAVIGATION_INSTRUCTIONS" => {
                    Some(Self::HtmlFormattedNavigationInstructions)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeRoutesResponse {
    #[prost(message, repeated, tag = "1")]
    pub routes: ::prost::alloc::vec::Vec<Route>,
    #[prost(message, optional, tag = "2")]
    pub fallback_info: ::core::option::Option<FallbackInfo>,
    #[prost(message, optional, tag = "3")]
    pub geocoding_results: ::core::option::Option<GeocodingResults>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeRouteMatrixRequest {
    #[prost(message, repeated, tag = "1")]
    pub origins: ::prost::alloc::vec::Vec<RouteMatrixOrigin>,
    #[prost(message, repeated, tag = "2")]
    pub destinations: ::prost::alloc::vec::Vec<RouteMatrixDestination>,
    #[prost(enumeration = "RouteTravelMode", tag = "3")]
    pub travel_mode: i32,
    #[prost(enumeration = "RoutingPreference", tag = "4")]
    pub routing_preference: i32,
    #[prost(message, optional, tag = "5")]
    pub departure_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub arrival_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub region_code: ::prost::alloc::string::String,
    #[prost(enumeration = "Units", tag = "7")]
    pub units: i32,
    #[prost(
        enumeration = "compute_route_matrix_request::ExtraComputation",
        repeated,
        packed = "false",
        tag = "8"
    )]
    pub extra_computations: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "TrafficModel", tag = "10")]
    pub traffic_model: i32,
    #[prost(message, optional, tag = "12")]
    pub transit_preferences: ::core::option::Option<TransitPreferences>,
}
/// Nested message and enum types in `ComputeRouteMatrixRequest`.
pub mod compute_route_matrix_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtraComputation {
        Unspecified = 0,
        Tolls = 1,
    }
    impl ExtraComputation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExtraComputation::Unspecified => "EXTRA_COMPUTATION_UNSPECIFIED",
                ExtraComputation::Tolls => "TOLLS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXTRA_COMPUTATION_UNSPECIFIED" => Some(Self::Unspecified),
                "TOLLS" => Some(Self::Tolls),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteMatrixOrigin {
    #[prost(message, optional, tag = "1")]
    pub waypoint: ::core::option::Option<Waypoint>,
    #[prost(message, optional, tag = "2")]
    pub route_modifiers: ::core::option::Option<RouteModifiers>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteMatrixDestination {
    #[prost(message, optional, tag = "1")]
    pub waypoint: ::core::option::Option<Waypoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteMatrixElement {
    #[prost(int32, optional, tag = "1")]
    pub origin_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub destination_index: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(enumeration = "RouteMatrixElementCondition", tag = "9")]
    pub condition: i32,
    #[prost(int32, tag = "4")]
    pub distance_meters: i32,
    #[prost(message, optional, tag = "5")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "6")]
    pub static_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "7")]
    pub travel_advisory: ::core::option::Option<RouteTravelAdvisory>,
    #[prost(message, optional, tag = "8")]
    pub fallback_info: ::core::option::Option<FallbackInfo>,
    #[prost(message, optional, tag = "10")]
    pub localized_values: ::core::option::Option<route_matrix_element::LocalizedValues>,
}
/// Nested message and enum types in `RouteMatrixElement`.
pub mod route_matrix_element {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocalizedValues {
        #[prost(message, optional, tag = "1")]
        pub distance: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "2")]
        pub duration: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "3")]
        pub static_duration: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
        #[prost(message, optional, tag = "4")]
        pub transit_fare: ::core::option::Option<
            super::super::super::super::r#type::LocalizedText,
        >,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RouteMatrixElementCondition {
    Unspecified = 0,
    RouteExists = 1,
    RouteNotFound = 2,
}
impl RouteMatrixElementCondition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RouteMatrixElementCondition::Unspecified => {
                "ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED"
            }
            RouteMatrixElementCondition::RouteExists => "ROUTE_EXISTS",
            RouteMatrixElementCondition::RouteNotFound => "ROUTE_NOT_FOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
            "ROUTE_EXISTS" => Some(Self::RouteExists),
            "ROUTE_NOT_FOUND" => Some(Self::RouteNotFound),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod routes_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Routes API.
    #[derive(Debug, Clone)]
    pub struct RoutesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RoutesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RoutesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RoutesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the primary route along with optional alternate routes, given a set
        /// of terminal and intermediate waypoints.
        ///
        /// **NOTE:** This method requires that you specify a response field mask in
        /// the input. You can provide the response field mask by using URL parameter
        /// `$fields` or `fields`, or by using an HTTP/gRPC header `X-Goog-FieldMask`
        /// (see the [available URL parameters and
        /// headers](https://cloud.google.com/apis/docs/system-parameters)). The value
        /// is a comma separated list of field paths. See detailed documentation about
        /// [how to construct the field
        /// paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
        ///
        /// For example, in this method:
        ///
        /// * Field mask of all available fields (for manual inspection):
        ///  `X-Goog-FieldMask: *`
        /// * Field mask of Route-level duration, distance, and polyline (an example
        ///  production setup):
        ///  `X-Goog-FieldMask: routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline`
        ///
        /// Google discourage the use of the wildcard (`*`) response field mask, or
        /// specifying the field mask at the top level (`routes`), because:
        ///
        /// * Selecting only the fields that you need helps our server save computation
        ///  cycles, allowing us to return the result to you with a lower latency.
        /// * Selecting only the fields that you need
        ///  in your production job ensures stable latency performance. We might add
        ///  more response fields in the future, and those new fields might require
        ///  extra computation time. If you select all fields, or if you select all
        ///  fields at the top level, then you might experience performance degradation
        ///  because any new field we add will be automatically included in the
        ///  response.
        /// * Selecting only the fields that you need results in a smaller response
        ///  size, and thus higher network throughput.
        pub async fn compute_routes(
            &mut self,
            request: impl tonic::IntoRequest<super::ComputeRoutesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeRoutesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.routing.v2.Routes/ComputeRoutes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.maps.routing.v2.Routes", "ComputeRoutes"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Takes in a list of origins and destinations and returns a stream containing
        /// route information for each combination of origin and destination.
        ///
        /// **NOTE:** This method requires that you specify a response field mask in
        /// the input. You can provide the response field mask by using the URL
        /// parameter `$fields` or `fields`, or by using the HTTP/gRPC header
        /// `X-Goog-FieldMask` (see the [available URL parameters and
        /// headers](https://cloud.google.com/apis/docs/system-parameters)).
        /// The value is a comma separated list of field paths. See this detailed
        /// documentation about [how to construct the field
        /// paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
        ///
        /// For example, in this method:
        ///
        /// * Field mask of all available fields (for manual inspection):
        ///  `X-Goog-FieldMask: *`
        /// * Field mask of route durations, distances, element status, condition, and
        ///  element indices (an example production setup):
        ///  `X-Goog-FieldMask: originIndex,destinationIndex,status,condition,distanceMeters,duration`
        ///
        /// It is critical that you include `status` in your field mask as otherwise
        /// all messages will appear to be OK. Google discourages the use of the
        /// wildcard (`*`) response field mask, because:
        ///
        /// * Selecting only the fields that you need helps our server save computation
        ///  cycles, allowing us to return the result to you with a lower latency.
        /// * Selecting only the fields that you need in your production job ensures
        ///  stable latency performance. We might add more response fields in the
        ///  future, and those new fields might require extra computation time. If you
        ///  select all fields, or if you select all fields at the top level, then you
        ///  might experience performance degradation because any new field we add will
        ///  be automatically included in the response.
        /// * Selecting only the fields that you need results in a smaller response
        ///  size, and thus higher network throughput.
        pub async fn compute_route_matrix(
            &mut self,
            request: impl tonic::IntoRequest<super::ComputeRouteMatrixRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RouteMatrixElement>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.routing.v2.Routes/ComputeRouteMatrix",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.routing.v2.Routes",
                        "ComputeRouteMatrix",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
