// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonMetadata {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "OperationType", tag = "3")]
pub operation_type: i32,
#[prost(map = "string, string", tag = "4")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(enumeration = "common_metadata::State", tag = "5")]
pub state: i32,
}
/// Nested message and enum types in `CommonMetadata`.
pub mod common_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Initializing = 1,
Processing = 2,
Cancelling = 3,
Finalizing = 4,
Successful = 5,
Failed = 6,
Cancelled = 7,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Initializing => "INITIALIZING",
State::Processing => "PROCESSING",
State::Cancelling => "CANCELLING",
State::Finalizing => "FINALIZING",
State::Successful => "SUCCESSFUL",
State::Failed => "FAILED",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"INITIALIZING" => Some(Self::Initializing),
"PROCESSING" => Some(Self::Processing),
"CANCELLING" => Some(Self::Cancelling),
"FINALIZING" => Some(Self::Finalizing),
"SUCCESSFUL" => Some(Self::Successful),
"FAILED" => Some(Self::Failed),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Progress {
#[prost(int64, tag = "1")]
pub work_completed: i64,
#[prost(int64, tag = "2")]
pub work_estimated: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportEntitiesRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "2")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub entity_filter: ::core::option::Option<EntityFilter>,
#[prost(string, tag = "4")]
pub output_url_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportEntitiesRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "2")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "3")]
pub input_url: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub entity_filter: ::core::option::Option<EntityFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportEntitiesResponse {
#[prost(string, tag = "1")]
pub output_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportEntitiesMetadata {
#[prost(message, optional, tag = "1")]
pub common: ::core::option::Option<CommonMetadata>,
#[prost(message, optional, tag = "2")]
pub progress_entities: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "3")]
pub progress_bytes: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "4")]
pub entity_filter: ::core::option::Option<EntityFilter>,
#[prost(string, tag = "5")]
pub output_url_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportEntitiesMetadata {
#[prost(message, optional, tag = "1")]
pub common: ::core::option::Option<CommonMetadata>,
#[prost(message, optional, tag = "2")]
pub progress_entities: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "3")]
pub progress_bytes: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "4")]
pub entity_filter: ::core::option::Option<EntityFilter>,
#[prost(string, tag = "5")]
pub input_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityFilter {
#[prost(string, repeated, tag = "1")]
pub kinds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "2")]
pub namespace_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationType {
Unspecified = 0,
ExportEntities = 1,
ImportEntities = 2,
}
impl OperationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OperationType::Unspecified => "OPERATION_TYPE_UNSPECIFIED",
OperationType::ExportEntities => "EXPORT_ENTITIES",
OperationType::ImportEntities => "IMPORT_ENTITIES",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"EXPORT_ENTITIES" => Some(Self::ExportEntities),
"IMPORT_ENTITIES" => Some(Self::ImportEntities),
_ => None,
}
}
}
/// Generated client implementations.
pub mod datastore_admin_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Google Cloud Datastore Admin API
///
/// The Datastore Admin API provides several admin services for Cloud Datastore.
///
/// -----------------------------------------------------------------------------
/// ## Concepts
///
/// Project, namespace, kind, and entity as defined in the Google Cloud Datastore
/// API.
///
/// Operation: An Operation represents work being performed in the background.
///
/// EntityFilter: Allows specifying a subset of entities in a project. This is
/// specified as a combination of kinds and namespaces (either or both of which
/// may be all).
///
/// -----------------------------------------------------------------------------
/// ## Services
///
/// # Export/Import
///
/// The Export/Import service provides the ability to copy all or a subset of
/// entities to/from Google Cloud Storage.
///
/// Exported data may be imported into Cloud Datastore for any Google Cloud
/// Platform project. It is not restricted to the export source project. It is
/// possible to export from one project and then import into another.
///
/// Exported data can also be loaded into Google BigQuery for analysis.
///
/// Exports and imports are performed asynchronously. An Operation resource is
/// created for each export/import. The state (including any errors encountered)
/// of the export/import may be queried via the Operation resource.
///
/// # Operation
///
/// The Operations collection provides a record of actions performed for the
/// specified project (including any operations in progress). Operations are not
/// created directly but through calls on other collections or resources.
///
/// An operation that is not yet done may be cancelled. The request to cancel is
/// asynchronous and the operation may continue to run for some time after the
/// request to cancel is made.
///
/// An operation that is done may be deleted so that it is no longer listed as
/// part of the Operation collection.
///
/// ListOperations returns all pending operations, but not completed operations.
///
/// Operations are created by service DatastoreAdmin,
/// but are accessed via service google.longrunning.Operations.
#[derive(Debug, Clone)]
pub struct DatastoreAdminClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DatastoreAdminClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DatastoreAdminClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DatastoreAdminClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Exports a copy of all or a subset of entities from Google Cloud Datastore
/// to another storage system, such as Google Cloud Storage. Recent updates to
/// entities may not be reflected in the export. The export occurs in the
/// background and its progress can be monitored and managed via the
/// Operation resource that is created. The output of an export may only be
/// used once the associated operation is done. If an export operation is
/// cancelled before completion it may leave partial data behind in Google
/// Cloud Storage.
pub async fn export_entities(&mut self, request: impl tonic::IntoRequest<super::ExportEntitiesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1beta1.DatastoreAdmin/ExportEntities");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1beta1.DatastoreAdmin", "ExportEntities"));
self.inner.unary(req, path, codec).await
}
/// Imports entities into Google Cloud Datastore. Existing entities with the
/// same key are overwritten. The import occurs in the background and its
/// progress can be monitored and managed via the Operation resource that is
/// created. If an ImportEntities operation is cancelled, it is possible
/// that a subset of the data has already been imported to Cloud Datastore.
pub async fn import_entities(&mut self, request: impl tonic::IntoRequest<super::ImportEntitiesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1beta1.DatastoreAdmin/ImportEntities");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1beta1.DatastoreAdmin", "ImportEntities"));
self.inner.unary(req, path, codec).await
}
}
}
