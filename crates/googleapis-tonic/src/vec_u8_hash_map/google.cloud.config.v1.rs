// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deployment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "deployment::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "7")]
    pub latest_revision: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub state_detail: ::prost::alloc::string::String,
    #[prost(enumeration = "deployment::ErrorCode", tag = "10")]
    pub error_code: i32,
    #[prost(message, optional, tag = "8")]
    pub delete_results: ::core::option::Option<ApplyResults>,
    #[prost(string, tag = "11")]
    pub delete_build: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub delete_logs: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "13")]
    pub tf_errors: ::prost::alloc::vec::Vec<TerraformError>,
    #[prost(string, tag = "14")]
    pub error_logs: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "15")]
    pub artifacts_gcs_bucket: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "16")]
    pub service_account: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "17")]
    pub import_existing_resources: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "19")]
    pub worker_pool: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "deployment::LockState", tag = "20")]
    pub lock_state: i32,
    #[prost(string, optional, tag = "21")]
    pub tf_version_constraint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "22")]
    pub tf_version: ::prost::alloc::string::String,
    #[prost(enumeration = "QuotaValidation", tag = "23")]
    pub quota_validation: i32,
    #[prost(map = "string, string", tag = "24")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "deployment::Blueprint", tags = "6")]
    pub blueprint: ::core::option::Option<deployment::Blueprint>,
}
/// Nested message and enum types in `Deployment`.
pub mod deployment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Updating = 3,
        Deleting = 4,
        Failed = 5,
        Suspended = 6,
        Deleted = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
                State::Suspended => "SUSPENDED",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "SUSPENDED" => Some(Self::Suspended),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        Unspecified = 0,
        RevisionFailed = 1,
        CloudBuildPermissionDenied = 3,
        DeleteBuildApiFailed = 5,
        DeleteBuildRunFailed = 6,
        BucketCreationPermissionDenied = 7,
        BucketCreationFailed = 8,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorCode::Unspecified => "ERROR_CODE_UNSPECIFIED",
                ErrorCode::RevisionFailed => "REVISION_FAILED",
                ErrorCode::CloudBuildPermissionDenied => "CLOUD_BUILD_PERMISSION_DENIED",
                ErrorCode::DeleteBuildApiFailed => "DELETE_BUILD_API_FAILED",
                ErrorCode::DeleteBuildRunFailed => "DELETE_BUILD_RUN_FAILED",
                ErrorCode::BucketCreationPermissionDenied => {
                    "BUCKET_CREATION_PERMISSION_DENIED"
                }
                ErrorCode::BucketCreationFailed => "BUCKET_CREATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "REVISION_FAILED" => Some(Self::RevisionFailed),
                "CLOUD_BUILD_PERMISSION_DENIED" => Some(Self::CloudBuildPermissionDenied),
                "DELETE_BUILD_API_FAILED" => Some(Self::DeleteBuildApiFailed),
                "DELETE_BUILD_RUN_FAILED" => Some(Self::DeleteBuildRunFailed),
                "BUCKET_CREATION_PERMISSION_DENIED" => {
                    Some(Self::BucketCreationPermissionDenied)
                }
                "BUCKET_CREATION_FAILED" => Some(Self::BucketCreationFailed),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LockState {
        Unspecified = 0,
        Locked = 1,
        Unlocked = 2,
        Locking = 3,
        Unlocking = 4,
        LockFailed = 5,
        UnlockFailed = 6,
    }
    impl LockState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LockState::Unspecified => "LOCK_STATE_UNSPECIFIED",
                LockState::Locked => "LOCKED",
                LockState::Unlocked => "UNLOCKED",
                LockState::Locking => "LOCKING",
                LockState::Unlocking => "UNLOCKING",
                LockState::LockFailed => "LOCK_FAILED",
                LockState::UnlockFailed => "UNLOCK_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "LOCKED" => Some(Self::Locked),
                "UNLOCKED" => Some(Self::Unlocked),
                "LOCKING" => Some(Self::Locking),
                "UNLOCKING" => Some(Self::Unlocking),
                "LOCK_FAILED" => Some(Self::LockFailed),
                "UNLOCK_FAILED" => Some(Self::UnlockFailed),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Blueprint {
        #[prost(message, tag = "6")]
        TerraformBlueprint(super::TerraformBlueprint),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformBlueprint {
    #[prost(map = "string, message", tag = "4")]
    pub input_values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TerraformVariable,
    >,
    #[prost(oneof = "terraform_blueprint::Source", tags = "1, 2")]
    pub source: ::core::option::Option<terraform_blueprint::Source>,
}
/// Nested message and enum types in `TerraformBlueprint`.
pub mod terraform_blueprint {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(string, tag = "1")]
        GcsSource(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        GitSource(super::GitSource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformVariable {
    #[prost(message, optional, tag = "5")]
    pub input_value: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyResults {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub artifacts: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "3")]
    pub outputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TerraformOutput,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformOutput {
    #[prost(bool, tag = "1")]
    pub sensitive: bool,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRevisionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub revisions: ::prost::alloc::vec::Vec<Revision>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRevisionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub deployment: ::core::option::Option<Deployment>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub deployment: ::core::option::Option<Deployment>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
    #[prost(enumeration = "delete_deployment_request::DeletePolicy", tag = "4")]
    pub delete_policy: i32,
}
/// Nested message and enum types in `DeleteDeploymentRequest`.
pub mod delete_deployment_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeletePolicy {
        Unspecified = 0,
        Delete = 1,
        Abandon = 2,
    }
    impl DeletePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeletePolicy::Unspecified => "DELETE_POLICY_UNSPECIFIED",
                DeletePolicy::Delete => "DELETE",
                DeletePolicy::Abandon => "ABANDON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DELETE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "DELETE" => Some(Self::Delete),
                "ABANDON" => Some(Self::Abandon),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
    #[prost(oneof = "operation_metadata::ResourceMetadata", tags = "8, 9")]
    pub resource_metadata: ::core::option::Option<operation_metadata::ResourceMetadata>,
}
/// Nested message and enum types in `OperationMetadata`.
pub mod operation_metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResourceMetadata {
        #[prost(message, tag = "8")]
        DeploymentMetadata(super::DeploymentOperationMetadata),
        #[prost(message, tag = "9")]
        PreviewMetadata(super::PreviewOperationMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Revision {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "revision::Action", tag = "4")]
    pub action: i32,
    #[prost(enumeration = "revision::State", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "7")]
    pub apply_results: ::core::option::Option<ApplyResults>,
    #[prost(string, tag = "8")]
    pub state_detail: ::prost::alloc::string::String,
    #[prost(enumeration = "revision::ErrorCode", tag = "9")]
    pub error_code: i32,
    #[prost(string, tag = "10")]
    pub build: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub logs: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "12")]
    pub tf_errors: ::prost::alloc::vec::Vec<TerraformError>,
    #[prost(string, tag = "13")]
    pub error_logs: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(bool, tag = "15")]
    pub import_existing_resources: bool,
    #[prost(string, tag = "17")]
    pub worker_pool: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub tf_version_constraint: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub tf_version: ::prost::alloc::string::String,
    #[prost(string, tag = "29")]
    pub quota_validation_results: ::prost::alloc::string::String,
    #[prost(enumeration = "QuotaValidation", tag = "20")]
    pub quota_validation: i32,
    #[prost(oneof = "revision::Blueprint", tags = "6")]
    pub blueprint: ::core::option::Option<revision::Blueprint>,
}
/// Nested message and enum types in `Revision`.
pub mod revision {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Unspecified = 0,
        Create = 1,
        Update = 2,
        Delete = 3,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Unspecified => "ACTION_UNSPECIFIED",
                Action::Create => "CREATE",
                Action::Update => "UPDATE",
                Action::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Applying = 1,
        Applied = 2,
        Failed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Applying => "APPLYING",
                State::Applied => "APPLIED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "APPLYING" => Some(Self::Applying),
                "APPLIED" => Some(Self::Applied),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        Unspecified = 0,
        CloudBuildPermissionDenied = 1,
        ApplyBuildApiFailed = 4,
        ApplyBuildRunFailed = 5,
        QuotaValidationFailed = 7,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorCode::Unspecified => "ERROR_CODE_UNSPECIFIED",
                ErrorCode::CloudBuildPermissionDenied => "CLOUD_BUILD_PERMISSION_DENIED",
                ErrorCode::ApplyBuildApiFailed => "APPLY_BUILD_API_FAILED",
                ErrorCode::ApplyBuildRunFailed => "APPLY_BUILD_RUN_FAILED",
                ErrorCode::QuotaValidationFailed => "QUOTA_VALIDATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_PERMISSION_DENIED" => Some(Self::CloudBuildPermissionDenied),
                "APPLY_BUILD_API_FAILED" => Some(Self::ApplyBuildApiFailed),
                "APPLY_BUILD_RUN_FAILED" => Some(Self::ApplyBuildRunFailed),
                "QUOTA_VALIDATION_FAILED" => Some(Self::QuotaValidationFailed),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Blueprint {
        #[prost(message, tag = "6")]
        TerraformBlueprint(super::TerraformBlueprint),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformError {
    #[prost(string, tag = "1")]
    pub resource_address: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub http_response_code: i32,
    #[prost(string, tag = "3")]
    pub error_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitSource {
    #[prost(string, optional, tag = "1")]
    pub repo: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub directory: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub r#ref: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentOperationMetadata {
    #[prost(enumeration = "deployment_operation_metadata::DeploymentStep", tag = "1")]
    pub step: i32,
    #[prost(message, optional, tag = "2")]
    pub apply_results: ::core::option::Option<ApplyResults>,
    #[prost(string, tag = "3")]
    pub build: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub logs: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DeploymentOperationMetadata`.
pub mod deployment_operation_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeploymentStep {
        Unspecified = 0,
        PreparingStorageBucket = 1,
        DownloadingBlueprint = 2,
        RunningTfInit = 3,
        RunningTfPlan = 4,
        RunningTfApply = 5,
        RunningTfDestroy = 6,
        RunningTfValidate = 7,
        UnlockingDeployment = 8,
        Succeeded = 9,
        Failed = 10,
        ValidatingRepository = 11,
        RunningQuotaValidation = 12,
    }
    impl DeploymentStep {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeploymentStep::Unspecified => "DEPLOYMENT_STEP_UNSPECIFIED",
                DeploymentStep::PreparingStorageBucket => "PREPARING_STORAGE_BUCKET",
                DeploymentStep::DownloadingBlueprint => "DOWNLOADING_BLUEPRINT",
                DeploymentStep::RunningTfInit => "RUNNING_TF_INIT",
                DeploymentStep::RunningTfPlan => "RUNNING_TF_PLAN",
                DeploymentStep::RunningTfApply => "RUNNING_TF_APPLY",
                DeploymentStep::RunningTfDestroy => "RUNNING_TF_DESTROY",
                DeploymentStep::RunningTfValidate => "RUNNING_TF_VALIDATE",
                DeploymentStep::UnlockingDeployment => "UNLOCKING_DEPLOYMENT",
                DeploymentStep::Succeeded => "SUCCEEDED",
                DeploymentStep::Failed => "FAILED",
                DeploymentStep::ValidatingRepository => "VALIDATING_REPOSITORY",
                DeploymentStep::RunningQuotaValidation => "RUNNING_QUOTA_VALIDATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEPLOYMENT_STEP_UNSPECIFIED" => Some(Self::Unspecified),
                "PREPARING_STORAGE_BUCKET" => Some(Self::PreparingStorageBucket),
                "DOWNLOADING_BLUEPRINT" => Some(Self::DownloadingBlueprint),
                "RUNNING_TF_INIT" => Some(Self::RunningTfInit),
                "RUNNING_TF_PLAN" => Some(Self::RunningTfPlan),
                "RUNNING_TF_APPLY" => Some(Self::RunningTfApply),
                "RUNNING_TF_DESTROY" => Some(Self::RunningTfDestroy),
                "RUNNING_TF_VALIDATE" => Some(Self::RunningTfValidate),
                "UNLOCKING_DEPLOYMENT" => Some(Self::UnlockingDeployment),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "VALIDATING_REPOSITORY" => Some(Self::ValidatingRepository),
                "RUNNING_QUOTA_VALIDATION" => Some(Self::RunningQuotaValidation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub terraform_info: ::core::option::Option<ResourceTerraformInfo>,
    #[prost(map = "string, message", tag = "3")]
    pub cai_assets: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ResourceCaiInfo,
    >,
    #[prost(enumeration = "resource::Intent", tag = "4")]
    pub intent: i32,
    #[prost(enumeration = "resource::State", tag = "5")]
    pub state: i32,
}
/// Nested message and enum types in `Resource`.
pub mod resource {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Intent {
        Unspecified = 0,
        Create = 1,
        Update = 2,
        Delete = 3,
        Recreate = 4,
        Unchanged = 5,
    }
    impl Intent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Intent::Unspecified => "INTENT_UNSPECIFIED",
                Intent::Create => "CREATE",
                Intent::Update => "UPDATE",
                Intent::Delete => "DELETE",
                Intent::Recreate => "RECREATE",
                Intent::Unchanged => "UNCHANGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INTENT_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                "RECREATE" => Some(Self::Recreate),
                "UNCHANGED" => Some(Self::Unchanged),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Planned = 1,
        InProgress = 2,
        Reconciled = 3,
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Planned => "PLANNED",
                State::InProgress => "IN_PROGRESS",
                State::Reconciled => "RECONCILED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PLANNED" => Some(Self::Planned),
                "IN_PROGRESS" => Some(Self::InProgress),
                "RECONCILED" => Some(Self::Reconciled),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceTerraformInfo {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCaiInfo {
    #[prost(string, tag = "1")]
    pub full_resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetResourceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourcesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<Resource>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Statefile {
    #[prost(string, tag = "1")]
    pub signed_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDeploymentStatefileRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub draft: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportRevisionStatefileRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportStatefileRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub lock_id: i64,
    #[prost(bool, tag = "3")]
    pub skip_draft: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStatefileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub lock_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub lock_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportLockInfoRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockInfo {
    #[prost(int64, tag = "1")]
    pub lock_id: i64,
    #[prost(string, tag = "2")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub info: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub who: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Preview {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "preview::State", tag = "4")]
    pub state: i32,
    #[prost(string, tag = "5")]
    pub deployment: ::prost::alloc::string::String,
    #[prost(enumeration = "preview::PreviewMode", tag = "15")]
    pub preview_mode: i32,
    #[prost(string, tag = "7")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "8")]
    pub artifacts_gcs_bucket: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub worker_pool: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "preview::ErrorCode", tag = "10")]
    pub error_code: i32,
    #[prost(message, optional, tag = "11")]
    pub error_status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(string, tag = "12")]
    pub build: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "13")]
    pub tf_errors: ::prost::alloc::vec::Vec<TerraformError>,
    #[prost(string, tag = "14")]
    pub error_logs: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub preview_artifacts: ::core::option::Option<PreviewArtifacts>,
    #[prost(string, tag = "17")]
    pub logs: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub tf_version: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "19")]
    pub tf_version_constraint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "preview::Blueprint", tags = "6")]
    pub blueprint: ::core::option::Option<preview::Blueprint>,
}
/// Nested message and enum types in `Preview`.
pub mod preview {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Succeeded = 2,
        Applying = 3,
        Stale = 4,
        Deleting = 5,
        Failed = 6,
        Deleted = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Succeeded => "SUCCEEDED",
                State::Applying => "APPLYING",
                State::Stale => "STALE",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "SUCCEEDED" => Some(Self::Succeeded),
                "APPLYING" => Some(Self::Applying),
                "STALE" => Some(Self::Stale),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PreviewMode {
        Unspecified = 0,
        Default = 1,
        Delete = 2,
    }
    impl PreviewMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PreviewMode::Unspecified => "PREVIEW_MODE_UNSPECIFIED",
                PreviewMode::Default => "DEFAULT",
                PreviewMode::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREVIEW_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DEFAULT" => Some(Self::Default),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        Unspecified = 0,
        CloudBuildPermissionDenied = 1,
        BucketCreationPermissionDenied = 2,
        BucketCreationFailed = 3,
        DeploymentLockAcquireFailed = 4,
        PreviewBuildApiFailed = 5,
        PreviewBuildRunFailed = 6,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorCode::Unspecified => "ERROR_CODE_UNSPECIFIED",
                ErrorCode::CloudBuildPermissionDenied => "CLOUD_BUILD_PERMISSION_DENIED",
                ErrorCode::BucketCreationPermissionDenied => {
                    "BUCKET_CREATION_PERMISSION_DENIED"
                }
                ErrorCode::BucketCreationFailed => "BUCKET_CREATION_FAILED",
                ErrorCode::DeploymentLockAcquireFailed => {
                    "DEPLOYMENT_LOCK_ACQUIRE_FAILED"
                }
                ErrorCode::PreviewBuildApiFailed => "PREVIEW_BUILD_API_FAILED",
                ErrorCode::PreviewBuildRunFailed => "PREVIEW_BUILD_RUN_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_PERMISSION_DENIED" => Some(Self::CloudBuildPermissionDenied),
                "BUCKET_CREATION_PERMISSION_DENIED" => {
                    Some(Self::BucketCreationPermissionDenied)
                }
                "BUCKET_CREATION_FAILED" => Some(Self::BucketCreationFailed),
                "DEPLOYMENT_LOCK_ACQUIRE_FAILED" => {
                    Some(Self::DeploymentLockAcquireFailed)
                }
                "PREVIEW_BUILD_API_FAILED" => Some(Self::PreviewBuildApiFailed),
                "PREVIEW_BUILD_RUN_FAILED" => Some(Self::PreviewBuildRunFailed),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Blueprint {
        #[prost(message, tag = "6")]
        TerraformBlueprint(super::TerraformBlueprint),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewOperationMetadata {
    #[prost(enumeration = "preview_operation_metadata::PreviewStep", tag = "1")]
    pub step: i32,
    #[prost(message, optional, tag = "2")]
    pub preview_artifacts: ::core::option::Option<PreviewArtifacts>,
    #[prost(string, tag = "3")]
    pub logs: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub build: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PreviewOperationMetadata`.
pub mod preview_operation_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PreviewStep {
        Unspecified = 0,
        PreparingStorageBucket = 1,
        DownloadingBlueprint = 2,
        RunningTfInit = 3,
        RunningTfPlan = 4,
        FetchingDeployment = 5,
        LockingDeployment = 6,
        UnlockingDeployment = 7,
        Succeeded = 8,
        Failed = 9,
        ValidatingRepository = 10,
    }
    impl PreviewStep {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PreviewStep::Unspecified => "PREVIEW_STEP_UNSPECIFIED",
                PreviewStep::PreparingStorageBucket => "PREPARING_STORAGE_BUCKET",
                PreviewStep::DownloadingBlueprint => "DOWNLOADING_BLUEPRINT",
                PreviewStep::RunningTfInit => "RUNNING_TF_INIT",
                PreviewStep::RunningTfPlan => "RUNNING_TF_PLAN",
                PreviewStep::FetchingDeployment => "FETCHING_DEPLOYMENT",
                PreviewStep::LockingDeployment => "LOCKING_DEPLOYMENT",
                PreviewStep::UnlockingDeployment => "UNLOCKING_DEPLOYMENT",
                PreviewStep::Succeeded => "SUCCEEDED",
                PreviewStep::Failed => "FAILED",
                PreviewStep::ValidatingRepository => "VALIDATING_REPOSITORY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREVIEW_STEP_UNSPECIFIED" => Some(Self::Unspecified),
                "PREPARING_STORAGE_BUCKET" => Some(Self::PreparingStorageBucket),
                "DOWNLOADING_BLUEPRINT" => Some(Self::DownloadingBlueprint),
                "RUNNING_TF_INIT" => Some(Self::RunningTfInit),
                "RUNNING_TF_PLAN" => Some(Self::RunningTfPlan),
                "FETCHING_DEPLOYMENT" => Some(Self::FetchingDeployment),
                "LOCKING_DEPLOYMENT" => Some(Self::LockingDeployment),
                "UNLOCKING_DEPLOYMENT" => Some(Self::UnlockingDeployment),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "VALIDATING_REPOSITORY" => Some(Self::ValidatingRepository),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewArtifacts {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub artifacts: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePreviewRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub preview_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub preview: ::core::option::Option<Preview>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreviewRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPreviewsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPreviewsResponse {
    #[prost(message, repeated, tag = "1")]
    pub previews: ::prost::alloc::vec::Vec<Preview>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePreviewRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportPreviewResultRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportPreviewResultResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<PreviewResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewResult {
    #[prost(string, tag = "1")]
    pub binary_signed_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub json_signed_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTerraformVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTerraformVersionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTerraformVersionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub terraform_versions: ::prost::alloc::vec::Vec<TerraformVersion>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformVersion {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "terraform_version::State", tag = "2")]
    pub state: i32,
    #[prost(message, optional, tag = "3")]
    pub support_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub deprecate_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub obsolete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TerraformVersion`.
pub mod terraform_version {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Deprecated = 2,
        Obsolete = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Deprecated => "DEPRECATED",
                State::Obsolete => "OBSOLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "DEPRECATED" => Some(Self::Deprecated),
                "OBSOLETE" => Some(Self::Obsolete),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QuotaValidation {
    Unspecified = 0,
    Enabled = 1,
    Enforced = 2,
}
impl QuotaValidation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            QuotaValidation::Unspecified => "QUOTA_VALIDATION_UNSPECIFIED",
            QuotaValidation::Enabled => "ENABLED",
            QuotaValidation::Enforced => "ENFORCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUOTA_VALIDATION_UNSPECIFIED" => Some(Self::Unspecified),
            "ENABLED" => Some(Self::Enabled),
            "ENFORCED" => Some(Self::Enforced),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod config_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Infrastructure Manager is a managed service that automates the deployment and
    /// management of Google Cloud infrastructure resources.
    #[derive(Debug, Clone)]
    pub struct ConfigClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ConfigClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConfigClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ConfigClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists \[Deployment\]\[google.cloud.config.v1.Deployment\]s in a given project
        /// and location.
        pub async fn list_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ListDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "ListDeployments"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a \[Deployment\]\[google.cloud.config.v1.Deployment\].
        pub async fn get_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/GetDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "GetDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[Deployment\]\[google.cloud.config.v1.Deployment\].
        pub async fn create_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/CreateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "CreateDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[Deployment\]\[google.cloud.config.v1.Deployment\].
        pub async fn update_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/UpdateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "UpdateDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Deployment\]\[google.cloud.config.v1.Deployment\].
        pub async fn delete_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/DeleteDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "DeleteDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists \[Revision\]\[google.cloud.config.v1.Revision\]s of a deployment.
        pub async fn list_revisions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRevisionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ListRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "ListRevisions"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a \[Revision\]\[google.cloud.config.v1.Revision\].
        pub async fn get_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRevisionRequest>,
        ) -> std::result::Result<tonic::Response<super::Revision>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/GetRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.config.v1.Config", "GetRevision"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a \[Resource\]\[google.cloud.config.v1.Resource\] deployed
        /// by Infra Manager.
        pub async fn get_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::GetResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::Resource>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/GetResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.config.v1.Config", "GetResource"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists \[Resource\]\[google.cloud.config.v1.Resource\]s in a given revision.
        pub async fn list_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListResourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ListResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "ListResources"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports Terraform state file from a given deployment.
        pub async fn export_deployment_statefile(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportDeploymentStatefileRequest>,
        ) -> std::result::Result<tonic::Response<super::Statefile>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ExportDeploymentStatefile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.config.v1.Config",
                        "ExportDeploymentStatefile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports Terraform state file from a given revision.
        pub async fn export_revision_statefile(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportRevisionStatefileRequest>,
        ) -> std::result::Result<tonic::Response<super::Statefile>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ExportRevisionStatefile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.config.v1.Config",
                        "ExportRevisionStatefile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports Terraform state file in a given deployment. The state file does not
        /// take effect until the Deployment has been unlocked.
        pub async fn import_statefile(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportStatefileRequest>,
        ) -> std::result::Result<tonic::Response<super::Statefile>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ImportStatefile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "ImportStatefile"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes Terraform state file in a given deployment.
        pub async fn delete_statefile(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteStatefileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/DeleteStatefile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "DeleteStatefile"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Locks a deployment.
        pub async fn lock_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::LockDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/LockDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "LockDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Unlocks a locked deployment.
        pub async fn unlock_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/UnlockDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "UnlockDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports the lock info on a locked deployment.
        pub async fn export_lock_info(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportLockInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::LockInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ExportLockInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "ExportLockInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[Preview\]\[google.cloud.config.v1.Preview\].
        pub async fn create_preview(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePreviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/CreatePreview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "CreatePreview"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a \[Preview\]\[google.cloud.config.v1.Preview\].
        pub async fn get_preview(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPreviewRequest>,
        ) -> std::result::Result<tonic::Response<super::Preview>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/GetPreview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.config.v1.Config", "GetPreview"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists \[Preview\]\[google.cloud.config.v1.Preview\]s in a given project and
        /// location.
        pub async fn list_previews(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPreviewsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPreviewsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ListPreviews",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "ListPreviews"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Preview\]\[google.cloud.config.v1.Preview\].
        pub async fn delete_preview(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePreviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/DeletePreview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.config.v1.Config", "DeletePreview"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export \[Preview\]\[google.cloud.config.v1.Preview\] results.
        pub async fn export_preview_result(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportPreviewResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExportPreviewResultResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ExportPreviewResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.config.v1.Config",
                        "ExportPreviewResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists \[TerraformVersion\]\[google.cloud.config.v1.TerraformVersion\]s in a
        /// given project and location.
        pub async fn list_terraform_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTerraformVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTerraformVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/ListTerraformVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.config.v1.Config",
                        "ListTerraformVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a
        /// \[TerraformVersion\]\[google.cloud.config.v1.TerraformVersion\].
        pub async fn get_terraform_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTerraformVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerraformVersion>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.config.v1.Config/GetTerraformVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.config.v1.Config",
                        "GetTerraformVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
