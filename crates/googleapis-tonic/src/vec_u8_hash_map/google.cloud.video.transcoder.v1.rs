// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub input_uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub output_uri: ::prost::alloc::string::String,
#[prost(enumeration = "job::ProcessingState", tag = "8")]
pub state: i32,
#[prost(message, optional, tag = "12")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "13")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "14")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int32, tag = "15")]
pub ttl_after_completion_days: i32,
#[prost(map = "string, string", tag = "16")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "17")]
pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(enumeration = "job::ProcessingMode", tag = "20")]
pub mode: i32,
#[prost(int32, tag = "21")]
pub batch_mode_priority: i32,
#[prost(enumeration = "job::OptimizationStrategy", tag = "22")]
pub optimization: i32,
#[prost(oneof = "job::JobConfig", tags = "4, 5")]
pub job_config: ::core::option::Option<job::JobConfig>,
}
/// Nested message and enum types in `Job`.
pub mod job {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessingState {
Unspecified = 0,
Pending = 1,
Running = 2,
Succeeded = 3,
Failed = 4,
}
impl ProcessingState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ProcessingState::Unspecified => "PROCESSING_STATE_UNSPECIFIED",
ProcessingState::Pending => "PENDING",
ProcessingState::Running => "RUNNING",
ProcessingState::Succeeded => "SUCCEEDED",
ProcessingState::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PROCESSING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessingMode {
Unspecified = 0,
Interactive = 1,
Batch = 2,
}
impl ProcessingMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ProcessingMode::Unspecified => "PROCESSING_MODE_UNSPECIFIED",
ProcessingMode::Interactive => "PROCESSING_MODE_INTERACTIVE",
ProcessingMode::Batch => "PROCESSING_MODE_BATCH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PROCESSING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"PROCESSING_MODE_INTERACTIVE" => Some(Self::Interactive),
"PROCESSING_MODE_BATCH" => Some(Self::Batch),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptimizationStrategy {
Unspecified = 0,
Autodetect = 1,
Disabled = 2,
}
impl OptimizationStrategy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OptimizationStrategy::Unspecified => "OPTIMIZATION_STRATEGY_UNSPECIFIED",
OptimizationStrategy::Autodetect => "AUTODETECT",
OptimizationStrategy::Disabled => "DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPTIMIZATION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
"AUTODETECT" => Some(Self::Autodetect),
"DISABLED" => Some(Self::Disabled),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum JobConfig {
#[prost(string, tag = "4")]
TemplateId(::prost::alloc::string::String),
#[prost(message, tag = "5")]
Config(super::JobConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobTemplate {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub config: ::core::option::Option<JobConfig>,
#[prost(map = "string, string", tag = "3")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobConfig {
#[prost(message, repeated, tag = "1")]
pub inputs: ::prost::alloc::vec::Vec<Input>,
#[prost(message, repeated, tag = "2")]
pub edit_list: ::prost::alloc::vec::Vec<EditAtom>,
#[prost(message, repeated, tag = "3")]
pub elementary_streams: ::prost::alloc::vec::Vec<ElementaryStream>,
#[prost(message, repeated, tag = "4")]
pub mux_streams: ::prost::alloc::vec::Vec<MuxStream>,
#[prost(message, repeated, tag = "5")]
pub manifests: ::prost::alloc::vec::Vec<Manifest>,
#[prost(message, optional, tag = "6")]
pub output: ::core::option::Option<Output>,
#[prost(message, repeated, tag = "7")]
pub ad_breaks: ::prost::alloc::vec::Vec<AdBreak>,
#[prost(message, optional, tag = "8")]
pub pubsub_destination: ::core::option::Option<PubsubDestination>,
#[prost(message, repeated, tag = "9")]
pub sprite_sheets: ::prost::alloc::vec::Vec<SpriteSheet>,
#[prost(message, repeated, tag = "10")]
pub overlays: ::prost::alloc::vec::Vec<Overlay>,
#[prost(message, repeated, tag = "11")]
pub encryptions: ::prost::alloc::vec::Vec<Encryption>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub preprocessing_config: ::core::option::Option<PreprocessingConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditAtom {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub inputs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "4")]
pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdBreak {
#[prost(message, optional, tag = "1")]
pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElementaryStream {
#[prost(string, tag = "4")]
pub key: ::prost::alloc::string::String,
#[prost(oneof = "elementary_stream::ElementaryStream", tags = "1, 2, 3")]
pub elementary_stream: ::core::option::Option<elementary_stream::ElementaryStream>,
}
/// Nested message and enum types in `ElementaryStream`.
pub mod elementary_stream {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ElementaryStream {
#[prost(message, tag = "1")]
VideoStream(super::VideoStream),
#[prost(message, tag = "2")]
AudioStream(super::AudioStream),
#[prost(message, tag = "3")]
TextStream(super::TextStream),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuxStream {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub file_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub container: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub elementary_streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "5")]
pub segment_settings: ::core::option::Option<SegmentSettings>,
#[prost(string, tag = "7")]
pub encryption_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
#[prost(string, tag = "1")]
pub file_name: ::prost::alloc::string::String,
#[prost(enumeration = "manifest::ManifestType", tag = "2")]
pub r#type: i32,
#[prost(string, repeated, tag = "3")]
pub mux_streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(oneof = "manifest::ManifestConfig", tags = "4")]
pub manifest_config: ::core::option::Option<manifest::ManifestConfig>,
}
/// Nested message and enum types in `Manifest`.
pub mod manifest {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DashConfig {
#[prost(enumeration = "dash_config::SegmentReferenceScheme", tag = "1")]
pub segment_reference_scheme: i32,
}
/// Nested message and enum types in `DashConfig`.
pub mod dash_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SegmentReferenceScheme {
Unspecified = 0,
SegmentList = 1,
SegmentTemplateNumber = 2,
}
impl SegmentReferenceScheme {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SegmentReferenceScheme::Unspecified => "SEGMENT_REFERENCE_SCHEME_UNSPECIFIED",
SegmentReferenceScheme::SegmentList => "SEGMENT_LIST",
SegmentReferenceScheme::SegmentTemplateNumber => "SEGMENT_TEMPLATE_NUMBER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEGMENT_REFERENCE_SCHEME_UNSPECIFIED" => Some(Self::Unspecified),
"SEGMENT_LIST" => Some(Self::SegmentList),
"SEGMENT_TEMPLATE_NUMBER" => Some(Self::SegmentTemplateNumber),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ManifestType {
Unspecified = 0,
Hls = 1,
Dash = 2,
}
impl ManifestType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ManifestType::Unspecified => "MANIFEST_TYPE_UNSPECIFIED",
ManifestType::Hls => "HLS",
ManifestType::Dash => "DASH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MANIFEST_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"HLS" => Some(Self::Hls),
"DASH" => Some(Self::Dash),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum ManifestConfig {
#[prost(message, tag = "4")]
Dash(DashConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubDestination {
#[prost(string, tag = "1")]
pub topic: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpriteSheet {
#[prost(string, tag = "1")]
pub format: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub file_prefix: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub sprite_width_pixels: i32,
#[prost(int32, tag = "4")]
pub sprite_height_pixels: i32,
#[prost(int32, tag = "5")]
pub column_count: i32,
#[prost(int32, tag = "6")]
pub row_count: i32,
#[prost(message, optional, tag = "7")]
pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "8")]
pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
#[prost(int32, tag = "11")]
pub quality: i32,
#[prost(oneof = "sprite_sheet::ExtractionStrategy", tags = "9, 10")]
pub extraction_strategy: ::core::option::Option<sprite_sheet::ExtractionStrategy>,
}
/// Nested message and enum types in `SpriteSheet`.
pub mod sprite_sheet {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum ExtractionStrategy {
#[prost(int32, tag = "9")]
TotalCount(i32),
#[prost(message, tag = "10")]
Interval(::prost_types::Duration),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Overlay {
#[prost(message, optional, tag = "1")]
pub image: ::core::option::Option<overlay::Image>,
#[prost(message, repeated, tag = "2")]
pub animations: ::prost::alloc::vec::Vec<overlay::Animation>,
}
/// Nested message and enum types in `Overlay`.
pub mod overlay {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedCoordinate {
#[prost(double, tag = "1")]
pub x: f64,
#[prost(double, tag = "2")]
pub y: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub resolution: ::core::option::Option<NormalizedCoordinate>,
#[prost(double, tag = "3")]
pub alpha: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnimationStatic {
#[prost(message, optional, tag = "1")]
pub xy: ::core::option::Option<NormalizedCoordinate>,
#[prost(message, optional, tag = "2")]
pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnimationFade {
#[prost(enumeration = "FadeType", tag = "1")]
pub fade_type: i32,
#[prost(message, optional, tag = "2")]
pub xy: ::core::option::Option<NormalizedCoordinate>,
#[prost(message, optional, tag = "3")]
pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "4")]
pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnimationEnd {
#[prost(message, optional, tag = "1")]
pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Animation {
#[prost(oneof = "animation::AnimationType", tags = "1, 2, 3")]
pub animation_type: ::core::option::Option<animation::AnimationType>,
}
/// Nested message and enum types in `Animation`.
pub mod animation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum AnimationType {
#[prost(message, tag = "1")]
AnimationStatic(super::AnimationStatic),
#[prost(message, tag = "2")]
AnimationFade(super::AnimationFade),
#[prost(message, tag = "3")]
AnimationEnd(super::AnimationEnd),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FadeType {
Unspecified = 0,
FadeIn = 1,
FadeOut = 2,
}
impl FadeType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FadeType::Unspecified => "FADE_TYPE_UNSPECIFIED",
FadeType::FadeIn => "FADE_IN",
FadeType::FadeOut => "FADE_OUT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FADE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"FADE_IN" => Some(Self::FadeIn),
"FADE_OUT" => Some(Self::FadeOut),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreprocessingConfig {
#[prost(message, optional, tag = "1")]
pub color: ::core::option::Option<preprocessing_config::Color>,
#[prost(message, optional, tag = "2")]
pub denoise: ::core::option::Option<preprocessing_config::Denoise>,
#[prost(message, optional, tag = "3")]
pub deblock: ::core::option::Option<preprocessing_config::Deblock>,
#[prost(message, optional, tag = "4")]
pub audio: ::core::option::Option<preprocessing_config::Audio>,
#[prost(message, optional, tag = "5")]
pub crop: ::core::option::Option<preprocessing_config::Crop>,
#[prost(message, optional, tag = "6")]
pub pad: ::core::option::Option<preprocessing_config::Pad>,
#[prost(message, optional, tag = "7")]
pub deinterlace: ::core::option::Option<preprocessing_config::Deinterlace>,
}
/// Nested message and enum types in `PreprocessingConfig`.
pub mod preprocessing_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Color {
#[prost(double, tag = "1")]
pub saturation: f64,
#[prost(double, tag = "2")]
pub contrast: f64,
#[prost(double, tag = "3")]
pub brightness: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Denoise {
#[prost(double, tag = "1")]
pub strength: f64,
#[prost(string, tag = "2")]
pub tune: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Deblock {
#[prost(double, tag = "1")]
pub strength: f64,
#[prost(bool, tag = "2")]
pub enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Audio {
#[prost(double, tag = "1")]
pub lufs: f64,
#[prost(bool, tag = "2")]
pub high_boost: bool,
#[prost(bool, tag = "3")]
pub low_boost: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Crop {
#[prost(int32, tag = "1")]
pub top_pixels: i32,
#[prost(int32, tag = "2")]
pub bottom_pixels: i32,
#[prost(int32, tag = "3")]
pub left_pixels: i32,
#[prost(int32, tag = "4")]
pub right_pixels: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Pad {
#[prost(int32, tag = "1")]
pub top_pixels: i32,
#[prost(int32, tag = "2")]
pub bottom_pixels: i32,
#[prost(int32, tag = "3")]
pub left_pixels: i32,
#[prost(int32, tag = "4")]
pub right_pixels: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deinterlace {
#[prost(oneof = "deinterlace::DeinterlacingFilter", tags = "1, 2")]
pub deinterlacing_filter: ::core::option::Option<deinterlace::DeinterlacingFilter>,
}
/// Nested message and enum types in `Deinterlace`.
pub mod deinterlace {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YadifConfig {
#[prost(string, tag = "1")]
pub mode: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub disable_spatial_interlacing: bool,
#[prost(string, tag = "3")]
pub parity: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub deinterlace_all_frames: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BwdifConfig {
#[prost(string, tag = "1")]
pub mode: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub parity: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub deinterlace_all_frames: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DeinterlacingFilter {
#[prost(message, tag = "1")]
Yadif(YadifConfig),
#[prost(message, tag = "2")]
Bwdif(BwdifConfig),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoStream {
#[prost(oneof = "video_stream::CodecSettings", tags = "1, 2, 3")]
pub codec_settings: ::core::option::Option<video_stream::CodecSettings>,
}
/// Nested message and enum types in `VideoStream`.
pub mod video_stream {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct H264CodecSettings {
#[prost(int32, tag = "1")]
pub width_pixels: i32,
#[prost(int32, tag = "2")]
pub height_pixels: i32,
#[prost(double, tag = "3")]
pub frame_rate: f64,
#[prost(int32, tag = "4")]
pub bitrate_bps: i32,
#[prost(string, tag = "5")]
pub pixel_format: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub rate_control_mode: ::prost::alloc::string::String,
#[prost(int32, tag = "7")]
pub crf_level: i32,
#[prost(bool, tag = "8")]
pub allow_open_gop: bool,
#[prost(bool, tag = "11")]
pub enable_two_pass: bool,
#[prost(int32, tag = "12")]
pub vbv_size_bits: i32,
#[prost(int32, tag = "13")]
pub vbv_fullness_bits: i32,
#[prost(string, tag = "14")]
pub entropy_coder: ::prost::alloc::string::String,
#[prost(bool, tag = "15")]
pub b_pyramid: bool,
#[prost(int32, tag = "16")]
pub b_frame_count: i32,
#[prost(double, tag = "17")]
pub aq_strength: f64,
#[prost(string, tag = "18")]
pub profile: ::prost::alloc::string::String,
#[prost(string, tag = "19")]
pub tune: ::prost::alloc::string::String,
#[prost(string, tag = "20")]
pub preset: ::prost::alloc::string::String,
#[prost(oneof = "h264_codec_settings::GopMode", tags = "9, 10")]
pub gop_mode: ::core::option::Option<h264_codec_settings::GopMode>,
}
/// Nested message and enum types in `H264CodecSettings`.
pub mod h264_codec_settings {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum GopMode {
#[prost(int32, tag = "9")]
GopFrameCount(i32),
#[prost(message, tag = "10")]
GopDuration(::prost_types::Duration),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct H265CodecSettings {
#[prost(int32, tag = "1")]
pub width_pixels: i32,
#[prost(int32, tag = "2")]
pub height_pixels: i32,
#[prost(double, tag = "3")]
pub frame_rate: f64,
#[prost(int32, tag = "4")]
pub bitrate_bps: i32,
#[prost(string, tag = "5")]
pub pixel_format: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub rate_control_mode: ::prost::alloc::string::String,
#[prost(int32, tag = "7")]
pub crf_level: i32,
#[prost(bool, tag = "8")]
pub allow_open_gop: bool,
#[prost(bool, tag = "11")]
pub enable_two_pass: bool,
#[prost(int32, tag = "12")]
pub vbv_size_bits: i32,
#[prost(int32, tag = "13")]
pub vbv_fullness_bits: i32,
#[prost(bool, tag = "14")]
pub b_pyramid: bool,
#[prost(int32, tag = "15")]
pub b_frame_count: i32,
#[prost(double, tag = "16")]
pub aq_strength: f64,
#[prost(string, tag = "17")]
pub profile: ::prost::alloc::string::String,
#[prost(string, tag = "18")]
pub tune: ::prost::alloc::string::String,
#[prost(string, tag = "19")]
pub preset: ::prost::alloc::string::String,
#[prost(oneof = "h265_codec_settings::GopMode", tags = "9, 10")]
pub gop_mode: ::core::option::Option<h265_codec_settings::GopMode>,
}
/// Nested message and enum types in `H265CodecSettings`.
pub mod h265_codec_settings {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum GopMode {
#[prost(int32, tag = "9")]
GopFrameCount(i32),
#[prost(message, tag = "10")]
GopDuration(::prost_types::Duration),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vp9CodecSettings {
#[prost(int32, tag = "1")]
pub width_pixels: i32,
#[prost(int32, tag = "2")]
pub height_pixels: i32,
#[prost(double, tag = "3")]
pub frame_rate: f64,
#[prost(int32, tag = "4")]
pub bitrate_bps: i32,
#[prost(string, tag = "5")]
pub pixel_format: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub rate_control_mode: ::prost::alloc::string::String,
#[prost(int32, tag = "7")]
pub crf_level: i32,
#[prost(string, tag = "10")]
pub profile: ::prost::alloc::string::String,
#[prost(oneof = "vp9_codec_settings::GopMode", tags = "8, 9")]
pub gop_mode: ::core::option::Option<vp9_codec_settings::GopMode>,
}
/// Nested message and enum types in `Vp9CodecSettings`.
pub mod vp9_codec_settings {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum GopMode {
#[prost(int32, tag = "8")]
GopFrameCount(i32),
#[prost(message, tag = "9")]
GopDuration(::prost_types::Duration),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum CodecSettings {
#[prost(message, tag = "1")]
H264(H264CodecSettings),
#[prost(message, tag = "2")]
H265(H265CodecSettings),
#[prost(message, tag = "3")]
Vp9(Vp9CodecSettings),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioStream {
#[prost(string, tag = "1")]
pub codec: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub bitrate_bps: i32,
#[prost(int32, tag = "3")]
pub channel_count: i32,
#[prost(string, repeated, tag = "4")]
pub channel_layout: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "5")]
pub mapping: ::prost::alloc::vec::Vec<audio_stream::AudioMapping>,
#[prost(int32, tag = "6")]
pub sample_rate_hertz: i32,
#[prost(string, tag = "7")]
pub language_code: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AudioStream`.
pub mod audio_stream {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioMapping {
#[prost(string, tag = "1")]
pub atom_key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub input_key: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub input_track: i32,
#[prost(int32, tag = "4")]
pub input_channel: i32,
#[prost(int32, tag = "5")]
pub output_channel: i32,
#[prost(double, tag = "6")]
pub gain_db: f64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextStream {
#[prost(string, tag = "1")]
pub codec: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub language_code: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub mapping: ::prost::alloc::vec::Vec<text_stream::TextMapping>,
#[prost(string, tag = "4")]
pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TextStream`.
pub mod text_stream {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextMapping {
#[prost(string, tag = "1")]
pub atom_key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub input_key: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub input_track: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SegmentSettings {
#[prost(message, optional, tag = "1")]
pub segment_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(bool, tag = "3")]
pub individual_segments: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Encryption {
#[prost(string, tag = "6")]
pub id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub drm_systems: ::core::option::Option<encryption::DrmSystems>,
#[prost(oneof = "encryption::EncryptionMode", tags = "3, 4, 5")]
pub encryption_mode: ::core::option::Option<encryption::EncryptionMode>,
#[prost(oneof = "encryption::SecretSource", tags = "7")]
pub secret_source: ::core::option::Option<encryption::SecretSource>,
}
/// Nested message and enum types in `Encryption`.
pub mod encryption {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Aes128Encryption {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SampleAesEncryption {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MpegCommonEncryption {
#[prost(string, tag = "2")]
pub scheme: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretManagerSource {
#[prost(string, tag = "1")]
pub secret_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Widevine {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Fairplay {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Playready {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Clearkey {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DrmSystems {
#[prost(message, optional, tag = "1")]
pub widevine: ::core::option::Option<Widevine>,
#[prost(message, optional, tag = "2")]
pub fairplay: ::core::option::Option<Fairplay>,
#[prost(message, optional, tag = "3")]
pub playready: ::core::option::Option<Playready>,
#[prost(message, optional, tag = "4")]
pub clearkey: ::core::option::Option<Clearkey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EncryptionMode {
#[prost(message, tag = "3")]
Aes128(Aes128Encryption),
#[prost(message, tag = "4")]
SampleAes(SampleAesEncryption),
#[prost(message, tag = "5")]
MpegCenc(MpegCommonEncryption),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum SecretSource {
#[prost(message, tag = "7")]
SecretManagerKeySource(SecretManagerSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub job: ::core::option::Option<Job>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
#[prost(message, repeated, tag = "1")]
pub jobs: ::prost::alloc::vec::Vec<Job>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobTemplateRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub job_template: ::core::option::Option<JobTemplate>,
#[prost(string, tag = "3")]
pub job_template_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobTemplatesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobTemplateRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobTemplateRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobTemplatesResponse {
#[prost(message, repeated, tag = "1")]
pub job_templates: ::prost::alloc::vec::Vec<JobTemplate>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod transcoder_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Using the Transcoder API, you can queue asynchronous jobs for transcoding
/// media into various output formats. Output formats may include different
/// streaming standards such as HTTP Live Streaming (HLS) and Dynamic Adaptive
/// Streaming over HTTP (DASH). You can also customize jobs using advanced
/// features such as Digital Rights Management (DRM), audio equalization, content
/// concatenation, and digital ad-stitch ready content generation.
#[derive(Debug, Clone)]
pub struct TranscoderServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> TranscoderServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> TranscoderServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
TranscoderServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a job in the specified region.
pub async fn create_job(&mut self, request: impl tonic::IntoRequest<super::CreateJobRequest>) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/CreateJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "CreateJob"));
self.inner.unary(req, path, codec).await
}
/// Lists jobs in the specified region.
pub async fn list_jobs(&mut self, request: impl tonic::IntoRequest<super::ListJobsRequest>) -> std::result::Result<tonic::Response<super::ListJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/ListJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "ListJobs"));
self.inner.unary(req, path, codec).await
}
/// Returns the job data.
pub async fn get_job(&mut self, request: impl tonic::IntoRequest<super::GetJobRequest>) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/GetJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "GetJob"));
self.inner.unary(req, path, codec).await
}
/// Deletes a job.
pub async fn delete_job(&mut self, request: impl tonic::IntoRequest<super::DeleteJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/DeleteJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "DeleteJob"));
self.inner.unary(req, path, codec).await
}
/// Creates a job template in the specified region.
pub async fn create_job_template(&mut self, request: impl tonic::IntoRequest<super::CreateJobTemplateRequest>) -> std::result::Result<tonic::Response<super::JobTemplate>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/CreateJobTemplate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "CreateJobTemplate"));
self.inner.unary(req, path, codec).await
}
/// Lists job templates in the specified region.
pub async fn list_job_templates(&mut self, request: impl tonic::IntoRequest<super::ListJobTemplatesRequest>) -> std::result::Result<tonic::Response<super::ListJobTemplatesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/ListJobTemplates");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "ListJobTemplates"));
self.inner.unary(req, path, codec).await
}
/// Returns the job template data.
pub async fn get_job_template(&mut self, request: impl tonic::IntoRequest<super::GetJobTemplateRequest>) -> std::result::Result<tonic::Response<super::JobTemplate>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/GetJobTemplate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "GetJobTemplate"));
self.inner.unary(req, path, codec).await
}
/// Deletes a job template.
pub async fn delete_job_template(&mut self, request: impl tonic::IntoRequest<super::DeleteJobTemplateRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.transcoder.v1.TranscoderService/DeleteJobTemplate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.transcoder.v1.TranscoderService", "DeleteJobTemplate"));
self.inner.unary(req, path, codec).await
}
}
}
