// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomColumnErrorEnum {}
/// Nested message and enum types in `CustomColumnErrorEnum`.
pub mod custom_column_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CustomColumnError {
        Unspecified = 0,
        Unknown = 1,
        CustomColumnNotFound = 2,
        CustomColumnNotAvailable = 3,
    }
    impl CustomColumnError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomColumnError::Unspecified => "UNSPECIFIED",
                CustomColumnError::Unknown => "UNKNOWN",
                CustomColumnError::CustomColumnNotFound => "CUSTOM_COLUMN_NOT_FOUND",
                CustomColumnError::CustomColumnNotAvailable => "CUSTOM_COLUMN_NOT_AVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOM_COLUMN_NOT_FOUND" => Some(Self::CustomColumnNotFound),
                "CUSTOM_COLUMN_NOT_AVAILABLE" => Some(Self::CustomColumnNotAvailable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistinctErrorEnum {}
/// Nested message and enum types in `DistinctErrorEnum`.
pub mod distinct_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DistinctError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateElement = 2,
        DuplicateType = 3,
    }
    impl DistinctError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DistinctError::Unspecified => "UNSPECIFIED",
                DistinctError::Unknown => "UNKNOWN",
                DistinctError::DuplicateElement => "DUPLICATE_ELEMENT",
                DistinctError::DuplicateType => "DUPLICATE_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ELEMENT" => Some(Self::DuplicateElement),
                "DUPLICATE_TYPE" => Some(Self::DuplicateType),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuotaErrorEnum {}
/// Nested message and enum types in `QuotaErrorEnum`.
pub mod quota_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum QuotaError {
        Unspecified = 0,
        Unknown = 1,
        ResourceExhausted = 2,
        ResourceTemporarilyExhausted = 4,
    }
    impl QuotaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QuotaError::Unspecified => "UNSPECIFIED",
                QuotaError::Unknown => "UNKNOWN",
                QuotaError::ResourceExhausted => "RESOURCE_EXHAUSTED",
                QuotaError::ResourceTemporarilyExhausted => "RESOURCE_TEMPORARILY_EXHAUSTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
                "RESOURCE_TEMPORARILY_EXHAUSTED" => Some(Self::ResourceTemporarilyExhausted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthorizationErrorEnum {}
/// Nested message and enum types in `AuthorizationErrorEnum`.
pub mod authorization_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AuthorizationError {
        Unspecified = 0,
        Unknown = 1,
        UserPermissionDenied = 2,
        ProjectDisabled = 5,
        AuthorizationError = 6,
        ActionNotPermitted = 7,
        IncompleteSignup = 8,
        CustomerNotEnabled = 24,
        MissingTos = 9,
        InvalidLoginCustomerIdServingCustomerIdCombination = 11,
        ServiceAccessDenied = 12,
        AccessDeniedForAccountType = 25,
        MetricAccessDenied = 26,
    }
    impl AuthorizationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AuthorizationError::Unspecified => "UNSPECIFIED",
                AuthorizationError::Unknown => "UNKNOWN",
                AuthorizationError::UserPermissionDenied => "USER_PERMISSION_DENIED",
                AuthorizationError::ProjectDisabled => "PROJECT_DISABLED",
                AuthorizationError::AuthorizationError => "AUTHORIZATION_ERROR",
                AuthorizationError::ActionNotPermitted => "ACTION_NOT_PERMITTED",
                AuthorizationError::IncompleteSignup => "INCOMPLETE_SIGNUP",
                AuthorizationError::CustomerNotEnabled => "CUSTOMER_NOT_ENABLED",
                AuthorizationError::MissingTos => "MISSING_TOS",
                AuthorizationError::InvalidLoginCustomerIdServingCustomerIdCombination => {
                    "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION"
                }
                AuthorizationError::ServiceAccessDenied => "SERVICE_ACCESS_DENIED",
                AuthorizationError::AccessDeniedForAccountType => "ACCESS_DENIED_FOR_ACCOUNT_TYPE",
                AuthorizationError::MetricAccessDenied => "METRIC_ACCESS_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "USER_PERMISSION_DENIED" => Some(Self::UserPermissionDenied),
                "PROJECT_DISABLED" => Some(Self::ProjectDisabled),
                "AUTHORIZATION_ERROR" => Some(Self::AuthorizationError),
                "ACTION_NOT_PERMITTED" => Some(Self::ActionNotPermitted),
                "INCOMPLETE_SIGNUP" => Some(Self::IncompleteSignup),
                "CUSTOMER_NOT_ENABLED" => Some(Self::CustomerNotEnabled),
                "MISSING_TOS" => Some(Self::MissingTos),
                "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION" => {
                    Some(Self::InvalidLoginCustomerIdServingCustomerIdCombination)
                }
                "SERVICE_ACCESS_DENIED" => Some(Self::ServiceAccessDenied),
                "ACCESS_DENIED_FOR_ACCOUNT_TYPE" => Some(Self::AccessDeniedForAccountType),
                "METRIC_ACCESS_DENIED" => Some(Self::MetricAccessDenied),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticationErrorEnum {}
/// Nested message and enum types in `AuthenticationErrorEnum`.
pub mod authentication_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AuthenticationError {
        Unspecified = 0,
        Unknown = 1,
        AuthenticationError = 2,
        ClientCustomerIdInvalid = 5,
        CustomerNotFound = 8,
        GoogleAccountDeleted = 9,
        GoogleAccountCookieInvalid = 10,
        GoogleAccountAuthenticationFailed = 25,
        GoogleAccountUserAndAdsUserMismatch = 12,
        LoginCookieRequired = 13,
        NotAdsUser = 14,
        OauthTokenInvalid = 15,
        OauthTokenExpired = 16,
        OauthTokenDisabled = 17,
        OauthTokenRevoked = 18,
        OauthTokenHeaderInvalid = 19,
        LoginCookieInvalid = 20,
        UserIdInvalid = 22,
        TwoStepVerificationNotEnrolled = 23,
        AdvancedProtectionNotEnrolled = 24,
    }
    impl AuthenticationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AuthenticationError::Unspecified => "UNSPECIFIED",
                AuthenticationError::Unknown => "UNKNOWN",
                AuthenticationError::AuthenticationError => "AUTHENTICATION_ERROR",
                AuthenticationError::ClientCustomerIdInvalid => "CLIENT_CUSTOMER_ID_INVALID",
                AuthenticationError::CustomerNotFound => "CUSTOMER_NOT_FOUND",
                AuthenticationError::GoogleAccountDeleted => "GOOGLE_ACCOUNT_DELETED",
                AuthenticationError::GoogleAccountCookieInvalid => "GOOGLE_ACCOUNT_COOKIE_INVALID",
                AuthenticationError::GoogleAccountAuthenticationFailed => {
                    "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED"
                }
                AuthenticationError::GoogleAccountUserAndAdsUserMismatch => {
                    "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH"
                }
                AuthenticationError::LoginCookieRequired => "LOGIN_COOKIE_REQUIRED",
                AuthenticationError::NotAdsUser => "NOT_ADS_USER",
                AuthenticationError::OauthTokenInvalid => "OAUTH_TOKEN_INVALID",
                AuthenticationError::OauthTokenExpired => "OAUTH_TOKEN_EXPIRED",
                AuthenticationError::OauthTokenDisabled => "OAUTH_TOKEN_DISABLED",
                AuthenticationError::OauthTokenRevoked => "OAUTH_TOKEN_REVOKED",
                AuthenticationError::OauthTokenHeaderInvalid => "OAUTH_TOKEN_HEADER_INVALID",
                AuthenticationError::LoginCookieInvalid => "LOGIN_COOKIE_INVALID",
                AuthenticationError::UserIdInvalid => "USER_ID_INVALID",
                AuthenticationError::TwoStepVerificationNotEnrolled => {
                    "TWO_STEP_VERIFICATION_NOT_ENROLLED"
                }
                AuthenticationError::AdvancedProtectionNotEnrolled => {
                    "ADVANCED_PROTECTION_NOT_ENROLLED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTHENTICATION_ERROR" => Some(Self::AuthenticationError),
                "CLIENT_CUSTOMER_ID_INVALID" => Some(Self::ClientCustomerIdInvalid),
                "CUSTOMER_NOT_FOUND" => Some(Self::CustomerNotFound),
                "GOOGLE_ACCOUNT_DELETED" => Some(Self::GoogleAccountDeleted),
                "GOOGLE_ACCOUNT_COOKIE_INVALID" => Some(Self::GoogleAccountCookieInvalid),
                "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED" => {
                    Some(Self::GoogleAccountAuthenticationFailed)
                }
                "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH" => {
                    Some(Self::GoogleAccountUserAndAdsUserMismatch)
                }
                "LOGIN_COOKIE_REQUIRED" => Some(Self::LoginCookieRequired),
                "NOT_ADS_USER" => Some(Self::NotAdsUser),
                "OAUTH_TOKEN_INVALID" => Some(Self::OauthTokenInvalid),
                "OAUTH_TOKEN_EXPIRED" => Some(Self::OauthTokenExpired),
                "OAUTH_TOKEN_DISABLED" => Some(Self::OauthTokenDisabled),
                "OAUTH_TOKEN_REVOKED" => Some(Self::OauthTokenRevoked),
                "OAUTH_TOKEN_HEADER_INVALID" => Some(Self::OauthTokenHeaderInvalid),
                "LOGIN_COOKIE_INVALID" => Some(Self::LoginCookieInvalid),
                "USER_ID_INVALID" => Some(Self::UserIdInvalid),
                "TWO_STEP_VERIFICATION_NOT_ENROLLED" => Some(Self::TwoStepVerificationNotEnrolled),
                "ADVANCED_PROTECTION_NOT_ENROLLED" => Some(Self::AdvancedProtectionNotEnrolled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateErrorEnum {}
/// Nested message and enum types in `DateErrorEnum`.
pub mod date_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DateError {
        Unspecified = 0,
        Unknown = 1,
        InvalidFieldValuesInDate = 2,
        InvalidFieldValuesInDateTime = 3,
        InvalidStringDate = 4,
        InvalidStringDateTimeMicros = 6,
        InvalidStringDateTimeSeconds = 11,
        InvalidStringDateTimeSecondsWithOffset = 12,
        EarlierThanMinimumDate = 7,
        LaterThanMaximumDate = 8,
        DateRangeMinimumDateLaterThanMaximumDate = 9,
        DateRangeMinimumAndMaximumDatesBothNull = 10,
    }
    impl DateError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DateError::Unspecified => "UNSPECIFIED",
                DateError::Unknown => "UNKNOWN",
                DateError::InvalidFieldValuesInDate => "INVALID_FIELD_VALUES_IN_DATE",
                DateError::InvalidFieldValuesInDateTime => "INVALID_FIELD_VALUES_IN_DATE_TIME",
                DateError::InvalidStringDate => "INVALID_STRING_DATE",
                DateError::InvalidStringDateTimeMicros => "INVALID_STRING_DATE_TIME_MICROS",
                DateError::InvalidStringDateTimeSeconds => "INVALID_STRING_DATE_TIME_SECONDS",
                DateError::InvalidStringDateTimeSecondsWithOffset => {
                    "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET"
                }
                DateError::EarlierThanMinimumDate => "EARLIER_THAN_MINIMUM_DATE",
                DateError::LaterThanMaximumDate => "LATER_THAN_MAXIMUM_DATE",
                DateError::DateRangeMinimumDateLaterThanMaximumDate => {
                    "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE"
                }
                DateError::DateRangeMinimumAndMaximumDatesBothNull => {
                    "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_FIELD_VALUES_IN_DATE" => Some(Self::InvalidFieldValuesInDate),
                "INVALID_FIELD_VALUES_IN_DATE_TIME" => Some(Self::InvalidFieldValuesInDateTime),
                "INVALID_STRING_DATE" => Some(Self::InvalidStringDate),
                "INVALID_STRING_DATE_TIME_MICROS" => Some(Self::InvalidStringDateTimeMicros),
                "INVALID_STRING_DATE_TIME_SECONDS" => Some(Self::InvalidStringDateTimeSeconds),
                "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET" => {
                    Some(Self::InvalidStringDateTimeSecondsWithOffset)
                }
                "EARLIER_THAN_MINIMUM_DATE" => Some(Self::EarlierThanMinimumDate),
                "LATER_THAN_MAXIMUM_DATE" => Some(Self::LaterThanMaximumDate),
                "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE" => {
                    Some(Self::DateRangeMinimumDateLaterThanMaximumDate)
                }
                "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL" => {
                    Some(Self::DateRangeMinimumAndMaximumDatesBothNull)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateRangeErrorEnum {}
/// Nested message and enum types in `DateRangeErrorEnum`.
pub mod date_range_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DateRangeError {
        Unspecified = 0,
        Unknown = 1,
        InvalidDate = 2,
        StartDateAfterEndDate = 3,
        CannotSetDateToPast = 4,
        AfterMaximumAllowableDate = 5,
        CannotModifyStartDateIfAlreadyStarted = 6,
    }
    impl DateRangeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DateRangeError::Unspecified => "UNSPECIFIED",
                DateRangeError::Unknown => "UNKNOWN",
                DateRangeError::InvalidDate => "INVALID_DATE",
                DateRangeError::StartDateAfterEndDate => "START_DATE_AFTER_END_DATE",
                DateRangeError::CannotSetDateToPast => "CANNOT_SET_DATE_TO_PAST",
                DateRangeError::AfterMaximumAllowableDate => "AFTER_MAXIMUM_ALLOWABLE_DATE",
                DateRangeError::CannotModifyStartDateIfAlreadyStarted => {
                    "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_DATE" => Some(Self::InvalidDate),
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "CANNOT_SET_DATE_TO_PAST" => Some(Self::CannotSetDateToPast),
                "AFTER_MAXIMUM_ALLOWABLE_DATE" => Some(Self::AfterMaximumAllowableDate),
                "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED" => {
                    Some(Self::CannotModifyStartDateIfAlreadyStarted)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HeaderErrorEnum {}
/// Nested message and enum types in `HeaderErrorEnum`.
pub mod header_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum HeaderError {
        Unspecified = 0,
        Unknown = 1,
        InvalidUserSelectedCustomerId = 2,
        InvalidLoginCustomerId = 3,
    }
    impl HeaderError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HeaderError::Unspecified => "UNSPECIFIED",
                HeaderError::Unknown => "UNKNOWN",
                HeaderError::InvalidUserSelectedCustomerId => "INVALID_USER_SELECTED_CUSTOMER_ID",
                HeaderError::InvalidLoginCustomerId => "INVALID_LOGIN_CUSTOMER_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_USER_SELECTED_CUSTOMER_ID" => Some(Self::InvalidUserSelectedCustomerId),
                "INVALID_LOGIN_CUSTOMER_ID" => Some(Self::InvalidLoginCustomerId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InternalErrorEnum {}
/// Nested message and enum types in `InternalErrorEnum`.
pub mod internal_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InternalError {
        Unspecified = 0,
        Unknown = 1,
        InternalError = 2,
        ErrorCodeNotPublished = 3,
        TransientError = 4,
        DeadlineExceeded = 5,
    }
    impl InternalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InternalError::Unspecified => "UNSPECIFIED",
                InternalError::Unknown => "UNKNOWN",
                InternalError::InternalError => "INTERNAL_ERROR",
                InternalError::ErrorCodeNotPublished => "ERROR_CODE_NOT_PUBLISHED",
                InternalError::TransientError => "TRANSIENT_ERROR",
                InternalError::DeadlineExceeded => "DEADLINE_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "ERROR_CODE_NOT_PUBLISHED" => Some(Self::ErrorCodeNotPublished),
                "TRANSIENT_ERROR" => Some(Self::TransientError),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvalidParameterErrorEnum {}
/// Nested message and enum types in `InvalidParameterErrorEnum`.
pub mod invalid_parameter_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InvalidParameterError {
        Unspecified = 0,
        Unknown = 1,
        InvalidCurrencyCode = 2,
    }
    impl InvalidParameterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InvalidParameterError::Unspecified => "UNSPECIFIED",
                InvalidParameterError::Unknown => "UNKNOWN",
                InvalidParameterError::InvalidCurrencyCode => "INVALID_CURRENCY_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_CURRENCY_CODE" => Some(Self::InvalidCurrencyCode),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryErrorEnum {}
/// Nested message and enum types in `QueryErrorEnum`.
pub mod query_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum QueryError {
        Unspecified = 0,
        Unknown = 1,
        QueryError = 50,
        BadEnumConstant = 18,
        BadEscapeSequence = 7,
        BadFieldName = 12,
        BadLimitValue = 15,
        BadNumber = 5,
        BadOperator = 3,
        BadParameterName = 61,
        BadParameterValue = 62,
        BadResourceTypeInFromClause = 45,
        BadSymbol = 2,
        BadValue = 4,
        DateRangeTooWide = 36,
        DateRangeTooNarrow = 60,
        ExpectedAnd = 30,
        ExpectedBy = 14,
        ExpectedDimensionFieldInSelectClause = 37,
        ExpectedFiltersOnDateRange = 55,
        ExpectedFrom = 44,
        ExpectedList = 41,
        ExpectedReferencedFieldInSelectClause = 16,
        ExpectedSelect = 13,
        ExpectedSingleValue = 42,
        ExpectedValueWithBetweenOperator = 29,
        InvalidDateFormat = 38,
        MisalignedDateForFilter = 64,
        InvalidStringValue = 57,
        InvalidValueWithBetweenOperator = 26,
        InvalidValueWithDuringOperator = 22,
        InvalidValueWithLikeOperator = 56,
        OperatorFieldMismatch = 35,
        ProhibitedEmptyListInCondition = 28,
        ProhibitedEnumConstant = 54,
        ProhibitedFieldCombinationInSelectClause = 31,
        ProhibitedFieldInOrderByClause = 40,
        ProhibitedFieldInSelectClause = 23,
        ProhibitedFieldInWhereClause = 24,
        ProhibitedResourceTypeInFromClause = 43,
        ProhibitedResourceTypeInSelectClause = 48,
        ProhibitedResourceTypeInWhereClause = 58,
        ProhibitedMetricInSelectOrWhereClause = 49,
        ProhibitedSegmentInSelectOrWhereClause = 51,
        ProhibitedSegmentWithMetricInSelectOrWhereClause = 53,
        LimitValueTooLow = 25,
        ProhibitedNewlineInString = 8,
        ProhibitedValueCombinationInList = 10,
        ProhibitedValueCombinationWithBetweenOperator = 21,
        StringNotTerminated = 6,
        TooManySegments = 34,
        UnexpectedEndOfQuery = 9,
        UnexpectedFromClause = 47,
        UnrecognizedField = 32,
        UnexpectedInput = 11,
        RequestedMetricsForManager = 59,
        FilterHasTooManyValues = 63,
    }
    impl QueryError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QueryError::Unspecified => "UNSPECIFIED",
                QueryError::Unknown => "UNKNOWN",
                QueryError::QueryError => "QUERY_ERROR",
                QueryError::BadEnumConstant => "BAD_ENUM_CONSTANT",
                QueryError::BadEscapeSequence => "BAD_ESCAPE_SEQUENCE",
                QueryError::BadFieldName => "BAD_FIELD_NAME",
                QueryError::BadLimitValue => "BAD_LIMIT_VALUE",
                QueryError::BadNumber => "BAD_NUMBER",
                QueryError::BadOperator => "BAD_OPERATOR",
                QueryError::BadParameterName => "BAD_PARAMETER_NAME",
                QueryError::BadParameterValue => "BAD_PARAMETER_VALUE",
                QueryError::BadResourceTypeInFromClause => "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE",
                QueryError::BadSymbol => "BAD_SYMBOL",
                QueryError::BadValue => "BAD_VALUE",
                QueryError::DateRangeTooWide => "DATE_RANGE_TOO_WIDE",
                QueryError::DateRangeTooNarrow => "DATE_RANGE_TOO_NARROW",
                QueryError::ExpectedAnd => "EXPECTED_AND",
                QueryError::ExpectedBy => "EXPECTED_BY",
                QueryError::ExpectedDimensionFieldInSelectClause => {
                    "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE"
                }
                QueryError::ExpectedFiltersOnDateRange => "EXPECTED_FILTERS_ON_DATE_RANGE",
                QueryError::ExpectedFrom => "EXPECTED_FROM",
                QueryError::ExpectedList => "EXPECTED_LIST",
                QueryError::ExpectedReferencedFieldInSelectClause => {
                    "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE"
                }
                QueryError::ExpectedSelect => "EXPECTED_SELECT",
                QueryError::ExpectedSingleValue => "EXPECTED_SINGLE_VALUE",
                QueryError::ExpectedValueWithBetweenOperator => {
                    "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR"
                }
                QueryError::InvalidDateFormat => "INVALID_DATE_FORMAT",
                QueryError::MisalignedDateForFilter => "MISALIGNED_DATE_FOR_FILTER",
                QueryError::InvalidStringValue => "INVALID_STRING_VALUE",
                QueryError::InvalidValueWithBetweenOperator => {
                    "INVALID_VALUE_WITH_BETWEEN_OPERATOR"
                }
                QueryError::InvalidValueWithDuringOperator => "INVALID_VALUE_WITH_DURING_OPERATOR",
                QueryError::InvalidValueWithLikeOperator => "INVALID_VALUE_WITH_LIKE_OPERATOR",
                QueryError::OperatorFieldMismatch => "OPERATOR_FIELD_MISMATCH",
                QueryError::ProhibitedEmptyListInCondition => "PROHIBITED_EMPTY_LIST_IN_CONDITION",
                QueryError::ProhibitedEnumConstant => "PROHIBITED_ENUM_CONSTANT",
                QueryError::ProhibitedFieldCombinationInSelectClause => {
                    "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE"
                }
                QueryError::ProhibitedFieldInOrderByClause => "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE",
                QueryError::ProhibitedFieldInSelectClause => "PROHIBITED_FIELD_IN_SELECT_CLAUSE",
                QueryError::ProhibitedFieldInWhereClause => "PROHIBITED_FIELD_IN_WHERE_CLAUSE",
                QueryError::ProhibitedResourceTypeInFromClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE"
                }
                QueryError::ProhibitedResourceTypeInSelectClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE"
                }
                QueryError::ProhibitedResourceTypeInWhereClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE"
                }
                QueryError::ProhibitedMetricInSelectOrWhereClause => {
                    "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                QueryError::ProhibitedSegmentInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE"
                }
                QueryError::ProhibitedSegmentWithMetricInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                QueryError::LimitValueTooLow => "LIMIT_VALUE_TOO_LOW",
                QueryError::ProhibitedNewlineInString => "PROHIBITED_NEWLINE_IN_STRING",
                QueryError::ProhibitedValueCombinationInList => {
                    "PROHIBITED_VALUE_COMBINATION_IN_LIST"
                }
                QueryError::ProhibitedValueCombinationWithBetweenOperator => {
                    "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR"
                }
                QueryError::StringNotTerminated => "STRING_NOT_TERMINATED",
                QueryError::TooManySegments => "TOO_MANY_SEGMENTS",
                QueryError::UnexpectedEndOfQuery => "UNEXPECTED_END_OF_QUERY",
                QueryError::UnexpectedFromClause => "UNEXPECTED_FROM_CLAUSE",
                QueryError::UnrecognizedField => "UNRECOGNIZED_FIELD",
                QueryError::UnexpectedInput => "UNEXPECTED_INPUT",
                QueryError::RequestedMetricsForManager => "REQUESTED_METRICS_FOR_MANAGER",
                QueryError::FilterHasTooManyValues => "FILTER_HAS_TOO_MANY_VALUES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "QUERY_ERROR" => Some(Self::QueryError),
                "BAD_ENUM_CONSTANT" => Some(Self::BadEnumConstant),
                "BAD_ESCAPE_SEQUENCE" => Some(Self::BadEscapeSequence),
                "BAD_FIELD_NAME" => Some(Self::BadFieldName),
                "BAD_LIMIT_VALUE" => Some(Self::BadLimitValue),
                "BAD_NUMBER" => Some(Self::BadNumber),
                "BAD_OPERATOR" => Some(Self::BadOperator),
                "BAD_PARAMETER_NAME" => Some(Self::BadParameterName),
                "BAD_PARAMETER_VALUE" => Some(Self::BadParameterValue),
                "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE" => Some(Self::BadResourceTypeInFromClause),
                "BAD_SYMBOL" => Some(Self::BadSymbol),
                "BAD_VALUE" => Some(Self::BadValue),
                "DATE_RANGE_TOO_WIDE" => Some(Self::DateRangeTooWide),
                "DATE_RANGE_TOO_NARROW" => Some(Self::DateRangeTooNarrow),
                "EXPECTED_AND" => Some(Self::ExpectedAnd),
                "EXPECTED_BY" => Some(Self::ExpectedBy),
                "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedDimensionFieldInSelectClause)
                }
                "EXPECTED_FILTERS_ON_DATE_RANGE" => Some(Self::ExpectedFiltersOnDateRange),
                "EXPECTED_FROM" => Some(Self::ExpectedFrom),
                "EXPECTED_LIST" => Some(Self::ExpectedList),
                "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedReferencedFieldInSelectClause)
                }
                "EXPECTED_SELECT" => Some(Self::ExpectedSelect),
                "EXPECTED_SINGLE_VALUE" => Some(Self::ExpectedSingleValue),
                "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ExpectedValueWithBetweenOperator)
                }
                "INVALID_DATE_FORMAT" => Some(Self::InvalidDateFormat),
                "MISALIGNED_DATE_FOR_FILTER" => Some(Self::MisalignedDateForFilter),
                "INVALID_STRING_VALUE" => Some(Self::InvalidStringValue),
                "INVALID_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::InvalidValueWithBetweenOperator)
                }
                "INVALID_VALUE_WITH_DURING_OPERATOR" => Some(Self::InvalidValueWithDuringOperator),
                "INVALID_VALUE_WITH_LIKE_OPERATOR" => Some(Self::InvalidValueWithLikeOperator),
                "OPERATOR_FIELD_MISMATCH" => Some(Self::OperatorFieldMismatch),
                "PROHIBITED_EMPTY_LIST_IN_CONDITION" => Some(Self::ProhibitedEmptyListInCondition),
                "PROHIBITED_ENUM_CONSTANT" => Some(Self::ProhibitedEnumConstant),
                "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedFieldCombinationInSelectClause)
                }
                "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE" => Some(Self::ProhibitedFieldInOrderByClause),
                "PROHIBITED_FIELD_IN_SELECT_CLAUSE" => Some(Self::ProhibitedFieldInSelectClause),
                "PROHIBITED_FIELD_IN_WHERE_CLAUSE" => Some(Self::ProhibitedFieldInWhereClause),
                "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInFromClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInSelectClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInWhereClause)
                }
                "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedMetricInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentWithMetricInSelectOrWhereClause)
                }
                "LIMIT_VALUE_TOO_LOW" => Some(Self::LimitValueTooLow),
                "PROHIBITED_NEWLINE_IN_STRING" => Some(Self::ProhibitedNewlineInString),
                "PROHIBITED_VALUE_COMBINATION_IN_LIST" => {
                    Some(Self::ProhibitedValueCombinationInList)
                }
                "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ProhibitedValueCombinationWithBetweenOperator)
                }
                "STRING_NOT_TERMINATED" => Some(Self::StringNotTerminated),
                "TOO_MANY_SEGMENTS" => Some(Self::TooManySegments),
                "UNEXPECTED_END_OF_QUERY" => Some(Self::UnexpectedEndOfQuery),
                "UNEXPECTED_FROM_CLAUSE" => Some(Self::UnexpectedFromClause),
                "UNRECOGNIZED_FIELD" => Some(Self::UnrecognizedField),
                "UNEXPECTED_INPUT" => Some(Self::UnexpectedInput),
                "REQUESTED_METRICS_FOR_MANAGER" => Some(Self::RequestedMetricsForManager),
                "FILTER_HAS_TOO_MANY_VALUES" => Some(Self::FilterHasTooManyValues),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestErrorEnum {}
/// Nested message and enum types in `RequestErrorEnum`.
pub mod request_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum RequestError {
        Unspecified = 0,
        Unknown = 1,
        ResourceNameMissing = 3,
        ResourceNameMalformed = 4,
        BadResourceId = 17,
        InvalidProductName = 35,
        InvalidCustomerId = 16,
        OperationRequired = 5,
        ResourceNotFound = 6,
        InvalidPageToken = 7,
        ExpiredPageToken = 8,
        InvalidPageSize = 22,
        RequiredFieldMissing = 9,
        ImmutableField = 11,
        TooManyMutateOperations = 13,
        CannotBeExecutedByManagerAccount = 14,
        CannotModifyForeignField = 15,
        InvalidEnumValue = 18,
        LoginCustomerIdParameterMissing = 20,
        LoginOrLinkedCustomerIdParameterRequired = 34,
        ValidateOnlyRequestHasPageToken = 21,
        CannotReturnSummaryRowForRequestWithoutMetrics = 29,
        CannotReturnSummaryRowForValidateOnlyRequests = 30,
        InconsistentReturnSummaryRowValue = 31,
        TotalResultsCountNotOriginallyRequested = 32,
        RpcDeadlineTooShort = 33,
        ProductNotSupported = 37,
    }
    impl RequestError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RequestError::Unspecified => "UNSPECIFIED",
                RequestError::Unknown => "UNKNOWN",
                RequestError::ResourceNameMissing => "RESOURCE_NAME_MISSING",
                RequestError::ResourceNameMalformed => "RESOURCE_NAME_MALFORMED",
                RequestError::BadResourceId => "BAD_RESOURCE_ID",
                RequestError::InvalidProductName => "INVALID_PRODUCT_NAME",
                RequestError::InvalidCustomerId => "INVALID_CUSTOMER_ID",
                RequestError::OperationRequired => "OPERATION_REQUIRED",
                RequestError::ResourceNotFound => "RESOURCE_NOT_FOUND",
                RequestError::InvalidPageToken => "INVALID_PAGE_TOKEN",
                RequestError::ExpiredPageToken => "EXPIRED_PAGE_TOKEN",
                RequestError::InvalidPageSize => "INVALID_PAGE_SIZE",
                RequestError::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
                RequestError::ImmutableField => "IMMUTABLE_FIELD",
                RequestError::TooManyMutateOperations => "TOO_MANY_MUTATE_OPERATIONS",
                RequestError::CannotBeExecutedByManagerAccount => {
                    "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT"
                }
                RequestError::CannotModifyForeignField => "CANNOT_MODIFY_FOREIGN_FIELD",
                RequestError::InvalidEnumValue => "INVALID_ENUM_VALUE",
                RequestError::LoginCustomerIdParameterMissing => {
                    "LOGIN_CUSTOMER_ID_PARAMETER_MISSING"
                }
                RequestError::LoginOrLinkedCustomerIdParameterRequired => {
                    "LOGIN_OR_LINKED_CUSTOMER_ID_PARAMETER_REQUIRED"
                }
                RequestError::ValidateOnlyRequestHasPageToken => {
                    "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN"
                }
                RequestError::CannotReturnSummaryRowForRequestWithoutMetrics => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS"
                }
                RequestError::CannotReturnSummaryRowForValidateOnlyRequests => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS"
                }
                RequestError::InconsistentReturnSummaryRowValue => {
                    "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE"
                }
                RequestError::TotalResultsCountNotOriginallyRequested => {
                    "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED"
                }
                RequestError::RpcDeadlineTooShort => "RPC_DEADLINE_TOO_SHORT",
                RequestError::ProductNotSupported => "PRODUCT_NOT_SUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_NAME_MISSING" => Some(Self::ResourceNameMissing),
                "RESOURCE_NAME_MALFORMED" => Some(Self::ResourceNameMalformed),
                "BAD_RESOURCE_ID" => Some(Self::BadResourceId),
                "INVALID_PRODUCT_NAME" => Some(Self::InvalidProductName),
                "INVALID_CUSTOMER_ID" => Some(Self::InvalidCustomerId),
                "OPERATION_REQUIRED" => Some(Self::OperationRequired),
                "RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
                "INVALID_PAGE_TOKEN" => Some(Self::InvalidPageToken),
                "EXPIRED_PAGE_TOKEN" => Some(Self::ExpiredPageToken),
                "INVALID_PAGE_SIZE" => Some(Self::InvalidPageSize),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "TOO_MANY_MUTATE_OPERATIONS" => Some(Self::TooManyMutateOperations),
                "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT" => {
                    Some(Self::CannotBeExecutedByManagerAccount)
                }
                "CANNOT_MODIFY_FOREIGN_FIELD" => Some(Self::CannotModifyForeignField),
                "INVALID_ENUM_VALUE" => Some(Self::InvalidEnumValue),
                "LOGIN_CUSTOMER_ID_PARAMETER_MISSING" => {
                    Some(Self::LoginCustomerIdParameterMissing)
                }
                "LOGIN_OR_LINKED_CUSTOMER_ID_PARAMETER_REQUIRED" => {
                    Some(Self::LoginOrLinkedCustomerIdParameterRequired)
                }
                "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN" => {
                    Some(Self::ValidateOnlyRequestHasPageToken)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS" => {
                    Some(Self::CannotReturnSummaryRowForRequestWithoutMetrics)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS" => {
                    Some(Self::CannotReturnSummaryRowForValidateOnlyRequests)
                }
                "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE" => {
                    Some(Self::InconsistentReturnSummaryRowValue)
                }
                "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED" => {
                    Some(Self::TotalResultsCountNotOriginallyRequested)
                }
                "RPC_DEADLINE_TOO_SHORT" => Some(Self::RpcDeadlineTooShort),
                "PRODUCT_NOT_SUPPORTED" => Some(Self::ProductNotSupported),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeLimitErrorEnum {}
/// Nested message and enum types in `SizeLimitErrorEnum`.
pub mod size_limit_error_enum {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SizeLimitError {
        Unspecified = 0,
        Unknown = 1,
        RequestSizeLimitExceeded = 2,
        ResponseSizeLimitExceeded = 3,
    }
    impl SizeLimitError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SizeLimitError::Unspecified => "UNSPECIFIED",
                SizeLimitError::Unknown => "UNKNOWN",
                SizeLimitError::RequestSizeLimitExceeded => "REQUEST_SIZE_LIMIT_EXCEEDED",
                SizeLimitError::ResponseSizeLimitExceeded => "RESPONSE_SIZE_LIMIT_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUEST_SIZE_LIMIT_EXCEEDED" => Some(Self::RequestSizeLimitExceeded),
                "RESPONSE_SIZE_LIMIT_EXCEEDED" => Some(Self::ResponseSizeLimitExceeded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAds360Failure {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<SearchAds360Error>,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAds360Error {
    #[prost(message, optional, tag = "1")]
    pub error_code: ::core::option::Option<ErrorCode>,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub trigger: ::core::option::Option<super::common::Value>,
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<ErrorLocation>,
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<ErrorDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ErrorCode {
    #[prost(
        oneof = "error_code::ErrorCode",
        tags = "1, 5, 9, 10, 11, 17, 33, 34, 35, 66, 118, 144, 175"
    )]
    pub error_code: ::core::option::Option<error_code::ErrorCode>,
}
/// Nested message and enum types in `ErrorCode`.
pub mod error_code {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ErrorCode {
        #[prost(enumeration = "super::request_error_enum::RequestError", tag = "1")]
        RequestError(i32),
        #[prost(enumeration = "super::query_error_enum::QueryError", tag = "5")]
        QueryError(i32),
        #[prost(
            enumeration = "super::authorization_error_enum::AuthorizationError",
            tag = "9"
        )]
        AuthorizationError(i32),
        #[prost(enumeration = "super::internal_error_enum::InternalError", tag = "10")]
        InternalError(i32),
        #[prost(enumeration = "super::quota_error_enum::QuotaError", tag = "11")]
        QuotaError(i32),
        #[prost(
            enumeration = "super::authentication_error_enum::AuthenticationError",
            tag = "17"
        )]
        AuthenticationError(i32),
        #[prost(enumeration = "super::date_error_enum::DateError", tag = "33")]
        DateError(i32),
        #[prost(
            enumeration = "super::date_range_error_enum::DateRangeError",
            tag = "34"
        )]
        DateRangeError(i32),
        #[prost(enumeration = "super::distinct_error_enum::DistinctError", tag = "35")]
        DistinctError(i32),
        #[prost(enumeration = "super::header_error_enum::HeaderError", tag = "66")]
        HeaderError(i32),
        #[prost(
            enumeration = "super::size_limit_error_enum::SizeLimitError",
            tag = "118"
        )]
        SizeLimitError(i32),
        #[prost(
            enumeration = "super::custom_column_error_enum::CustomColumnError",
            tag = "144"
        )]
        CustomColumnError(i32),
        #[prost(
            enumeration = "super::invalid_parameter_error_enum::InvalidParameterError",
            tag = "175"
        )]
        InvalidParameterError(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorLocation {
    #[prost(message, repeated, tag = "2")]
    pub field_path_elements: ::prost::alloc::vec::Vec<error_location::FieldPathElement>,
}
/// Nested message and enum types in `ErrorLocation`.
pub mod error_location {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldPathElement {
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        #[prost(int32, optional, tag = "3")]
        pub index: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
    #[prost(string, tag = "1")]
    pub unpublished_error_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub quota_error_details: ::core::option::Option<QuotaErrorDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuotaErrorDetails {
    #[prost(enumeration = "quota_error_details::QuotaRateScope", tag = "1")]
    pub rate_scope: i32,
    #[prost(string, tag = "2")]
    pub rate_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub retry_delay: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `QuotaErrorDetails`.
pub mod quota_error_details {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum QuotaRateScope {
        Unspecified = 0,
        Unknown = 1,
        Account = 2,
        Developer = 3,
    }
    impl QuotaRateScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QuotaRateScope::Unspecified => "UNSPECIFIED",
                QuotaRateScope::Unknown => "UNKNOWN",
                QuotaRateScope::Account => "ACCOUNT",
                QuotaRateScope::Developer => "DEVELOPER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT" => Some(Self::Account),
                "DEVELOPER" => Some(Self::Developer),
                _ => None,
            }
        }
    }
}
