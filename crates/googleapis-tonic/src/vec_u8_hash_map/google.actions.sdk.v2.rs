// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountLinkingSecret {
#[prost(bytes = "vec", tag = "1")]
pub encrypted_client_secret: ::prost::alloc::vec::Vec<u8>,
#[prost(string, tag = "2")]
pub encryption_key_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Actions {
#[prost(map = "string, message", tag = "3")]
pub custom: ::std::collections::HashMap<::prost::alloc::string::String, actions::CustomAction>,
}
/// Nested message and enum types in `Actions`.
pub mod actions {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Engagement {
#[prost(string, tag = "1")]
pub title: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub push_notification: ::core::option::Option<engagement::PushNotification>,
#[deprecated]
#[prost(message, optional, tag = "4")]
pub action_link: ::core::option::Option<engagement::ActionLink>,
#[prost(message, optional, tag = "6")]
pub assistant_link: ::core::option::Option<engagement::AssistantLink>,
#[prost(oneof = "engagement::RecurringUpdate", tags = "3")]
pub recurring_update: ::core::option::Option<engagement::RecurringUpdate>,
}
/// Nested message and enum types in `Engagement`.
pub mod engagement {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PushNotification {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyUpdate {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionLink {
#[prost(string, tag = "1")]
pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssistantLink {
#[prost(string, tag = "1")]
pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum RecurringUpdate {
#[prost(message, tag = "3")]
DailyUpdate(DailyUpdate),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAction {
#[prost(message, optional, tag = "2")]
pub engagement: ::core::option::Option<Engagement>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
#[prost(string, tag = "1")]
pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountLinking {
#[prost(bool, tag = "1")]
pub enable_account_creation: bool,
#[prost(enumeration = "account_linking::LinkingType", tag = "2")]
pub linking_type: i32,
#[prost(enumeration = "account_linking::AuthGrantType", tag = "3")]
pub auth_grant_type: i32,
#[prost(string, tag = "4")]
pub app_client_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub authorization_url: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub token_url: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "7")]
pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "8")]
pub learn_more_url: ::prost::alloc::string::String,
#[prost(bool, tag = "9")]
pub use_basic_auth_header: bool,
}
/// Nested message and enum types in `AccountLinking`.
pub mod account_linking {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkingType {
Unspecified = 0,
GoogleSignIn = 1,
OauthAndGoogleSignIn = 2,
Oauth = 3,
}
impl LinkingType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LinkingType::Unspecified => "LINKING_TYPE_UNSPECIFIED",
LinkingType::GoogleSignIn => "GOOGLE_SIGN_IN",
LinkingType::OauthAndGoogleSignIn => "OAUTH_AND_GOOGLE_SIGN_IN",
LinkingType::Oauth => "OAUTH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LINKING_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"GOOGLE_SIGN_IN" => Some(Self::GoogleSignIn),
"OAUTH_AND_GOOGLE_SIGN_IN" => Some(Self::OauthAndGoogleSignIn),
"OAUTH" => Some(Self::Oauth),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthGrantType {
Unspecified = 0,
AuthCode = 1,
Implicit = 2,
}
impl AuthGrantType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AuthGrantType::Unspecified => "AUTH_GRANT_TYPE_UNSPECIFIED",
AuthGrantType::AuthCode => "AUTH_CODE",
AuthGrantType::Implicit => "IMPLICIT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"AUTH_GRANT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"AUTH_CODE" => Some(Self::AuthCode),
"IMPLICIT" => Some(Self::Implicit),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThemeCustomization {
#[prost(string, tag = "1")]
pub background_color: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub primary_color: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub font_family: ::prost::alloc::string::String,
#[prost(enumeration = "theme_customization::ImageCornerStyle", tag = "4")]
pub image_corner_style: i32,
#[prost(string, tag = "5")]
pub landscape_background_image: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub portrait_background_image: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ThemeCustomization`.
pub mod theme_customization {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImageCornerStyle {
Unspecified = 0,
Curved = 1,
Angled = 2,
}
impl ImageCornerStyle {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ImageCornerStyle::Unspecified => "IMAGE_CORNER_STYLE_UNSPECIFIED",
ImageCornerStyle::Curved => "CURVED",
ImageCornerStyle::Angled => "ANGLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"IMAGE_CORNER_STYLE_UNSPECIFIED" => Some(Self::Unspecified),
"CURVED" => Some(Self::Curved),
"ANGLED" => Some(Self::Angled),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizedSettings {
#[prost(string, tag = "1")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub pronunciation: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub short_description: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub full_description: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub small_logo_image: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub large_banner_image: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub developer_name: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub developer_email: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub terms_of_service_url: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub voice: ::prost::alloc::string::String,
#[prost(string, tag = "14")]
pub voice_locale: ::prost::alloc::string::String,
#[prost(string, tag = "11")]
pub privacy_policy_url: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "12")]
pub sample_invocations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "13")]
pub theme_customization: ::core::option::Option<ThemeCustomization>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SurfaceRequirements {
#[prost(message, repeated, tag = "1")]
pub minimum_requirements: ::prost::alloc::vec::Vec<CapabilityRequirement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CapabilityRequirement {
#[prost(enumeration = "capability_requirement::SurfaceCapability", tag = "1")]
pub capability: i32,
}
/// Nested message and enum types in `CapabilityRequirement`.
pub mod capability_requirement {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SurfaceCapability {
Unspecified = 0,
AudioOutput = 1,
ScreenOutput = 2,
MediaResponseAudio = 3,
WebBrowser = 4,
AccountLinking = 7,
InteractiveCanvas = 8,
HomeStorage = 9,
}
impl SurfaceCapability {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SurfaceCapability::Unspecified => "SURFACE_CAPABILITY_UNSPECIFIED",
SurfaceCapability::AudioOutput => "AUDIO_OUTPUT",
SurfaceCapability::ScreenOutput => "SCREEN_OUTPUT",
SurfaceCapability::MediaResponseAudio => "MEDIA_RESPONSE_AUDIO",
SurfaceCapability::WebBrowser => "WEB_BROWSER",
SurfaceCapability::AccountLinking => "ACCOUNT_LINKING",
SurfaceCapability::InteractiveCanvas => "INTERACTIVE_CANVAS",
SurfaceCapability::HomeStorage => "HOME_STORAGE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SURFACE_CAPABILITY_UNSPECIFIED" => Some(Self::Unspecified),
"AUDIO_OUTPUT" => Some(Self::AudioOutput),
"SCREEN_OUTPUT" => Some(Self::ScreenOutput),
"MEDIA_RESPONSE_AUDIO" => Some(Self::MediaResponseAudio),
"WEB_BROWSER" => Some(Self::WebBrowser),
"ACCOUNT_LINKING" => Some(Self::AccountLinking),
"INTERACTIVE_CANVAS" => Some(Self::InteractiveCanvas),
"HOME_STORAGE" => Some(Self::HomeStorage),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub default_locale: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub enabled_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub disabled_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "settings::Category", tag = "5")]
pub category: i32,
#[prost(bool, tag = "6")]
pub uses_transactions_api: bool,
#[prost(bool, tag = "7")]
pub uses_digital_purchase_api: bool,
#[prost(bool, tag = "8")]
pub uses_interactive_canvas: bool,
#[prost(bool, tag = "17")]
pub uses_home_storage: bool,
#[prost(bool, tag = "9")]
pub designed_for_family: bool,
#[prost(bool, tag = "11")]
pub contains_alcohol_or_tobacco_content: bool,
#[prost(bool, tag = "12")]
pub keeps_mic_open: bool,
#[prost(message, optional, tag = "13")]
pub surface_requirements: ::core::option::Option<SurfaceRequirements>,
#[prost(string, tag = "14")]
pub testing_instructions: ::prost::alloc::string::String,
#[prost(message, optional, tag = "15")]
pub localized_settings: ::core::option::Option<LocalizedSettings>,
#[prost(message, optional, tag = "16")]
pub account_linking: ::core::option::Option<AccountLinking>,
#[prost(string, repeated, tag = "20")]
pub selected_android_apps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Settings`.
pub mod settings {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Category {
Unspecified = 0,
BusinessAndFinance = 2,
EducationAndReference = 3,
FoodAndDrink = 4,
GamesAndTrivia = 5,
HealthAndFitness = 6,
KidsAndFamily = 20,
Lifestyle = 7,
Local = 8,
MoviesAndTv = 9,
MusicAndAudio = 10,
News = 1,
NoveltyAndHumor = 11,
Productivity = 12,
Shopping = 13,
Social = 14,
Sports = 15,
TravelAndTransportation = 16,
Utilities = 17,
Weather = 18,
HomeControl = 19,
}
impl Category {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Category::Unspecified => "CATEGORY_UNSPECIFIED",
Category::BusinessAndFinance => "BUSINESS_AND_FINANCE",
Category::EducationAndReference => "EDUCATION_AND_REFERENCE",
Category::FoodAndDrink => "FOOD_AND_DRINK",
Category::GamesAndTrivia => "GAMES_AND_TRIVIA",
Category::HealthAndFitness => "HEALTH_AND_FITNESS",
Category::KidsAndFamily => "KIDS_AND_FAMILY",
Category::Lifestyle => "LIFESTYLE",
Category::Local => "LOCAL",
Category::MoviesAndTv => "MOVIES_AND_TV",
Category::MusicAndAudio => "MUSIC_AND_AUDIO",
Category::News => "NEWS",
Category::NoveltyAndHumor => "NOVELTY_AND_HUMOR",
Category::Productivity => "PRODUCTIVITY",
Category::Shopping => "SHOPPING",
Category::Social => "SOCIAL",
Category::Sports => "SPORTS",
Category::TravelAndTransportation => "TRAVEL_AND_TRANSPORTATION",
Category::Utilities => "UTILITIES",
Category::Weather => "WEATHER",
Category::HomeControl => "HOME_CONTROL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
"BUSINESS_AND_FINANCE" => Some(Self::BusinessAndFinance),
"EDUCATION_AND_REFERENCE" => Some(Self::EducationAndReference),
"FOOD_AND_DRINK" => Some(Self::FoodAndDrink),
"GAMES_AND_TRIVIA" => Some(Self::GamesAndTrivia),
"HEALTH_AND_FITNESS" => Some(Self::HealthAndFitness),
"KIDS_AND_FAMILY" => Some(Self::KidsAndFamily),
"LIFESTYLE" => Some(Self::Lifestyle),
"LOCAL" => Some(Self::Local),
"MOVIES_AND_TV" => Some(Self::MoviesAndTv),
"MUSIC_AND_AUDIO" => Some(Self::MusicAndAudio),
"NEWS" => Some(Self::News),
"NOVELTY_AND_HUMOR" => Some(Self::NoveltyAndHumor),
"PRODUCTIVITY" => Some(Self::Productivity),
"SHOPPING" => Some(Self::Shopping),
"SOCIAL" => Some(Self::Social),
"SPORTS" => Some(Self::Sports),
"TRAVEL_AND_TRANSPORTATION" => Some(Self::TravelAndTransportation),
"UTILITIES" => Some(Self::Utilities),
"WEATHER" => Some(Self::Weather),
"HOME_CONTROL" => Some(Self::HomeControl),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Webhook {
#[prost(message, repeated, tag = "1")]
pub handlers: ::prost::alloc::vec::Vec<webhook::Handler>,
#[prost(oneof = "webhook::WebhookType", tags = "2, 3")]
pub webhook_type: ::core::option::Option<webhook::WebhookType>,
}
/// Nested message and enum types in `Webhook`.
pub mod webhook {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Handler {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpsEndpoint {
#[prost(string, tag = "1")]
pub base_url: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "2")]
pub http_headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(int32, tag = "3")]
pub endpoint_api_version: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineCloudFunction {
#[prost(string, tag = "1")]
pub execute_function: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum WebhookType {
#[prost(message, tag = "2")]
HttpsEndpoint(HttpsEndpoint),
#[prost(message, tag = "3")]
InlineCloudFunction(InlineCloudFunction),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigFiles {
#[prost(message, repeated, tag = "1")]
pub config_files: ::prost::alloc::vec::Vec<ConfigFile>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigFile {
#[prost(string, tag = "1")]
pub file_path: ::prost::alloc::string::String,
#[prost(oneof = "config_file::File", tags = "2, 3, 4, 6, 7, 8, 15, 9, 10, 11, 13, 12")]
pub file: ::core::option::Option<config_file::File>,
}
/// Nested message and enum types in `ConfigFile`.
pub mod config_file {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum File {
#[prost(message, tag = "2")]
Manifest(super::Manifest),
#[prost(message, tag = "3")]
Actions(super::Actions),
#[prost(message, tag = "4")]
Settings(super::Settings),
#[prost(message, tag = "6")]
Webhook(super::Webhook),
#[prost(message, tag = "7")]
Intent(super::interactionmodel::Intent),
#[prost(message, tag = "8")]
Type(super::interactionmodel::r#type::Type),
#[prost(message, tag = "15")]
EntitySet(super::interactionmodel::EntitySet),
#[prost(message, tag = "9")]
GlobalIntentEvent(super::interactionmodel::GlobalIntentEvent),
#[prost(message, tag = "10")]
Scene(super::interactionmodel::Scene),
#[prost(message, tag = "11")]
StaticPrompt(super::interactionmodel::prompt::StaticPrompt),
#[prost(message, tag = "13")]
AccountLinkingSecret(super::AccountLinkingSecret),
#[prost(message, tag = "12")]
ResourceBundle(::prost_types::Struct),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataFiles {
#[prost(message, repeated, tag = "1")]
pub data_files: ::prost::alloc::vec::Vec<DataFile>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataFile {
#[prost(string, tag = "1")]
pub file_path: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content_type: ::prost::alloc::string::String,
#[prost(bytes = "vec", tag = "3")]
pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Files {
#[prost(oneof = "files::FileType", tags = "1, 2")]
pub file_type: ::core::option::Option<files::FileType>,
}
/// Nested message and enum types in `Files`.
pub mod files {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum FileType {
#[prost(message, tag = "1")]
ConfigFiles(super::ConfigFiles),
#[prost(message, tag = "2")]
DataFiles(super::DataFiles),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseChannel {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub current_version: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub pending_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationResults {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<ValidationResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationResult {
#[prost(string, tag = "1")]
pub validation_message: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub validation_context: ::core::option::Option<validation_result::ValidationContext>,
}
/// Nested message and enum types in `ValidationResult`.
pub mod validation_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationContext {
#[prost(string, tag = "1")]
pub language_code: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub version_state: ::core::option::Option<version::VersionState>,
#[prost(string, tag = "3")]
pub creator: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Version`.
pub mod version {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionState {
#[prost(enumeration = "version_state::State", tag = "1")]
pub state: i32,
#[prost(string, tag = "2")]
pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `VersionState`.
pub mod version_state {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
CreationInProgress = 1,
CreationFailed = 2,
Created = 3,
ReviewInProgress = 4,
Approved = 5,
ConditionallyApproved = 6,
Denied = 7,
UnderTakedown = 8,
Deleted = 9,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::CreationInProgress => "CREATION_IN_PROGRESS",
State::CreationFailed => "CREATION_FAILED",
State::Created => "CREATED",
State::ReviewInProgress => "REVIEW_IN_PROGRESS",
State::Approved => "APPROVED",
State::ConditionallyApproved => "CONDITIONALLY_APPROVED",
State::Denied => "DENIED",
State::UnderTakedown => "UNDER_TAKEDOWN",
State::Deleted => "DELETED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATION_IN_PROGRESS" => Some(Self::CreationInProgress),
"CREATION_FAILED" => Some(Self::CreationFailed),
"CREATED" => Some(Self::Created),
"REVIEW_IN_PROGRESS" => Some(Self::ReviewInProgress),
"APPROVED" => Some(Self::Approved),
"CONDITIONALLY_APPROVED" => Some(Self::ConditionallyApproved),
"DENIED" => Some(Self::Denied),
"UNDER_TAKEDOWN" => Some(Self::UnderTakedown),
"DELETED" => Some(Self::Deleted),
_ => None,
}
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteDraftRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub files: ::core::option::Option<Files>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Draft {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub validation_results: ::core::option::Option<ValidationResults>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WritePreviewRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub preview_settings: ::core::option::Option<write_preview_request::PreviewSettings>,
#[prost(oneof = "write_preview_request::Source", tags = "5, 6, 7")]
pub source: ::core::option::Option<write_preview_request::Source>,
}
/// Nested message and enum types in `WritePreviewRequest`.
pub mod write_preview_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContentFromDraft {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentFromSubmittedVersion {
#[prost(string, tag = "1")]
pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PreviewSettings {
#[prost(message, optional, tag = "1")]
pub sandbox: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "5")]
Files(super::Files),
#[prost(message, tag = "6")]
Draft(ContentFromDraft),
#[prost(message, tag = "7")]
SubmittedVersion(ContentFromSubmittedVersion),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Preview {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub validation_results: ::core::option::Option<ValidationResults>,
#[prost(string, tag = "3")]
pub simulator_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVersionRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub files: ::core::option::Option<Files>,
#[prost(string, tag = "4")]
pub release_channel: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadDraftRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub client_secret_encryption_key_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadDraftResponse {
#[prost(message, optional, tag = "3")]
pub files: ::core::option::Option<Files>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadVersionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub client_secret_encryption_key_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadVersionResponse {
#[prost(message, optional, tag = "1")]
pub files: ::core::option::Option<Files>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptSecretRequest {
#[prost(string, tag = "1")]
pub client_secret: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptSecretResponse {
#[prost(message, optional, tag = "1")]
pub account_linking_secret: ::core::option::Option<AccountLinkingSecret>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptSecretRequest {
#[prost(bytes = "vec", tag = "1")]
pub encrypted_client_secret: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptSecretResponse {
#[prost(string, tag = "1")]
pub client_secret: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSampleProjectsRequest {
#[prost(int32, tag = "1")]
pub page_size: i32,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSampleProjectsResponse {
#[prost(message, repeated, tag = "1")]
pub sample_projects: ::prost::alloc::vec::Vec<SampleProject>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleProject {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub hosted_url: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleaseChannelsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleaseChannelsResponse {
#[prost(message, repeated, tag = "1")]
pub release_channels: ::prost::alloc::vec::Vec<ReleaseChannel>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsResponse {
#[prost(message, repeated, tag = "1")]
pub versions: ::prost::alloc::vec::Vec<Version>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod actions_sdk_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Actions SDK API which allows developers to build projects using the SDK.
#[derive(Debug, Clone)]
pub struct ActionsSdkClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ActionsSdkClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ActionsSdkClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ActionsSdkClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Updates the project draft based on the model.
pub async fn write_draft(&mut self, request: impl tonic::IntoStreamingRequest<Message = super::WriteDraftRequest>) -> std::result::Result<tonic::Response<super::Draft>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/WriteDraft");
let mut req = request.into_streaming_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "WriteDraft"));
self.inner.client_streaming(req, path, codec).await
}
/// Updates the user's project preview based on the model.
pub async fn write_preview(&mut self, request: impl tonic::IntoStreamingRequest<Message = super::WritePreviewRequest>) -> std::result::Result<tonic::Response<super::Preview>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/WritePreview");
let mut req = request.into_streaming_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "WritePreview"));
self.inner.client_streaming(req, path, codec).await
}
/// Creates a project version based on the model and triggers deployment to the
/// specified release channel, if specified.
pub async fn create_version(&mut self, request: impl tonic::IntoStreamingRequest<Message = super::CreateVersionRequest>) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/CreateVersion");
let mut req = request.into_streaming_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "CreateVersion"));
self.inner.client_streaming(req, path, codec).await
}
/// Reads the entire content of the project draft.
pub async fn read_draft(&mut self, request: impl tonic::IntoRequest<super::ReadDraftRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::ReadDraftResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/ReadDraft");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "ReadDraft"));
self.inner.server_streaming(req, path, codec).await
}
/// Reads the entire content of a project version.
pub async fn read_version(&mut self, request: impl tonic::IntoRequest<super::ReadVersionRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::ReadVersionResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/ReadVersion");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "ReadVersion"));
self.inner.server_streaming(req, path, codec).await
}
/// Encrypts the OAuth client secret used in account linking flows.
/// This can be used to encrypt the client secret for the first time (e.g.
/// before the first push or after changing the client secret) or to re-encrypt
/// a client secret using the latest primary key version (considering key
/// rotation).
pub async fn encrypt_secret(&mut self, request: impl tonic::IntoRequest<super::EncryptSecretRequest>) -> std::result::Result<tonic::Response<super::EncryptSecretResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/EncryptSecret");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "EncryptSecret"));
self.inner.unary(req, path, codec).await
}
/// Decrypts the OAuth client secret used in account linking flows.
/// This can be used to view the client secret (e.g. after pulling a project).
pub async fn decrypt_secret(&mut self, request: impl tonic::IntoRequest<super::DecryptSecretRequest>) -> std::result::Result<tonic::Response<super::DecryptSecretResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/DecryptSecret");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "DecryptSecret"));
self.inner.unary(req, path, codec).await
}
/// Lists all the sample projects supported by the gactions CLI.
pub async fn list_sample_projects(&mut self, request: impl tonic::IntoRequest<super::ListSampleProjectsRequest>) -> std::result::Result<tonic::Response<super::ListSampleProjectsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/ListSampleProjects");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "ListSampleProjects"));
self.inner.unary(req, path, codec).await
}
/// Lists all release channels and corresponding versions, if any.
pub async fn list_release_channels(&mut self, request: impl tonic::IntoRequest<super::ListReleaseChannelsRequest>) -> std::result::Result<tonic::Response<super::ListReleaseChannelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/ListReleaseChannels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "ListReleaseChannels"));
self.inner.unary(req, path, codec).await
}
/// Lists all versions and their current states.
pub async fn list_versions(&mut self, request: impl tonic::IntoRequest<super::ListVersionsRequest>) -> std::result::Result<tonic::Response<super::ListVersionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsSdk/ListVersions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsSdk", "ListVersions"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionEvent {
#[prost(message, optional, tag = "1")]
pub event_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub execution_state: ::core::option::Option<ExecutionState>,
#[prost(message, optional, tag = "3")]
pub status: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(string, repeated, tag = "17")]
pub warning_messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(oneof = "execution_event::EventData", tags = "4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16")]
pub event_data: ::core::option::Option<execution_event::EventData>,
}
/// Nested message and enum types in `ExecutionEvent`.
pub mod execution_event {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EventData {
#[prost(message, tag = "4")]
UserInput(super::UserConversationInput),
#[prost(message, tag = "5")]
IntentMatch(super::IntentMatch),
#[prost(message, tag = "6")]
ConditionsEvaluated(super::ConditionsEvaluated),
#[prost(message, tag = "7")]
OnSceneEnter(super::OnSceneEnter),
#[prost(message, tag = "8")]
WebhookRequest(super::WebhookRequest),
#[prost(message, tag = "9")]
WebhookResponse(super::WebhookResponse),
#[prost(message, tag = "10")]
WebhookInitiatedTransition(super::WebhookInitiatedTransition),
#[prost(message, tag = "11")]
SlotMatch(super::SlotMatch),
#[prost(message, tag = "12")]
SlotRequested(super::SlotRequested),
#[prost(message, tag = "13")]
SlotValidated(super::SlotValidated),
#[prost(message, tag = "14")]
FormFilled(super::FormFilled),
#[prost(message, tag = "15")]
WaitingUserInput(super::WaitingForUserInput),
#[prost(message, tag = "16")]
EndConversation(super::EndConversation),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionState {
#[prost(string, tag = "1")]
pub current_scene_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub session_storage: ::core::option::Option<::prost_types::Struct>,
#[prost(message, optional, tag = "5")]
pub slots: ::core::option::Option<Slots>,
#[prost(message, repeated, tag = "7")]
pub prompt_queue: ::prost::alloc::vec::Vec<conversation::Prompt>,
#[prost(message, optional, tag = "6")]
pub user_storage: ::core::option::Option<::prost_types::Struct>,
#[prost(message, optional, tag = "8")]
pub household_storage: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Slots {
#[prost(enumeration = "conversation::SlotFillingStatus", tag = "2")]
pub status: i32,
#[prost(map = "string, message", tag = "3")]
pub slots: ::std::collections::HashMap<::prost::alloc::string::String, conversation::Slot>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserConversationInput {
#[prost(string, tag = "1")]
pub r#type: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub original_query: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentMatch {
#[prost(string, tag = "1")]
pub intent_id: ::prost::alloc::string::String,
#[prost(map = "string, message", tag = "5")]
pub intent_parameters: ::std::collections::HashMap<::prost::alloc::string::String, conversation::IntentParameterValue>,
#[prost(string, tag = "3")]
pub handler: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub next_scene_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionsEvaluated {
#[prost(message, repeated, tag = "1")]
pub failed_conditions: ::prost::alloc::vec::Vec<Condition>,
#[prost(message, optional, tag = "2")]
pub success_condition: ::core::option::Option<Condition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
#[prost(string, tag = "1")]
pub expression: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub handler: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub next_scene_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnSceneEnter {
#[prost(string, tag = "1")]
pub handler: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookInitiatedTransition {
#[prost(string, tag = "1")]
pub next_scene_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookRequest {
#[prost(string, tag = "1")]
pub request_json: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookResponse {
#[prost(string, tag = "1")]
pub response_json: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlotMatch {
#[prost(map = "string, message", tag = "2")]
pub nlu_parameters: ::std::collections::HashMap<::prost::alloc::string::String, conversation::IntentParameterValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlotRequested {
#[prost(string, tag = "1")]
pub slot: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub prompt: ::core::option::Option<conversation::Prompt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SlotValidated {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FormFilled {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WaitingForUserInput {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EndConversation {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendInteractionRequest {
#[prost(string, tag = "1")]
pub project: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub input: ::core::option::Option<UserInput>,
#[prost(message, optional, tag = "3")]
pub device_properties: ::core::option::Option<DeviceProperties>,
#[prost(string, tag = "4")]
pub conversation_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInput {
#[prost(string, tag = "1")]
pub query: ::prost::alloc::string::String,
#[prost(enumeration = "user_input::InputType", tag = "2")]
pub r#type: i32,
}
/// Nested message and enum types in `UserInput`.
pub mod user_input {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InputType {
Unspecified = 0,
Touch = 1,
Voice = 2,
Keyboard = 3,
Url = 4,
}
impl InputType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
InputType::Unspecified => "INPUT_TYPE_UNSPECIFIED",
InputType::Touch => "TOUCH",
InputType::Voice => "VOICE",
InputType::Keyboard => "KEYBOARD",
InputType::Url => "URL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INPUT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"TOUCH" => Some(Self::Touch),
"VOICE" => Some(Self::Voice),
"KEYBOARD" => Some(Self::Keyboard),
"URL" => Some(Self::Url),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceProperties {
#[prost(enumeration = "device_properties::Surface", tag = "1")]
pub surface: i32,
#[prost(message, optional, tag = "2")]
pub location: ::core::option::Option<Location>,
#[prost(string, tag = "3")]
pub locale: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub time_zone: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DeviceProperties`.
pub mod device_properties {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Surface {
Unspecified = 0,
Speaker = 1,
Phone = 2,
Allo = 3,
SmartDisplay = 4,
KaiOs = 5,
}
impl Surface {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Surface::Unspecified => "SURFACE_UNSPECIFIED",
Surface::Speaker => "SPEAKER",
Surface::Phone => "PHONE",
Surface::Allo => "ALLO",
Surface::SmartDisplay => "SMART_DISPLAY",
Surface::KaiOs => "KAI_OS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SURFACE_UNSPECIFIED" => Some(Self::Unspecified),
"SPEAKER" => Some(Self::Speaker),
"PHONE" => Some(Self::Phone),
"ALLO" => Some(Self::Allo),
"SMART_DISPLAY" => Some(Self::SmartDisplay),
"KAI_OS" => Some(Self::KaiOs),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Location {
#[prost(message, optional, tag = "1")]
pub coordinates: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(string, tag = "2")]
pub formatted_address: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub zip_code: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub city: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendInteractionResponse {
#[prost(message, optional, tag = "1")]
pub output: ::core::option::Option<Output>,
#[prost(message, optional, tag = "2")]
pub diagnostics: ::core::option::Option<Diagnostics>,
#[prost(string, tag = "3")]
pub conversation_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
#[prost(string, tag = "1")]
pub text: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub speech: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub canvas: ::core::option::Option<conversation::Canvas>,
#[prost(message, optional, tag = "4")]
pub actions_builder_prompt: ::core::option::Option<conversation::Prompt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Diagnostics {
#[prost(message, repeated, tag = "1")]
pub actions_builder_events: ::prost::alloc::vec::Vec<ExecutionEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchIntentsRequest {
#[prost(string, tag = "1")]
pub project: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub locale: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchIntentsResponse {
#[prost(message, repeated, tag = "1")]
pub matched_intents: ::prost::alloc::vec::Vec<conversation::Intent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetWebAndAppActivityControlRequest {
#[prost(bool, tag = "1")]
pub enabled: bool,
}
/// Generated client implementations.
pub mod actions_testing_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Actions Testing API which allows developers to run automated tests.
#[derive(Debug, Clone)]
pub struct ActionsTestingClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ActionsTestingClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ActionsTestingClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ActionsTestingClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Plays one round of the conversation.
pub async fn send_interaction(&mut self, request: impl tonic::IntoRequest<super::SendInteractionRequest>) -> std::result::Result<tonic::Response<super::SendInteractionResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsTesting/SendInteraction");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsTesting", "SendInteraction"));
self.inner.unary(req, path, codec).await
}
/// Finds the intents that match a given query.
pub async fn match_intents(&mut self, request: impl tonic::IntoRequest<super::MatchIntentsRequest>) -> std::result::Result<tonic::Response<super::MatchIntentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsTesting/MatchIntents");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsTesting", "MatchIntents"));
self.inner.unary(req, path, codec).await
}
/// Sets the Web & App Activity control on a service account.
///
/// It is necessary to have this setting enabled in order to use call Actions.
/// The setting is originally disabled for service accounts, and it is
/// preserved until set to a different value. This means it only needs to be
/// enabled once per account (and not necessarily once per test), unless it is
/// later disabled.
///
/// Returns an error if the caller is not a service account. User accounts can
/// change this setting via the Activity Controls page. See
/// https://support.google.com/websearch/answer/54068.
pub async fn set_web_and_app_activity_control(&mut self, request: impl tonic::IntoRequest<super::SetWebAndAppActivityControlRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.actions.sdk.v2.ActionsTesting/SetWebAndAppActivityControl");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.actions.sdk.v2.ActionsTesting", "SetWebAndAppActivityControl"));
self.inner.unary(req, path, codec).await
}
}
}
