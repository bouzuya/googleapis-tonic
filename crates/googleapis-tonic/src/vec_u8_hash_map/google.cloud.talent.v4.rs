// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimestampRange {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Location {
#[prost(enumeration = "location::LocationType", tag = "1")]
pub location_type: i32,
#[prost(message, optional, tag = "2")]
pub postal_address: ::core::option::Option<super::super::super::r#type::PostalAddress>,
#[prost(message, optional, tag = "3")]
pub lat_lng: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(double, tag = "4")]
pub radius_miles: f64,
}
/// Nested message and enum types in `Location`.
pub mod location {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LocationType {
Unspecified = 0,
Country = 1,
AdministrativeArea = 2,
SubAdministrativeArea = 3,
Locality = 4,
PostalCode = 5,
SubLocality = 6,
SubLocality1 = 7,
SubLocality2 = 8,
Neighborhood = 9,
StreetAddress = 10,
}
impl LocationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LocationType::Unspecified => "LOCATION_TYPE_UNSPECIFIED",
LocationType::Country => "COUNTRY",
LocationType::AdministrativeArea => "ADMINISTRATIVE_AREA",
LocationType::SubAdministrativeArea => "SUB_ADMINISTRATIVE_AREA",
LocationType::Locality => "LOCALITY",
LocationType::PostalCode => "POSTAL_CODE",
LocationType::SubLocality => "SUB_LOCALITY",
LocationType::SubLocality1 => "SUB_LOCALITY_1",
LocationType::SubLocality2 => "SUB_LOCALITY_2",
LocationType::Neighborhood => "NEIGHBORHOOD",
LocationType::StreetAddress => "STREET_ADDRESS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOCATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"COUNTRY" => Some(Self::Country),
"ADMINISTRATIVE_AREA" => Some(Self::AdministrativeArea),
"SUB_ADMINISTRATIVE_AREA" => Some(Self::SubAdministrativeArea),
"LOCALITY" => Some(Self::Locality),
"POSTAL_CODE" => Some(Self::PostalCode),
"SUB_LOCALITY" => Some(Self::SubLocality),
"SUB_LOCALITY_1" => Some(Self::SubLocality1),
"SUB_LOCALITY_2" => Some(Self::SubLocality2),
"NEIGHBORHOOD" => Some(Self::Neighborhood),
"STREET_ADDRESS" => Some(Self::StreetAddress),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestMetadata {
#[prost(string, tag = "1")]
pub domain: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub session_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub user_id: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub allow_missing_ids: bool,
#[prost(message, optional, tag = "5")]
pub device_info: ::core::option::Option<DeviceInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseMetadata {
#[prost(string, tag = "1")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
#[prost(enumeration = "device_info::DeviceType", tag = "1")]
pub device_type: i32,
#[prost(string, tag = "2")]
pub id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DeviceInfo`.
pub mod device_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceType {
Unspecified = 0,
Web = 1,
MobileWeb = 2,
Android = 3,
Ios = 4,
Bot = 5,
Other = 6,
}
impl DeviceType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DeviceType::Unspecified => "DEVICE_TYPE_UNSPECIFIED",
DeviceType::Web => "WEB",
DeviceType::MobileWeb => "MOBILE_WEB",
DeviceType::Android => "ANDROID",
DeviceType::Ios => "IOS",
DeviceType::Bot => "BOT",
DeviceType::Other => "OTHER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DEVICE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"WEB" => Some(Self::Web),
"MOBILE_WEB" => Some(Self::MobileWeb),
"ANDROID" => Some(Self::Android),
"IOS" => Some(Self::Ios),
"BOT" => Some(Self::Bot),
"OTHER" => Some(Self::Other),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAttribute {
#[prost(string, repeated, tag = "1")]
pub string_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int64, repeated, tag = "2")]
pub long_values: ::prost::alloc::vec::Vec<i64>,
#[prost(bool, tag = "3")]
pub filterable: bool,
#[prost(bool, tag = "4")]
pub keyword_searchable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpellingCorrection {
#[prost(bool, tag = "1")]
pub corrected: bool,
#[prost(string, tag = "2")]
pub corrected_text: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub corrected_html: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationInfo {
#[prost(message, repeated, tag = "1")]
pub entries: ::prost::alloc::vec::Vec<compensation_info::CompensationEntry>,
#[prost(message, optional, tag = "2")]
pub annualized_base_compensation_range: ::core::option::Option<compensation_info::CompensationRange>,
#[prost(message, optional, tag = "3")]
pub annualized_total_compensation_range: ::core::option::Option<compensation_info::CompensationRange>,
}
/// Nested message and enum types in `CompensationInfo`.
pub mod compensation_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationEntry {
#[prost(enumeration = "CompensationType", tag = "1")]
pub r#type: i32,
#[prost(enumeration = "CompensationUnit", tag = "2")]
pub unit: i32,
#[prost(string, tag = "5")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub expected_units_per_year: ::core::option::Option<f64>,
#[prost(oneof = "compensation_entry::CompensationAmount", tags = "3, 4")]
pub compensation_amount: ::core::option::Option<compensation_entry::CompensationAmount>,
}
/// Nested message and enum types in `CompensationEntry`.
pub mod compensation_entry {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum CompensationAmount {
#[prost(message, tag = "3")]
Amount(super::super::super::super::super::r#type::Money),
#[prost(message, tag = "4")]
Range(super::CompensationRange),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationRange {
#[prost(message, optional, tag = "2")]
pub max_compensation: ::core::option::Option<super::super::super::super::r#type::Money>,
#[prost(message, optional, tag = "1")]
pub min_compensation: ::core::option::Option<super::super::super::super::r#type::Money>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompensationType {
Unspecified = 0,
Base = 1,
Bonus = 2,
SigningBonus = 3,
Equity = 4,
ProfitSharing = 5,
Commissions = 6,
Tips = 7,
OtherCompensationType = 8,
}
impl CompensationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CompensationType::Unspecified => "COMPENSATION_TYPE_UNSPECIFIED",
CompensationType::Base => "BASE",
CompensationType::Bonus => "BONUS",
CompensationType::SigningBonus => "SIGNING_BONUS",
CompensationType::Equity => "EQUITY",
CompensationType::ProfitSharing => "PROFIT_SHARING",
CompensationType::Commissions => "COMMISSIONS",
CompensationType::Tips => "TIPS",
CompensationType::OtherCompensationType => "OTHER_COMPENSATION_TYPE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMPENSATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"BASE" => Some(Self::Base),
"BONUS" => Some(Self::Bonus),
"SIGNING_BONUS" => Some(Self::SigningBonus),
"EQUITY" => Some(Self::Equity),
"PROFIT_SHARING" => Some(Self::ProfitSharing),
"COMMISSIONS" => Some(Self::Commissions),
"TIPS" => Some(Self::Tips),
"OTHER_COMPENSATION_TYPE" => Some(Self::OtherCompensationType),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompensationUnit {
Unspecified = 0,
Hourly = 1,
Daily = 2,
Weekly = 3,
Monthly = 4,
Yearly = 5,
OneTime = 6,
OtherCompensationUnit = 7,
}
impl CompensationUnit {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CompensationUnit::Unspecified => "COMPENSATION_UNIT_UNSPECIFIED",
CompensationUnit::Hourly => "HOURLY",
CompensationUnit::Daily => "DAILY",
CompensationUnit::Weekly => "WEEKLY",
CompensationUnit::Monthly => "MONTHLY",
CompensationUnit::Yearly => "YEARLY",
CompensationUnit::OneTime => "ONE_TIME",
CompensationUnit::OtherCompensationUnit => "OTHER_COMPENSATION_UNIT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMPENSATION_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
"HOURLY" => Some(Self::Hourly),
"DAILY" => Some(Self::Daily),
"WEEKLY" => Some(Self::Weekly),
"MONTHLY" => Some(Self::Monthly),
"YEARLY" => Some(Self::Yearly),
"ONE_TIME" => Some(Self::OneTime),
"OTHER_COMPENSATION_UNIT" => Some(Self::OtherCompensationUnit),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchOperationMetadata {
#[prost(enumeration = "batch_operation_metadata::State", tag = "1")]
pub state: i32,
#[prost(string, tag = "2")]
pub state_description: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub success_count: i32,
#[prost(int32, tag = "4")]
pub failure_count: i32,
#[prost(int32, tag = "5")]
pub total_count: i32,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `BatchOperationMetadata`.
pub mod batch_operation_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Initializing = 1,
Processing = 2,
Succeeded = 3,
Failed = 4,
Cancelling = 5,
Cancelled = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Initializing => "INITIALIZING",
State::Processing => "PROCESSING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Cancelling => "CANCELLING",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"INITIALIZING" => Some(Self::Initializing),
"PROCESSING" => Some(Self::Processing),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"CANCELLING" => Some(Self::Cancelling),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompanySize {
Unspecified = 0,
Mini = 1,
Small = 2,
Smedium = 3,
Medium = 4,
Big = 5,
Bigger = 6,
Giant = 7,
}
impl CompanySize {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CompanySize::Unspecified => "COMPANY_SIZE_UNSPECIFIED",
CompanySize::Mini => "MINI",
CompanySize::Small => "SMALL",
CompanySize::Smedium => "SMEDIUM",
CompanySize::Medium => "MEDIUM",
CompanySize::Big => "BIG",
CompanySize::Bigger => "BIGGER",
CompanySize::Giant => "GIANT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMPANY_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
"MINI" => Some(Self::Mini),
"SMALL" => Some(Self::Small),
"SMEDIUM" => Some(Self::Smedium),
"MEDIUM" => Some(Self::Medium),
"BIG" => Some(Self::Big),
"BIGGER" => Some(Self::Bigger),
"GIANT" => Some(Self::Giant),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobBenefit {
Unspecified = 0,
ChildCare = 1,
Dental = 2,
DomesticPartner = 3,
FlexibleHours = 4,
Medical = 5,
LifeInsurance = 6,
ParentalLeave = 7,
RetirementPlan = 8,
SickDays = 9,
Vacation = 10,
Vision = 11,
}
impl JobBenefit {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JobBenefit::Unspecified => "JOB_BENEFIT_UNSPECIFIED",
JobBenefit::ChildCare => "CHILD_CARE",
JobBenefit::Dental => "DENTAL",
JobBenefit::DomesticPartner => "DOMESTIC_PARTNER",
JobBenefit::FlexibleHours => "FLEXIBLE_HOURS",
JobBenefit::Medical => "MEDICAL",
JobBenefit::LifeInsurance => "LIFE_INSURANCE",
JobBenefit::ParentalLeave => "PARENTAL_LEAVE",
JobBenefit::RetirementPlan => "RETIREMENT_PLAN",
JobBenefit::SickDays => "SICK_DAYS",
JobBenefit::Vacation => "VACATION",
JobBenefit::Vision => "VISION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JOB_BENEFIT_UNSPECIFIED" => Some(Self::Unspecified),
"CHILD_CARE" => Some(Self::ChildCare),
"DENTAL" => Some(Self::Dental),
"DOMESTIC_PARTNER" => Some(Self::DomesticPartner),
"FLEXIBLE_HOURS" => Some(Self::FlexibleHours),
"MEDICAL" => Some(Self::Medical),
"LIFE_INSURANCE" => Some(Self::LifeInsurance),
"PARENTAL_LEAVE" => Some(Self::ParentalLeave),
"RETIREMENT_PLAN" => Some(Self::RetirementPlan),
"SICK_DAYS" => Some(Self::SickDays),
"VACATION" => Some(Self::Vacation),
"VISION" => Some(Self::Vision),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DegreeType {
Unspecified = 0,
PrimaryEducation = 1,
LowerSecondaryEducation = 2,
UpperSecondaryEducation = 3,
AdultRemedialEducation = 4,
AssociatesOrEquivalent = 5,
BachelorsOrEquivalent = 6,
MastersOrEquivalent = 7,
DoctoralOrEquivalent = 8,
}
impl DegreeType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DegreeType::Unspecified => "DEGREE_TYPE_UNSPECIFIED",
DegreeType::PrimaryEducation => "PRIMARY_EDUCATION",
DegreeType::LowerSecondaryEducation => "LOWER_SECONDARY_EDUCATION",
DegreeType::UpperSecondaryEducation => "UPPER_SECONDARY_EDUCATION",
DegreeType::AdultRemedialEducation => "ADULT_REMEDIAL_EDUCATION",
DegreeType::AssociatesOrEquivalent => "ASSOCIATES_OR_EQUIVALENT",
DegreeType::BachelorsOrEquivalent => "BACHELORS_OR_EQUIVALENT",
DegreeType::MastersOrEquivalent => "MASTERS_OR_EQUIVALENT",
DegreeType::DoctoralOrEquivalent => "DOCTORAL_OR_EQUIVALENT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DEGREE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PRIMARY_EDUCATION" => Some(Self::PrimaryEducation),
"LOWER_SECONDARY_EDUCATION" => Some(Self::LowerSecondaryEducation),
"UPPER_SECONDARY_EDUCATION" => Some(Self::UpperSecondaryEducation),
"ADULT_REMEDIAL_EDUCATION" => Some(Self::AdultRemedialEducation),
"ASSOCIATES_OR_EQUIVALENT" => Some(Self::AssociatesOrEquivalent),
"BACHELORS_OR_EQUIVALENT" => Some(Self::BachelorsOrEquivalent),
"MASTERS_OR_EQUIVALENT" => Some(Self::MastersOrEquivalent),
"DOCTORAL_OR_EQUIVALENT" => Some(Self::DoctoralOrEquivalent),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmploymentType {
Unspecified = 0,
FullTime = 1,
PartTime = 2,
Contractor = 3,
ContractToHire = 4,
Temporary = 5,
Intern = 6,
Volunteer = 7,
PerDiem = 8,
FlyInFlyOut = 9,
OtherEmploymentType = 10,
}
impl EmploymentType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EmploymentType::Unspecified => "EMPLOYMENT_TYPE_UNSPECIFIED",
EmploymentType::FullTime => "FULL_TIME",
EmploymentType::PartTime => "PART_TIME",
EmploymentType::Contractor => "CONTRACTOR",
EmploymentType::ContractToHire => "CONTRACT_TO_HIRE",
EmploymentType::Temporary => "TEMPORARY",
EmploymentType::Intern => "INTERN",
EmploymentType::Volunteer => "VOLUNTEER",
EmploymentType::PerDiem => "PER_DIEM",
EmploymentType::FlyInFlyOut => "FLY_IN_FLY_OUT",
EmploymentType::OtherEmploymentType => "OTHER_EMPLOYMENT_TYPE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EMPLOYMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"FULL_TIME" => Some(Self::FullTime),
"PART_TIME" => Some(Self::PartTime),
"CONTRACTOR" => Some(Self::Contractor),
"CONTRACT_TO_HIRE" => Some(Self::ContractToHire),
"TEMPORARY" => Some(Self::Temporary),
"INTERN" => Some(Self::Intern),
"VOLUNTEER" => Some(Self::Volunteer),
"PER_DIEM" => Some(Self::PerDiem),
"FLY_IN_FLY_OUT" => Some(Self::FlyInFlyOut),
"OTHER_EMPLOYMENT_TYPE" => Some(Self::OtherEmploymentType),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobLevel {
Unspecified = 0,
EntryLevel = 1,
Experienced = 2,
Manager = 3,
Director = 4,
Executive = 5,
}
impl JobLevel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JobLevel::Unspecified => "JOB_LEVEL_UNSPECIFIED",
JobLevel::EntryLevel => "ENTRY_LEVEL",
JobLevel::Experienced => "EXPERIENCED",
JobLevel::Manager => "MANAGER",
JobLevel::Director => "DIRECTOR",
JobLevel::Executive => "EXECUTIVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JOB_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
"ENTRY_LEVEL" => Some(Self::EntryLevel),
"EXPERIENCED" => Some(Self::Experienced),
"MANAGER" => Some(Self::Manager),
"DIRECTOR" => Some(Self::Director),
"EXECUTIVE" => Some(Self::Executive),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobCategory {
Unspecified = 0,
AccountingAndFinance = 1,
AdministrativeAndOffice = 2,
AdvertisingAndMarketing = 3,
AnimalCare = 4,
ArtFashionAndDesign = 5,
BusinessOperations = 6,
CleaningAndFacilities = 7,
ComputerAndIt = 8,
Construction = 9,
CustomerService = 10,
Education = 11,
EntertainmentAndTravel = 12,
FarmingAndOutdoors = 13,
Healthcare = 14,
HumanResources = 15,
InstallationMaintenanceAndRepair = 16,
Legal = 17,
Management = 18,
ManufacturingAndWarehouse = 19,
MediaCommunicationsAndWriting = 20,
OilGasAndMining = 21,
PersonalCareAndServices = 22,
ProtectiveServices = 23,
RealEstate = 24,
RestaurantAndHospitality = 25,
SalesAndRetail = 26,
ScienceAndEngineering = 27,
SocialServicesAndNonProfit = 28,
SportsFitnessAndRecreation = 29,
TransportationAndLogistics = 30,
}
impl JobCategory {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JobCategory::Unspecified => "JOB_CATEGORY_UNSPECIFIED",
JobCategory::AccountingAndFinance => "ACCOUNTING_AND_FINANCE",
JobCategory::AdministrativeAndOffice => "ADMINISTRATIVE_AND_OFFICE",
JobCategory::AdvertisingAndMarketing => "ADVERTISING_AND_MARKETING",
JobCategory::AnimalCare => "ANIMAL_CARE",
JobCategory::ArtFashionAndDesign => "ART_FASHION_AND_DESIGN",
JobCategory::BusinessOperations => "BUSINESS_OPERATIONS",
JobCategory::CleaningAndFacilities => "CLEANING_AND_FACILITIES",
JobCategory::ComputerAndIt => "COMPUTER_AND_IT",
JobCategory::Construction => "CONSTRUCTION",
JobCategory::CustomerService => "CUSTOMER_SERVICE",
JobCategory::Education => "EDUCATION",
JobCategory::EntertainmentAndTravel => "ENTERTAINMENT_AND_TRAVEL",
JobCategory::FarmingAndOutdoors => "FARMING_AND_OUTDOORS",
JobCategory::Healthcare => "HEALTHCARE",
JobCategory::HumanResources => "HUMAN_RESOURCES",
JobCategory::InstallationMaintenanceAndRepair => "INSTALLATION_MAINTENANCE_AND_REPAIR",
JobCategory::Legal => "LEGAL",
JobCategory::Management => "MANAGEMENT",
JobCategory::ManufacturingAndWarehouse => "MANUFACTURING_AND_WAREHOUSE",
JobCategory::MediaCommunicationsAndWriting => "MEDIA_COMMUNICATIONS_AND_WRITING",
JobCategory::OilGasAndMining => "OIL_GAS_AND_MINING",
JobCategory::PersonalCareAndServices => "PERSONAL_CARE_AND_SERVICES",
JobCategory::ProtectiveServices => "PROTECTIVE_SERVICES",
JobCategory::RealEstate => "REAL_ESTATE",
JobCategory::RestaurantAndHospitality => "RESTAURANT_AND_HOSPITALITY",
JobCategory::SalesAndRetail => "SALES_AND_RETAIL",
JobCategory::ScienceAndEngineering => "SCIENCE_AND_ENGINEERING",
JobCategory::SocialServicesAndNonProfit => "SOCIAL_SERVICES_AND_NON_PROFIT",
JobCategory::SportsFitnessAndRecreation => "SPORTS_FITNESS_AND_RECREATION",
JobCategory::TransportationAndLogistics => "TRANSPORTATION_AND_LOGISTICS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JOB_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
"ACCOUNTING_AND_FINANCE" => Some(Self::AccountingAndFinance),
"ADMINISTRATIVE_AND_OFFICE" => Some(Self::AdministrativeAndOffice),
"ADVERTISING_AND_MARKETING" => Some(Self::AdvertisingAndMarketing),
"ANIMAL_CARE" => Some(Self::AnimalCare),
"ART_FASHION_AND_DESIGN" => Some(Self::ArtFashionAndDesign),
"BUSINESS_OPERATIONS" => Some(Self::BusinessOperations),
"CLEANING_AND_FACILITIES" => Some(Self::CleaningAndFacilities),
"COMPUTER_AND_IT" => Some(Self::ComputerAndIt),
"CONSTRUCTION" => Some(Self::Construction),
"CUSTOMER_SERVICE" => Some(Self::CustomerService),
"EDUCATION" => Some(Self::Education),
"ENTERTAINMENT_AND_TRAVEL" => Some(Self::EntertainmentAndTravel),
"FARMING_AND_OUTDOORS" => Some(Self::FarmingAndOutdoors),
"HEALTHCARE" => Some(Self::Healthcare),
"HUMAN_RESOURCES" => Some(Self::HumanResources),
"INSTALLATION_MAINTENANCE_AND_REPAIR" => Some(Self::InstallationMaintenanceAndRepair),
"LEGAL" => Some(Self::Legal),
"MANAGEMENT" => Some(Self::Management),
"MANUFACTURING_AND_WAREHOUSE" => Some(Self::ManufacturingAndWarehouse),
"MEDIA_COMMUNICATIONS_AND_WRITING" => Some(Self::MediaCommunicationsAndWriting),
"OIL_GAS_AND_MINING" => Some(Self::OilGasAndMining),
"PERSONAL_CARE_AND_SERVICES" => Some(Self::PersonalCareAndServices),
"PROTECTIVE_SERVICES" => Some(Self::ProtectiveServices),
"REAL_ESTATE" => Some(Self::RealEstate),
"RESTAURANT_AND_HOSPITALITY" => Some(Self::RestaurantAndHospitality),
"SALES_AND_RETAIL" => Some(Self::SalesAndRetail),
"SCIENCE_AND_ENGINEERING" => Some(Self::ScienceAndEngineering),
"SOCIAL_SERVICES_AND_NON_PROFIT" => Some(Self::SocialServicesAndNonProfit),
"SPORTS_FITNESS_AND_RECREATION" => Some(Self::SportsFitnessAndRecreation),
"TRANSPORTATION_AND_LOGISTICS" => Some(Self::TransportationAndLogistics),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PostingRegion {
Unspecified = 0,
AdministrativeArea = 1,
Nation = 2,
Telecommute = 3,
}
impl PostingRegion {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PostingRegion::Unspecified => "POSTING_REGION_UNSPECIFIED",
PostingRegion::AdministrativeArea => "ADMINISTRATIVE_AREA",
PostingRegion::Nation => "NATION",
PostingRegion::Telecommute => "TELECOMMUTE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"POSTING_REGION_UNSPECIFIED" => Some(Self::Unspecified),
"ADMINISTRATIVE_AREA" => Some(Self::AdministrativeArea),
"NATION" => Some(Self::Nation),
"TELECOMMUTE" => Some(Self::Telecommute),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Visibility {
Unspecified = 0,
AccountOnly = 1,
SharedWithGoogle = 2,
SharedWithPublic = 3,
}
impl Visibility {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Visibility::Unspecified => "VISIBILITY_UNSPECIFIED",
Visibility::AccountOnly => "ACCOUNT_ONLY",
Visibility::SharedWithGoogle => "SHARED_WITH_GOOGLE",
Visibility::SharedWithPublic => "SHARED_WITH_PUBLIC",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VISIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
"ACCOUNT_ONLY" => Some(Self::AccountOnly),
"SHARED_WITH_GOOGLE" => Some(Self::SharedWithGoogle),
"SHARED_WITH_PUBLIC" => Some(Self::SharedWithPublic),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HtmlSanitization {
Unspecified = 0,
Disabled = 1,
SimpleFormattingOnly = 2,
}
impl HtmlSanitization {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HtmlSanitization::Unspecified => "HTML_SANITIZATION_UNSPECIFIED",
HtmlSanitization::Disabled => "HTML_SANITIZATION_DISABLED",
HtmlSanitization::SimpleFormattingOnly => "SIMPLE_FORMATTING_ONLY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"HTML_SANITIZATION_UNSPECIFIED" => Some(Self::Unspecified),
"HTML_SANITIZATION_DISABLED" => Some(Self::Disabled),
"SIMPLE_FORMATTING_ONLY" => Some(Self::SimpleFormattingOnly),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommuteMethod {
Unspecified = 0,
Driving = 1,
Transit = 2,
Walking = 3,
Cycling = 4,
TransitAccessible = 5,
}
impl CommuteMethod {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CommuteMethod::Unspecified => "COMMUTE_METHOD_UNSPECIFIED",
CommuteMethod::Driving => "DRIVING",
CommuteMethod::Transit => "TRANSIT",
CommuteMethod::Walking => "WALKING",
CommuteMethod::Cycling => "CYCLING",
CommuteMethod::TransitAccessible => "TRANSIT_ACCESSIBLE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMMUTE_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
"DRIVING" => Some(Self::Driving),
"TRANSIT" => Some(Self::Transit),
"WALKING" => Some(Self::Walking),
"CYCLING" => Some(Self::Cycling),
"TRANSIT_ACCESSIBLE" => Some(Self::TransitAccessible),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryRequest {
#[prost(string, tag = "1")]
pub tenant: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub language_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int32, tag = "4")]
pub page_size: i32,
#[prost(string, tag = "5")]
pub company: ::prost::alloc::string::String,
#[prost(enumeration = "complete_query_request::CompletionScope", tag = "6")]
pub scope: i32,
#[prost(enumeration = "complete_query_request::CompletionType", tag = "7")]
pub r#type: i32,
}
/// Nested message and enum types in `CompleteQueryRequest`.
pub mod complete_query_request {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompletionScope {
Unspecified = 0,
Tenant = 1,
Public = 2,
}
impl CompletionScope {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CompletionScope::Unspecified => "COMPLETION_SCOPE_UNSPECIFIED",
CompletionScope::Tenant => "TENANT",
CompletionScope::Public => "PUBLIC",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMPLETION_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
"TENANT" => Some(Self::Tenant),
"PUBLIC" => Some(Self::Public),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompletionType {
Unspecified = 0,
JobTitle = 1,
CompanyName = 2,
Combined = 3,
}
impl CompletionType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CompletionType::Unspecified => "COMPLETION_TYPE_UNSPECIFIED",
CompletionType::JobTitle => "JOB_TITLE",
CompletionType::CompanyName => "COMPANY_NAME",
CompletionType::Combined => "COMBINED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMPLETION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"JOB_TITLE" => Some(Self::JobTitle),
"COMPANY_NAME" => Some(Self::CompanyName),
"COMBINED" => Some(Self::Combined),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryResponse {
#[prost(message, repeated, tag = "1")]
pub completion_results: ::prost::alloc::vec::Vec<complete_query_response::CompletionResult>,
#[prost(message, optional, tag = "2")]
pub metadata: ::core::option::Option<ResponseMetadata>,
}
/// Nested message and enum types in `CompleteQueryResponse`.
pub mod complete_query_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionResult {
#[prost(string, tag = "1")]
pub suggestion: ::prost::alloc::string::String,
#[prost(enumeration = "super::complete_query_request::CompletionType", tag = "2")]
pub r#type: i32,
#[prost(string, tag = "3")]
pub image_uri: ::prost::alloc::string::String,
}
}
/// Generated client implementations.
pub mod completion_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service handles auto completion.
#[derive(Debug, Clone)]
pub struct CompletionClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CompletionClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CompletionClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CompletionClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Completes the specified prefix with keyword suggestions.
/// Intended for use by a job search auto-complete search box.
pub async fn complete_query(&mut self, request: impl tonic::IntoRequest<super::CompleteQueryRequest>) -> std::result::Result<tonic::Response<super::CompleteQueryResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.Completion/CompleteQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.Completion", "CompleteQuery"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tenant {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub external_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTenantRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub tenant: ::core::option::Option<Tenant>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTenantRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTenantRequest {
#[prost(message, optional, tag = "1")]
pub tenant: ::core::option::Option<Tenant>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTenantRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantsResponse {
#[prost(message, repeated, tag = "1")]
pub tenants: ::prost::alloc::vec::Vec<Tenant>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub metadata: ::core::option::Option<ResponseMetadata>,
}
/// Generated client implementations.
pub mod tenant_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service that handles tenant management, including CRUD and enumeration.
#[derive(Debug, Clone)]
pub struct TenantServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> TenantServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> TenantServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
TenantServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new tenant entity.
pub async fn create_tenant(&mut self, request: impl tonic::IntoRequest<super::CreateTenantRequest>) -> std::result::Result<tonic::Response<super::Tenant>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.TenantService/CreateTenant");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.TenantService", "CreateTenant"));
self.inner.unary(req, path, codec).await
}
/// Retrieves specified tenant.
pub async fn get_tenant(&mut self, request: impl tonic::IntoRequest<super::GetTenantRequest>) -> std::result::Result<tonic::Response<super::Tenant>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.TenantService/GetTenant");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.TenantService", "GetTenant"));
self.inner.unary(req, path, codec).await
}
/// Updates specified tenant.
pub async fn update_tenant(&mut self, request: impl tonic::IntoRequest<super::UpdateTenantRequest>) -> std::result::Result<tonic::Response<super::Tenant>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.TenantService/UpdateTenant");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.TenantService", "UpdateTenant"));
self.inner.unary(req, path, codec).await
}
/// Deletes specified tenant.
pub async fn delete_tenant(&mut self, request: impl tonic::IntoRequest<super::DeleteTenantRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.TenantService/DeleteTenant");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.TenantService", "DeleteTenant"));
self.inner.unary(req, path, codec).await
}
/// Lists all tenants associated with the project.
pub async fn list_tenants(&mut self, request: impl tonic::IntoRequest<super::ListTenantsRequest>) -> std::result::Result<tonic::Response<super::ListTenantsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.TenantService/ListTenants");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.TenantService", "ListTenants"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Company {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub external_id: ::prost::alloc::string::String,
#[prost(enumeration = "CompanySize", tag = "4")]
pub size: i32,
#[prost(string, tag = "5")]
pub headquarters_address: ::prost::alloc::string::String,
#[prost(bool, tag = "6")]
pub hiring_agency: bool,
#[prost(string, tag = "7")]
pub eeo_text: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub website_uri: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub career_site_uri: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub image_uri: ::prost::alloc::string::String,
#[deprecated]
#[prost(string, repeated, tag = "11")]
pub keyword_searchable_job_custom_attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "12")]
pub derived_info: ::core::option::Option<company::DerivedInfo>,
#[prost(bool, tag = "13")]
pub suspended: bool,
}
/// Nested message and enum types in `Company`.
pub mod company {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DerivedInfo {
#[prost(message, optional, tag = "1")]
pub headquarters_location: ::core::option::Option<super::Location>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobQuery {
#[prost(string, tag = "1")]
pub query: ::prost::alloc::string::String,
#[prost(string, tag = "14")]
pub query_language_code: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub companies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "3")]
pub location_filters: ::prost::alloc::vec::Vec<LocationFilter>,
#[prost(enumeration = "JobCategory", repeated, tag = "4")]
pub job_categories: ::prost::alloc::vec::Vec<i32>,
#[prost(message, optional, tag = "5")]
pub commute_filter: ::core::option::Option<CommuteFilter>,
#[prost(string, repeated, tag = "6")]
pub company_display_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub compensation_filter: ::core::option::Option<CompensationFilter>,
#[prost(string, tag = "8")]
pub custom_attribute_filter: ::prost::alloc::string::String,
#[prost(bool, tag = "9")]
pub disable_spell_check: bool,
#[prost(enumeration = "EmploymentType", repeated, tag = "10")]
pub employment_types: ::prost::alloc::vec::Vec<i32>,
#[prost(string, repeated, tag = "11")]
pub language_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "12")]
pub publish_time_range: ::core::option::Option<TimestampRange>,
#[prost(string, repeated, tag = "13")]
pub excluded_jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationFilter {
#[prost(string, tag = "1")]
pub address: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub region_code: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub lat_lng: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(double, tag = "4")]
pub distance_in_miles: f64,
#[prost(enumeration = "location_filter::TelecommutePreference", tag = "5")]
pub telecommute_preference: i32,
}
/// Nested message and enum types in `LocationFilter`.
pub mod location_filter {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TelecommutePreference {
Unspecified = 0,
TelecommuteExcluded = 1,
TelecommuteAllowed = 2,
TelecommuteJobsExcluded = 3,
}
impl TelecommutePreference {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TelecommutePreference::Unspecified => "TELECOMMUTE_PREFERENCE_UNSPECIFIED",
TelecommutePreference::TelecommuteExcluded => "TELECOMMUTE_EXCLUDED",
TelecommutePreference::TelecommuteAllowed => "TELECOMMUTE_ALLOWED",
TelecommutePreference::TelecommuteJobsExcluded => "TELECOMMUTE_JOBS_EXCLUDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TELECOMMUTE_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
"TELECOMMUTE_EXCLUDED" => Some(Self::TelecommuteExcluded),
"TELECOMMUTE_ALLOWED" => Some(Self::TelecommuteAllowed),
"TELECOMMUTE_JOBS_EXCLUDED" => Some(Self::TelecommuteJobsExcluded),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationFilter {
#[prost(enumeration = "compensation_filter::FilterType", tag = "1")]
pub r#type: i32,
#[prost(enumeration = "compensation_info::CompensationUnit", repeated, packed = "false", tag = "2")]
pub units: ::prost::alloc::vec::Vec<i32>,
#[prost(message, optional, tag = "3")]
pub range: ::core::option::Option<compensation_info::CompensationRange>,
#[prost(bool, tag = "4")]
pub include_jobs_with_unspecified_compensation_range: bool,
}
/// Nested message and enum types in `CompensationFilter`.
pub mod compensation_filter {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FilterType {
Unspecified = 0,
UnitOnly = 1,
UnitAndAmount = 2,
AnnualizedBaseAmount = 3,
AnnualizedTotalAmount = 4,
}
impl FilterType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FilterType::Unspecified => "FILTER_TYPE_UNSPECIFIED",
FilterType::UnitOnly => "UNIT_ONLY",
FilterType::UnitAndAmount => "UNIT_AND_AMOUNT",
FilterType::AnnualizedBaseAmount => "ANNUALIZED_BASE_AMOUNT",
FilterType::AnnualizedTotalAmount => "ANNUALIZED_TOTAL_AMOUNT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FILTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"UNIT_ONLY" => Some(Self::UnitOnly),
"UNIT_AND_AMOUNT" => Some(Self::UnitAndAmount),
"ANNUALIZED_BASE_AMOUNT" => Some(Self::AnnualizedBaseAmount),
"ANNUALIZED_TOTAL_AMOUNT" => Some(Self::AnnualizedTotalAmount),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommuteFilter {
#[prost(enumeration = "CommuteMethod", tag = "1")]
pub commute_method: i32,
#[prost(message, optional, tag = "2")]
pub start_coordinates: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(message, optional, tag = "3")]
pub travel_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(bool, tag = "4")]
pub allow_imprecise_addresses: bool,
#[prost(oneof = "commute_filter::TrafficOption", tags = "5, 6")]
pub traffic_option: ::core::option::Option<commute_filter::TrafficOption>,
}
/// Nested message and enum types in `CommuteFilter`.
pub mod commute_filter {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoadTraffic {
Unspecified = 0,
TrafficFree = 1,
BusyHour = 2,
}
impl RoadTraffic {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RoadTraffic::Unspecified => "ROAD_TRAFFIC_UNSPECIFIED",
RoadTraffic::TrafficFree => "TRAFFIC_FREE",
RoadTraffic::BusyHour => "BUSY_HOUR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ROAD_TRAFFIC_UNSPECIFIED" => Some(Self::Unspecified),
"TRAFFIC_FREE" => Some(Self::TrafficFree),
"BUSY_HOUR" => Some(Self::BusyHour),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum TrafficOption {
#[prost(enumeration = "RoadTraffic", tag = "5")]
RoadTraffic(i32),
#[prost(message, tag = "6")]
DepartureTime(super::super::super::super::r#type::TimeOfDay),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramQuery {
#[prost(string, tag = "1")]
pub histogram_query: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramQueryResult {
#[prost(string, tag = "1")]
pub histogram_query: ::prost::alloc::string::String,
#[prost(map = "string, int64", tag = "2")]
pub histogram: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub company: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub requisition_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub description: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "6")]
pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub application_info: ::core::option::Option<job::ApplicationInfo>,
#[prost(enumeration = "JobBenefit", repeated, tag = "8")]
pub job_benefits: ::prost::alloc::vec::Vec<i32>,
#[prost(message, optional, tag = "9")]
pub compensation_info: ::core::option::Option<CompensationInfo>,
#[prost(map = "string, message", tag = "10")]
pub custom_attributes: ::std::collections::HashMap<::prost::alloc::string::String, CustomAttribute>,
#[prost(enumeration = "DegreeType", repeated, tag = "11")]
pub degree_types: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "12")]
pub department: ::prost::alloc::string::String,
#[prost(enumeration = "EmploymentType", repeated, tag = "13")]
pub employment_types: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "14")]
pub incentives: ::prost::alloc::string::String,
#[prost(string, tag = "15")]
pub language_code: ::prost::alloc::string::String,
#[prost(enumeration = "JobLevel", tag = "16")]
pub job_level: i32,
#[prost(int32, tag = "17")]
pub promotion_value: i32,
#[prost(string, tag = "18")]
pub qualifications: ::prost::alloc::string::String,
#[prost(string, tag = "19")]
pub responsibilities: ::prost::alloc::string::String,
#[prost(enumeration = "PostingRegion", tag = "20")]
pub posting_region: i32,
#[deprecated]
#[prost(enumeration = "Visibility", tag = "21")]
pub visibility: i32,
#[prost(message, optional, tag = "22")]
pub job_start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "23")]
pub job_end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "24")]
pub posting_publish_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "25")]
pub posting_expire_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "26")]
pub posting_create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "27")]
pub posting_update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "28")]
pub company_display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "29")]
pub derived_info: ::core::option::Option<job::DerivedInfo>,
#[prost(message, optional, tag = "30")]
pub processing_options: ::core::option::Option<job::ProcessingOptions>,
}
/// Nested message and enum types in `Job`.
pub mod job {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationInfo {
#[prost(string, repeated, tag = "1")]
pub emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "2")]
pub instruction: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DerivedInfo {
#[prost(message, repeated, tag = "1")]
pub locations: ::prost::alloc::vec::Vec<super::Location>,
#[prost(enumeration = "super::JobCategory", repeated, tag = "3")]
pub job_categories: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessingOptions {
#[prost(bool, tag = "1")]
pub disable_street_address_resolution: bool,
#[prost(enumeration = "super::HtmlSanitization", tag = "2")]
pub html_sanitization: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub job: ::core::option::Option<Job>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateJobRequest {
#[prost(message, optional, tag = "1")]
pub job: ::core::option::Option<Job>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "4")]
pub page_size: i32,
#[prost(enumeration = "JobView", tag = "5")]
pub job_view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
#[prost(message, repeated, tag = "1")]
pub jobs: ::prost::alloc::vec::Vec<Job>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(enumeration = "search_jobs_request::SearchMode", tag = "2")]
pub search_mode: i32,
#[prost(message, optional, tag = "3")]
pub request_metadata: ::core::option::Option<RequestMetadata>,
#[prost(message, optional, tag = "4")]
pub job_query: ::core::option::Option<JobQuery>,
#[prost(bool, tag = "5")]
pub enable_broadening: bool,
#[prost(message, repeated, tag = "7")]
pub histogram_queries: ::prost::alloc::vec::Vec<HistogramQuery>,
#[prost(enumeration = "JobView", tag = "8")]
pub job_view: i32,
#[prost(int32, tag = "9")]
pub offset: i32,
#[prost(int32, tag = "10")]
pub max_page_size: i32,
#[prost(string, tag = "11")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "12")]
pub order_by: ::prost::alloc::string::String,
#[prost(enumeration = "search_jobs_request::DiversificationLevel", tag = "13")]
pub diversification_level: i32,
#[prost(message, optional, tag = "14")]
pub custom_ranking_info: ::core::option::Option<search_jobs_request::CustomRankingInfo>,
#[deprecated]
#[prost(bool, tag = "16")]
pub disable_keyword_match: bool,
#[prost(enumeration = "search_jobs_request::KeywordMatchMode", tag = "18")]
pub keyword_match_mode: i32,
}
/// Nested message and enum types in `SearchJobsRequest`.
pub mod search_jobs_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomRankingInfo {
#[prost(enumeration = "custom_ranking_info::ImportanceLevel", tag = "1")]
pub importance_level: i32,
#[prost(string, tag = "2")]
pub ranking_expression: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CustomRankingInfo`.
pub mod custom_ranking_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImportanceLevel {
Unspecified = 0,
None = 1,
Low = 2,
Mild = 3,
Medium = 4,
High = 5,
Extreme = 6,
}
impl ImportanceLevel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ImportanceLevel::Unspecified => "IMPORTANCE_LEVEL_UNSPECIFIED",
ImportanceLevel::None => "NONE",
ImportanceLevel::Low => "LOW",
ImportanceLevel::Mild => "MILD",
ImportanceLevel::Medium => "MEDIUM",
ImportanceLevel::High => "HIGH",
ImportanceLevel::Extreme => "EXTREME",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"IMPORTANCE_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
"NONE" => Some(Self::None),
"LOW" => Some(Self::Low),
"MILD" => Some(Self::Mild),
"MEDIUM" => Some(Self::Medium),
"HIGH" => Some(Self::High),
"EXTREME" => Some(Self::Extreme),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchMode {
Unspecified = 0,
JobSearch = 1,
FeaturedJobSearch = 2,
}
impl SearchMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SearchMode::Unspecified => "SEARCH_MODE_UNSPECIFIED",
SearchMode::JobSearch => "JOB_SEARCH",
SearchMode::FeaturedJobSearch => "FEATURED_JOB_SEARCH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEARCH_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"JOB_SEARCH" => Some(Self::JobSearch),
"FEATURED_JOB_SEARCH" => Some(Self::FeaturedJobSearch),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DiversificationLevel {
Unspecified = 0,
Disabled = 1,
Simple = 2,
OnePerCompany = 3,
TwoPerCompany = 4,
MaxThreePerCompany = 6,
DiversifyByLooserSimilarity = 5,
}
impl DiversificationLevel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DiversificationLevel::Unspecified => "DIVERSIFICATION_LEVEL_UNSPECIFIED",
DiversificationLevel::Disabled => "DISABLED",
DiversificationLevel::Simple => "SIMPLE",
DiversificationLevel::OnePerCompany => "ONE_PER_COMPANY",
DiversificationLevel::TwoPerCompany => "TWO_PER_COMPANY",
DiversificationLevel::MaxThreePerCompany => "MAX_THREE_PER_COMPANY",
DiversificationLevel::DiversifyByLooserSimilarity => "DIVERSIFY_BY_LOOSER_SIMILARITY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DIVERSIFICATION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
"DISABLED" => Some(Self::Disabled),
"SIMPLE" => Some(Self::Simple),
"ONE_PER_COMPANY" => Some(Self::OnePerCompany),
"TWO_PER_COMPANY" => Some(Self::TwoPerCompany),
"MAX_THREE_PER_COMPANY" => Some(Self::MaxThreePerCompany),
"DIVERSIFY_BY_LOOSER_SIMILARITY" => Some(Self::DiversifyByLooserSimilarity),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeywordMatchMode {
Unspecified = 0,
KeywordMatchDisabled = 1,
KeywordMatchAll = 2,
KeywordMatchTitleOnly = 3,
}
impl KeywordMatchMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
KeywordMatchMode::Unspecified => "KEYWORD_MATCH_MODE_UNSPECIFIED",
KeywordMatchMode::KeywordMatchDisabled => "KEYWORD_MATCH_DISABLED",
KeywordMatchMode::KeywordMatchAll => "KEYWORD_MATCH_ALL",
KeywordMatchMode::KeywordMatchTitleOnly => "KEYWORD_MATCH_TITLE_ONLY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"KEYWORD_MATCH_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"KEYWORD_MATCH_DISABLED" => Some(Self::KeywordMatchDisabled),
"KEYWORD_MATCH_ALL" => Some(Self::KeywordMatchAll),
"KEYWORD_MATCH_TITLE_ONLY" => Some(Self::KeywordMatchTitleOnly),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchJobsResponse {
#[prost(message, repeated, tag = "1")]
pub matching_jobs: ::prost::alloc::vec::Vec<search_jobs_response::MatchingJob>,
#[prost(message, repeated, tag = "2")]
pub histogram_query_results: ::prost::alloc::vec::Vec<HistogramQueryResult>,
#[prost(string, tag = "3")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub location_filters: ::prost::alloc::vec::Vec<Location>,
#[prost(int32, tag = "6")]
pub total_size: i32,
#[prost(message, optional, tag = "7")]
pub metadata: ::core::option::Option<ResponseMetadata>,
#[prost(int32, tag = "8")]
pub broadened_query_jobs_count: i32,
#[prost(message, optional, tag = "9")]
pub spell_correction: ::core::option::Option<SpellingCorrection>,
}
/// Nested message and enum types in `SearchJobsResponse`.
pub mod search_jobs_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchingJob {
#[prost(message, optional, tag = "1")]
pub job: ::core::option::Option<super::Job>,
#[prost(string, tag = "2")]
pub job_summary: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub job_title_snippet: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub search_text_snippet: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub commute_info: ::core::option::Option<CommuteInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommuteInfo {
#[prost(message, optional, tag = "1")]
pub job_location: ::core::option::Option<super::Location>,
#[prost(message, optional, tag = "2")]
pub travel_duration: ::core::option::Option<::prost_types::Duration>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub jobs: ::prost::alloc::vec::Vec<Job>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub jobs: ::prost::alloc::vec::Vec<Job>,
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobResult {
#[prost(message, optional, tag = "1")]
pub job: ::core::option::Option<Job>,
#[prost(message, optional, tag = "2")]
pub status: ::core::option::Option<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateJobsResponse {
#[prost(message, repeated, tag = "1")]
pub job_results: ::prost::alloc::vec::Vec<JobResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateJobsResponse {
#[prost(message, repeated, tag = "1")]
pub job_results: ::prost::alloc::vec::Vec<JobResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteJobsResponse {
#[prost(message, repeated, tag = "1")]
pub job_results: ::prost::alloc::vec::Vec<JobResult>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobView {
Unspecified = 0,
IdOnly = 1,
Minimal = 2,
Small = 3,
Full = 4,
}
impl JobView {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JobView::Unspecified => "JOB_VIEW_UNSPECIFIED",
JobView::IdOnly => "JOB_VIEW_ID_ONLY",
JobView::Minimal => "JOB_VIEW_MINIMAL",
JobView::Small => "JOB_VIEW_SMALL",
JobView::Full => "JOB_VIEW_FULL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JOB_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
"JOB_VIEW_ID_ONLY" => Some(Self::IdOnly),
"JOB_VIEW_MINIMAL" => Some(Self::Minimal),
"JOB_VIEW_SMALL" => Some(Self::Small),
"JOB_VIEW_FULL" => Some(Self::Full),
_ => None,
}
}
}
/// Generated client implementations.
pub mod job_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service handles job management, including job CRUD, enumeration and search.
#[derive(Debug, Clone)]
pub struct JobServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> JobServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> JobServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
JobServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new job.
///
/// Typically, the job becomes searchable within 10 seconds, but it may take
/// up to 5 minutes.
pub async fn create_job(&mut self, request: impl tonic::IntoRequest<super::CreateJobRequest>) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/CreateJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "CreateJob"));
self.inner.unary(req, path, codec).await
}
/// Begins executing a batch create jobs operation.
pub async fn batch_create_jobs(&mut self, request: impl tonic::IntoRequest<super::BatchCreateJobsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/BatchCreateJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "BatchCreateJobs"));
self.inner.unary(req, path, codec).await
}
/// Retrieves the specified job, whose status is OPEN or recently EXPIRED
/// within the last 90 days.
pub async fn get_job(&mut self, request: impl tonic::IntoRequest<super::GetJobRequest>) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/GetJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "GetJob"));
self.inner.unary(req, path, codec).await
}
/// Updates specified job.
///
/// Typically, updated contents become visible in search results within 10
/// seconds, but it may take up to 5 minutes.
pub async fn update_job(&mut self, request: impl tonic::IntoRequest<super::UpdateJobRequest>) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/UpdateJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "UpdateJob"));
self.inner.unary(req, path, codec).await
}
/// Begins executing a batch update jobs operation.
pub async fn batch_update_jobs(&mut self, request: impl tonic::IntoRequest<super::BatchUpdateJobsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/BatchUpdateJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "BatchUpdateJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified job.
///
/// Typically, the job becomes unsearchable within 10 seconds, but it may take
/// up to 5 minutes.
pub async fn delete_job(&mut self, request: impl tonic::IntoRequest<super::DeleteJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/DeleteJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "DeleteJob"));
self.inner.unary(req, path, codec).await
}
/// Begins executing a batch delete jobs operation.
pub async fn batch_delete_jobs(&mut self, request: impl tonic::IntoRequest<super::BatchDeleteJobsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/BatchDeleteJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "BatchDeleteJobs"));
self.inner.unary(req, path, codec).await
}
/// Lists jobs by filter.
pub async fn list_jobs(&mut self, request: impl tonic::IntoRequest<super::ListJobsRequest>) -> std::result::Result<tonic::Response<super::ListJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/ListJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "ListJobs"));
self.inner.unary(req, path, codec).await
}
/// Searches for jobs using the provided
/// [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
///
/// This call constrains the
/// [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
/// database, and only returns jobs that the caller has permission to search
/// against.
pub async fn search_jobs(&mut self, request: impl tonic::IntoRequest<super::SearchJobsRequest>) -> std::result::Result<tonic::Response<super::SearchJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/SearchJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "SearchJobs"));
self.inner.unary(req, path, codec).await
}
/// Searches for jobs using the provided
/// [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
///
/// This API call is intended for the use case of targeting passive job
/// seekers (for example, job seekers who have signed up to receive email
/// alerts about potential job opportunities), it has different algorithmic
/// adjustments that are designed to specifically target passive job seekers.
///
/// This call constrains the
/// [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
/// database, and only returns jobs the caller has permission to search
/// against.
pub async fn search_jobs_for_alert(&mut self, request: impl tonic::IntoRequest<super::SearchJobsRequest>) -> std::result::Result<tonic::Response<super::SearchJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.JobService/SearchJobsForAlert");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.JobService", "SearchJobsForAlert"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientEvent {
#[prost(string, tag = "1")]
pub request_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub event_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "9")]
pub event_notes: ::prost::alloc::string::String,
#[prost(oneof = "client_event::Event", tags = "5")]
pub event: ::core::option::Option<client_event::Event>,
}
/// Nested message and enum types in `ClientEvent`.
pub mod client_event {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Event {
#[prost(message, tag = "5")]
JobEvent(super::JobEvent),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobEvent {
#[prost(enumeration = "job_event::JobEventType", tag = "1")]
pub r#type: i32,
#[prost(string, repeated, tag = "2")]
pub jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `JobEvent`.
pub mod job_event {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobEventType {
Unspecified = 0,
Impression = 1,
View = 2,
ViewRedirect = 3,
ApplicationStart = 4,
ApplicationFinish = 5,
ApplicationQuickSubmission = 6,
ApplicationRedirect = 7,
ApplicationStartFromSearch = 8,
ApplicationRedirectFromSearch = 9,
ApplicationCompanySubmit = 10,
Bookmark = 11,
Notification = 12,
Hired = 13,
SentCv = 14,
InterviewGranted = 15,
}
impl JobEventType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JobEventType::Unspecified => "JOB_EVENT_TYPE_UNSPECIFIED",
JobEventType::Impression => "IMPRESSION",
JobEventType::View => "VIEW",
JobEventType::ViewRedirect => "VIEW_REDIRECT",
JobEventType::ApplicationStart => "APPLICATION_START",
JobEventType::ApplicationFinish => "APPLICATION_FINISH",
JobEventType::ApplicationQuickSubmission => "APPLICATION_QUICK_SUBMISSION",
JobEventType::ApplicationRedirect => "APPLICATION_REDIRECT",
JobEventType::ApplicationStartFromSearch => "APPLICATION_START_FROM_SEARCH",
JobEventType::ApplicationRedirectFromSearch => "APPLICATION_REDIRECT_FROM_SEARCH",
JobEventType::ApplicationCompanySubmit => "APPLICATION_COMPANY_SUBMIT",
JobEventType::Bookmark => "BOOKMARK",
JobEventType::Notification => "NOTIFICATION",
JobEventType::Hired => "HIRED",
JobEventType::SentCv => "SENT_CV",
JobEventType::InterviewGranted => "INTERVIEW_GRANTED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JOB_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"IMPRESSION" => Some(Self::Impression),
"VIEW" => Some(Self::View),
"VIEW_REDIRECT" => Some(Self::ViewRedirect),
"APPLICATION_START" => Some(Self::ApplicationStart),
"APPLICATION_FINISH" => Some(Self::ApplicationFinish),
"APPLICATION_QUICK_SUBMISSION" => Some(Self::ApplicationQuickSubmission),
"APPLICATION_REDIRECT" => Some(Self::ApplicationRedirect),
"APPLICATION_START_FROM_SEARCH" => Some(Self::ApplicationStartFromSearch),
"APPLICATION_REDIRECT_FROM_SEARCH" => Some(Self::ApplicationRedirectFromSearch),
"APPLICATION_COMPANY_SUBMIT" => Some(Self::ApplicationCompanySubmit),
"BOOKMARK" => Some(Self::Bookmark),
"NOTIFICATION" => Some(Self::Notification),
"HIRED" => Some(Self::Hired),
"SENT_CV" => Some(Self::SentCv),
"INTERVIEW_GRANTED" => Some(Self::InterviewGranted),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCompanyRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub company: ::core::option::Option<Company>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompanyRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCompanyRequest {
#[prost(message, optional, tag = "1")]
pub company: ::core::option::Option<Company>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCompanyRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCompaniesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(bool, tag = "4")]
pub require_open_jobs: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCompaniesResponse {
#[prost(message, repeated, tag = "1")]
pub companies: ::prost::alloc::vec::Vec<Company>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub metadata: ::core::option::Option<ResponseMetadata>,
}
/// Generated client implementations.
pub mod company_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service that handles company management, including CRUD and enumeration.
#[derive(Debug, Clone)]
pub struct CompanyServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CompanyServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CompanyServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CompanyServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new company entity.
pub async fn create_company(&mut self, request: impl tonic::IntoRequest<super::CreateCompanyRequest>) -> std::result::Result<tonic::Response<super::Company>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.CompanyService/CreateCompany");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.CompanyService", "CreateCompany"));
self.inner.unary(req, path, codec).await
}
/// Retrieves specified company.
pub async fn get_company(&mut self, request: impl tonic::IntoRequest<super::GetCompanyRequest>) -> std::result::Result<tonic::Response<super::Company>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.CompanyService/GetCompany");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.CompanyService", "GetCompany"));
self.inner.unary(req, path, codec).await
}
/// Updates specified company.
pub async fn update_company(&mut self, request: impl tonic::IntoRequest<super::UpdateCompanyRequest>) -> std::result::Result<tonic::Response<super::Company>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.CompanyService/UpdateCompany");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.CompanyService", "UpdateCompany"));
self.inner.unary(req, path, codec).await
}
/// Deletes specified company.
/// Prerequisite: The company has no jobs associated with it.
pub async fn delete_company(&mut self, request: impl tonic::IntoRequest<super::DeleteCompanyRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.CompanyService/DeleteCompany");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.CompanyService", "DeleteCompany"));
self.inner.unary(req, path, codec).await
}
/// Lists all companies associated with the project.
pub async fn list_companies(&mut self, request: impl tonic::IntoRequest<super::ListCompaniesRequest>) -> std::result::Result<tonic::Response<super::ListCompaniesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.CompanyService/ListCompanies");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.CompanyService", "ListCompanies"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClientEventRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub client_event: ::core::option::Option<ClientEvent>,
}
/// Generated client implementations.
pub mod event_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service handles client event report.
#[derive(Debug, Clone)]
pub struct EventServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> EventServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> EventServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
EventServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Report events issued when end user interacts with customer's application
/// that uses Cloud Talent Solution. You may inspect the created events in
/// [self service
/// tools](https://console.cloud.google.com/talent-solution/overview).
/// [Learn
/// more](https://cloud.google.com/talent-solution/docs/management-tools)
/// about self service tools.
pub async fn create_client_event(&mut self, request: impl tonic::IntoRequest<super::CreateClientEventRequest>) -> std::result::Result<tonic::Response<super::ClientEvent>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.talent.v4.EventService/CreateClientEvent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.talent.v4.EventService", "CreateClientEvent"));
self.inner.unary(req, path, codec).await
}
}
}
