// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceErrorDetail {
#[prost(message, optional, tag = "1")]
pub resource_info: ::core::option::Option<super::super::super::super::rpc::ResourceInfo>,
#[prost(message, repeated, tag = "2")]
pub error_details: ::prost::alloc::vec::Vec<ErrorDetail>,
#[prost(int32, tag = "3")]
pub error_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetail {
#[prost(message, optional, tag = "1")]
pub location: ::core::option::Option<ErrorLocation>,
#[prost(message, optional, tag = "2")]
pub error_info: ::core::option::Option<super::super::super::super::rpc::ErrorInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ErrorLocation {
#[prost(int32, tag = "1")]
pub line: i32,
#[prost(int32, tag = "2")]
pub column: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslationDetails {
#[prost(message, repeated, tag = "1")]
pub source_target_mapping: ::prost::alloc::vec::Vec<SourceTargetMapping>,
#[prost(string, tag = "2")]
pub target_base_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub source_environment: ::core::option::Option<SourceEnvironment>,
#[prost(string, repeated, tag = "4")]
pub target_return_literals: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "5")]
pub target_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceTargetMapping {
#[prost(message, optional, tag = "1")]
pub source_spec: ::core::option::Option<SourceSpec>,
#[prost(message, optional, tag = "2")]
pub target_spec: ::core::option::Option<TargetSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceSpec {
#[prost(string, tag = "3")]
pub encoding: ::prost::alloc::string::String,
#[prost(oneof = "source_spec::Source", tags = "1, 2")]
pub source: ::core::option::Option<source_spec::Source>,
}
/// Nested message and enum types in `SourceSpec`.
pub mod source_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(string, tag = "1")]
BaseUri(::prost::alloc::string::String),
#[prost(message, tag = "2")]
Literal(super::Literal),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSpec {
#[prost(string, tag = "1")]
pub relative_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Literal {
#[prost(string, tag = "1")]
pub relative_path: ::prost::alloc::string::String,
#[prost(oneof = "literal::LiteralData", tags = "2, 3")]
pub literal_data: ::core::option::Option<literal::LiteralData>,
}
/// Nested message and enum types in `Literal`.
pub mod literal {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum LiteralData {
#[prost(string, tag = "2")]
LiteralString(::prost::alloc::string::String),
#[prost(bytes, tag = "3")]
LiteralBytes(::prost::alloc::vec::Vec<u8>),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceEnvironment {
#[prost(string, tag = "1")]
pub default_database: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub schema_search_path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "3")]
pub metadata_store_dataset: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
#[prost(string, tag = "1")]
pub metric: ::prost::alloc::string::String,
#[prost(enumeration = "super::super::super::super::api::metric_descriptor::ValueType", tag = "2")]
pub value_type: i32,
#[prost(enumeration = "super::super::super::super::api::metric_descriptor::MetricKind", tag = "3")]
pub metric_kind: i32,
#[prost(message, repeated, tag = "4")]
pub points: ::prost::alloc::vec::Vec<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Point {
#[prost(message, optional, tag = "1")]
pub interval: ::core::option::Option<TimeInterval>,
#[prost(message, optional, tag = "2")]
pub value: ::core::option::Option<TypedValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeInterval {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypedValue {
#[prost(oneof = "typed_value::Value", tags = "1, 2, 3, 4, 5")]
pub value: ::core::option::Option<typed_value::Value>,
}
/// Nested message and enum types in `TypedValue`.
pub mod typed_value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(bool, tag = "1")]
BoolValue(bool),
#[prost(int64, tag = "2")]
Int64Value(i64),
#[prost(double, tag = "3")]
DoubleValue(f64),
#[prost(string, tag = "4")]
StringValue(::prost::alloc::string::String),
#[prost(message, tag = "5")]
DistributionValue(super::super::super::super::super::api::Distribution),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslationConfigDetails {
#[prost(message, optional, tag = "3")]
pub source_dialect: ::core::option::Option<Dialect>,
#[prost(message, optional, tag = "4")]
pub target_dialect: ::core::option::Option<Dialect>,
#[prost(message, optional, tag = "6")]
pub source_env: ::core::option::Option<SourceEnv>,
#[prost(string, tag = "8")]
pub request_source: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "9")]
pub target_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(oneof = "translation_config_details::SourceLocation", tags = "1")]
pub source_location: ::core::option::Option<translation_config_details::SourceLocation>,
#[prost(oneof = "translation_config_details::TargetLocation", tags = "2")]
pub target_location: ::core::option::Option<translation_config_details::TargetLocation>,
#[prost(oneof = "translation_config_details::OutputNameMapping", tags = "5")]
pub output_name_mapping: ::core::option::Option<translation_config_details::OutputNameMapping>,
}
/// Nested message and enum types in `TranslationConfigDetails`.
pub mod translation_config_details {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum SourceLocation {
#[prost(string, tag = "1")]
GcsSourcePath(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TargetLocation {
#[prost(string, tag = "2")]
GcsTargetPath(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum OutputNameMapping {
#[prost(message, tag = "5")]
NameMappingList(super::ObjectNameMappingList),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dialect {
#[prost(oneof = "dialect::DialectValue", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17")]
pub dialect_value: ::core::option::Option<dialect::DialectValue>,
}
/// Nested message and enum types in `Dialect`.
pub mod dialect {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum DialectValue {
#[prost(message, tag = "1")]
BigqueryDialect(super::BigQueryDialect),
#[prost(message, tag = "2")]
HiveqlDialect(super::HiveQlDialect),
#[prost(message, tag = "3")]
RedshiftDialect(super::RedshiftDialect),
#[prost(message, tag = "4")]
TeradataDialect(super::TeradataDialect),
#[prost(message, tag = "5")]
OracleDialect(super::OracleDialect),
#[prost(message, tag = "6")]
SparksqlDialect(super::SparkSqlDialect),
#[prost(message, tag = "7")]
SnowflakeDialect(super::SnowflakeDialect),
#[prost(message, tag = "8")]
NetezzaDialect(super::NetezzaDialect),
#[prost(message, tag = "9")]
AzureSynapseDialect(super::AzureSynapseDialect),
#[prost(message, tag = "10")]
VerticaDialect(super::VerticaDialect),
#[prost(message, tag = "11")]
SqlServerDialect(super::SqlServerDialect),
#[prost(message, tag = "12")]
PostgresqlDialect(super::PostgresqlDialect),
#[prost(message, tag = "13")]
PrestoDialect(super::PrestoDialect),
#[prost(message, tag = "14")]
MysqlDialect(super::MySqlDialect),
#[prost(message, tag = "15")]
Db2Dialect(super::Db2Dialect),
#[prost(message, tag = "16")]
SqliteDialect(super::SqLiteDialect),
#[prost(message, tag = "17")]
GreenplumDialect(super::GreenplumDialect),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BigQueryDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HiveQlDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedshiftDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeradataDialect {
#[prost(enumeration = "teradata_dialect::Mode", tag = "1")]
pub mode: i32,
}
/// Nested message and enum types in `TeradataDialect`.
pub mod teradata_dialect {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Mode {
Unspecified = 0,
Sql = 1,
Bteq = 2,
}
impl Mode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Mode::Unspecified => "MODE_UNSPECIFIED",
Mode::Sql => "SQL",
Mode::Bteq => "BTEQ",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODE_UNSPECIFIED" => Some(Self::Unspecified),
"SQL" => Some(Self::Sql),
"BTEQ" => Some(Self::Bteq),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OracleDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SparkSqlDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnowflakeDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetezzaDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AzureSynapseDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerticaDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SqlServerDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PostgresqlDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrestoDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MySqlDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Db2Dialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SqLiteDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GreenplumDialect {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectNameMappingList {
#[prost(message, repeated, tag = "1")]
pub name_map: ::prost::alloc::vec::Vec<ObjectNameMapping>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectNameMapping {
#[prost(message, optional, tag = "1")]
pub source: ::core::option::Option<NameMappingKey>,
#[prost(message, optional, tag = "2")]
pub target: ::core::option::Option<NameMappingValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NameMappingKey {
#[prost(enumeration = "name_mapping_key::Type", tag = "1")]
pub r#type: i32,
#[prost(string, tag = "2")]
pub database: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub schema: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub relation: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub attribute: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NameMappingKey`.
pub mod name_mapping_key {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Database = 1,
Schema = 2,
Relation = 3,
Attribute = 4,
RelationAlias = 5,
AttributeAlias = 6,
Function = 7,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Database => "DATABASE",
Type::Schema => "SCHEMA",
Type::Relation => "RELATION",
Type::Attribute => "ATTRIBUTE",
Type::RelationAlias => "RELATION_ALIAS",
Type::AttributeAlias => "ATTRIBUTE_ALIAS",
Type::Function => "FUNCTION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"DATABASE" => Some(Self::Database),
"SCHEMA" => Some(Self::Schema),
"RELATION" => Some(Self::Relation),
"ATTRIBUTE" => Some(Self::Attribute),
"RELATION_ALIAS" => Some(Self::RelationAlias),
"ATTRIBUTE_ALIAS" => Some(Self::AttributeAlias),
"FUNCTION" => Some(Self::Function),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NameMappingValue {
#[prost(string, tag = "1")]
pub database: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub schema: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub relation: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub attribute: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceEnv {
#[prost(string, tag = "1")]
pub default_database: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub schema_search_path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "3")]
pub metadata_store_dataset: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsReportLogMessage {
#[prost(string, tag = "1")]
pub severity: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub category: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub file_path: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filename: ::prost::alloc::string::String,
#[prost(int32, tag = "5")]
pub source_script_line: i32,
#[prost(int32, tag = "6")]
pub source_script_column: i32,
#[prost(string, tag = "7")]
pub message: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub script_context: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub action: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub effect: ::prost::alloc::string::String,
#[prost(string, tag = "11")]
pub object_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationWorkflow {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub display_name: ::prost::alloc::string::String,
#[prost(map = "string, message", tag = "2")]
pub tasks: ::std::collections::HashMap<::prost::alloc::string::String, MigrationTask>,
#[prost(enumeration = "migration_workflow::State", tag = "3")]
pub state: i32,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `MigrationWorkflow`.
pub mod migration_workflow {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Draft = 1,
Running = 2,
Paused = 3,
Completed = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Draft => "DRAFT",
State::Running => "RUNNING",
State::Paused => "PAUSED",
State::Completed => "COMPLETED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"DRAFT" => Some(Self::Draft),
"RUNNING" => Some(Self::Running),
"PAUSED" => Some(Self::Paused),
"COMPLETED" => Some(Self::Completed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationTask {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub r#type: ::prost::alloc::string::String,
#[prost(enumeration = "migration_task::State", tag = "4")]
pub state: i32,
#[prost(message, optional, tag = "5")]
pub processing_error: ::core::option::Option<super::super::super::super::rpc::ErrorInfo>,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, repeated, tag = "17")]
pub resource_error_details: ::prost::alloc::vec::Vec<ResourceErrorDetail>,
#[prost(int32, tag = "18")]
pub resource_error_count: i32,
#[prost(message, repeated, tag = "19")]
pub metrics: ::prost::alloc::vec::Vec<TimeSeries>,
#[prost(message, optional, tag = "20")]
pub task_result: ::core::option::Option<MigrationTaskResult>,
#[prost(int32, tag = "21")]
pub total_processing_error_count: i32,
#[prost(int32, tag = "22")]
pub total_resource_error_count: i32,
#[prost(oneof = "migration_task::TaskDetails", tags = "14, 16")]
pub task_details: ::core::option::Option<migration_task::TaskDetails>,
}
/// Nested message and enum types in `MigrationTask`.
pub mod migration_task {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Orchestrating = 2,
Running = 3,
Paused = 4,
Succeeded = 5,
Failed = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Orchestrating => "ORCHESTRATING",
State::Running => "RUNNING",
State::Paused => "PAUSED",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"ORCHESTRATING" => Some(Self::Orchestrating),
"RUNNING" => Some(Self::Running),
"PAUSED" => Some(Self::Paused),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TaskDetails {
#[prost(message, tag = "14")]
TranslationConfigDetails(super::TranslationConfigDetails),
#[prost(message, tag = "16")]
TranslationDetails(super::TranslationDetails),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationSubtask {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub task_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub r#type: ::prost::alloc::string::String,
#[prost(enumeration = "migration_subtask::State", tag = "5")]
pub state: i32,
#[prost(message, optional, tag = "6")]
pub processing_error: ::core::option::Option<super::super::super::super::rpc::ErrorInfo>,
#[prost(message, repeated, tag = "12")]
pub resource_error_details: ::prost::alloc::vec::Vec<ResourceErrorDetail>,
#[prost(int32, tag = "13")]
pub resource_error_count: i32,
#[prost(message, optional, tag = "7")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, repeated, tag = "11")]
pub metrics: ::prost::alloc::vec::Vec<TimeSeries>,
}
/// Nested message and enum types in `MigrationSubtask`.
pub mod migration_subtask {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Active = 1,
Running = 2,
Succeeded = 3,
Failed = 4,
Paused = 5,
PendingDependency = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Active => "ACTIVE",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Paused => "PAUSED",
State::PendingDependency => "PENDING_DEPENDENCY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ACTIVE" => Some(Self::Active),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"PAUSED" => Some(Self::Paused),
"PENDING_DEPENDENCY" => Some(Self::PendingDependency),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationTaskResult {
#[prost(oneof = "migration_task_result::Details", tags = "2")]
pub details: ::core::option::Option<migration_task_result::Details>,
}
/// Nested message and enum types in `MigrationTaskResult`.
pub mod migration_task_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Details {
#[prost(message, tag = "2")]
TranslationTaskResult(super::TranslationTaskResult),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslationTaskResult {
#[prost(message, repeated, tag = "1")]
pub translated_literals: ::prost::alloc::vec::Vec<Literal>,
#[prost(message, repeated, tag = "2")]
pub report_log_messages: ::prost::alloc::vec::Vec<GcsReportLogMessage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMigrationWorkflowRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub migration_workflow: ::core::option::Option<MigrationWorkflow>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMigrationWorkflowRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMigrationWorkflowsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMigrationWorkflowsResponse {
#[prost(message, repeated, tag = "1")]
pub migration_workflows: ::prost::alloc::vec::Vec<MigrationWorkflow>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMigrationWorkflowRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartMigrationWorkflowRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMigrationSubtaskRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMigrationSubtasksRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMigrationSubtasksResponse {
#[prost(message, repeated, tag = "1")]
pub migration_subtasks: ::prost::alloc::vec::Vec<MigrationSubtask>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod migration_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to handle EDW migrations.
#[derive(Debug, Clone)]
pub struct MigrationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> MigrationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> MigrationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
MigrationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a migration workflow.
pub async fn create_migration_workflow(&mut self, request: impl tonic::IntoRequest<super::CreateMigrationWorkflowRequest>) -> std::result::Result<tonic::Response<super::MigrationWorkflow>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.migration.v2.MigrationService/CreateMigrationWorkflow");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.migration.v2.MigrationService", "CreateMigrationWorkflow"));
self.inner.unary(req, path, codec).await
}
/// Gets a previously created migration workflow.
pub async fn get_migration_workflow(&mut self, request: impl tonic::IntoRequest<super::GetMigrationWorkflowRequest>) -> std::result::Result<tonic::Response<super::MigrationWorkflow>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.migration.v2.MigrationService/GetMigrationWorkflow");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.migration.v2.MigrationService", "GetMigrationWorkflow"));
self.inner.unary(req, path, codec).await
}
/// Lists previously created migration workflow.
pub async fn list_migration_workflows(&mut self, request: impl tonic::IntoRequest<super::ListMigrationWorkflowsRequest>) -> std::result::Result<tonic::Response<super::ListMigrationWorkflowsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.migration.v2.MigrationService/ListMigrationWorkflows");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.migration.v2.MigrationService", "ListMigrationWorkflows"));
self.inner.unary(req, path, codec).await
}
/// Deletes a migration workflow by name.
pub async fn delete_migration_workflow(&mut self, request: impl tonic::IntoRequest<super::DeleteMigrationWorkflowRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.migration.v2.MigrationService/DeleteMigrationWorkflow");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.migration.v2.MigrationService", "DeleteMigrationWorkflow"));
self.inner.unary(req, path, codec).await
}
/// Starts a previously created migration workflow. I.e., the state transitions
/// from DRAFT to RUNNING. This is a no-op if the state is already RUNNING.
/// An error will be signaled if the state is anything other than DRAFT or
/// RUNNING.
pub async fn start_migration_workflow(&mut self, request: impl tonic::IntoRequest<super::StartMigrationWorkflowRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.migration.v2.MigrationService/StartMigrationWorkflow");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.migration.v2.MigrationService", "StartMigrationWorkflow"));
self.inner.unary(req, path, codec).await
}
/// Gets a previously created migration subtask.
pub async fn get_migration_subtask(&mut self, request: impl tonic::IntoRequest<super::GetMigrationSubtaskRequest>) -> std::result::Result<tonic::Response<super::MigrationSubtask>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.migration.v2.MigrationService/GetMigrationSubtask");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.migration.v2.MigrationService", "GetMigrationSubtask"));
self.inner.unary(req, path, codec).await
}
/// Lists previously created migration subtasks.
pub async fn list_migration_subtasks(&mut self, request: impl tonic::IntoRequest<super::ListMigrationSubtasksRequest>) -> std::result::Result<tonic::Response<super::ListMigrationSubtasksResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.migration.v2.MigrationService/ListMigrationSubtasks");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.migration.v2.MigrationService", "ListMigrationSubtasks"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslationReportRecord {
#[prost(enumeration = "translation_report_record::Severity", tag = "1")]
pub severity: i32,
#[prost(int32, tag = "2")]
pub script_line: i32,
#[prost(int32, tag = "3")]
pub script_column: i32,
#[prost(string, tag = "4")]
pub category: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TranslationReportRecord`.
pub mod translation_report_record {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
Unspecified = 0,
Info = 1,
Warning = 2,
Error = 3,
}
impl Severity {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Severity::Unspecified => "SEVERITY_UNSPECIFIED",
Severity::Info => "INFO",
Severity::Warning => "WARNING",
Severity::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
"INFO" => Some(Self::Info),
"WARNING" => Some(Self::Warning),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
