// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticCanvasPrompt {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(bool, tag = "3")]
    pub suppress_mic: bool,
    #[prost(bool, tag = "5")]
    pub send_state_data_to_canvas_app: bool,
    #[prost(bool, tag = "6")]
    pub enable_full_screen: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticImagePrompt {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub alt: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub height: i32,
    #[prost(int32, tag = "4")]
    pub width: i32,
}
/// Nested message and enum types in `StaticImagePrompt`.
pub mod static_image_prompt {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageFill {
        Unspecified = 0,
        Gray = 1,
        White = 2,
        Cropped = 3,
    }
    impl ImageFill {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImageFill::Unspecified => "UNSPECIFIED",
                ImageFill::Gray => "GRAY",
                ImageFill::White => "WHITE",
                ImageFill::Cropped => "CROPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "GRAY" => Some(Self::Gray),
                "WHITE" => Some(Self::White),
                "CROPPED" => Some(Self::Cropped),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticLinkPrompt {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub open: ::core::option::Option<OpenUrl>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenUrl {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(enumeration = "UrlHint", tag = "2")]
    pub hint: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UrlHint {
    HintUnspecified = 0,
    Amp = 1,
}
impl UrlHint {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UrlHint::HintUnspecified => "HINT_UNSPECIFIED",
            UrlHint::Amp => "AMP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HINT_UNSPECIFIED" => Some(Self::HintUnspecified),
            "AMP" => Some(Self::Amp),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticCardPrompt {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub image: ::core::option::Option<StaticImagePrompt>,
    #[prost(enumeration = "static_image_prompt::ImageFill", tag = "5")]
    pub image_fill: i32,
    #[prost(message, optional, tag = "6")]
    pub button: ::core::option::Option<StaticLinkPrompt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticCollectionBrowsePrompt {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<
        static_collection_browse_prompt::CollectionBrowseItem,
    >,
    #[prost(enumeration = "static_image_prompt::ImageFill", tag = "2")]
    pub image_fill: i32,
}
/// Nested message and enum types in `StaticCollectionBrowsePrompt`.
pub mod static_collection_browse_prompt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CollectionBrowseItem {
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub footer: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub image: ::core::option::Option<super::StaticImagePrompt>,
        #[prost(message, optional, tag = "5")]
        pub open_uri_action: ::core::option::Option<super::OpenUrl>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticCollectionPrompt {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<static_collection_prompt::CollectionItem>,
    #[prost(enumeration = "static_image_prompt::ImageFill", tag = "4")]
    pub image_fill: i32,
}
/// Nested message and enum types in `StaticCollectionPrompt`.
pub mod static_collection_prompt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CollectionItem {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub image: ::core::option::Option<super::StaticImagePrompt>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticListPrompt {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<static_list_prompt::ListItem>,
}
/// Nested message and enum types in `StaticListPrompt`.
pub mod static_list_prompt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListItem {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub image: ::core::option::Option<super::StaticImagePrompt>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticMediaPrompt {
    #[prost(enumeration = "static_media_prompt::MediaType", tag = "8")]
    pub media_type: i32,
    #[prost(message, optional, tag = "5")]
    pub start_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(
        enumeration = "static_media_prompt::OptionalMediaControls",
        repeated,
        tag = "6"
    )]
    pub optional_media_controls: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "7")]
    pub media_objects: ::prost::alloc::vec::Vec<MediaObject>,
    #[prost(enumeration = "static_media_prompt::RepeatMode", tag = "9")]
    pub repeat_mode: i32,
}
/// Nested message and enum types in `StaticMediaPrompt`.
pub mod static_media_prompt {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaType {
        Unspecified = 0,
        Audio = 1,
        MediaStatusAck = 2,
    }
    impl MediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaType::Unspecified => "MEDIA_TYPE_UNSPECIFIED",
                MediaType::Audio => "AUDIO",
                MediaType::MediaStatusAck => "MEDIA_STATUS_ACK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEDIA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUDIO" => Some(Self::Audio),
                "MEDIA_STATUS_ACK" => Some(Self::MediaStatusAck),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptionalMediaControls {
        Unspecified = 0,
        Paused = 1,
        Stopped = 2,
    }
    impl OptionalMediaControls {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OptionalMediaControls::Unspecified => {
                    "OPTIONAL_MEDIA_CONTROLS_UNSPECIFIED"
                }
                OptionalMediaControls::Paused => "PAUSED",
                OptionalMediaControls::Stopped => "STOPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPTIONAL_MEDIA_CONTROLS_UNSPECIFIED" => Some(Self::Unspecified),
                "PAUSED" => Some(Self::Paused),
                "STOPPED" => Some(Self::Stopped),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RepeatMode {
        Unspecified = 0,
        Off = 1,
        All = 2,
    }
    impl RepeatMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RepeatMode::Unspecified => "REPEAT_MODE_UNSPECIFIED",
                RepeatMode::Off => "OFF",
                RepeatMode::All => "ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPEAT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "OFF" => Some(Self::Off),
                "ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaObject {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub image: ::core::option::Option<MediaImage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaImage {
    #[prost(oneof = "media_image::Image", tags = "1, 2")]
    pub image: ::core::option::Option<media_image::Image>,
}
/// Nested message and enum types in `MediaImage`.
pub mod media_image {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Image {
        #[prost(message, tag = "1")]
        Large(super::StaticImagePrompt),
        #[prost(message, tag = "2")]
        Icon(super::StaticImagePrompt),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticTablePrompt {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub image: ::core::option::Option<StaticImagePrompt>,
    #[prost(message, repeated, tag = "4")]
    pub columns: ::prost::alloc::vec::Vec<TableColumn>,
    #[prost(message, repeated, tag = "5")]
    pub rows: ::prost::alloc::vec::Vec<TableRow>,
    #[prost(message, optional, tag = "6")]
    pub button: ::core::option::Option<StaticLinkPrompt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableColumn {
    #[prost(string, tag = "1")]
    pub header: ::prost::alloc::string::String,
    #[prost(enumeration = "table_column::HorizontalAlignment", tag = "2")]
    pub align: i32,
}
/// Nested message and enum types in `TableColumn`.
pub mod table_column {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HorizontalAlignment {
        Unspecified = 0,
        Leading = 1,
        Center = 2,
        Trailing = 3,
    }
    impl HorizontalAlignment {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HorizontalAlignment::Unspecified => "UNSPECIFIED",
                HorizontalAlignment::Leading => "LEADING",
                HorizontalAlignment::Center => "CENTER",
                HorizontalAlignment::Trailing => "TRAILING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "LEADING" => Some(Self::Leading),
                "CENTER" => Some(Self::Center),
                "TRAILING" => Some(Self::Trailing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableCell {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRow {
    #[prost(message, repeated, tag = "1")]
    pub cells: ::prost::alloc::vec::Vec<TableCell>,
    #[prost(bool, tag = "2")]
    pub divider: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticContentPrompt {
    #[prost(oneof = "static_content_prompt::Content", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub content: ::core::option::Option<static_content_prompt::Content>,
}
/// Nested message and enum types in `StaticContentPrompt`.
pub mod static_content_prompt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "1")]
        Card(super::StaticCardPrompt),
        #[prost(message, tag = "2")]
        Image(super::StaticImagePrompt),
        #[prost(message, tag = "3")]
        Table(super::StaticTablePrompt),
        #[prost(message, tag = "4")]
        Media(super::StaticMediaPrompt),
        #[prost(message, tag = "5")]
        List(super::StaticListPrompt),
        #[prost(message, tag = "6")]
        Collection(super::StaticCollectionPrompt),
        #[prost(message, tag = "7")]
        CollectionBrowse(super::StaticCollectionBrowsePrompt),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticSimplePrompt {
    #[prost(message, repeated, tag = "1")]
    pub variants: ::prost::alloc::vec::Vec<static_simple_prompt::Variant>,
}
/// Nested message and enum types in `StaticSimplePrompt`.
pub mod static_simple_prompt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Variant {
        #[prost(string, tag = "1")]
        pub speech: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub text: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Suggestion {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SurfaceCapabilities {
    #[prost(
        enumeration = "surface_capabilities::Capability",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub capabilities: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `SurfaceCapabilities`.
pub mod surface_capabilities {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Capability {
        Unspecified = 0,
        Speech = 1,
        RichResponse = 2,
        LongFormAudio = 3,
        InteractiveCanvas = 4,
        WebLink = 5,
        HomeStorage = 6,
    }
    impl Capability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Capability::Unspecified => "UNSPECIFIED",
                Capability::Speech => "SPEECH",
                Capability::RichResponse => "RICH_RESPONSE",
                Capability::LongFormAudio => "LONG_FORM_AUDIO",
                Capability::InteractiveCanvas => "INTERACTIVE_CANVAS",
                Capability::WebLink => "WEB_LINK",
                Capability::HomeStorage => "HOME_STORAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "SPEECH" => Some(Self::Speech),
                "RICH_RESPONSE" => Some(Self::RichResponse),
                "LONG_FORM_AUDIO" => Some(Self::LongFormAudio),
                "INTERACTIVE_CANVAS" => Some(Self::InteractiveCanvas),
                "WEB_LINK" => Some(Self::WebLink),
                "HOME_STORAGE" => Some(Self::HomeStorage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticPrompt {
    #[prost(message, repeated, tag = "1")]
    pub candidates: ::prost::alloc::vec::Vec<static_prompt::StaticPromptCandidate>,
}
/// Nested message and enum types in `StaticPrompt`.
pub mod static_prompt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticPromptCandidate {
        #[prost(message, optional, tag = "1")]
        pub selector: ::core::option::Option<Selector>,
        #[prost(message, optional, tag = "2")]
        pub prompt_response: ::core::option::Option<
            static_prompt_candidate::StaticPromptResponse,
        >,
    }
    /// Nested message and enum types in `StaticPromptCandidate`.
    pub mod static_prompt_candidate {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct StaticPromptResponse {
            #[prost(message, optional, tag = "2")]
            pub first_simple: ::core::option::Option<super::super::StaticSimplePrompt>,
            #[prost(message, optional, tag = "3")]
            pub content: ::core::option::Option<super::super::StaticContentPrompt>,
            #[prost(message, optional, tag = "4")]
            pub last_simple: ::core::option::Option<super::super::StaticSimplePrompt>,
            #[prost(message, repeated, tag = "5")]
            pub suggestions: ::prost::alloc::vec::Vec<super::super::Suggestion>,
            #[prost(message, optional, tag = "6")]
            pub link: ::core::option::Option<super::super::StaticLinkPrompt>,
            #[prost(bool, tag = "7")]
            pub r#override: bool,
            #[prost(message, optional, tag = "8")]
            pub canvas: ::core::option::Option<super::super::StaticCanvasPrompt>,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Selector {
        #[prost(message, optional, tag = "1")]
        pub surface_capabilities: ::core::option::Option<super::SurfaceCapabilities>,
    }
}
