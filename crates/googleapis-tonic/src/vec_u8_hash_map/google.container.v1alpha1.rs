// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeConfig {
#[prost(string, tag = "1")]
pub machine_type: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub disk_size_gb: i32,
#[prost(string, repeated, tag = "3")]
pub oauth_scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "9")]
pub service_account: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "4")]
pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub image_type: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "6")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(int32, tag = "7")]
pub local_ssd_count: i32,
#[prost(string, repeated, tag = "8")]
pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "10")]
pub preemptible: bool,
#[prost(message, repeated, tag = "11")]
pub accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
#[prost(string, tag = "13")]
pub min_cpu_platform: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "15")]
pub taints: ::prost::alloc::vec::Vec<NodeTaint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTaint {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub value: ::prost::alloc::string::String,
#[prost(enumeration = "node_taint::Effect", tag = "3")]
pub effect: i32,
}
/// Nested message and enum types in `NodeTaint`.
pub mod node_taint {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Effect {
Unspecified = 0,
NoSchedule = 1,
PreferNoSchedule = 2,
NoExecute = 3,
}
impl Effect {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Effect::Unspecified => "EFFECT_UNSPECIFIED",
Effect::NoSchedule => "NO_SCHEDULE",
Effect::PreferNoSchedule => "PREFER_NO_SCHEDULE",
Effect::NoExecute => "NO_EXECUTE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EFFECT_UNSPECIFIED" => Some(Self::Unspecified),
"NO_SCHEDULE" => Some(Self::NoSchedule),
"PREFER_NO_SCHEDULE" => Some(Self::PreferNoSchedule),
"NO_EXECUTE" => Some(Self::NoExecute),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterAuth {
#[prost(string, tag = "1")]
pub username: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub password: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub client_certificate_config: ::core::option::Option<ClientCertificateConfig>,
#[prost(string, tag = "100")]
pub cluster_ca_certificate: ::prost::alloc::string::String,
#[prost(string, tag = "101")]
pub client_certificate: ::prost::alloc::string::String,
#[prost(string, tag = "102")]
pub client_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientCertificateConfig {
#[prost(bool, tag = "1")]
pub issue_client_certificate: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddonsConfig {
#[prost(message, optional, tag = "1")]
pub http_load_balancing: ::core::option::Option<HttpLoadBalancing>,
#[prost(message, optional, tag = "2")]
pub horizontal_pod_autoscaling: ::core::option::Option<HorizontalPodAutoscaling>,
#[prost(message, optional, tag = "3")]
pub kubernetes_dashboard: ::core::option::Option<KubernetesDashboard>,
#[prost(message, optional, tag = "4")]
pub network_policy_config: ::core::option::Option<NetworkPolicyConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HttpLoadBalancing {
#[prost(bool, tag = "1")]
pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HorizontalPodAutoscaling {
#[prost(bool, tag = "1")]
pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KubernetesDashboard {
#[prost(bool, tag = "1")]
pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkPolicyConfig {
#[prost(bool, tag = "1")]
pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterAuthorizedNetworksConfig {
#[prost(bool, tag = "1")]
pub enabled: bool,
#[prost(message, repeated, tag = "2")]
pub cidr_blocks: ::prost::alloc::vec::Vec<master_authorized_networks_config::CidrBlock>,
}
/// Nested message and enum types in `MasterAuthorizedNetworksConfig`.
pub mod master_authorized_networks_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CidrBlock {
#[prost(string, tag = "1")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub cidr_block: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkPolicy {
#[prost(enumeration = "network_policy::Provider", tag = "1")]
pub provider: i32,
#[prost(bool, tag = "2")]
pub enabled: bool,
}
/// Nested message and enum types in `NetworkPolicy`.
pub mod network_policy {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Provider {
Unspecified = 0,
Calico = 1,
}
impl Provider {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Provider::Unspecified => "PROVIDER_UNSPECIFIED",
Provider::Calico => "CALICO",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
"CALICO" => Some(Self::Calico),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAllocationPolicy {
#[prost(bool, tag = "1")]
pub use_ip_aliases: bool,
#[prost(bool, tag = "2")]
pub create_subnetwork: bool,
#[prost(string, tag = "3")]
pub subnetwork_name: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub cluster_ipv4_cidr: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub node_ipv4_cidr: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub services_ipv4_cidr: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub cluster_secondary_range_name: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub services_secondary_range_name: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub cluster_ipv4_cidr_block: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub node_ipv4_cidr_block: ::prost::alloc::string::String,
#[prost(string, tag = "11")]
pub services_ipv4_cidr_block: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PodSecurityPolicyConfig {
#[prost(bool, tag = "1")]
pub enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub initial_node_count: i32,
#[prost(message, optional, tag = "4")]
pub node_config: ::core::option::Option<NodeConfig>,
#[prost(message, optional, tag = "5")]
pub master_auth: ::core::option::Option<MasterAuth>,
#[prost(string, tag = "6")]
pub logging_service: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub monitoring_service: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub network: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub cluster_ipv4_cidr: ::prost::alloc::string::String,
#[prost(message, optional, tag = "10")]
pub addons_config: ::core::option::Option<AddonsConfig>,
#[prost(string, tag = "11")]
pub subnetwork: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "12")]
pub node_pools: ::prost::alloc::vec::Vec<NodePool>,
#[prost(string, repeated, tag = "13")]
pub locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "14")]
pub enable_kubernetes_alpha: bool,
#[prost(message, optional, tag = "19")]
pub network_policy: ::core::option::Option<NetworkPolicy>,
#[prost(message, optional, tag = "20")]
pub ip_allocation_policy: ::core::option::Option<IpAllocationPolicy>,
#[prost(message, optional, tag = "22")]
pub master_authorized_networks_config: ::core::option::Option<MasterAuthorizedNetworksConfig>,
#[prost(message, optional, tag = "23")]
pub maintenance_policy: ::core::option::Option<MaintenancePolicy>,
#[prost(message, optional, tag = "25")]
pub pod_security_policy_config: ::core::option::Option<PodSecurityPolicyConfig>,
#[prost(string, tag = "100")]
pub self_link: ::prost::alloc::string::String,
#[prost(string, tag = "101")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "102")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "103")]
pub initial_cluster_version: ::prost::alloc::string::String,
#[prost(string, tag = "104")]
pub current_master_version: ::prost::alloc::string::String,
#[prost(string, tag = "105")]
pub current_node_version: ::prost::alloc::string::String,
#[prost(string, tag = "106")]
pub create_time: ::prost::alloc::string::String,
#[prost(enumeration = "cluster::Status", tag = "107")]
pub status: i32,
#[prost(string, tag = "108")]
pub status_message: ::prost::alloc::string::String,
#[prost(int32, tag = "109")]
pub node_ipv4_cidr_size: i32,
#[prost(string, tag = "110")]
pub services_ipv4_cidr: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "111")]
pub instance_group_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int32, tag = "112")]
pub current_node_count: i32,
#[prost(string, tag = "113")]
pub expire_time: ::prost::alloc::string::String,
#[prost(string, tag = "114")]
pub location: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
Unspecified = 0,
Provisioning = 1,
Running = 2,
Reconciling = 3,
Stopping = 4,
Error = 5,
}
impl Status {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Status::Unspecified => "STATUS_UNSPECIFIED",
Status::Provisioning => "PROVISIONING",
Status::Running => "RUNNING",
Status::Reconciling => "RECONCILING",
Status::Stopping => "STOPPING",
Status::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATUS_UNSPECIFIED" => Some(Self::Unspecified),
"PROVISIONING" => Some(Self::Provisioning),
"RUNNING" => Some(Self::Running),
"RECONCILING" => Some(Self::Reconciling),
"STOPPING" => Some(Self::Stopping),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterUpdate {
#[prost(string, tag = "4")]
pub desired_node_version: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub desired_monitoring_service: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub desired_addons_config: ::core::option::Option<AddonsConfig>,
#[prost(string, tag = "7")]
pub desired_node_pool_id: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub desired_image_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub desired_node_pool_autoscaling: ::core::option::Option<NodePoolAutoscaling>,
#[prost(string, repeated, tag = "10")]
pub desired_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "12")]
pub desired_master_authorized_networks_config: ::core::option::Option<MasterAuthorizedNetworksConfig>,
#[prost(message, optional, tag = "14")]
pub desired_pod_security_policy_config: ::core::option::Option<PodSecurityPolicyConfig>,
#[prost(string, tag = "100")]
pub desired_master_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(enumeration = "operation::Type", tag = "3")]
pub operation_type: i32,
#[prost(enumeration = "operation::Status", tag = "4")]
pub status: i32,
#[prost(string, tag = "8")]
pub detail: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub status_message: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub self_link: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub target_link: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub location: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub start_time: ::prost::alloc::string::String,
#[prost(string, tag = "11")]
pub end_time: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
Unspecified = 0,
Pending = 1,
Running = 2,
Done = 3,
Aborting = 4,
}
impl Status {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Status::Unspecified => "STATUS_UNSPECIFIED",
Status::Pending => "PENDING",
Status::Running => "RUNNING",
Status::Done => "DONE",
Status::Aborting => "ABORTING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATUS_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"RUNNING" => Some(Self::Running),
"DONE" => Some(Self::Done),
"ABORTING" => Some(Self::Aborting),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
CreateCluster = 1,
DeleteCluster = 2,
UpgradeMaster = 3,
UpgradeNodes = 4,
RepairCluster = 5,
UpdateCluster = 6,
CreateNodePool = 7,
DeleteNodePool = 8,
SetNodePoolManagement = 9,
AutoRepairNodes = 10,
AutoUpgradeNodes = 11,
SetLabels = 12,
SetMasterAuth = 13,
SetNodePoolSize = 14,
SetNetworkPolicy = 15,
SetMaintenancePolicy = 16,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::CreateCluster => "CREATE_CLUSTER",
Type::DeleteCluster => "DELETE_CLUSTER",
Type::UpgradeMaster => "UPGRADE_MASTER",
Type::UpgradeNodes => "UPGRADE_NODES",
Type::RepairCluster => "REPAIR_CLUSTER",
Type::UpdateCluster => "UPDATE_CLUSTER",
Type::CreateNodePool => "CREATE_NODE_POOL",
Type::DeleteNodePool => "DELETE_NODE_POOL",
Type::SetNodePoolManagement => "SET_NODE_POOL_MANAGEMENT",
Type::AutoRepairNodes => "AUTO_REPAIR_NODES",
Type::AutoUpgradeNodes => "AUTO_UPGRADE_NODES",
Type::SetLabels => "SET_LABELS",
Type::SetMasterAuth => "SET_MASTER_AUTH",
Type::SetNodePoolSize => "SET_NODE_POOL_SIZE",
Type::SetNetworkPolicy => "SET_NETWORK_POLICY",
Type::SetMaintenancePolicy => "SET_MAINTENANCE_POLICY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATE_CLUSTER" => Some(Self::CreateCluster),
"DELETE_CLUSTER" => Some(Self::DeleteCluster),
"UPGRADE_MASTER" => Some(Self::UpgradeMaster),
"UPGRADE_NODES" => Some(Self::UpgradeNodes),
"REPAIR_CLUSTER" => Some(Self::RepairCluster),
"UPDATE_CLUSTER" => Some(Self::UpdateCluster),
"CREATE_NODE_POOL" => Some(Self::CreateNodePool),
"DELETE_NODE_POOL" => Some(Self::DeleteNodePool),
"SET_NODE_POOL_MANAGEMENT" => Some(Self::SetNodePoolManagement),
"AUTO_REPAIR_NODES" => Some(Self::AutoRepairNodes),
"AUTO_UPGRADE_NODES" => Some(Self::AutoUpgradeNodes),
"SET_LABELS" => Some(Self::SetLabels),
"SET_MASTER_AUTH" => Some(Self::SetMasterAuth),
"SET_NODE_POOL_SIZE" => Some(Self::SetNodePoolSize),
"SET_NETWORK_POLICY" => Some(Self::SetNetworkPolicy),
"SET_MAINTENANCE_POLICY" => Some(Self::SetMaintenancePolicy),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClusterRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub cluster: ::core::option::Option<Cluster>,
#[prost(string, tag = "5")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClusterRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub update: ::core::option::Option<ClusterUpdate>,
#[prost(string, tag = "5")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNodePoolRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub node_version: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub image_type: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNodePoolAutoscalingRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub autoscaling: ::core::option::Option<NodePoolAutoscaling>,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLoggingServiceRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub logging_service: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMonitoringServiceRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub monitoring_service: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAddonsConfigRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub addons_config: ::core::option::Option<AddonsConfig>,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLocationsRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMasterRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub master_version: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMasterAuthRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(enumeration = "set_master_auth_request::Action", tag = "4")]
pub action: i32,
#[prost(message, optional, tag = "5")]
pub update: ::core::option::Option<MasterAuth>,
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SetMasterAuthRequest`.
pub mod set_master_auth_request {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Action {
Unknown = 0,
SetPassword = 1,
GeneratePassword = 2,
SetUsername = 3,
}
impl Action {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Action::Unknown => "UNKNOWN",
Action::SetPassword => "SET_PASSWORD",
Action::GeneratePassword => "GENERATE_PASSWORD",
Action::SetUsername => "SET_USERNAME",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"UNKNOWN" => Some(Self::Unknown),
"SET_PASSWORD" => Some(Self::SetPassword),
"GENERATE_PASSWORD" => Some(Self::GeneratePassword),
"SET_USERNAME" => Some(Self::SetUsername),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteClusterRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersResponse {
#[prost(message, repeated, tag = "1")]
pub clusters: ::prost::alloc::vec::Vec<Cluster>,
#[prost(string, repeated, tag = "2")]
pub missing_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOperationRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub operation_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOperationsRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelOperationRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub operation_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOperationsResponse {
#[prost(message, repeated, tag = "1")]
pub operations: ::prost::alloc::vec::Vec<Operation>,
#[prost(string, repeated, tag = "2")]
pub missing_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerConfigRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfig {
#[prost(string, tag = "1")]
pub default_cluster_version: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub valid_node_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub default_image_type: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "5")]
pub valid_image_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "6")]
pub valid_master_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNodePoolRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub node_pool: ::core::option::Option<NodePool>,
#[prost(string, tag = "6")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodePoolRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodePoolsRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodePoolRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePool {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub config: ::core::option::Option<NodeConfig>,
#[prost(int32, tag = "3")]
pub initial_node_count: i32,
#[prost(message, optional, tag = "4")]
pub autoscaling: ::core::option::Option<NodePoolAutoscaling>,
#[prost(message, optional, tag = "5")]
pub management: ::core::option::Option<NodeManagement>,
#[prost(string, tag = "100")]
pub self_link: ::prost::alloc::string::String,
#[prost(string, tag = "101")]
pub version: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "102")]
pub instance_group_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "node_pool::Status", tag = "103")]
pub status: i32,
#[prost(string, tag = "104")]
pub status_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NodePool`.
pub mod node_pool {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
Unspecified = 0,
Provisioning = 1,
Running = 2,
RunningWithError = 3,
Reconciling = 4,
Stopping = 5,
Error = 6,
}
impl Status {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Status::Unspecified => "STATUS_UNSPECIFIED",
Status::Provisioning => "PROVISIONING",
Status::Running => "RUNNING",
Status::RunningWithError => "RUNNING_WITH_ERROR",
Status::Reconciling => "RECONCILING",
Status::Stopping => "STOPPING",
Status::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATUS_UNSPECIFIED" => Some(Self::Unspecified),
"PROVISIONING" => Some(Self::Provisioning),
"RUNNING" => Some(Self::Running),
"RUNNING_WITH_ERROR" => Some(Self::RunningWithError),
"RECONCILING" => Some(Self::Reconciling),
"STOPPING" => Some(Self::Stopping),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeManagement {
#[prost(bool, tag = "1")]
pub auto_upgrade: bool,
#[prost(bool, tag = "2")]
pub auto_repair: bool,
#[prost(message, optional, tag = "10")]
pub upgrade_options: ::core::option::Option<AutoUpgradeOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoUpgradeOptions {
#[prost(string, tag = "1")]
pub auto_upgrade_start_time: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenancePolicy {
#[prost(message, optional, tag = "1")]
pub window: ::core::option::Option<MaintenanceWindow>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceWindow {
#[prost(oneof = "maintenance_window::Policy", tags = "2")]
pub policy: ::core::option::Option<maintenance_window::Policy>,
}
/// Nested message and enum types in `MaintenanceWindow`.
pub mod maintenance_window {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Policy {
#[prost(message, tag = "2")]
DailyMaintenanceWindow(super::DailyMaintenanceWindow),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DailyMaintenanceWindow {
#[prost(string, tag = "2")]
pub start_time: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub duration: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNodePoolManagementRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub management: ::core::option::Option<NodeManagement>,
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNodePoolSizeRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(int32, tag = "5")]
pub node_count: i32,
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackNodePoolUpgradeRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodePoolsResponse {
#[prost(message, repeated, tag = "1")]
pub node_pools: ::prost::alloc::vec::Vec<NodePool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodePoolAutoscaling {
#[prost(bool, tag = "1")]
pub enabled: bool,
#[prost(int32, tag = "2")]
pub min_node_count: i32,
#[prost(int32, tag = "3")]
pub max_node_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "4")]
pub resource_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub label_fingerprint: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLegacyAbacRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub enabled: bool,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartIpRotationRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteIpRotationRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorConfig {
#[prost(int64, tag = "1")]
pub accelerator_count: i64,
#[prost(string, tag = "2")]
pub accelerator_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNetworkPolicyRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub network_policy: ::core::option::Option<NetworkPolicy>,
#[prost(string, tag = "6")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMaintenancePolicyRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub maintenance_policy: ::core::option::Option<MaintenancePolicy>,
#[prost(string, tag = "5")]
pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod cluster_manager_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Google Container Engine Cluster Manager v1alpha1
#[derive(Debug, Clone)]
pub struct ClusterManagerClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ClusterManagerClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ClusterManagerClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ClusterManagerClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Lists all clusters owned by a project in either the specified zone or all
/// zones.
pub async fn list_clusters(&mut self, request: impl tonic::IntoRequest<super::ListClustersRequest>) -> std::result::Result<tonic::Response<super::ListClustersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/ListClusters");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "ListClusters"));
self.inner.unary(req, path, codec).await
}
/// Gets the details of a specific cluster.
pub async fn get_cluster(&mut self, request: impl tonic::IntoRequest<super::GetClusterRequest>) -> std::result::Result<tonic::Response<super::Cluster>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/GetCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "GetCluster"));
self.inner.unary(req, path, codec).await
}
/// Creates a cluster, consisting of the specified number and type of Google
/// Compute Engine instances.
///
/// By default, the cluster is created in the project's
/// [default network](/compute/docs/networks-and-firewalls#networks).
///
/// One firewall is added for the cluster. After cluster creation,
/// the cluster creates routes for each node to allow the containers
/// on that node to communicate with all other instances in the
/// cluster.
///
/// Finally, an entry is added to the project's global metadata indicating
/// which CIDR range is being used by the cluster.
pub async fn create_cluster(&mut self, request: impl tonic::IntoRequest<super::CreateClusterRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/CreateCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "CreateCluster"));
self.inner.unary(req, path, codec).await
}
/// Updates the settings of a specific cluster.
pub async fn update_cluster(&mut self, request: impl tonic::IntoRequest<super::UpdateClusterRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/UpdateCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "UpdateCluster"));
self.inner.unary(req, path, codec).await
}
/// Updates the version and/or iamge type of a specific node pool.
pub async fn update_node_pool(&mut self, request: impl tonic::IntoRequest<super::UpdateNodePoolRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/UpdateNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "UpdateNodePool"));
self.inner.unary(req, path, codec).await
}
/// Sets the autoscaling settings of a specific node pool.
pub async fn set_node_pool_autoscaling(&mut self, request: impl tonic::IntoRequest<super::SetNodePoolAutoscalingRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetNodePoolAutoscaling");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetNodePoolAutoscaling"));
self.inner.unary(req, path, codec).await
}
/// Sets the logging service of a specific cluster.
pub async fn set_logging_service(&mut self, request: impl tonic::IntoRequest<super::SetLoggingServiceRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetLoggingService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetLoggingService"));
self.inner.unary(req, path, codec).await
}
/// Sets the monitoring service of a specific cluster.
pub async fn set_monitoring_service(&mut self, request: impl tonic::IntoRequest<super::SetMonitoringServiceRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetMonitoringService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetMonitoringService"));
self.inner.unary(req, path, codec).await
}
/// Sets the addons of a specific cluster.
pub async fn set_addons_config(&mut self, request: impl tonic::IntoRequest<super::SetAddonsConfigRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetAddonsConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetAddonsConfig"));
self.inner.unary(req, path, codec).await
}
/// Sets the locations of a specific cluster.
pub async fn set_locations(&mut self, request: impl tonic::IntoRequest<super::SetLocationsRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetLocations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetLocations"));
self.inner.unary(req, path, codec).await
}
/// Updates the master of a specific cluster.
pub async fn update_master(&mut self, request: impl tonic::IntoRequest<super::UpdateMasterRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/UpdateMaster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "UpdateMaster"));
self.inner.unary(req, path, codec).await
}
/// Used to set master auth materials. Currently supports :-
/// Changing the admin password of a specific cluster.
/// This can be either via password generation or explicitly set.
/// Modify basic_auth.csv and reset the K8S API server.
pub async fn set_master_auth(&mut self, request: impl tonic::IntoRequest<super::SetMasterAuthRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetMasterAuth");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetMasterAuth"));
self.inner.unary(req, path, codec).await
}
/// Deletes the cluster, including the Kubernetes endpoint and all worker
/// nodes.
///
/// Firewalls and routes that were configured during cluster creation
/// are also deleted.
///
/// Other Google Compute Engine resources that might be in use by the cluster
/// (e.g. load balancer resources) will not be deleted if they weren't present
/// at the initial create time.
pub async fn delete_cluster(&mut self, request: impl tonic::IntoRequest<super::DeleteClusterRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/DeleteCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "DeleteCluster"));
self.inner.unary(req, path, codec).await
}
/// Lists all operations in a project in a specific zone or all zones.
pub async fn list_operations(&mut self, request: impl tonic::IntoRequest<super::ListOperationsRequest>) -> std::result::Result<tonic::Response<super::ListOperationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/ListOperations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "ListOperations"));
self.inner.unary(req, path, codec).await
}
/// Gets the specified operation.
pub async fn get_operation(&mut self, request: impl tonic::IntoRequest<super::GetOperationRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/GetOperation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "GetOperation"));
self.inner.unary(req, path, codec).await
}
/// Cancels the specified operation.
pub async fn cancel_operation(&mut self, request: impl tonic::IntoRequest<super::CancelOperationRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/CancelOperation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "CancelOperation"));
self.inner.unary(req, path, codec).await
}
/// Returns configuration info about the Container Engine service.
pub async fn get_server_config(&mut self, request: impl tonic::IntoRequest<super::GetServerConfigRequest>) -> std::result::Result<tonic::Response<super::ServerConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/GetServerConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "GetServerConfig"));
self.inner.unary(req, path, codec).await
}
/// Lists the node pools for a cluster.
pub async fn list_node_pools(&mut self, request: impl tonic::IntoRequest<super::ListNodePoolsRequest>) -> std::result::Result<tonic::Response<super::ListNodePoolsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/ListNodePools");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "ListNodePools"));
self.inner.unary(req, path, codec).await
}
/// Retrieves the node pool requested.
pub async fn get_node_pool(&mut self, request: impl tonic::IntoRequest<super::GetNodePoolRequest>) -> std::result::Result<tonic::Response<super::NodePool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/GetNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "GetNodePool"));
self.inner.unary(req, path, codec).await
}
/// Creates a node pool for a cluster.
pub async fn create_node_pool(&mut self, request: impl tonic::IntoRequest<super::CreateNodePoolRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/CreateNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "CreateNodePool"));
self.inner.unary(req, path, codec).await
}
/// Deletes a node pool from a cluster.
pub async fn delete_node_pool(&mut self, request: impl tonic::IntoRequest<super::DeleteNodePoolRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/DeleteNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "DeleteNodePool"));
self.inner.unary(req, path, codec).await
}
/// Roll back the previously Aborted or Failed NodePool upgrade.
/// This will be an no-op if the last upgrade successfully completed.
pub async fn rollback_node_pool_upgrade(&mut self, request: impl tonic::IntoRequest<super::RollbackNodePoolUpgradeRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/RollbackNodePoolUpgrade");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "RollbackNodePoolUpgrade"));
self.inner.unary(req, path, codec).await
}
/// Sets the NodeManagement options for a node pool.
pub async fn set_node_pool_management(&mut self, request: impl tonic::IntoRequest<super::SetNodePoolManagementRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetNodePoolManagement");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetNodePoolManagement"));
self.inner.unary(req, path, codec).await
}
/// Sets labels on a cluster.
pub async fn set_labels(&mut self, request: impl tonic::IntoRequest<super::SetLabelsRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetLabels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetLabels"));
self.inner.unary(req, path, codec).await
}
/// Enables or disables the ABAC authorization mechanism on a cluster.
pub async fn set_legacy_abac(&mut self, request: impl tonic::IntoRequest<super::SetLegacyAbacRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetLegacyAbac");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetLegacyAbac"));
self.inner.unary(req, path, codec).await
}
/// Start master IP rotation.
pub async fn start_ip_rotation(&mut self, request: impl tonic::IntoRequest<super::StartIpRotationRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/StartIPRotation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "StartIPRotation"));
self.inner.unary(req, path, codec).await
}
/// Completes master IP rotation.
pub async fn complete_ip_rotation(&mut self, request: impl tonic::IntoRequest<super::CompleteIpRotationRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/CompleteIPRotation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "CompleteIPRotation"));
self.inner.unary(req, path, codec).await
}
/// Sets the size of a specific node pool.
pub async fn set_node_pool_size(&mut self, request: impl tonic::IntoRequest<super::SetNodePoolSizeRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetNodePoolSize");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetNodePoolSize"));
self.inner.unary(req, path, codec).await
}
/// Enables/Disables Network Policy for a cluster.
pub async fn set_network_policy(&mut self, request: impl tonic::IntoRequest<super::SetNetworkPolicyRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetNetworkPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetNetworkPolicy"));
self.inner.unary(req, path, codec).await
}
/// Sets the maintenance policy for a cluster.
pub async fn set_maintenance_policy(&mut self, request: impl tonic::IntoRequest<super::SetMaintenancePolicyRequest>) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.container.v1alpha1.ClusterManager/SetMaintenancePolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.container.v1alpha1.ClusterManager", "SetMaintenancePolicy"));
self.inner.unary(req, path, codec).await
}
}
}
