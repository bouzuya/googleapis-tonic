// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrchestrationCluster {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub management_config: ::core::option::Option<ManagementConfig>,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub tna_version: ::prost::alloc::string::String,
    #[prost(enumeration = "orchestration_cluster::State", tag = "7")]
    pub state: i32,
}
/// Nested message and enum types in `OrchestrationCluster`.
pub mod orchestration_cluster {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Deleting = 3,
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EdgeSlm {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub orchestration_cluster: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub tna_version: ::prost::alloc::string::String,
    #[prost(enumeration = "edge_slm::State", tag = "7")]
    pub state: i32,
    #[prost(enumeration = "edge_slm::WorkloadClusterType", tag = "8")]
    pub workload_cluster_type: i32,
}
/// Nested message and enum types in `EdgeSlm`.
pub mod edge_slm {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Deleting = 3,
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum WorkloadClusterType {
        Unspecified = 0,
        Gdce = 1,
        Gke = 2,
    }
    impl WorkloadClusterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WorkloadClusterType::Unspecified => "WORKLOAD_CLUSTER_TYPE_UNSPECIFIED",
                WorkloadClusterType::Gdce => "GDCE",
                WorkloadClusterType::Gke => "GKE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WORKLOAD_CLUSTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GDCE" => Some(Self::Gdce),
                "GKE" => Some(Self::Gke),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blueprint {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_blueprint: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "blueprint::ApprovalState", tag = "6")]
    pub approval_state: i32,
    #[prost(string, tag = "7")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub repository: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub files: ::prost::alloc::vec::Vec<File>,
    #[prost(map = "string, string", tag = "10")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "13")]
    pub source_provider: ::prost::alloc::string::String,
    #[prost(enumeration = "DeploymentLevel", tag = "14")]
    pub deployment_level: i32,
    #[prost(bool, tag = "15")]
    pub rollback_support: bool,
}
/// Nested message and enum types in `Blueprint`.
pub mod blueprint {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ApprovalState {
        Unspecified = 0,
        Draft = 1,
        Proposed = 2,
        Approved = 3,
    }
    impl ApprovalState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ApprovalState::Unspecified => "APPROVAL_STATE_UNSPECIFIED",
                ApprovalState::Draft => "DRAFT",
                ApprovalState::Proposed => "PROPOSED",
                ApprovalState::Approved => "APPROVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPROVAL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "PROPOSED" => Some(Self::Proposed),
                "APPROVED" => Some(Self::Approved),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicBlueprint {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "DeploymentLevel", tag = "4")]
    pub deployment_level: i32,
    #[prost(string, tag = "5")]
    pub source_provider: ::prost::alloc::string::String,
    #[prost(bool, tag = "15")]
    pub rollback_support: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deployment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_blueprint_revision: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "deployment::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub repository: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<File>,
    #[prost(map = "string, string", tag = "9")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "12")]
    pub source_provider: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub workload_cluster: ::prost::alloc::string::String,
    #[prost(enumeration = "DeploymentLevel", tag = "14")]
    pub deployment_level: i32,
    #[prost(bool, tag = "15")]
    pub rollback_support: bool,
}
/// Nested message and enum types in `Deployment`.
pub mod deployment {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Draft = 1,
        Applied = 2,
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Draft => "DRAFT",
                State::Applied => "APPLIED",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "APPLIED" => Some(Self::Applied),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HydratedDeployment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "hydrated_deployment::State", tag = "2")]
    pub state: i32,
    #[prost(message, repeated, tag = "3")]
    pub files: ::prost::alloc::vec::Vec<File>,
    #[prost(string, tag = "4")]
    pub workload_cluster: ::prost::alloc::string::String,
}
/// Nested message and enum types in `HydratedDeployment`.
pub mod hydrated_deployment {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Draft = 1,
        Applied = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Draft => "DRAFT",
                State::Applied => "APPLIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "APPLIED" => Some(Self::Applied),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrchestrationClustersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrchestrationClustersResponse {
    #[prost(message, repeated, tag = "1")]
    pub orchestration_clusters: ::prost::alloc::vec::Vec<OrchestrationCluster>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrchestrationClusterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOrchestrationClusterRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub orchestration_cluster_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub orchestration_cluster: ::core::option::Option<OrchestrationCluster>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOrchestrationClusterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEdgeSlmsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEdgeSlmsResponse {
    #[prost(message, repeated, tag = "1")]
    pub edge_slms: ::prost::alloc::vec::Vec<EdgeSlm>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEdgeSlmRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEdgeSlmRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub edge_slm_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub edge_slm: ::core::option::Option<EdgeSlm>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEdgeSlmRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBlueprintRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub blueprint_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub blueprint: ::core::option::Option<Blueprint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBlueprintRequest {
    #[prost(message, optional, tag = "1")]
    pub blueprint: ::core::option::Option<Blueprint>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlueprintRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "BlueprintView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBlueprintRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintsResponse {
    #[prost(message, repeated, tag = "1")]
    pub blueprints: ::prost::alloc::vec::Vec<Blueprint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveBlueprintRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposeBlueprintRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectBlueprintRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintRevisionsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub blueprints: ::prost::alloc::vec::Vec<Blueprint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchBlueprintRevisionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchBlueprintRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub blueprints: ::prost::alloc::vec::Vec<Blueprint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscardBlueprintChangesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiscardBlueprintChangesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublicBlueprintsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublicBlueprintsResponse {
    #[prost(message, repeated, tag = "1")]
    pub public_blueprints: ::prost::alloc::vec::Vec<PublicBlueprint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublicBlueprintRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub deployment: ::core::option::Option<Deployment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentRequest {
    #[prost(message, optional, tag = "1")]
    pub deployment: ::core::option::Option<Deployment>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "DeploymentView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentRevisionsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDeploymentRevisionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDeploymentRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscardDeploymentChangesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiscardDeploymentChangesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeDeploymentStatusRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeDeploymentStatusResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "Status", tag = "2")]
    pub aggregated_status: i32,
    #[prost(message, repeated, tag = "3")]
    pub resource_statuses: ::prost::alloc::vec::Vec<ResourceStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHydratedDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHydratedDeploymentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHydratedDeploymentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub hydrated_deployments: ::prost::alloc::vec::Vec<HydratedDeployment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHydratedDeploymentRequest {
    #[prost(message, optional, tag = "1")]
    pub hydrated_deployment: ::core::option::Option<HydratedDeployment>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyHydratedDeploymentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagementConfig {
    #[prost(oneof = "management_config::OneofConfig", tags = "1, 2")]
    pub oneof_config: ::core::option::Option<management_config::OneofConfig>,
}
/// Nested message and enum types in `ManagementConfig`.
pub mod management_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneofConfig {
        #[prost(message, tag = "1")]
        StandardManagementConfig(super::StandardManagementConfig),
        #[prost(message, tag = "2")]
        FullManagementConfig(super::FullManagementConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardManagementConfig {
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subnet: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub master_ipv4_cidr_block: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub cluster_cidr_block: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub services_cidr_block: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub cluster_named_range: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub services_named_range: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub master_authorized_networks_config: ::core::option::Option<MasterAuthorizedNetworksConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullManagementConfig {
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subnet: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub master_ipv4_cidr_block: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub cluster_cidr_block: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub services_cidr_block: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub cluster_named_range: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub services_named_range: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub master_authorized_networks_config: ::core::option::Option<MasterAuthorizedNetworksConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterAuthorizedNetworksConfig {
    #[prost(message, repeated, tag = "1")]
    pub cidr_blocks: ::prost::alloc::vec::Vec<master_authorized_networks_config::CidrBlock>,
}
/// Nested message and enum types in `MasterAuthorizedNetworksConfig`.
pub mod master_authorized_networks_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CidrBlock {
        #[prost(string, tag = "1")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub cidr_block: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct File {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub deleted: bool,
    #[prost(bool, tag = "4")]
    pub editable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceStatus {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub resource_namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub group: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub kind: ::prost::alloc::string::String,
    #[prost(enumeration = "ResourceType", tag = "6")]
    pub resource_type: i32,
    #[prost(enumeration = "Status", tag = "7")]
    pub status: i32,
    #[prost(message, optional, tag = "8")]
    pub nf_deploy_status: ::core::option::Option<NfDeployStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfDeployStatus {
    #[prost(int32, tag = "1")]
    pub targeted_nfs: i32,
    #[prost(int32, tag = "2")]
    pub ready_nfs: i32,
    #[prost(message, repeated, tag = "3")]
    pub sites: ::prost::alloc::vec::Vec<NfDeploySiteStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfDeploySiteStatus {
    #[prost(string, tag = "1")]
    pub site: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub pending_deletion: bool,
    #[prost(message, optional, tag = "3")]
    pub hydration: ::core::option::Option<HydrationStatus>,
    #[prost(message, optional, tag = "4")]
    pub workload: ::core::option::Option<WorkloadStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HydrationStatus {
    #[prost(message, optional, tag = "1")]
    pub site_version: ::core::option::Option<SiteVersion>,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SiteVersion {
    #[prost(string, tag = "1")]
    pub nf_vendor: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub nf_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub nf_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadStatus {
    #[prost(message, optional, tag = "1")]
    pub site_version: ::core::option::Option<SiteVersion>,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlueprintView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl BlueprintView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BlueprintView::Unspecified => "BLUEPRINT_VIEW_UNSPECIFIED",
            BlueprintView::Basic => "BLUEPRINT_VIEW_BASIC",
            BlueprintView::Full => "BLUEPRINT_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLUEPRINT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BLUEPRINT_VIEW_BASIC" => Some(Self::Basic),
            "BLUEPRINT_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl DeploymentView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DeploymentView::Unspecified => "DEPLOYMENT_VIEW_UNSPECIFIED",
            DeploymentView::Basic => "DEPLOYMENT_VIEW_BASIC",
            DeploymentView::Full => "DEPLOYMENT_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "DEPLOYMENT_VIEW_BASIC" => Some(Self::Basic),
            "DEPLOYMENT_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceType {
    Unspecified = 0,
    NfDeployResource = 1,
    DeploymentResource = 2,
}
impl ResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResourceType::Unspecified => "RESOURCE_TYPE_UNSPECIFIED",
            ResourceType::NfDeployResource => "NF_DEPLOY_RESOURCE",
            ResourceType::DeploymentResource => "DEPLOYMENT_RESOURCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NF_DEPLOY_RESOURCE" => Some(Self::NfDeployResource),
            "DEPLOYMENT_RESOURCE" => Some(Self::DeploymentResource),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Unspecified = 0,
    InProgress = 1,
    Active = 2,
    Failed = 3,
    Deleting = 4,
    Deleted = 5,
    Peering = 10,
    NotApplicable = 11,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Status::Unspecified => "STATUS_UNSPECIFIED",
            Status::InProgress => "STATUS_IN_PROGRESS",
            Status::Active => "STATUS_ACTIVE",
            Status::Failed => "STATUS_FAILED",
            Status::Deleting => "STATUS_DELETING",
            Status::Deleted => "STATUS_DELETED",
            Status::Peering => "STATUS_PEERING",
            Status::NotApplicable => "STATUS_NOT_APPLICABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "STATUS_IN_PROGRESS" => Some(Self::InProgress),
            "STATUS_ACTIVE" => Some(Self::Active),
            "STATUS_FAILED" => Some(Self::Failed),
            "STATUS_DELETING" => Some(Self::Deleting),
            "STATUS_DELETED" => Some(Self::Deleted),
            "STATUS_PEERING" => Some(Self::Peering),
            "STATUS_NOT_APPLICABLE" => Some(Self::NotApplicable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentLevel {
    Unspecified = 0,
    Hydration = 1,
    SingleDeployment = 2,
    MultiDeployment = 3,
    WorkloadClusterDeployment = 4,
}
impl DeploymentLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DeploymentLevel::Unspecified => "DEPLOYMENT_LEVEL_UNSPECIFIED",
            DeploymentLevel::Hydration => "HYDRATION",
            DeploymentLevel::SingleDeployment => "SINGLE_DEPLOYMENT",
            DeploymentLevel::MultiDeployment => "MULTI_DEPLOYMENT",
            DeploymentLevel::WorkloadClusterDeployment => "WORKLOAD_CLUSTER_DEPLOYMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "HYDRATION" => Some(Self::Hydration),
            "SINGLE_DEPLOYMENT" => Some(Self::SingleDeployment),
            "MULTI_DEPLOYMENT" => Some(Self::MultiDeployment),
            "WORKLOAD_CLUSTER_DEPLOYMENT" => Some(Self::WorkloadClusterDeployment),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod telco_automation_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// TelcoAutomation Service manages the control plane cluster a.k.a.
    /// Orchestration Cluster (GKE cluster with config controller) of TNA. It also
    /// exposes blueprint APIs which manages the lifecycle of blueprints that control
    /// the infrastructure setup (e.g GDCE clusters) and deployment of network
    /// functions.
    #[derive(Debug, Clone)]
    pub struct TelcoAutomationClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TelcoAutomationClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TelcoAutomationClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            TelcoAutomationClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists OrchestrationClusters in a given project and location.
        pub async fn list_orchestration_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOrchestrationClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrchestrationClustersResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListOrchestrationClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListOrchestrationClusters",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single OrchestrationCluster.
        pub async fn get_orchestration_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrchestrationClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::OrchestrationCluster>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetOrchestrationCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "GetOrchestrationCluster",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new OrchestrationCluster in a given project and location.
        pub async fn create_orchestration_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateOrchestrationClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateOrchestrationCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "CreateOrchestrationCluster",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single OrchestrationCluster.
        pub async fn delete_orchestration_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteOrchestrationClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DeleteOrchestrationCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "DeleteOrchestrationCluster",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists EdgeSlms in a given project and location.
        pub async fn list_edge_slms(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEdgeSlmsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListEdgeSlmsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListEdgeSlms",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListEdgeSlms",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single EdgeSlm.
        pub async fn get_edge_slm(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEdgeSlmRequest>,
        ) -> std::result::Result<tonic::Response<super::EdgeSlm>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetEdgeSlm",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "GetEdgeSlm",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new EdgeSlm in a given project and location.
        pub async fn create_edge_slm(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEdgeSlmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateEdgeSlm",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "CreateEdgeSlm",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single EdgeSlm.
        pub async fn delete_edge_slm(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEdgeSlmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DeleteEdgeSlm",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "DeleteEdgeSlm",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a blueprint.
        pub async fn create_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "CreateBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a blueprint.
        pub async fn update_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/UpdateBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "UpdateBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested blueprint.
        pub async fn get_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "GetBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a blueprint and all its revisions.
        pub async fn delete_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DeleteBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "DeleteBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List all blueprints.
        pub async fn list_blueprints(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBlueprintsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListBlueprintsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListBlueprints",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListBlueprints",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Approves a blueprint and commits a new revision.
        pub async fn approve_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::ApproveBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ApproveBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ApproveBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Proposes a blueprint for approval of changes.
        pub async fn propose_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::ProposeBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ProposeBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ProposeBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Rejects a blueprint revision proposal and flips it back to Draft state.
        pub async fn reject_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::RejectBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/RejectBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "RejectBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List blueprint revisions of a given blueprint.
        pub async fn list_blueprint_revisions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBlueprintRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBlueprintRevisionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListBlueprintRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListBlueprintRevisions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Searches across blueprint revisions.
        pub async fn search_blueprint_revisions(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchBlueprintRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchBlueprintRevisionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/SearchBlueprintRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "SearchBlueprintRevisions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Searches across deployment revisions.
        pub async fn search_deployment_revisions(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchDeploymentRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchDeploymentRevisionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/SearchDeploymentRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "SearchDeploymentRevisions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Discards the changes in a blueprint and reverts the blueprint to the last
        /// approved blueprint revision. No changes take place if a blueprint does not
        /// have revisions.
        pub async fn discard_blueprint_changes(
            &mut self,
            request: impl tonic::IntoRequest<super::DiscardBlueprintChangesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DiscardBlueprintChangesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DiscardBlueprintChanges",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "DiscardBlueprintChanges",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the blueprints in TNA's public catalog. Default page size = 20,
        /// Max Page Size = 100.
        pub async fn list_public_blueprints(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPublicBlueprintsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListPublicBlueprintsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListPublicBlueprints",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListPublicBlueprints",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested public blueprint.
        pub async fn get_public_blueprint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPublicBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::PublicBlueprint>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetPublicBlueprint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "GetPublicBlueprint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a deployment.
        pub async fn create_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "CreateDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a deployment.
        pub async fn update_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/UpdateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "UpdateDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested deployment.
        pub async fn get_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "GetDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Removes the deployment by marking it as DELETING. Post which deployment and
        /// it's revisions gets deleted.
        pub async fn remove_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/RemoveDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "RemoveDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List all deployments.
        pub async fn list_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeploymentsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListDeploymentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListDeployments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List deployment revisions of a given deployment.
        pub async fn list_deployment_revisions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeploymentRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentRevisionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListDeploymentRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListDeploymentRevisions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Discards the changes in a deployment and reverts the deployment to the last
        /// approved deployment revision. No changes take place if a deployment does
        /// not have revisions.
        pub async fn discard_deployment_changes(
            &mut self,
            request: impl tonic::IntoRequest<super::DiscardDeploymentChangesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DiscardDeploymentChangesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DiscardDeploymentChanges",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "DiscardDeploymentChanges",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Applies the deployment's YAML files to the parent orchestration cluster.
        pub async fn apply_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ApplyDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ApplyDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested deployment status.
        pub async fn compute_deployment_status(
            &mut self,
            request: impl tonic::IntoRequest<super::ComputeDeploymentStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeDeploymentStatusResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ComputeDeploymentStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ComputeDeploymentStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Rollback the active deployment to the given past approved deployment
        /// revision.
        pub async fn rollback_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/RollbackDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "RollbackDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested hydrated deployment.
        pub async fn get_hydrated_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHydratedDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::HydratedDeployment>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetHydratedDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "GetHydratedDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List all hydrated deployments present under a deployment.
        pub async fn list_hydrated_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHydratedDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHydratedDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListHydratedDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ListHydratedDeployments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a hydrated deployment.
        pub async fn update_hydrated_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHydratedDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::HydratedDeployment>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/UpdateHydratedDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "UpdateHydratedDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Applies a hydrated deployment to a workload cluster.
        pub async fn apply_hydrated_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyHydratedDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::HydratedDeployment>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ApplyHydratedDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.telcoautomation.v1.TelcoAutomation",
                "ApplyHydratedDeployment",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
