// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Package {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "DesiredState", tag = "2")]
pub desired_state: i32,
#[prost(enumeration = "package::Manager", tag = "3")]
pub manager: i32,
}
/// Nested message and enum types in `Package`.
pub mod package {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Manager {
Unspecified = 0,
Any = 1,
Apt = 2,
Yum = 3,
Zypper = 4,
Goo = 5,
}
impl Manager {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Manager::Unspecified => "MANAGER_UNSPECIFIED",
Manager::Any => "ANY",
Manager::Apt => "APT",
Manager::Yum => "YUM",
Manager::Zypper => "ZYPPER",
Manager::Goo => "GOO",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MANAGER_UNSPECIFIED" => Some(Self::Unspecified),
"ANY" => Some(Self::Any),
"APT" => Some(Self::Apt),
"YUM" => Some(Self::Yum),
"ZYPPER" => Some(Self::Zypper),
"GOO" => Some(Self::Goo),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AptRepository {
#[prost(enumeration = "apt_repository::ArchiveType", tag = "1")]
pub archive_type: i32,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub distribution: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub gpg_key: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AptRepository`.
pub mod apt_repository {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArchiveType {
Unspecified = 0,
Deb = 1,
DebSrc = 2,
}
impl ArchiveType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ArchiveType::Unspecified => "ARCHIVE_TYPE_UNSPECIFIED",
ArchiveType::Deb => "DEB",
ArchiveType::DebSrc => "DEB_SRC",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ARCHIVE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"DEB" => Some(Self::Deb),
"DEB_SRC" => Some(Self::DebSrc),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YumRepository {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub base_url: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub gpg_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZypperRepository {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub base_url: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub gpg_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GooRepository {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageRepository {
#[prost(oneof = "package_repository::Repository", tags = "1, 2, 3, 4")]
pub repository: ::core::option::Option<package_repository::Repository>,
}
/// Nested message and enum types in `PackageRepository`.
pub mod package_repository {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Repository {
#[prost(message, tag = "1")]
Apt(super::AptRepository),
#[prost(message, tag = "2")]
Yum(super::YumRepository),
#[prost(message, tag = "3")]
Zypper(super::ZypperRepository),
#[prost(message, tag = "4")]
Goo(super::GooRepository),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SoftwareRecipe {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub version: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub artifacts: ::prost::alloc::vec::Vec<software_recipe::Artifact>,
#[prost(message, repeated, tag = "4")]
pub install_steps: ::prost::alloc::vec::Vec<software_recipe::Step>,
#[prost(message, repeated, tag = "5")]
pub update_steps: ::prost::alloc::vec::Vec<software_recipe::Step>,
#[prost(enumeration = "DesiredState", tag = "6")]
pub desired_state: i32,
}
/// Nested message and enum types in `SoftwareRecipe`.
pub mod software_recipe {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifact {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub allow_insecure: bool,
#[prost(oneof = "artifact::Artifact", tags = "2, 3")]
pub artifact: ::core::option::Option<artifact::Artifact>,
}
/// Nested message and enum types in `Artifact`.
pub mod artifact {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Remote {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub checksum: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gcs {
#[prost(string, tag = "1")]
pub bucket: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub object: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub generation: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Artifact {
#[prost(message, tag = "2")]
Remote(Remote),
#[prost(message, tag = "3")]
Gcs(Gcs),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Step {
#[prost(oneof = "step::Step", tags = "1, 2, 3, 4, 5, 6, 7")]
pub step: ::core::option::Option<step::Step>,
}
/// Nested message and enum types in `Step`.
pub mod step {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyFile {
#[prost(string, tag = "1")]
pub artifact_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub destination: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub overwrite: bool,
#[prost(string, tag = "4")]
pub permissions: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtractArchive {
#[prost(string, tag = "1")]
pub artifact_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub destination: ::prost::alloc::string::String,
#[prost(enumeration = "extract_archive::ArchiveType", tag = "3")]
pub r#type: i32,
}
/// Nested message and enum types in `ExtractArchive`.
pub mod extract_archive {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArchiveType {
Unspecified = 0,
Tar = 1,
TarGzip = 2,
TarBzip = 3,
TarLzma = 4,
TarXz = 5,
Zip = 11,
}
impl ArchiveType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ArchiveType::Unspecified => "ARCHIVE_TYPE_UNSPECIFIED",
ArchiveType::Tar => "TAR",
ArchiveType::TarGzip => "TAR_GZIP",
ArchiveType::TarBzip => "TAR_BZIP",
ArchiveType::TarLzma => "TAR_LZMA",
ArchiveType::TarXz => "TAR_XZ",
ArchiveType::Zip => "ZIP",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ARCHIVE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"TAR" => Some(Self::Tar),
"TAR_GZIP" => Some(Self::TarGzip),
"TAR_BZIP" => Some(Self::TarBzip),
"TAR_LZMA" => Some(Self::TarLzma),
"TAR_XZ" => Some(Self::TarXz),
"ZIP" => Some(Self::Zip),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallMsi {
#[prost(string, tag = "1")]
pub artifact_id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub flags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int32, repeated, tag = "3")]
pub allowed_exit_codes: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallDpkg {
#[prost(string, tag = "1")]
pub artifact_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallRpm {
#[prost(string, tag = "1")]
pub artifact_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecFile {
#[prost(string, repeated, tag = "3")]
pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int32, repeated, tag = "4")]
pub allowed_exit_codes: ::prost::alloc::vec::Vec<i32>,
#[prost(oneof = "exec_file::LocationType", tags = "1, 2")]
pub location_type: ::core::option::Option<exec_file::LocationType>,
}
/// Nested message and enum types in `ExecFile`.
pub mod exec_file {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum LocationType {
#[prost(string, tag = "1")]
ArtifactId(::prost::alloc::string::String),
#[prost(string, tag = "2")]
LocalPath(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunScript {
#[prost(string, tag = "1")]
pub script: ::prost::alloc::string::String,
#[prost(int32, repeated, tag = "2")]
pub allowed_exit_codes: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "run_script::Interpreter", tag = "3")]
pub interpreter: i32,
}
/// Nested message and enum types in `RunScript`.
pub mod run_script {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Interpreter {
Unspecified = 0,
Shell = 1,
Powershell = 3,
}
impl Interpreter {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Interpreter::Unspecified => "INTERPRETER_UNSPECIFIED",
Interpreter::Shell => "SHELL",
Interpreter::Powershell => "POWERSHELL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INTERPRETER_UNSPECIFIED" => Some(Self::Unspecified),
"SHELL" => Some(Self::Shell),
"POWERSHELL" => Some(Self::Powershell),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Step {
#[prost(message, tag = "1")]
FileCopy(CopyFile),
#[prost(message, tag = "2")]
ArchiveExtraction(ExtractArchive),
#[prost(message, tag = "3")]
MsiInstallation(InstallMsi),
#[prost(message, tag = "4")]
DpkgInstallation(InstallDpkg),
#[prost(message, tag = "5")]
RpmInstallation(InstallRpm),
#[prost(message, tag = "6")]
FileExec(ExecFile),
#[prost(message, tag = "7")]
ScriptRun(RunScript),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupEffectiveGuestPolicyRequest {
#[prost(string, tag = "1")]
pub instance_id_token: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub os_short_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub os_version: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub os_architecture: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffectiveGuestPolicy {
#[prost(message, repeated, tag = "1")]
pub packages: ::prost::alloc::vec::Vec<effective_guest_policy::SourcedPackage>,
#[prost(message, repeated, tag = "2")]
pub package_repositories: ::prost::alloc::vec::Vec<effective_guest_policy::SourcedPackageRepository>,
#[prost(message, repeated, tag = "3")]
pub software_recipes: ::prost::alloc::vec::Vec<effective_guest_policy::SourcedSoftwareRecipe>,
}
/// Nested message and enum types in `EffectiveGuestPolicy`.
pub mod effective_guest_policy {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourcedPackage {
#[prost(string, tag = "1")]
pub source: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub package: ::core::option::Option<super::Package>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourcedPackageRepository {
#[prost(string, tag = "1")]
pub source: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub package_repository: ::core::option::Option<super::PackageRepository>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourcedSoftwareRecipe {
#[prost(string, tag = "1")]
pub source: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub software_recipe: ::core::option::Option<super::SoftwareRecipe>,
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DesiredState {
Unspecified = 0,
Installed = 1,
Updated = 2,
Removed = 3,
}
impl DesiredState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DesiredState::Unspecified => "DESIRED_STATE_UNSPECIFIED",
DesiredState::Installed => "INSTALLED",
DesiredState::Updated => "UPDATED",
DesiredState::Removed => "REMOVED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DESIRED_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"INSTALLED" => Some(Self::Installed),
"UPDATED" => Some(Self::Updated),
"REMOVED" => Some(Self::Removed),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchConfig {
#[prost(enumeration = "patch_config::RebootConfig", tag = "1")]
pub reboot_config: i32,
#[prost(message, optional, tag = "2")]
pub retry_strategy: ::core::option::Option<RetryStrategy>,
#[prost(message, optional, tag = "3")]
pub apt: ::core::option::Option<AptSettings>,
#[prost(message, optional, tag = "4")]
pub yum: ::core::option::Option<YumSettings>,
#[prost(message, optional, tag = "5")]
pub goo: ::core::option::Option<GooSettings>,
#[prost(message, optional, tag = "6")]
pub zypper: ::core::option::Option<ZypperSettings>,
#[prost(message, optional, tag = "7")]
pub windows_update: ::core::option::Option<WindowsUpdateSettings>,
#[prost(message, optional, tag = "8")]
pub pre_step: ::core::option::Option<ExecStep>,
#[prost(message, optional, tag = "9")]
pub post_step: ::core::option::Option<ExecStep>,
#[prost(bool, tag = "10")]
pub mig_instances_allowed: bool,
}
/// Nested message and enum types in `PatchConfig`.
pub mod patch_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RebootConfig {
Unspecified = 0,
Default = 1,
Always = 2,
Never = 3,
}
impl RebootConfig {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RebootConfig::Unspecified => "REBOOT_CONFIG_UNSPECIFIED",
RebootConfig::Default => "DEFAULT",
RebootConfig::Always => "ALWAYS",
RebootConfig::Never => "NEVER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"REBOOT_CONFIG_UNSPECIFIED" => Some(Self::Unspecified),
"DEFAULT" => Some(Self::Default),
"ALWAYS" => Some(Self::Always),
"NEVER" => Some(Self::Never),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AptSettings {
#[prost(enumeration = "apt_settings::Type", tag = "1")]
pub r#type: i32,
#[prost(string, repeated, tag = "2")]
pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub exclusive_packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AptSettings`.
pub mod apt_settings {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Dist = 1,
Upgrade = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Dist => "DIST",
Type::Upgrade => "UPGRADE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"DIST" => Some(Self::Dist),
"UPGRADE" => Some(Self::Upgrade),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YumSettings {
#[prost(bool, tag = "1")]
pub security: bool,
#[prost(bool, tag = "2")]
pub minimal: bool,
#[prost(string, repeated, tag = "3")]
pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub exclusive_packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GooSettings {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZypperSettings {
#[prost(bool, tag = "1")]
pub with_optional: bool,
#[prost(bool, tag = "2")]
pub with_update: bool,
#[prost(string, repeated, tag = "3")]
pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub severities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "5")]
pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "6")]
pub exclusive_patches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowsUpdateSettings {
#[prost(enumeration = "windows_update_settings::Classification", repeated, tag = "1")]
pub classifications: ::prost::alloc::vec::Vec<i32>,
#[prost(string, repeated, tag = "2")]
pub excludes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub exclusive_patches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `WindowsUpdateSettings`.
pub mod windows_update_settings {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Classification {
Unspecified = 0,
Critical = 1,
Security = 2,
Definition = 3,
Driver = 4,
FeaturePack = 5,
ServicePack = 6,
Tool = 7,
UpdateRollup = 8,
Update = 9,
}
impl Classification {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Classification::Unspecified => "CLASSIFICATION_UNSPECIFIED",
Classification::Critical => "CRITICAL",
Classification::Security => "SECURITY",
Classification::Definition => "DEFINITION",
Classification::Driver => "DRIVER",
Classification::FeaturePack => "FEATURE_PACK",
Classification::ServicePack => "SERVICE_PACK",
Classification::Tool => "TOOL",
Classification::UpdateRollup => "UPDATE_ROLLUP",
Classification::Update => "UPDATE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CLASSIFICATION_UNSPECIFIED" => Some(Self::Unspecified),
"CRITICAL" => Some(Self::Critical),
"SECURITY" => Some(Self::Security),
"DEFINITION" => Some(Self::Definition),
"DRIVER" => Some(Self::Driver),
"FEATURE_PACK" => Some(Self::FeaturePack),
"SERVICE_PACK" => Some(Self::ServicePack),
"TOOL" => Some(Self::Tool),
"UPDATE_ROLLUP" => Some(Self::UpdateRollup),
"UPDATE" => Some(Self::Update),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetryStrategy {
#[prost(bool, tag = "1")]
pub enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecStep {
#[prost(message, optional, tag = "1")]
pub linux_exec_step_config: ::core::option::Option<ExecStepConfig>,
#[prost(message, optional, tag = "2")]
pub windows_exec_step_config: ::core::option::Option<ExecStepConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecStepConfig {
#[prost(int32, repeated, tag = "3")]
pub allowed_success_codes: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "exec_step_config::Interpreter", tag = "4")]
pub interpreter: i32,
#[prost(oneof = "exec_step_config::Executable", tags = "1, 2")]
pub executable: ::core::option::Option<exec_step_config::Executable>,
}
/// Nested message and enum types in `ExecStepConfig`.
pub mod exec_step_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Interpreter {
Unspecified = 0,
None = 3,
Shell = 1,
Powershell = 2,
}
impl Interpreter {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Interpreter::Unspecified => "INTERPRETER_UNSPECIFIED",
Interpreter::None => "NONE",
Interpreter::Shell => "SHELL",
Interpreter::Powershell => "POWERSHELL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INTERPRETER_UNSPECIFIED" => Some(Self::Unspecified),
"NONE" => Some(Self::None),
"SHELL" => Some(Self::Shell),
"POWERSHELL" => Some(Self::Powershell),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Executable {
#[prost(string, tag = "1")]
LocalPath(::prost::alloc::string::String),
#[prost(message, tag = "2")]
GcsObject(super::GcsObject),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsObject {
#[prost(string, tag = "1")]
pub bucket: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub object: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub generation_number: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
#[prost(string, tag = "1")]
pub task_id: ::prost::alloc::string::String,
#[prost(enumeration = "TaskType", tag = "2")]
pub task_type: i32,
#[prost(enumeration = "TaskDirective", tag = "3")]
pub task_directive: i32,
#[prost(map = "string, string", tag = "6")]
pub service_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(oneof = "task::TaskDetails", tags = "4, 5")]
pub task_details: ::core::option::Option<task::TaskDetails>,
}
/// Nested message and enum types in `Task`.
pub mod task {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TaskDetails {
#[prost(message, tag = "4")]
ApplyPatchesTask(super::ApplyPatchesTask),
#[prost(message, tag = "5")]
ExecStepTask(super::ExecStepTask),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyPatchesTask {
#[prost(message, optional, tag = "1")]
pub patch_config: ::core::option::Option<PatchConfig>,
#[prost(bool, tag = "3")]
pub dry_run: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApplyPatchesTaskProgress {
#[prost(enumeration = "apply_patches_task_progress::State", tag = "1")]
pub state: i32,
}
/// Nested message and enum types in `ApplyPatchesTaskProgress`.
pub mod apply_patches_task_progress {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Started = 4,
DownloadingPatches = 1,
ApplyingPatches = 2,
Rebooting = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Started => "STARTED",
State::DownloadingPatches => "DOWNLOADING_PATCHES",
State::ApplyingPatches => "APPLYING_PATCHES",
State::Rebooting => "REBOOTING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"STARTED" => Some(Self::Started),
"DOWNLOADING_PATCHES" => Some(Self::DownloadingPatches),
"APPLYING_PATCHES" => Some(Self::ApplyingPatches),
"REBOOTING" => Some(Self::Rebooting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApplyPatchesTaskOutput {
#[prost(enumeration = "apply_patches_task_output::State", tag = "1")]
pub state: i32,
}
/// Nested message and enum types in `ApplyPatchesTaskOutput`.
pub mod apply_patches_task_output {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Succeeded = 1,
SucceededRebootRequired = 2,
Failed = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Succeeded => "SUCCEEDED",
State::SucceededRebootRequired => "SUCCEEDED_REBOOT_REQUIRED",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"SUCCEEDED" => Some(Self::Succeeded),
"SUCCEEDED_REBOOT_REQUIRED" => Some(Self::SucceededRebootRequired),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecStepTask {
#[prost(message, optional, tag = "1")]
pub exec_step: ::core::option::Option<ExecStep>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecStepTaskProgress {
#[prost(enumeration = "exec_step_task_progress::State", tag = "1")]
pub state: i32,
}
/// Nested message and enum types in `ExecStepTaskProgress`.
pub mod exec_step_task_progress {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Started = 1,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Started => "STARTED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"STARTED" => Some(Self::Started),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecStepTaskOutput {
#[prost(enumeration = "exec_step_task_output::State", tag = "1")]
pub state: i32,
#[prost(int32, tag = "2")]
pub exit_code: i32,
}
/// Nested message and enum types in `ExecStepTaskOutput`.
pub mod exec_step_task_output {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Completed = 1,
TimedOut = 2,
Cancelled = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Completed => "COMPLETED",
State::TimedOut => "TIMED_OUT",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"COMPLETED" => Some(Self::Completed),
"TIMED_OUT" => Some(Self::TimedOut),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskDirective {
Unspecified = 0,
Continue = 1,
Stop = 2,
}
impl TaskDirective {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TaskDirective::Unspecified => "TASK_DIRECTIVE_UNSPECIFIED",
TaskDirective::Continue => "CONTINUE",
TaskDirective::Stop => "STOP",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TASK_DIRECTIVE_UNSPECIFIED" => Some(Self::Unspecified),
"CONTINUE" => Some(Self::Continue),
"STOP" => Some(Self::Stop),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskType {
Unspecified = 0,
ApplyPatches = 1,
ExecStepTask = 2,
}
impl TaskType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TaskType::Unspecified => "TASK_TYPE_UNSPECIFIED",
TaskType::ApplyPatches => "APPLY_PATCHES",
TaskType::ExecStepTask => "EXEC_STEP_TASK",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TASK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"APPLY_PATCHES" => Some(Self::ApplyPatches),
"EXEC_STEP_TASK" => Some(Self::ExecStepTask),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiveTaskNotificationRequest {
#[prost(string, tag = "1")]
pub instance_id_token: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub agent_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceiveTaskNotificationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNextTaskRequest {
#[prost(string, tag = "1")]
pub instance_id_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNextTaskResponse {
#[prost(message, optional, tag = "1")]
pub task: ::core::option::Option<Task>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportTaskProgressRequest {
#[prost(string, tag = "1")]
pub instance_id_token: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub task_id: ::prost::alloc::string::String,
#[prost(enumeration = "TaskType", tag = "3")]
pub task_type: i32,
#[prost(oneof = "report_task_progress_request::Progress", tags = "4, 5")]
pub progress: ::core::option::Option<report_task_progress_request::Progress>,
}
/// Nested message and enum types in `ReportTaskProgressRequest`.
pub mod report_task_progress_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Progress {
#[prost(message, tag = "4")]
ApplyPatchesTaskProgress(super::ApplyPatchesTaskProgress),
#[prost(message, tag = "5")]
ExecStepTaskProgress(super::ExecStepTaskProgress),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportTaskProgressResponse {
#[prost(enumeration = "TaskDirective", tag = "1")]
pub task_directive: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportTaskCompleteRequest {
#[prost(string, tag = "1")]
pub instance_id_token: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub task_id: ::prost::alloc::string::String,
#[prost(enumeration = "TaskType", tag = "3")]
pub task_type: i32,
#[prost(string, tag = "4")]
pub error_message: ::prost::alloc::string::String,
#[prost(oneof = "report_task_complete_request::Output", tags = "5, 6")]
pub output: ::core::option::Option<report_task_complete_request::Output>,
}
/// Nested message and enum types in `ReportTaskCompleteRequest`.
pub mod report_task_complete_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Output {
#[prost(message, tag = "5")]
ApplyPatchesTaskOutput(super::ApplyPatchesTaskOutput),
#[prost(message, tag = "6")]
ExecStepTaskOutput(super::ExecStepTaskOutput),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportTaskCompleteResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterAgentRequest {
#[prost(string, tag = "1")]
pub instance_id_token: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub agent_version: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub supported_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub os_long_name: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub os_short_name: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub os_version: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub os_architecture: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegisterAgentResponse {}
/// Generated client implementations.
pub mod agent_endpoint_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// OS Config agent endpoint API.
#[derive(Debug, Clone)]
pub struct AgentEndpointServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AgentEndpointServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AgentEndpointServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AgentEndpointServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Stream established by client to receive Task notifications.
pub async fn receive_task_notification(&mut self, request: impl tonic::IntoRequest<super::ReceiveTaskNotificationRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::ReceiveTaskNotificationResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService/ReceiveTaskNotification");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService", "ReceiveTaskNotification"));
self.inner.server_streaming(req, path, codec).await
}
/// Signals the start of a task execution and returns the task info.
pub async fn start_next_task(&mut self, request: impl tonic::IntoRequest<super::StartNextTaskRequest>) -> std::result::Result<tonic::Response<super::StartNextTaskResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService/StartNextTask");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService", "StartNextTask"));
self.inner.unary(req, path, codec).await
}
/// Signals an intermediary progress checkpoint in task execution.
pub async fn report_task_progress(&mut self, request: impl tonic::IntoRequest<super::ReportTaskProgressRequest>) -> std::result::Result<tonic::Response<super::ReportTaskProgressResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService/ReportTaskProgress");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService", "ReportTaskProgress"));
self.inner.unary(req, path, codec).await
}
/// Signals that the task execution is complete and optionally returns the next
/// task.
pub async fn report_task_complete(&mut self, request: impl tonic::IntoRequest<super::ReportTaskCompleteRequest>) -> std::result::Result<tonic::Response<super::ReportTaskCompleteResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService/ReportTaskComplete");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService", "ReportTaskComplete"));
self.inner.unary(req, path, codec).await
}
/// Lookup the effective guest policy that applies to a VM instance. This
/// lookup merges all policies that are assigned to the instance ancestry.
pub async fn lookup_effective_guest_policy(&mut self, request: impl tonic::IntoRequest<super::LookupEffectiveGuestPolicyRequest>) -> std::result::Result<tonic::Response<super::EffectiveGuestPolicy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService/LookupEffectiveGuestPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService", "LookupEffectiveGuestPolicy"));
self.inner.unary(req, path, codec).await
}
/// Registers the agent running on the VM.
pub async fn register_agent(&mut self, request: impl tonic::IntoRequest<super::RegisterAgentRequest>) -> std::result::Result<tonic::Response<super::RegisterAgentResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService/RegisterAgent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.osconfig.agentendpoint.v1beta.AgentEndpointService", "RegisterAgent"));
self.inner.unary(req, path, codec).await
}
}
}
