// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTuningModel {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub model_version: i64,
#[prost(enumeration = "custom_tuning_model::ModelState", tag = "4")]
pub model_state: i32,
#[prost(message, optional, tag = "5")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub training_start_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `CustomTuningModel`.
pub mod custom_tuning_model {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelState {
Unspecified = 0,
TrainingPaused = 1,
Training = 2,
TrainingComplete = 3,
ReadyForServing = 4,
TrainingFailed = 5,
}
impl ModelState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ModelState::Unspecified => "MODEL_STATE_UNSPECIFIED",
ModelState::TrainingPaused => "TRAINING_PAUSED",
ModelState::Training => "TRAINING",
ModelState::TrainingComplete => "TRAINING_COMPLETE",
ModelState::ReadyForServing => "READY_FOR_SERVING",
ModelState::TrainingFailed => "TRAINING_FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODEL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"TRAINING_PAUSED" => Some(Self::TrainingPaused),
"TRAINING" => Some(Self::Training),
"TRAINING_COMPLETE" => Some(Self::TrainingComplete),
"READY_FOR_SERVING" => Some(Self::ReadyForServing),
"TRAINING_FAILED" => Some(Self::TrainingFailed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub provision_completion_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(map = "string, message", tag = "4")]
pub service_terms_map: ::std::collections::HashMap<::prost::alloc::string::String, project::ServiceTerms>,
}
/// Nested message and enum types in `Project`.
pub mod project {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceTerms {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub version: ::prost::alloc::string::String,
#[prost(enumeration = "service_terms::State", tag = "4")]
pub state: i32,
#[prost(message, optional, tag = "5")]
pub accept_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub decline_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `ServiceTerms`.
pub mod service_terms {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
TermsAccepted = 1,
TermsPending = 2,
TermsDeclined = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::TermsAccepted => "TERMS_ACCEPTED",
State::TermsPending => "TERMS_PENDING",
State::TermsDeclined => "TERMS_DECLINED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"TERMS_ACCEPTED" => Some(Self::TermsAccepted),
"TERMS_PENDING" => Some(Self::TermsPending),
"TERMS_DECLINED" => Some(Self::TermsDeclined),
_ => None,
}
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SiteSearchEngine {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSite {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub provided_uri_pattern: ::prost::alloc::string::String,
#[prost(enumeration = "target_site::Type", tag = "3")]
pub r#type: i32,
#[prost(bool, tag = "6")]
pub exact_match: bool,
#[prost(string, tag = "4")]
pub generated_uri_pattern: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub root_domain_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub site_verification_info: ::core::option::Option<SiteVerificationInfo>,
#[prost(enumeration = "target_site::IndexingStatus", tag = "8")]
pub indexing_status: i32,
#[prost(message, optional, tag = "5")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub failure_reason: ::core::option::Option<target_site::FailureReason>,
}
/// Nested message and enum types in `TargetSite`.
pub mod target_site {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailureReason {
#[prost(oneof = "failure_reason::Failure", tags = "1")]
pub failure: ::core::option::Option<failure_reason::Failure>,
}
/// Nested message and enum types in `FailureReason`.
pub mod failure_reason {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuotaFailure {
#[prost(int64, tag = "1")]
pub total_required_quota: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Failure {
#[prost(message, tag = "1")]
QuotaFailure(QuotaFailure),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Include = 1,
Exclude = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Include => "INCLUDE",
Type::Exclude => "EXCLUDE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"INCLUDE" => Some(Self::Include),
"EXCLUDE" => Some(Self::Exclude),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexingStatus {
Unspecified = 0,
Pending = 1,
Failed = 2,
Succeeded = 3,
Deleting = 4,
}
impl IndexingStatus {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
IndexingStatus::Unspecified => "INDEXING_STATUS_UNSPECIFIED",
IndexingStatus::Pending => "PENDING",
IndexingStatus::Failed => "FAILED",
IndexingStatus::Succeeded => "SUCCEEDED",
IndexingStatus::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INDEXING_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"FAILED" => Some(Self::Failed),
"SUCCEEDED" => Some(Self::Succeeded),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SiteVerificationInfo {
#[prost(enumeration = "site_verification_info::SiteVerificationState", tag = "1")]
pub site_verification_state: i32,
#[prost(message, optional, tag = "2")]
pub verify_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `SiteVerificationInfo`.
pub mod site_verification_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SiteVerificationState {
Unspecified = 0,
Verified = 1,
Unverified = 2,
Exempted = 3,
}
impl SiteVerificationState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SiteVerificationState::Unspecified => "SITE_VERIFICATION_STATE_UNSPECIFIED",
SiteVerificationState::Verified => "VERIFIED",
SiteVerificationState::Unverified => "UNVERIFIED",
SiteVerificationState::Exempted => "EXEMPTED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SITE_VERIFICATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"VERIFIED" => Some(Self::Verified),
"UNVERIFIED" => Some(Self::Unverified),
"EXEMPTED" => Some(Self::Exempted),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSiteSearchEngineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTargetSiteRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub target_site: ::core::option::Option<TargetSite>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateTargetSiteMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSitesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub requests: ::prost::alloc::vec::Vec<CreateTargetSiteRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetSiteRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTargetSiteRequest {
#[prost(message, optional, tag = "1")]
pub target_site: ::core::option::Option<TargetSite>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateTargetSiteMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetSiteRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTargetSiteMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetSitesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetSitesResponse {
#[prost(message, repeated, tag = "1")]
pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSiteMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSitesResponse {
#[prost(message, repeated, tag = "1")]
pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableAdvancedSiteSearchRequest {
#[prost(string, tag = "1")]
pub site_search_engine: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableAdvancedSiteSearchResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableAdvancedSiteSearchMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableAdvancedSiteSearchRequest {
#[prost(string, tag = "1")]
pub site_search_engine: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableAdvancedSiteSearchResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableAdvancedSiteSearchMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecrawlUrisRequest {
#[prost(string, tag = "1")]
pub site_search_engine: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecrawlUrisResponse {
#[prost(message, repeated, tag = "1")]
pub failure_samples: ::prost::alloc::vec::Vec<recrawl_uris_response::FailureInfo>,
#[prost(string, repeated, tag = "2")]
pub failed_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RecrawlUrisResponse`.
pub mod recrawl_uris_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailureInfo {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub failure_reasons: ::prost::alloc::vec::Vec<failure_info::FailureReason>,
}
/// Nested message and enum types in `FailureInfo`.
pub mod failure_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailureReason {
#[prost(enumeration = "failure_reason::CorpusType", tag = "1")]
pub corpus_type: i32,
#[prost(string, tag = "2")]
pub error_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `FailureReason`.
pub mod failure_reason {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CorpusType {
Unspecified = 0,
Desktop = 1,
Mobile = 2,
}
impl CorpusType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CorpusType::Unspecified => "CORPUS_TYPE_UNSPECIFIED",
CorpusType::Desktop => "DESKTOP",
CorpusType::Mobile => "MOBILE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CORPUS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"DESKTOP" => Some(Self::Desktop),
"MOBILE" => Some(Self::Mobile),
_ => None,
}
}
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecrawlUrisMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, repeated, tag = "3")]
pub invalid_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int32, tag = "4")]
pub valid_uris_count: i32,
#[prost(int32, tag = "5")]
pub success_count: i32,
#[prost(int32, tag = "6")]
pub pending_count: i32,
#[prost(int32, tag = "7")]
pub quota_exceeded_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchVerifyTargetSitesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchVerifyTargetSitesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchVerifyTargetSitesMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchDomainVerificationStatusRequest {
#[prost(string, tag = "1")]
pub site_search_engine: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchDomainVerificationStatusResponse {
#[prost(message, repeated, tag = "1")]
pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub total_size: i32,
}
/// Generated client implementations.
pub mod site_search_engine_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing site search related resources.
#[derive(Debug, Clone)]
pub struct SiteSearchEngineServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SiteSearchEngineServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SiteSearchEngineServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SiteSearchEngineServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets the
/// [SiteSearchEngine][google.cloud.discoveryengine.v1alpha.SiteSearchEngine].
pub async fn get_site_search_engine(&mut self, request: impl tonic::IntoRequest<super::GetSiteSearchEngineRequest>) -> std::result::Result<tonic::Response<super::SiteSearchEngine>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/GetSiteSearchEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "GetSiteSearchEngine"));
self.inner.unary(req, path, codec).await
}
/// Creates a [TargetSite][google.cloud.discoveryengine.v1alpha.TargetSite].
pub async fn create_target_site(&mut self, request: impl tonic::IntoRequest<super::CreateTargetSiteRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/CreateTargetSite");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "CreateTargetSite"));
self.inner.unary(req, path, codec).await
}
/// Creates [TargetSite][google.cloud.discoveryengine.v1alpha.TargetSite] in a
/// batch.
pub async fn batch_create_target_sites(&mut self, request: impl tonic::IntoRequest<super::BatchCreateTargetSitesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/BatchCreateTargetSites");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "BatchCreateTargetSites"));
self.inner.unary(req, path, codec).await
}
/// Gets a [TargetSite][google.cloud.discoveryengine.v1alpha.TargetSite].
pub async fn get_target_site(&mut self, request: impl tonic::IntoRequest<super::GetTargetSiteRequest>) -> std::result::Result<tonic::Response<super::TargetSite>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/GetTargetSite");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "GetTargetSite"));
self.inner.unary(req, path, codec).await
}
/// Updates a [TargetSite][google.cloud.discoveryengine.v1alpha.TargetSite].
pub async fn update_target_site(&mut self, request: impl tonic::IntoRequest<super::UpdateTargetSiteRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/UpdateTargetSite");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "UpdateTargetSite"));
self.inner.unary(req, path, codec).await
}
/// Deletes a [TargetSite][google.cloud.discoveryengine.v1alpha.TargetSite].
pub async fn delete_target_site(&mut self, request: impl tonic::IntoRequest<super::DeleteTargetSiteRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/DeleteTargetSite");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "DeleteTargetSite"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of
/// [TargetSite][google.cloud.discoveryengine.v1alpha.TargetSite]s.
pub async fn list_target_sites(&mut self, request: impl tonic::IntoRequest<super::ListTargetSitesRequest>) -> std::result::Result<tonic::Response<super::ListTargetSitesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/ListTargetSites");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "ListTargetSites"));
self.inner.unary(req, path, codec).await
}
/// Upgrade from basic site search to advanced site search.
pub async fn enable_advanced_site_search(&mut self, request: impl tonic::IntoRequest<super::EnableAdvancedSiteSearchRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/EnableAdvancedSiteSearch");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "EnableAdvancedSiteSearch"));
self.inner.unary(req, path, codec).await
}
/// Downgrade from advanced site search to basic site search.
pub async fn disable_advanced_site_search(&mut self, request: impl tonic::IntoRequest<super::DisableAdvancedSiteSearchRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/DisableAdvancedSiteSearch");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "DisableAdvancedSiteSearch"));
self.inner.unary(req, path, codec).await
}
/// Request on-demand recrawl for a list of URIs.
pub async fn recrawl_uris(&mut self, request: impl tonic::IntoRequest<super::RecrawlUrisRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/RecrawlUris");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "RecrawlUris"));
self.inner.unary(req, path, codec).await
}
/// Verify target sites' ownership and validity.
/// This API sends all the target sites under site search engine for
/// verification.
pub async fn batch_verify_target_sites(&mut self, request: impl tonic::IntoRequest<super::BatchVerifyTargetSitesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/BatchVerifyTargetSites");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "BatchVerifyTargetSites"));
self.inner.unary(req, path, codec).await
}
/// Returns list of target sites with its domain verification status.
/// This method can only be called under data store with BASIC_SITE_SEARCH
/// state at the moment.
pub async fn fetch_domain_verification_status(&mut self, request: impl tonic::IntoRequest<super::FetchDomainVerificationStatusRequest>) -> std::result::Result<tonic::Response<super::FetchDomainVerificationStatusResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SiteSearchEngineService/FetchDomainVerificationStatus");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SiteSearchEngineService", "FetchDomainVerificationStatus"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Interval {
#[prost(oneof = "interval::Min", tags = "1, 2")]
pub min: ::core::option::Option<interval::Min>,
#[prost(oneof = "interval::Max", tags = "3, 4")]
pub max: ::core::option::Option<interval::Max>,
}
/// Nested message and enum types in `Interval`.
pub mod interval {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Min {
#[prost(double, tag = "1")]
Minimum(f64),
#[prost(double, tag = "2")]
ExclusiveMinimum(f64),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Max {
#[prost(double, tag = "3")]
Maximum(f64),
#[prost(double, tag = "4")]
ExclusiveMaximum(f64),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAttribute {
#[prost(string, repeated, tag = "1")]
pub text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(double, repeated, tag = "2")]
pub numbers: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
#[prost(string, tag = "1")]
pub user_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub user_agent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbeddingConfig {
#[prost(string, tag = "1")]
pub field_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleList {
#[prost(double, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GuidedSearchSpec {
#[prost(bool, tag = "1")]
pub enable_refinement_attributes: bool,
#[prost(bool, tag = "2")]
pub enable_related_questions: bool,
#[prost(int32, tag = "3")]
pub max_related_questions: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomFineTuningSpec {
#[prost(bool, tag = "1")]
pub enable_search_adaptor: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdpConfig {
#[prost(enumeration = "idp_config::IdpType", tag = "1")]
pub idp_type: i32,
#[prost(message, optional, tag = "2")]
pub external_idp_config: ::core::option::Option<idp_config::ExternalIdpConfig>,
}
/// Nested message and enum types in `IdpConfig`.
pub mod idp_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalIdpConfig {
#[prost(string, tag = "1")]
pub workforce_pool_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IdpType {
Unspecified = 0,
Gsuite = 1,
ThirdParty = 2,
}
impl IdpType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
IdpType::Unspecified => "IDP_TYPE_UNSPECIFIED",
IdpType::Gsuite => "GSUITE",
IdpType::ThirdParty => "THIRD_PARTY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"IDP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"GSUITE" => Some(Self::Gsuite),
"THIRD_PARTY" => Some(Self::ThirdParty),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Principal {
#[prost(oneof = "principal::Principal", tags = "1, 2")]
pub principal: ::core::option::Option<principal::Principal>,
}
/// Nested message and enum types in `Principal`.
pub mod principal {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Principal {
#[prost(string, tag = "1")]
UserId(::prost::alloc::string::String),
#[prost(string, tag = "2")]
GroupId(::prost::alloc::string::String),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndustryVertical {
Unspecified = 0,
Generic = 1,
Media = 2,
HealthcareFhir = 7,
}
impl IndustryVertical {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
IndustryVertical::Unspecified => "INDUSTRY_VERTICAL_UNSPECIFIED",
IndustryVertical::Generic => "GENERIC",
IndustryVertical::Media => "MEDIA",
IndustryVertical::HealthcareFhir => "HEALTHCARE_FHIR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INDUSTRY_VERTICAL_UNSPECIFIED" => Some(Self::Unspecified),
"GENERIC" => Some(Self::Generic),
"MEDIA" => Some(Self::Media),
"HEALTHCARE_FHIR" => Some(Self::HealthcareFhir),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolutionType {
Unspecified = 0,
Recommendation = 1,
Search = 2,
Chat = 3,
GenerativeChat = 4,
}
impl SolutionType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SolutionType::Unspecified => "SOLUTION_TYPE_UNSPECIFIED",
SolutionType::Recommendation => "SOLUTION_TYPE_RECOMMENDATION",
SolutionType::Search => "SOLUTION_TYPE_SEARCH",
SolutionType::Chat => "SOLUTION_TYPE_CHAT",
SolutionType::GenerativeChat => "SOLUTION_TYPE_GENERATIVE_CHAT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SOLUTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"SOLUTION_TYPE_RECOMMENDATION" => Some(Self::Recommendation),
"SOLUTION_TYPE_SEARCH" => Some(Self::Search),
"SOLUTION_TYPE_CHAT" => Some(Self::Chat),
"SOLUTION_TYPE_GENERATIVE_CHAT" => Some(Self::GenerativeChat),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchUseCase {
Unspecified = 0,
Search = 1,
Browse = 2,
}
impl SearchUseCase {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SearchUseCase::Unspecified => "SEARCH_USE_CASE_UNSPECIFIED",
SearchUseCase::Search => "SEARCH_USE_CASE_SEARCH",
SearchUseCase::Browse => "SEARCH_USE_CASE_BROWSE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEARCH_USE_CASE_UNSPECIFIED" => Some(Self::Unspecified),
"SEARCH_USE_CASE_SEARCH" => Some(Self::Search),
"SEARCH_USE_CASE_BROWSE" => Some(Self::Browse),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchTier {
Unspecified = 0,
Standard = 1,
Enterprise = 2,
}
impl SearchTier {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SearchTier::Unspecified => "SEARCH_TIER_UNSPECIFIED",
SearchTier::Standard => "SEARCH_TIER_STANDARD",
SearchTier::Enterprise => "SEARCH_TIER_ENTERPRISE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEARCH_TIER_UNSPECIFIED" => Some(Self::Unspecified),
"SEARCH_TIER_STANDARD" => Some(Self::Standard),
"SEARCH_TIER_ENTERPRISE" => Some(Self::Enterprise),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchAddOn {
Unspecified = 0,
Llm = 1,
}
impl SearchAddOn {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SearchAddOn::Unspecified => "SEARCH_ADD_ON_UNSPECIFIED",
SearchAddOn::Llm => "SEARCH_ADD_ON_LLM",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEARCH_ADD_ON_UNSPECIFIED" => Some(Self::Unspecified),
"SEARCH_ADD_ON_LLM" => Some(Self::Llm),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserEvent {
#[prost(string, tag = "1")]
pub event_type: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub user_pseudo_id: ::prost::alloc::string::String,
#[prost(string, tag = "19")]
pub engine: ::prost::alloc::string::String,
#[prost(string, tag = "20")]
pub data_store: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub event_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub user_info: ::core::option::Option<UserInfo>,
#[prost(bool, tag = "5")]
pub direct_user_request: bool,
#[prost(string, tag = "6")]
pub session_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub page_info: ::core::option::Option<PageInfo>,
#[prost(string, tag = "8")]
pub attribution_token: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub filter: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "10")]
pub documents: ::prost::alloc::vec::Vec<DocumentInfo>,
#[prost(message, optional, tag = "11")]
pub panel: ::core::option::Option<PanelInfo>,
#[prost(message, optional, tag = "12")]
pub search_info: ::core::option::Option<SearchInfo>,
#[prost(message, optional, tag = "13")]
pub completion_info: ::core::option::Option<CompletionInfo>,
#[prost(message, optional, tag = "14")]
pub transaction_info: ::core::option::Option<TransactionInfo>,
#[prost(string, repeated, tag = "15")]
pub tag_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "16")]
pub promotion_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(map = "string, message", tag = "17")]
pub attributes: ::std::collections::HashMap<::prost::alloc::string::String, CustomAttribute>,
#[prost(message, optional, tag = "18")]
pub media_info: ::core::option::Option<MediaInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageInfo {
#[prost(string, tag = "1")]
pub pageview_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_category: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub referrer_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchInfo {
#[prost(string, tag = "1")]
pub search_query: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub order_by: ::prost::alloc::string::String,
#[prost(int32, optional, tag = "3")]
pub offset: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionInfo {
#[prost(string, tag = "1")]
pub selected_suggestion: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub selected_position: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInfo {
#[prost(float, optional, tag = "1")]
pub value: ::core::option::Option<f32>,
#[prost(string, tag = "2")]
pub currency: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub transaction_id: ::prost::alloc::string::String,
#[prost(float, optional, tag = "4")]
pub tax: ::core::option::Option<f32>,
#[prost(float, optional, tag = "5")]
pub cost: ::core::option::Option<f32>,
#[prost(float, optional, tag = "6")]
pub discount_value: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentInfo {
#[prost(int32, optional, tag = "3")]
pub quantity: ::core::option::Option<i32>,
#[prost(string, repeated, tag = "4")]
pub promotion_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(oneof = "document_info::DocumentDescriptor", tags = "1, 2, 6")]
pub document_descriptor: ::core::option::Option<document_info::DocumentDescriptor>,
}
/// Nested message and enum types in `DocumentInfo`.
pub mod document_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DocumentDescriptor {
#[prost(string, tag = "1")]
Id(::prost::alloc::string::String),
#[prost(string, tag = "2")]
Name(::prost::alloc::string::String),
#[prost(string, tag = "6")]
Uri(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PanelInfo {
#[prost(string, tag = "2")]
pub panel_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(int32, optional, tag = "4")]
pub panel_position: ::core::option::Option<i32>,
#[prost(int32, optional, tag = "5")]
pub total_panels: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaInfo {
#[prost(message, optional, tag = "1")]
pub media_progress_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(float, optional, tag = "2")]
pub media_progress_percentage: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestionDenyListEntry {
#[prost(string, tag = "1")]
pub block_phrase: ::prost::alloc::string::String,
#[prost(enumeration = "suggestion_deny_list_entry::MatchOperator", tag = "2")]
pub match_operator: i32,
}
/// Nested message and enum types in `SuggestionDenyListEntry`.
pub mod suggestion_deny_list_entry {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchOperator {
Unspecified = 0,
ExactMatch = 1,
Contains = 2,
}
impl MatchOperator {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MatchOperator::Unspecified => "MATCH_OPERATOR_UNSPECIFIED",
MatchOperator::ExactMatch => "EXACT_MATCH",
MatchOperator::Contains => "CONTAINS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MATCH_OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
"EXACT_MATCH" => Some(Self::ExactMatch),
"CONTAINS" => Some(Self::Contains),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub schema_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "10")]
pub content: ::core::option::Option<document::Content>,
#[prost(string, tag = "7")]
pub parent_document_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub derived_struct_data: ::core::option::Option<::prost_types::Struct>,
#[prost(message, optional, tag = "11")]
pub acl_info: ::core::option::Option<document::AclInfo>,
#[prost(message, optional, tag = "13")]
pub index_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(oneof = "document::Data", tags = "4, 5")]
pub data: ::core::option::Option<document::Data>,
}
/// Nested message and enum types in `Document`.
pub mod document {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
#[prost(string, tag = "1")]
pub mime_type: ::prost::alloc::string::String,
#[prost(oneof = "content::Content", tags = "2, 3")]
pub content: ::core::option::Option<content::Content>,
}
/// Nested message and enum types in `Content`.
pub mod content {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Content {
#[prost(bytes, tag = "2")]
RawBytes(::prost::alloc::vec::Vec<u8>),
#[prost(string, tag = "3")]
Uri(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AclInfo {
#[prost(message, repeated, tag = "1")]
pub readers: ::prost::alloc::vec::Vec<acl_info::AccessRestriction>,
}
/// Nested message and enum types in `AclInfo`.
pub mod acl_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessRestriction {
#[prost(message, repeated, tag = "1")]
pub principals: ::prost::alloc::vec::Vec<super::super::Principal>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Data {
#[prost(message, tag = "4")]
StructData(::prost_types::Struct),
#[prost(string, tag = "5")]
JsonData(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessedDocument {
#[prost(string, tag = "1")]
pub document: ::prost::alloc::string::String,
#[prost(oneof = "processed_document::ProcessedDataFormat", tags = "2")]
pub processed_data_format: ::core::option::Option<processed_document::ProcessedDataFormat>,
}
/// Nested message and enum types in `ProcessedDocument`.
pub mod processed_document {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ProcessedDataFormat {
#[prost(string, tag = "2")]
JsonData(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleQuery {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(oneof = "sample_query::Content", tags = "2")]
pub content: ::core::option::Option<sample_query::Content>,
}
/// Nested message and enum types in `SampleQuery`.
pub mod sample_query {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryEntry {
#[prost(string, tag = "1")]
pub query: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub targets: ::prost::alloc::vec::Vec<query_entry::Target>,
}
/// Nested message and enum types in `QueryEntry`.
pub mod query_entry {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(int32, repeated, tag = "2")]
pub page_numbers: ::prost::alloc::vec::Vec<i32>,
#[prost(double, optional, tag = "3")]
pub score: ::core::option::Option<f64>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Content {
#[prost(message, tag = "2")]
QueryEntry(QueryEntry),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
#[prost(string, repeated, tag = "1")]
pub input_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "2")]
pub data_schema: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuerySource {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub dataset_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub table_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub gcs_staging_dir: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub data_schema: ::prost::alloc::string::String,
#[prost(oneof = "big_query_source::Partition", tags = "5")]
pub partition: ::core::option::Option<big_query_source::Partition>,
}
/// Nested message and enum types in `BigQuerySource`.
pub mod big_query_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Partition {
#[prost(message, tag = "5")]
PartitionDate(super::super::super::super::r#type::Date),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpannerSource {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub instance_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub database_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub table_id: ::prost::alloc::string::String,
#[prost(bool, tag = "5")]
pub enable_data_boost: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableOptions {
#[prost(string, tag = "1")]
pub key_field_name: ::prost::alloc::string::String,
#[prost(map = "string, message", tag = "2")]
pub families: ::std::collections::HashMap<::prost::alloc::string::String, bigtable_options::BigtableColumnFamily>,
}
/// Nested message and enum types in `BigtableOptions`.
pub mod bigtable_options {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableColumnFamily {
#[prost(string, tag = "1")]
pub field_name: ::prost::alloc::string::String,
#[prost(enumeration = "Encoding", tag = "2")]
pub encoding: i32,
#[prost(enumeration = "Type", tag = "3")]
pub r#type: i32,
#[prost(message, repeated, tag = "4")]
pub columns: ::prost::alloc::vec::Vec<BigtableColumn>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableColumn {
#[prost(bytes = "vec", tag = "1")]
pub qualifier: ::prost::alloc::vec::Vec<u8>,
#[prost(string, tag = "2")]
pub field_name: ::prost::alloc::string::String,
#[prost(enumeration = "Encoding", tag = "3")]
pub encoding: i32,
#[prost(enumeration = "Type", tag = "4")]
pub r#type: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
String = 1,
Number = 2,
Integer = 3,
VarInteger = 4,
BigNumeric = 5,
Boolean = 6,
Json = 7,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::String => "STRING",
Type::Number => "NUMBER",
Type::Integer => "INTEGER",
Type::VarInteger => "VAR_INTEGER",
Type::BigNumeric => "BIG_NUMERIC",
Type::Boolean => "BOOLEAN",
Type::Json => "JSON",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"STRING" => Some(Self::String),
"NUMBER" => Some(Self::Number),
"INTEGER" => Some(Self::Integer),
"VAR_INTEGER" => Some(Self::VarInteger),
"BIG_NUMERIC" => Some(Self::BigNumeric),
"BOOLEAN" => Some(Self::Boolean),
"JSON" => Some(Self::Json),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
Unspecified = 0,
Text = 1,
Binary = 2,
}
impl Encoding {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Encoding::Unspecified => "ENCODING_UNSPECIFIED",
Encoding::Text => "TEXT",
Encoding::Binary => "BINARY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
"TEXT" => Some(Self::Text),
"BINARY" => Some(Self::Binary),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableSource {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub instance_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub table_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub bigtable_options: ::core::option::Option<BigtableOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FhirStoreSource {
#[prost(string, tag = "1")]
pub fhir_store: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub gcs_staging_dir: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudSqlSource {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub instance_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub database_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub table_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub gcs_staging_dir: ::prost::alloc::string::String,
#[prost(bool, tag = "6")]
pub offload: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirestoreSource {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub database_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub collection_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub gcs_staging_dir: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportErrorConfig {
#[prost(oneof = "import_error_config::Destination", tags = "1")]
pub destination: ::core::option::Option<import_error_config::Destination>,
}
/// Nested message and enum types in `ImportErrorConfig`.
pub mod import_error_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(string, tag = "1")]
GcsPrefix(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
#[prost(oneof = "import_user_events_request::Source", tags = "2, 3, 4")]
pub source: ::core::option::Option<import_user_events_request::Source>,
}
/// Nested message and enum types in `ImportUserEventsRequest`.
pub mod import_user_events_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineSource {
#[prost(message, repeated, tag = "1")]
pub user_events: ::prost::alloc::vec::Vec<super::UserEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
InlineSource(InlineSource),
#[prost(message, tag = "3")]
GcsSource(super::GcsSource),
#[prost(message, tag = "4")]
BigquerySource(super::BigQuerySource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsResponse {
#[prost(message, repeated, tag = "1")]
pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "2")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
#[prost(int64, tag = "3")]
pub joined_events_count: i64,
#[prost(int64, tag = "4")]
pub unjoined_events_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportUserEventsMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "3")]
pub success_count: i64,
#[prost(int64, tag = "4")]
pub failure_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportDocumentsMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "3")]
pub success_count: i64,
#[prost(int64, tag = "4")]
pub failure_count: i64,
#[prost(int64, tag = "5")]
pub total_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
#[prost(enumeration = "import_documents_request::ReconciliationMode", tag = "6")]
pub reconciliation_mode: i32,
#[prost(message, optional, tag = "7")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(bool, tag = "8")]
pub auto_generate_ids: bool,
#[prost(string, tag = "9")]
pub id_field: ::prost::alloc::string::String,
#[prost(oneof = "import_documents_request::Source", tags = "2, 3, 4, 10, 11, 12, 13, 15")]
pub source: ::core::option::Option<import_documents_request::Source>,
}
/// Nested message and enum types in `ImportDocumentsRequest`.
pub mod import_documents_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineSource {
#[prost(message, repeated, tag = "1")]
pub documents: ::prost::alloc::vec::Vec<super::Document>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReconciliationMode {
Unspecified = 0,
Incremental = 1,
Full = 2,
}
impl ReconciliationMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ReconciliationMode::Unspecified => "RECONCILIATION_MODE_UNSPECIFIED",
ReconciliationMode::Incremental => "INCREMENTAL",
ReconciliationMode::Full => "FULL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RECONCILIATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"INCREMENTAL" => Some(Self::Incremental),
"FULL" => Some(Self::Full),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
InlineSource(InlineSource),
#[prost(message, tag = "3")]
GcsSource(super::GcsSource),
#[prost(message, tag = "4")]
BigquerySource(super::BigQuerySource),
#[prost(message, tag = "10")]
FhirStoreSource(super::FhirStoreSource),
#[prost(message, tag = "11")]
SpannerSource(super::SpannerSource),
#[prost(message, tag = "12")]
CloudSqlSource(super::CloudSqlSource),
#[prost(message, tag = "13")]
FirestoreSource(super::FirestoreSource),
#[prost(message, tag = "15")]
BigtableSource(super::BigtableSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsResponse {
#[prost(message, repeated, tag = "1")]
pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "2")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(oneof = "import_suggestion_deny_list_entries_request::Source", tags = "2, 3")]
pub source: ::core::option::Option<import_suggestion_deny_list_entries_request::Source>,
}
/// Nested message and enum types in `ImportSuggestionDenyListEntriesRequest`.
pub mod import_suggestion_deny_list_entries_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineSource {
#[prost(message, repeated, tag = "1")]
pub entries: ::prost::alloc::vec::Vec<super::SuggestionDenyListEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
InlineSource(InlineSource),
#[prost(message, tag = "3")]
GcsSource(super::GcsSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesResponse {
#[prost(message, repeated, tag = "1")]
pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(int64, tag = "2")]
pub imported_entries_count: i64,
#[prost(int64, tag = "3")]
pub failed_entries_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSampleQueriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
#[prost(oneof = "import_sample_queries_request::Source", tags = "2, 3, 4")]
pub source: ::core::option::Option<import_sample_queries_request::Source>,
}
/// Nested message and enum types in `ImportSampleQueriesRequest`.
pub mod import_sample_queries_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineSource {
#[prost(message, repeated, tag = "1")]
pub sample_queries: ::prost::alloc::vec::Vec<super::SampleQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
InlineSource(InlineSource),
#[prost(message, tag = "3")]
GcsSource(super::GcsSource),
#[prost(message, tag = "4")]
BigquerySource(super::BigQuerySource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSampleQueriesResponse {
#[prost(message, repeated, tag = "1")]
pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "2")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportSampleQueriesMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "3")]
pub success_count: i64,
#[prost(int64, tag = "4")]
pub failure_count: i64,
#[prost(int64, tag = "5")]
pub total_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomModelsRequest {
#[prost(string, tag = "1")]
pub data_store: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomModelsResponse {
#[prost(message, repeated, tag = "1")]
pub models: ::prost::alloc::vec::Vec<CustomTuningModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainCustomModelRequest {
#[prost(string, tag = "1")]
pub data_store: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub model_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
#[prost(string, tag = "5")]
pub model_id: ::prost::alloc::string::String,
#[prost(oneof = "train_custom_model_request::TrainingInput", tags = "2")]
pub training_input: ::core::option::Option<train_custom_model_request::TrainingInput>,
}
/// Nested message and enum types in `TrainCustomModelRequest`.
pub mod train_custom_model_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsTrainingInput {
#[prost(string, tag = "1")]
pub corpus_data_path: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query_data_path: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub train_data_path: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub test_data_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TrainingInput {
#[prost(message, tag = "2")]
GcsTrainingInput(GcsTrainingInput),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainCustomModelResponse {
#[prost(message, repeated, tag = "1")]
pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "2")]
pub error_config: ::core::option::Option<ImportErrorConfig>,
#[prost(string, tag = "3")]
pub model_status: ::prost::alloc::string::String,
#[prost(map = "string, double", tag = "4")]
pub metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
#[prost(string, tag = "5")]
pub model_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrainCustomModelMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod search_tuning_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for search tuning.
#[derive(Debug, Clone)]
pub struct SearchTuningServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SearchTuningServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SearchTuningServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SearchTuningServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Trains a custom model.
pub async fn train_custom_model(&mut self, request: impl tonic::IntoRequest<super::TrainCustomModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SearchTuningService/TrainCustomModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SearchTuningService", "TrainCustomModel"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of all the custom models.
pub async fn list_custom_models(&mut self, request: impl tonic::IntoRequest<super::ListCustomModelsRequest>) -> std::result::Result<tonic::Response<super::ListCustomModelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SearchTuningService/ListCustomModels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SearchTuningService", "ListCustomModels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Answer {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "answer::State", tag = "2")]
pub state: i32,
#[prost(string, tag = "3")]
pub answer_text: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub citations: ::prost::alloc::vec::Vec<answer::Citation>,
#[prost(message, repeated, tag = "5")]
pub references: ::prost::alloc::vec::Vec<answer::Reference>,
#[prost(string, repeated, tag = "6")]
pub related_questions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "7")]
pub steps: ::prost::alloc::vec::Vec<answer::Step>,
#[prost(message, optional, tag = "10")]
pub query_understanding_info: ::core::option::Option<answer::QueryUnderstandingInfo>,
#[prost(enumeration = "answer::AnswerSkippedReason", repeated, tag = "11")]
pub answer_skipped_reasons: ::prost::alloc::vec::Vec<i32>,
#[prost(message, optional, tag = "8")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Answer`.
pub mod answer {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Citation {
#[prost(int64, tag = "1")]
pub start_index: i64,
#[prost(int64, tag = "2")]
pub end_index: i64,
#[prost(message, repeated, tag = "3")]
pub sources: ::prost::alloc::vec::Vec<CitationSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CitationSource {
#[prost(string, tag = "1")]
pub reference_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reference {
#[prost(oneof = "reference::Content", tags = "1, 2")]
pub content: ::core::option::Option<reference::Content>,
}
/// Nested message and enum types in `Reference`.
pub mod reference {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnstructuredDocumentInfo {
#[prost(string, tag = "1")]
pub document: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub title: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub chunk_contents: ::prost::alloc::vec::Vec<unstructured_document_info::ChunkContent>,
#[prost(message, optional, tag = "5")]
pub struct_data: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `UnstructuredDocumentInfo`.
pub mod unstructured_document_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkContent {
#[prost(string, tag = "1")]
pub content: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_identifier: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkInfo {
#[prost(string, tag = "1")]
pub chunk: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
#[prost(float, optional, tag = "3")]
pub relevance_score: ::core::option::Option<f32>,
#[prost(message, optional, tag = "4")]
pub document_metadata: ::core::option::Option<chunk_info::DocumentMetadata>,
}
/// Nested message and enum types in `ChunkInfo`.
pub mod chunk_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentMetadata {
#[prost(string, tag = "1")]
pub document: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub page_identifier: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub struct_data: ::core::option::Option<::prost_types::Struct>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Content {
#[prost(message, tag = "1")]
UnstructuredDocumentInfo(UnstructuredDocumentInfo),
#[prost(message, tag = "2")]
ChunkInfo(ChunkInfo),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Step {
#[prost(enumeration = "step::State", tag = "1")]
pub state: i32,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub thought: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub actions: ::prost::alloc::vec::Vec<step::Action>,
}
/// Nested message and enum types in `Step`.
pub mod step {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
#[prost(message, optional, tag = "3")]
pub observation: ::core::option::Option<action::Observation>,
#[prost(oneof = "action::Action", tags = "2")]
pub action: ::core::option::Option<action::Action>,
}
/// Nested message and enum types in `Action`.
pub mod action {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAction {
#[prost(string, tag = "1")]
pub query: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Observation {
#[prost(message, repeated, tag = "2")]
pub search_results: ::prost::alloc::vec::Vec<observation::SearchResult>,
}
/// Nested message and enum types in `Observation`.
pub mod observation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
#[prost(string, tag = "1")]
pub document: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub title: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub snippet_info: ::prost::alloc::vec::Vec<search_result::SnippetInfo>,
#[prost(message, repeated, tag = "5")]
pub chunk_info: ::prost::alloc::vec::Vec<search_result::ChunkInfo>,
}
/// Nested message and enum types in `SearchResult`.
pub mod search_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnippetInfo {
#[prost(string, tag = "1")]
pub snippet: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub snippet_status: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkInfo {
#[prost(string, tag = "1")]
pub chunk: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
#[prost(float, optional, tag = "3")]
pub relevance_score: ::core::option::Option<f32>,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Action {
#[prost(message, tag = "2")]
SearchAction(SearchAction),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
InProgress = 1,
Failed = 2,
Succeeded = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::InProgress => "IN_PROGRESS",
State::Failed => "FAILED",
State::Succeeded => "SUCCEEDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"IN_PROGRESS" => Some(Self::InProgress),
"FAILED" => Some(Self::Failed),
"SUCCEEDED" => Some(Self::Succeeded),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUnderstandingInfo {
#[prost(message, repeated, tag = "1")]
pub query_classification_info: ::prost::alloc::vec::Vec<query_understanding_info::QueryClassificationInfo>,
}
/// Nested message and enum types in `QueryUnderstandingInfo`.
pub mod query_understanding_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryClassificationInfo {
#[prost(enumeration = "query_classification_info::Type", tag = "1")]
pub r#type: i32,
#[prost(bool, tag = "2")]
pub positive: bool,
}
/// Nested message and enum types in `QueryClassificationInfo`.
pub mod query_classification_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
AdversarialQuery = 1,
NonAnswerSeekingQuery = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::AdversarialQuery => "ADVERSARIAL_QUERY",
Type::NonAnswerSeekingQuery => "NON_ANSWER_SEEKING_QUERY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ADVERSARIAL_QUERY" => Some(Self::AdversarialQuery),
"NON_ANSWER_SEEKING_QUERY" => Some(Self::NonAnswerSeekingQuery),
_ => None,
}
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
InProgress = 1,
Failed = 2,
Succeeded = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::InProgress => "IN_PROGRESS",
State::Failed => "FAILED",
State::Succeeded => "SUCCEEDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"IN_PROGRESS" => Some(Self::InProgress),
"FAILED" => Some(Self::Failed),
"SUCCEEDED" => Some(Self::Succeeded),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnswerSkippedReason {
Unspecified = 0,
AdversarialQueryIgnored = 1,
NonAnswerSeekingQueryIgnored = 2,
OutOfDomainQueryIgnored = 3,
PotentialPolicyViolation = 4,
}
impl AnswerSkippedReason {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AnswerSkippedReason::Unspecified => "ANSWER_SKIPPED_REASON_UNSPECIFIED",
AnswerSkippedReason::AdversarialQueryIgnored => "ADVERSARIAL_QUERY_IGNORED",
AnswerSkippedReason::NonAnswerSeekingQueryIgnored => "NON_ANSWER_SEEKING_QUERY_IGNORED",
AnswerSkippedReason::OutOfDomainQueryIgnored => "OUT_OF_DOMAIN_QUERY_IGNORED",
AnswerSkippedReason::PotentialPolicyViolation => "POTENTIAL_POLICY_VIOLATION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ANSWER_SKIPPED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
"ADVERSARIAL_QUERY_IGNORED" => Some(Self::AdversarialQueryIgnored),
"NON_ANSWER_SEEKING_QUERY_IGNORED" => Some(Self::NonAnswerSeekingQueryIgnored),
"OUT_OF_DOMAIN_QUERY_IGNORED" => Some(Self::OutOfDomainQueryIgnored),
"POTENTIAL_POLICY_VIOLATION" => Some(Self::PotentialPolicyViolation),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chunk {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub content: ::prost::alloc::string::String,
#[prost(double, optional, tag = "8")]
pub relevance_score: ::core::option::Option<f64>,
#[prost(message, optional, tag = "5")]
pub document_metadata: ::core::option::Option<chunk::DocumentMetadata>,
#[prost(message, optional, tag = "4")]
pub derived_struct_data: ::core::option::Option<::prost_types::Struct>,
#[prost(message, optional, tag = "6")]
pub page_span: ::core::option::Option<chunk::PageSpan>,
#[prost(message, optional, tag = "7")]
pub chunk_metadata: ::core::option::Option<chunk::ChunkMetadata>,
}
/// Nested message and enum types in `Chunk`.
pub mod chunk {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentMetadata {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub title: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub struct_data: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PageSpan {
#[prost(int32, tag = "1")]
pub page_start: i32,
#[prost(int32, tag = "2")]
pub page_end: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkMetadata {
#[prost(message, repeated, tag = "1")]
pub previous_chunks: ::prost::alloc::vec::Vec<super::Chunk>,
#[prost(message, repeated, tag = "2")]
pub next_chunks: ::prost::alloc::vec::Vec<super::Chunk>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRequest {
#[prost(string, tag = "1")]
pub serving_config: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub branch: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub query: ::prost::alloc::string::String,
#[prost(message, optional, tag = "19")]
pub image_query: ::core::option::Option<search_request::ImageQuery>,
#[prost(int32, tag = "4")]
pub page_size: i32,
#[prost(string, tag = "5")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "6")]
pub offset: i32,
#[prost(message, repeated, tag = "32")]
pub data_store_specs: ::prost::alloc::vec::Vec<search_request::DataStoreSpec>,
#[prost(string, tag = "7")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "29")]
pub canonical_filter: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "21")]
pub user_info: ::core::option::Option<UserInfo>,
#[prost(message, repeated, tag = "9")]
pub facet_specs: ::prost::alloc::vec::Vec<search_request::FacetSpec>,
#[prost(message, optional, tag = "10")]
pub boost_spec: ::core::option::Option<search_request::BoostSpec>,
#[prost(map = "string, message", tag = "11")]
pub params: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Value>,
#[prost(message, optional, tag = "13")]
pub query_expansion_spec: ::core::option::Option<search_request::QueryExpansionSpec>,
#[prost(message, optional, tag = "14")]
pub spell_correction_spec: ::core::option::Option<search_request::SpellCorrectionSpec>,
#[prost(string, tag = "15")]
pub user_pseudo_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "24")]
pub content_search_spec: ::core::option::Option<search_request::ContentSearchSpec>,
#[prost(message, optional, tag = "23")]
pub embedding_spec: ::core::option::Option<search_request::EmbeddingSpec>,
#[prost(string, tag = "26")]
pub ranking_expression: ::prost::alloc::string::String,
#[prost(bool, tag = "20")]
pub safe_search: bool,
#[prost(map = "string, string", tag = "22")]
pub user_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "34")]
pub custom_fine_tuning_spec: ::core::option::Option<CustomFineTuningSpec>,
}
/// Nested message and enum types in `SearchRequest`.
pub mod search_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageQuery {
#[prost(oneof = "image_query::Image", tags = "1")]
pub image: ::core::option::Option<image_query::Image>,
}
/// Nested message and enum types in `ImageQuery`.
pub mod image_query {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Image {
#[prost(string, tag = "1")]
ImageBytes(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataStoreSpec {
#[prost(string, tag = "1")]
pub data_store: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetSpec {
#[prost(message, optional, tag = "1")]
pub facet_key: ::core::option::Option<facet_spec::FacetKey>,
#[prost(int32, tag = "2")]
pub limit: i32,
#[prost(string, repeated, tag = "3")]
pub excluded_filter_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "4")]
pub enable_dynamic_position: bool,
}
/// Nested message and enum types in `FacetSpec`.
pub mod facet_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetKey {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub intervals: ::prost::alloc::vec::Vec<super::super::Interval>,
#[prost(string, repeated, tag = "3")]
pub restricted_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "5")]
pub contains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "6")]
pub case_insensitive: bool,
#[prost(string, tag = "7")]
pub order_by: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoostSpec {
#[prost(message, repeated, tag = "1")]
pub condition_boost_specs: ::prost::alloc::vec::Vec<boost_spec::ConditionBoostSpec>,
}
/// Nested message and enum types in `BoostSpec`.
pub mod boost_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionBoostSpec {
#[prost(string, tag = "1")]
pub condition: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub boost: f32,
#[prost(message, optional, tag = "3")]
pub boost_control_spec: ::core::option::Option<condition_boost_spec::BoostControlSpec>,
}
/// Nested message and enum types in `ConditionBoostSpec`.
pub mod condition_boost_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoostControlSpec {
#[prost(string, tag = "1")]
pub field_name: ::prost::alloc::string::String,
#[prost(enumeration = "boost_control_spec::AttributeType", tag = "2")]
pub attribute_type: i32,
#[prost(enumeration = "boost_control_spec::InterpolationType", tag = "3")]
pub interpolation_type: i32,
#[prost(message, repeated, tag = "4")]
pub control_points: ::prost::alloc::vec::Vec<boost_control_spec::ControlPoint>,
}
/// Nested message and enum types in `BoostControlSpec`.
pub mod boost_control_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlPoint {
#[prost(string, tag = "1")]
pub attribute_value: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub boost_amount: f32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AttributeType {
Unspecified = 0,
Numerical = 1,
Freshness = 2,
}
impl AttributeType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AttributeType::Unspecified => "ATTRIBUTE_TYPE_UNSPECIFIED",
AttributeType::Numerical => "NUMERICAL",
AttributeType::Freshness => "FRESHNESS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ATTRIBUTE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"NUMERICAL" => Some(Self::Numerical),
"FRESHNESS" => Some(Self::Freshness),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterpolationType {
Unspecified = 0,
Linear = 1,
}
impl InterpolationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
InterpolationType::Unspecified => "INTERPOLATION_TYPE_UNSPECIFIED",
InterpolationType::Linear => "LINEAR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INTERPOLATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"LINEAR" => Some(Self::Linear),
_ => None,
}
}
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryExpansionSpec {
#[prost(enumeration = "query_expansion_spec::Condition", tag = "1")]
pub condition: i32,
#[prost(bool, tag = "2")]
pub pin_unexpanded_results: bool,
}
/// Nested message and enum types in `QueryExpansionSpec`.
pub mod query_expansion_spec {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Condition {
Unspecified = 0,
Disabled = 1,
Auto = 2,
}
impl Condition {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Condition::Unspecified => "CONDITION_UNSPECIFIED",
Condition::Disabled => "DISABLED",
Condition::Auto => "AUTO",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
"DISABLED" => Some(Self::Disabled),
"AUTO" => Some(Self::Auto),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpellCorrectionSpec {
#[prost(enumeration = "spell_correction_spec::Mode", tag = "1")]
pub mode: i32,
}
/// Nested message and enum types in `SpellCorrectionSpec`.
pub mod spell_correction_spec {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Mode {
Unspecified = 0,
SuggestionOnly = 1,
Auto = 2,
}
impl Mode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Mode::Unspecified => "MODE_UNSPECIFIED",
Mode::SuggestionOnly => "SUGGESTION_ONLY",
Mode::Auto => "AUTO",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODE_UNSPECIFIED" => Some(Self::Unspecified),
"SUGGESTION_ONLY" => Some(Self::SuggestionOnly),
"AUTO" => Some(Self::Auto),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentSearchSpec {
#[prost(message, optional, tag = "1")]
pub snippet_spec: ::core::option::Option<content_search_spec::SnippetSpec>,
#[prost(message, optional, tag = "2")]
pub summary_spec: ::core::option::Option<content_search_spec::SummarySpec>,
#[prost(message, optional, tag = "3")]
pub extractive_content_spec: ::core::option::Option<content_search_spec::ExtractiveContentSpec>,
#[prost(enumeration = "content_search_spec::SearchResultMode", tag = "4")]
pub search_result_mode: i32,
#[prost(message, optional, tag = "5")]
pub chunk_spec: ::core::option::Option<content_search_spec::ChunkSpec>,
}
/// Nested message and enum types in `ContentSearchSpec`.
pub mod content_search_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnippetSpec {
#[deprecated]
#[prost(int32, tag = "1")]
pub max_snippet_count: i32,
#[deprecated]
#[prost(bool, tag = "2")]
pub reference_only: bool,
#[prost(bool, tag = "3")]
pub return_snippet: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarySpec {
#[prost(int32, tag = "1")]
pub summary_result_count: i32,
#[prost(bool, tag = "2")]
pub include_citations: bool,
#[prost(bool, tag = "3")]
pub ignore_adversarial_query: bool,
#[prost(bool, tag = "4")]
pub ignore_non_summary_seeking_query: bool,
#[prost(message, optional, tag = "5")]
pub model_prompt_spec: ::core::option::Option<summary_spec::ModelPromptSpec>,
#[prost(string, tag = "6")]
pub language_code: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub model_spec: ::core::option::Option<summary_spec::ModelSpec>,
#[prost(bool, tag = "8")]
pub use_semantic_chunks: bool,
}
/// Nested message and enum types in `SummarySpec`.
pub mod summary_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelPromptSpec {
#[prost(string, tag = "1")]
pub preamble: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelSpec {
#[prost(string, tag = "1")]
pub version: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtractiveContentSpec {
#[prost(int32, tag = "1")]
pub max_extractive_answer_count: i32,
#[prost(int32, tag = "2")]
pub max_extractive_segment_count: i32,
#[prost(bool, tag = "3")]
pub return_extractive_segment_score: bool,
#[prost(int32, tag = "4")]
pub num_previous_segments: i32,
#[prost(int32, tag = "5")]
pub num_next_segments: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChunkSpec {
#[prost(int32, tag = "1")]
pub num_previous_chunks: i32,
#[prost(int32, tag = "2")]
pub num_next_chunks: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchResultMode {
Unspecified = 0,
Documents = 1,
Chunks = 2,
}
impl SearchResultMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SearchResultMode::Unspecified => "SEARCH_RESULT_MODE_UNSPECIFIED",
SearchResultMode::Documents => "DOCUMENTS",
SearchResultMode::Chunks => "CHUNKS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEARCH_RESULT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"DOCUMENTS" => Some(Self::Documents),
"CHUNKS" => Some(Self::Chunks),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbeddingSpec {
#[prost(message, repeated, tag = "1")]
pub embedding_vectors: ::prost::alloc::vec::Vec<embedding_spec::EmbeddingVector>,
}
/// Nested message and enum types in `EmbeddingSpec`.
pub mod embedding_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbeddingVector {
#[prost(string, tag = "1")]
pub field_path: ::prost::alloc::string::String,
#[prost(float, repeated, tag = "2")]
pub vector: ::prost::alloc::vec::Vec<f32>,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<search_response::SearchResult>,
#[prost(message, repeated, tag = "2")]
pub facets: ::prost::alloc::vec::Vec<search_response::Facet>,
#[prost(message, optional, tag = "8")]
pub guided_search_result: ::core::option::Option<search_response::GuidedSearchResult>,
#[prost(int32, tag = "3")]
pub total_size: i32,
#[prost(string, tag = "4")]
pub attribution_token: ::prost::alloc::string::String,
#[prost(string, tag = "12")]
pub redirect_uri: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub corrected_query: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub summary: ::core::option::Option<search_response::Summary>,
#[prost(string, repeated, tag = "10")]
pub applied_controls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "16")]
pub geo_search_debug_info: ::prost::alloc::vec::Vec<search_response::GeoSearchDebugInfo>,
#[prost(message, optional, tag = "14")]
pub query_expansion_info: ::core::option::Option<search_response::QueryExpansionInfo>,
}
/// Nested message and enum types in `SearchResponse`.
pub mod search_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub document: ::core::option::Option<super::Document>,
#[prost(message, optional, tag = "18")]
pub chunk: ::core::option::Option<super::Chunk>,
#[prost(map = "string, message", tag = "4")]
pub model_scores: ::std::collections::HashMap<::prost::alloc::string::String, super::DoubleList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Facet {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub values: ::prost::alloc::vec::Vec<facet::FacetValue>,
#[prost(bool, tag = "3")]
pub dynamic_facet: bool,
}
/// Nested message and enum types in `Facet`.
pub mod facet {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetValue {
#[prost(int64, tag = "3")]
pub count: i64,
#[prost(oneof = "facet_value::FacetValue", tags = "1, 2")]
pub facet_value: ::core::option::Option<facet_value::FacetValue>,
}
/// Nested message and enum types in `FacetValue`.
pub mod facet_value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum FacetValue {
#[prost(string, tag = "1")]
Value(::prost::alloc::string::String),
#[prost(message, tag = "2")]
Interval(super::super::super::Interval),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuidedSearchResult {
#[prost(message, repeated, tag = "1")]
pub refinement_attributes: ::prost::alloc::vec::Vec<guided_search_result::RefinementAttribute>,
#[prost(string, repeated, tag = "2")]
pub follow_up_questions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `GuidedSearchResult`.
pub mod guided_search_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefinementAttribute {
#[prost(string, tag = "1")]
pub attribute_key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub attribute_value: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Summary {
#[prost(string, tag = "1")]
pub summary_text: ::prost::alloc::string::String,
#[prost(enumeration = "summary::SummarySkippedReason", repeated, tag = "2")]
pub summary_skipped_reasons: ::prost::alloc::vec::Vec<i32>,
#[prost(message, optional, tag = "3")]
pub safety_attributes: ::core::option::Option<summary::SafetyAttributes>,
#[prost(message, optional, tag = "4")]
pub summary_with_metadata: ::core::option::Option<summary::SummaryWithMetadata>,
}
/// Nested message and enum types in `Summary`.
pub mod summary {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SafetyAttributes {
#[prost(string, repeated, tag = "1")]
pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(float, repeated, tag = "2")]
pub scores: ::prost::alloc::vec::Vec<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CitationMetadata {
#[prost(message, repeated, tag = "1")]
pub citations: ::prost::alloc::vec::Vec<Citation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Citation {
#[prost(int64, tag = "1")]
pub start_index: i64,
#[prost(int64, tag = "2")]
pub end_index: i64,
#[prost(message, repeated, tag = "3")]
pub sources: ::prost::alloc::vec::Vec<CitationSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CitationSource {
#[prost(int64, tag = "4")]
pub reference_index: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reference {
#[prost(string, tag = "1")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub document: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub uri: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub chunk_contents: ::prost::alloc::vec::Vec<reference::ChunkContent>,
}
/// Nested message and enum types in `Reference`.
pub mod reference {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkContent {
#[prost(string, tag = "1")]
pub content: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_identifier: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummaryWithMetadata {
#[prost(string, tag = "1")]
pub summary: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub citation_metadata: ::core::option::Option<CitationMetadata>,
#[prost(message, repeated, tag = "3")]
pub references: ::prost::alloc::vec::Vec<Reference>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SummarySkippedReason {
Unspecified = 0,
AdversarialQueryIgnored = 1,
NonSummarySeekingQueryIgnored = 2,
OutOfDomainQueryIgnored = 3,
PotentialPolicyViolation = 4,
LlmAddonNotEnabled = 5,
}
impl SummarySkippedReason {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SummarySkippedReason::Unspecified => "SUMMARY_SKIPPED_REASON_UNSPECIFIED",
SummarySkippedReason::AdversarialQueryIgnored => "ADVERSARIAL_QUERY_IGNORED",
SummarySkippedReason::NonSummarySeekingQueryIgnored => "NON_SUMMARY_SEEKING_QUERY_IGNORED",
SummarySkippedReason::OutOfDomainQueryIgnored => "OUT_OF_DOMAIN_QUERY_IGNORED",
SummarySkippedReason::PotentialPolicyViolation => "POTENTIAL_POLICY_VIOLATION",
SummarySkippedReason::LlmAddonNotEnabled => "LLM_ADDON_NOT_ENABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SUMMARY_SKIPPED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
"ADVERSARIAL_QUERY_IGNORED" => Some(Self::AdversarialQueryIgnored),
"NON_SUMMARY_SEEKING_QUERY_IGNORED" => Some(Self::NonSummarySeekingQueryIgnored),
"OUT_OF_DOMAIN_QUERY_IGNORED" => Some(Self::OutOfDomainQueryIgnored),
"POTENTIAL_POLICY_VIOLATION" => Some(Self::PotentialPolicyViolation),
"LLM_ADDON_NOT_ENABLED" => Some(Self::LlmAddonNotEnabled),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoSearchDebugInfo {
#[prost(string, tag = "1")]
pub original_address_query: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryExpansionInfo {
#[prost(bool, tag = "1")]
pub expanded_query: bool,
#[prost(int64, tag = "2")]
pub pinned_result_count: i64,
}
}
/// Generated client implementations.
pub mod search_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for search.
#[derive(Debug, Clone)]
pub struct SearchServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SearchServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SearchServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SearchServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Performs a search.
pub async fn search(&mut self, request: impl tonic::IntoRequest<super::SearchRequest>) -> std::result::Result<tonic::Response<super::SearchResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SearchService/Search");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SearchService", "Search"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "conversation::State", tag = "2")]
pub state: i32,
#[prost(string, tag = "3")]
pub user_pseudo_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub messages: ::prost::alloc::vec::Vec<ConversationMessage>,
#[prost(message, optional, tag = "5")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Conversation`.
pub mod conversation {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
InProgress = 1,
Completed = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::InProgress => "IN_PROGRESS",
State::Completed => "COMPLETED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"IN_PROGRESS" => Some(Self::InProgress),
"COMPLETED" => Some(Self::Completed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reply {
#[deprecated]
#[prost(string, tag = "1")]
pub reply: ::prost::alloc::string::String,
#[deprecated]
#[prost(message, repeated, tag = "2")]
pub references: ::prost::alloc::vec::Vec<reply::Reference>,
#[prost(message, optional, tag = "3")]
pub summary: ::core::option::Option<search_response::Summary>,
}
/// Nested message and enum types in `Reply`.
pub mod reply {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reference {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub anchor_text: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub start: i32,
#[prost(int32, tag = "4")]
pub end: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationContext {
#[prost(string, repeated, tag = "1")]
pub context_documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "2")]
pub active_document: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInput {
#[prost(string, tag = "1")]
pub input: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub context: ::core::option::Option<ConversationContext>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationMessage {
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(oneof = "conversation_message::Message", tags = "1, 2")]
pub message: ::core::option::Option<conversation_message::Message>,
}
/// Nested message and enum types in `ConversationMessage`.
pub mod conversation_message {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Message {
#[prost(message, tag = "1")]
UserInput(super::TextInput),
#[prost(message, tag = "2")]
Reply(super::Reply),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "session::State", tag = "2")]
pub state: i32,
#[prost(string, tag = "3")]
pub user_pseudo_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub turns: ::prost::alloc::vec::Vec<session::Turn>,
#[prost(message, optional, tag = "5")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Session`.
pub mod session {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Turn {
#[prost(message, optional, tag = "1")]
pub query: ::core::option::Option<super::Query>,
#[prost(string, tag = "2")]
pub answer: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
InProgress = 1,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::InProgress => "IN_PROGRESS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"IN_PROGRESS" => Some(Self::InProgress),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
#[prost(string, tag = "1")]
pub query_id: ::prost::alloc::string::String,
#[prost(oneof = "query::Content", tags = "2")]
pub content: ::core::option::Option<query::Content>,
}
/// Nested message and enum types in `Query`.
pub mod query {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Content {
#[prost(string, tag = "2")]
Text(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConverseConversationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub query: ::core::option::Option<TextInput>,
#[prost(string, tag = "3")]
pub serving_config: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub conversation: ::core::option::Option<Conversation>,
#[prost(bool, tag = "6")]
pub safe_search: bool,
#[prost(map = "string, string", tag = "7")]
pub user_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "8")]
pub summary_spec: ::core::option::Option<search_request::content_search_spec::SummarySpec>,
#[prost(string, tag = "9")]
pub filter: ::prost::alloc::string::String,
#[prost(message, optional, tag = "10")]
pub boost_spec: ::core::option::Option<search_request::BoostSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConverseConversationResponse {
#[prost(message, optional, tag = "1")]
pub reply: ::core::option::Option<Reply>,
#[prost(message, optional, tag = "2")]
pub conversation: ::core::option::Option<Conversation>,
#[prost(string, repeated, tag = "6")]
pub related_questions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "3")]
pub search_results: ::prost::alloc::vec::Vec<search_response::SearchResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversation: ::core::option::Option<Conversation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversationRequest {
#[prost(message, optional, tag = "1")]
pub conversation: ::core::option::Option<Conversation>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConversationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsResponse {
#[prost(message, repeated, tag = "1")]
pub conversations: ::prost::alloc::vec::Vec<Conversation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQueryRequest {
#[prost(string, tag = "1")]
pub serving_config: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub query: ::core::option::Option<Query>,
#[prost(string, tag = "3")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub safety_spec: ::core::option::Option<answer_query_request::SafetySpec>,
#[prost(message, optional, tag = "5")]
pub related_questions_spec: ::core::option::Option<answer_query_request::RelatedQuestionsSpec>,
#[prost(message, optional, tag = "7")]
pub answer_generation_spec: ::core::option::Option<answer_query_request::AnswerGenerationSpec>,
#[prost(message, optional, tag = "8")]
pub search_spec: ::core::option::Option<answer_query_request::SearchSpec>,
#[prost(message, optional, tag = "9")]
pub query_understanding_spec: ::core::option::Option<answer_query_request::QueryUnderstandingSpec>,
#[prost(bool, tag = "10")]
pub asynchronous_mode: bool,
#[prost(string, tag = "12")]
pub user_pseudo_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AnswerQueryRequest`.
pub mod answer_query_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetySpec {
#[prost(bool, tag = "1")]
pub enable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RelatedQuestionsSpec {
#[prost(bool, tag = "1")]
pub enable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerGenerationSpec {
#[prost(message, optional, tag = "1")]
pub model_spec: ::core::option::Option<answer_generation_spec::ModelSpec>,
#[prost(message, optional, tag = "2")]
pub prompt_spec: ::core::option::Option<answer_generation_spec::PromptSpec>,
#[prost(bool, tag = "3")]
pub include_citations: bool,
#[prost(string, tag = "4")]
pub answer_language_code: ::prost::alloc::string::String,
#[prost(bool, tag = "5")]
pub ignore_adversarial_query: bool,
#[prost(bool, tag = "6")]
pub ignore_non_answer_seeking_query: bool,
#[prost(bool, optional, tag = "7")]
pub ignore_low_relevant_content: ::core::option::Option<bool>,
}
/// Nested message and enum types in `AnswerGenerationSpec`.
pub mod answer_generation_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelSpec {
#[prost(string, tag = "1")]
pub model_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromptSpec {
#[prost(string, tag = "1")]
pub preamble: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSpec {
#[prost(oneof = "search_spec::Input", tags = "1, 2")]
pub input: ::core::option::Option<search_spec::Input>,
}
/// Nested message and enum types in `SearchSpec`.
pub mod search_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchParams {
#[prost(int32, tag = "1")]
pub max_return_results: i32,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub boost_spec: ::core::option::Option<super::super::search_request::BoostSpec>,
#[prost(string, tag = "4")]
pub order_by: ::prost::alloc::string::String,
#[prost(enumeration = "super::super::search_request::content_search_spec::SearchResultMode", tag = "5")]
pub search_result_mode: i32,
#[prost(message, optional, tag = "6")]
pub custom_fine_tuning_spec: ::core::option::Option<super::super::CustomFineTuningSpec>,
#[prost(message, repeated, tag = "7")]
pub data_store_specs: ::prost::alloc::vec::Vec<super::super::search_request::DataStoreSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResultList {
#[prost(message, repeated, tag = "1")]
pub search_results: ::prost::alloc::vec::Vec<search_result_list::SearchResult>,
}
/// Nested message and enum types in `SearchResultList`.
pub mod search_result_list {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
#[prost(oneof = "search_result::Content", tags = "1, 2")]
pub content: ::core::option::Option<search_result::Content>,
}
/// Nested message and enum types in `SearchResult`.
pub mod search_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnstructuredDocumentInfo {
#[prost(string, tag = "1")]
pub document: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub title: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub document_contexts: ::prost::alloc::vec::Vec<unstructured_document_info::DocumentContext>,
#[prost(message, repeated, tag = "5")]
pub extractive_segments: ::prost::alloc::vec::Vec<unstructured_document_info::ExtractiveSegment>,
#[prost(message, repeated, tag = "6")]
pub extractive_answers: ::prost::alloc::vec::Vec<unstructured_document_info::ExtractiveAnswer>,
}
/// Nested message and enum types in `UnstructuredDocumentInfo`.
pub mod unstructured_document_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentContext {
#[prost(string, tag = "1")]
pub page_identifier: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtractiveSegment {
#[prost(string, tag = "1")]
pub page_identifier: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtractiveAnswer {
#[prost(string, tag = "1")]
pub page_identifier: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkInfo {
#[prost(string, tag = "1")]
pub chunk: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Content {
#[prost(message, tag = "1")]
UnstructuredDocumentInfo(UnstructuredDocumentInfo),
#[prost(message, tag = "2")]
ChunkInfo(ChunkInfo),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Input {
#[prost(message, tag = "1")]
SearchParams(SearchParams),
#[prost(message, tag = "2")]
SearchResultList(SearchResultList),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUnderstandingSpec {
#[prost(message, optional, tag = "1")]
pub query_classification_spec: ::core::option::Option<query_understanding_spec::QueryClassificationSpec>,
#[prost(message, optional, tag = "2")]
pub query_rephraser_spec: ::core::option::Option<query_understanding_spec::QueryRephraserSpec>,
}
/// Nested message and enum types in `QueryUnderstandingSpec`.
pub mod query_understanding_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassificationSpec {
#[prost(enumeration = "query_classification_spec::Type", repeated, tag = "1")]
pub types: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `QueryClassificationSpec`.
pub mod query_classification_spec {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
AdversarialQuery = 1,
NonAnswerSeekingQuery = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::AdversarialQuery => "ADVERSARIAL_QUERY",
Type::NonAnswerSeekingQuery => "NON_ANSWER_SEEKING_QUERY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ADVERSARIAL_QUERY" => Some(Self::AdversarialQuery),
"NON_ANSWER_SEEKING_QUERY" => Some(Self::NonAnswerSeekingQuery),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryRephraserSpec {
#[prost(bool, tag = "1")]
pub disable: bool,
#[prost(int32, tag = "2")]
pub max_rephrase_steps: i32,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQueryResponse {
#[prost(message, optional, tag = "1")]
pub answer: ::core::option::Option<Answer>,
#[prost(message, optional, tag = "2")]
pub session: ::core::option::Option<Session>,
#[prost(string, tag = "3")]
pub answer_query_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnswerRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub session: ::core::option::Option<Session>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSessionRequest {
#[prost(message, optional, tag = "1")]
pub session: ::core::option::Option<Session>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSessionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
#[prost(message, repeated, tag = "1")]
pub sessions: ::prost::alloc::vec::Vec<Session>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod conversational_search_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for conversational search.
#[derive(Debug, Clone)]
pub struct ConversationalSearchServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversationalSearchServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversationalSearchServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversationalSearchServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Converses a conversation.
pub async fn converse_conversation(&mut self, request: impl tonic::IntoRequest<super::ConverseConversationRequest>) -> std::result::Result<tonic::Response<super::ConverseConversationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/ConverseConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "ConverseConversation"));
self.inner.unary(req, path, codec).await
}
/// Creates a Conversation.
///
/// If the [Conversation][google.cloud.discoveryengine.v1alpha.Conversation] to
/// create already exists, an ALREADY_EXISTS error is returned.
pub async fn create_conversation(&mut self, request: impl tonic::IntoRequest<super::CreateConversationRequest>) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/CreateConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "CreateConversation"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Conversation.
///
/// If the [Conversation][google.cloud.discoveryengine.v1alpha.Conversation] to
/// delete does not exist, a NOT_FOUND error is returned.
pub async fn delete_conversation(&mut self, request: impl tonic::IntoRequest<super::DeleteConversationRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/DeleteConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "DeleteConversation"));
self.inner.unary(req, path, codec).await
}
/// Updates a Conversation.
///
/// [Conversation][google.cloud.discoveryengine.v1alpha.Conversation] action
/// type cannot be changed. If the
/// [Conversation][google.cloud.discoveryengine.v1alpha.Conversation] to update
/// does not exist, a NOT_FOUND error is returned.
pub async fn update_conversation(&mut self, request: impl tonic::IntoRequest<super::UpdateConversationRequest>) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/UpdateConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "UpdateConversation"));
self.inner.unary(req, path, codec).await
}
/// Gets a Conversation.
pub async fn get_conversation(&mut self, request: impl tonic::IntoRequest<super::GetConversationRequest>) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/GetConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "GetConversation"));
self.inner.unary(req, path, codec).await
}
/// Lists all Conversations by their parent
/// [DataStore][google.cloud.discoveryengine.v1alpha.DataStore].
pub async fn list_conversations(&mut self, request: impl tonic::IntoRequest<super::ListConversationsRequest>) -> std::result::Result<tonic::Response<super::ListConversationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/ListConversations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "ListConversations"));
self.inner.unary(req, path, codec).await
}
/// Answer query method.
pub async fn answer_query(&mut self, request: impl tonic::IntoRequest<super::AnswerQueryRequest>) -> std::result::Result<tonic::Response<super::AnswerQueryResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/AnswerQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "AnswerQuery"));
self.inner.unary(req, path, codec).await
}
/// Gets a Answer.
pub async fn get_answer(&mut self, request: impl tonic::IntoRequest<super::GetAnswerRequest>) -> std::result::Result<tonic::Response<super::Answer>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/GetAnswer");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "GetAnswer"));
self.inner.unary(req, path, codec).await
}
/// Creates a Session.
///
/// If the [Session][google.cloud.discoveryengine.v1alpha.Session] to create
/// already exists, an ALREADY_EXISTS error is returned.
pub async fn create_session(&mut self, request: impl tonic::IntoRequest<super::CreateSessionRequest>) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/CreateSession");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "CreateSession"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Session.
///
/// If the [Session][google.cloud.discoveryengine.v1alpha.Session] to delete
/// does not exist, a NOT_FOUND error is returned.
pub async fn delete_session(&mut self, request: impl tonic::IntoRequest<super::DeleteSessionRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/DeleteSession");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "DeleteSession"));
self.inner.unary(req, path, codec).await
}
/// Updates a Session.
///
/// [Session][google.cloud.discoveryengine.v1alpha.Session] action type cannot
/// be changed. If the [Session][google.cloud.discoveryengine.v1alpha.Session]
/// to update does not exist, a NOT_FOUND error is returned.
pub async fn update_session(&mut self, request: impl tonic::IntoRequest<super::UpdateSessionRequest>) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/UpdateSession");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "UpdateSession"));
self.inner.unary(req, path, codec).await
}
/// Gets a Session.
pub async fn get_session(&mut self, request: impl tonic::IntoRequest<super::GetSessionRequest>) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/GetSession");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "GetSession"));
self.inner.unary(req, path, codec).await
}
/// Lists all Sessions by their parent
/// [DataStore][google.cloud.discoveryengine.v1alpha.DataStore].
pub async fn list_sessions(&mut self, request: impl tonic::IntoRequest<super::ListSessionsRequest>) -> std::result::Result<tonic::Response<super::ListSessionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ConversationalSearchService/ListSessions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ConversationalSearchService", "ListSessions"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeUserEventsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeUserEventsResponse {
#[prost(int64, tag = "1")]
pub purge_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeUserEventsMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "3")]
pub success_count: i64,
#[prost(int64, tag = "4")]
pub failure_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeErrorConfig {
#[prost(oneof = "purge_error_config::Destination", tags = "1")]
pub destination: ::core::option::Option<purge_error_config::Destination>,
}
/// Nested message and enum types in `PurgeErrorConfig`.
pub mod purge_error_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(string, tag = "1")]
GcsPrefix(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeDocumentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub error_config: ::core::option::Option<PurgeErrorConfig>,
#[prost(bool, tag = "3")]
pub force: bool,
#[prost(oneof = "purge_documents_request::Source", tags = "5")]
pub source: ::core::option::Option<purge_documents_request::Source>,
}
/// Nested message and enum types in `PurgeDocumentsRequest`.
pub mod purge_documents_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "5")]
GcsSource(super::GcsSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeDocumentsResponse {
#[prost(int64, tag = "1")]
pub purge_count: i64,
#[prost(string, repeated, tag = "2")]
pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeDocumentsMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "3")]
pub success_count: i64,
#[prost(int64, tag = "4")]
pub failure_count: i64,
#[prost(int64, tag = "5")]
pub ignored_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesResponse {
#[prost(int64, tag = "1")]
pub purge_count: i64,
#[prost(message, repeated, tag = "2")]
pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteUserEventRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub user_event: ::core::option::Option<UserEvent>,
#[prost(bool, tag = "3")]
pub write_async: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectUserEventRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub user_event: ::prost::alloc::string::String,
#[prost(string, optional, tag = "3")]
pub uri: ::core::option::Option<::prost::alloc::string::String>,
#[prost(int64, optional, tag = "4")]
pub ets: ::core::option::Option<i64>,
}
/// Generated client implementations.
pub mod user_event_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for ingesting end user actions on a website to Discovery Engine API.
#[derive(Debug, Clone)]
pub struct UserEventServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> UserEventServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> UserEventServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
UserEventServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Writes a single user event.
pub async fn write_user_event(&mut self, request: impl tonic::IntoRequest<super::WriteUserEventRequest>) -> std::result::Result<tonic::Response<super::UserEvent>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.UserEventService/WriteUserEvent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.UserEventService", "WriteUserEvent"));
self.inner.unary(req, path, codec).await
}
/// Writes a single user event from the browser. This uses a GET request to
/// due to browser restriction of POST-ing to a third-party domain.
///
/// This method is used only by the Discovery Engine API JavaScript pixel and
/// Google Tag Manager. Users should not call this method directly.
pub async fn collect_user_event(&mut self, request: impl tonic::IntoRequest<super::CollectUserEventRequest>) -> std::result::Result<tonic::Response<super::super::super::super::api::HttpBody>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.UserEventService/CollectUserEvent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.UserEventService", "CollectUserEvent"));
self.inner.unary(req, path, codec).await
}
/// Deletes permanently all user events specified by the filter provided.
/// Depending on the number of events specified by the filter, this operation
/// could take hours or days to complete. To test a filter, use the list
/// command first.
pub async fn purge_user_events(&mut self, request: impl tonic::IntoRequest<super::PurgeUserEventsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.UserEventService/PurgeUserEvents");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.UserEventService", "PurgeUserEvents"));
self.inner.unary(req, path, codec).await
}
/// Bulk import of user events. Request processing might be
/// synchronous. Events that already exist are skipped.
/// Use this method for backfilling historical user events.
///
/// Operation.response is of type ImportResponse. Note that it is
/// possible for a subset of the items to be successfully inserted.
/// Operation.metadata is of type ImportMetadata.
pub async fn import_user_events(&mut self, request: impl tonic::IntoRequest<super::ImportUserEventsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.UserEventService/ImportUserEvents");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.UserEventService", "ImportUserEvents"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentProcessingConfig {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub chunking_config: ::core::option::Option<document_processing_config::ChunkingConfig>,
#[prost(message, optional, tag = "4")]
pub default_parsing_config: ::core::option::Option<document_processing_config::ParsingConfig>,
#[prost(map = "string, message", tag = "5")]
pub parsing_config_overrides: ::std::collections::HashMap<::prost::alloc::string::String, document_processing_config::ParsingConfig>,
}
/// Nested message and enum types in `DocumentProcessingConfig`.
pub mod document_processing_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChunkingConfig {
#[prost(oneof = "chunking_config::ChunkMode", tags = "1")]
pub chunk_mode: ::core::option::Option<chunking_config::ChunkMode>,
}
/// Nested message and enum types in `ChunkingConfig`.
pub mod chunking_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LayoutBasedChunkingConfig {
#[prost(int32, tag = "1")]
pub chunk_size: i32,
#[prost(bool, tag = "2")]
pub include_ancestor_headings: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum ChunkMode {
#[prost(message, tag = "1")]
LayoutBasedChunkingConfig(LayoutBasedChunkingConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParsingConfig {
#[prost(oneof = "parsing_config::TypeDedicatedConfig", tags = "1, 2, 3")]
pub type_dedicated_config: ::core::option::Option<parsing_config::TypeDedicatedConfig>,
}
/// Nested message and enum types in `ParsingConfig`.
pub mod parsing_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DigitalParsingConfig {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OcrParsingConfig {
#[deprecated]
#[prost(string, repeated, tag = "1")]
pub enhanced_document_elements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "2")]
pub use_native_text: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LayoutParsingConfig {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TypeDedicatedConfig {
#[prost(message, tag = "1")]
DigitalParsingConfig(DigitalParsingConfig),
#[prost(message, tag = "2")]
OcrParsingConfig(OcrParsingConfig),
#[prost(message, tag = "3")]
LayoutParsingConfig(LayoutParsingConfig),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Evaluation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub evaluation_spec: ::core::option::Option<evaluation::EvaluationSpec>,
#[prost(message, optional, tag = "3")]
pub quality_metrics: ::core::option::Option<QualityMetrics>,
#[prost(enumeration = "evaluation::State", tag = "4")]
pub state: i32,
#[prost(message, optional, tag = "5")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, repeated, tag = "8")]
pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// Nested message and enum types in `Evaluation`.
pub mod evaluation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluationSpec {
#[prost(message, optional, tag = "1")]
pub query_set_spec: ::core::option::Option<evaluation_spec::QuerySetSpec>,
#[prost(oneof = "evaluation_spec::SearchSpec", tags = "2")]
pub search_spec: ::core::option::Option<evaluation_spec::SearchSpec>,
}
/// Nested message and enum types in `EvaluationSpec`.
pub mod evaluation_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySetSpec {
#[prost(string, tag = "1")]
pub sample_query_set: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum SearchSpec {
#[prost(message, tag = "2")]
SearchRequest(super::super::SearchRequest),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Running = 2,
Succeeded = 3,
Failed = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QualityMetrics {
#[prost(message, optional, tag = "1")]
pub doc_recall: ::core::option::Option<quality_metrics::TopkMetrics>,
#[prost(message, optional, tag = "2")]
pub doc_precision: ::core::option::Option<quality_metrics::TopkMetrics>,
#[prost(message, optional, tag = "3")]
pub doc_ndcg: ::core::option::Option<quality_metrics::TopkMetrics>,
#[prost(message, optional, tag = "4")]
pub page_recall: ::core::option::Option<quality_metrics::TopkMetrics>,
#[prost(message, optional, tag = "5")]
pub page_ndcg: ::core::option::Option<quality_metrics::TopkMetrics>,
}
/// Nested message and enum types in `QualityMetrics`.
pub mod quality_metrics {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopkMetrics {
#[prost(double, tag = "1")]
pub top_1: f64,
#[prost(double, tag = "2")]
pub top_3: f64,
#[prost(double, tag = "3")]
pub top_5: f64,
#[prost(double, tag = "4")]
pub top_10: f64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryRequest {
#[prost(string, tag = "1")]
pub data_store: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub query_model: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub user_pseudo_id: ::prost::alloc::string::String,
#[prost(bool, tag = "5")]
pub include_tail_suggestions: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryResponse {
#[prost(message, repeated, tag = "1")]
pub query_suggestions: ::prost::alloc::vec::Vec<complete_query_response::QuerySuggestion>,
#[prost(bool, tag = "2")]
pub tail_match_triggered: bool,
}
/// Nested message and enum types in `CompleteQueryResponse`.
pub mod complete_query_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySuggestion {
#[prost(string, tag = "1")]
pub suggestion: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub completable_field_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
}
/// Generated client implementations.
pub mod completion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for Auto-Completion.
#[derive(Debug, Clone)]
pub struct CompletionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CompletionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CompletionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CompletionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Completes the specified user input with keyword suggestions.
pub async fn complete_query(&mut self, request: impl tonic::IntoRequest<super::CompleteQueryRequest>) -> std::result::Result<tonic::Response<super::CompleteQueryResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.CompletionService/CompleteQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.CompletionService", "CompleteQuery"));
self.inner.unary(req, path, codec).await
}
/// Imports all
/// [SuggestionDenyListEntry][google.cloud.discoveryengine.v1alpha.SuggestionDenyListEntry]
/// for a DataStore.
pub async fn import_suggestion_deny_list_entries(&mut self, request: impl tonic::IntoRequest<super::ImportSuggestionDenyListEntriesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.CompletionService/ImportSuggestionDenyListEntries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.CompletionService", "ImportSuggestionDenyListEntries"));
self.inner.unary(req, path, codec).await
}
/// Permanently deletes all
/// [SuggestionDenyListEntry][google.cloud.discoveryengine.v1alpha.SuggestionDenyListEntry]
/// for a DataStore.
pub async fn purge_suggestion_deny_list_entries(&mut self, request: impl tonic::IntoRequest<super::PurgeSuggestionDenyListEntriesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.CompletionService/PurgeSuggestionDenyListEntries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.CompletionService", "PurgeSuggestionDenyListEntries"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub field_configs: ::prost::alloc::vec::Vec<FieldConfig>,
#[prost(oneof = "schema::Schema", tags = "2, 3")]
pub schema: ::core::option::Option<schema::Schema>,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Schema {
#[prost(message, tag = "2")]
StructSchema(::prost_types::Struct),
#[prost(string, tag = "3")]
JsonSchema(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldConfig {
#[prost(string, tag = "1")]
pub field_path: ::prost::alloc::string::String,
#[prost(enumeration = "field_config::FieldType", tag = "2")]
pub field_type: i32,
#[prost(enumeration = "field_config::IndexableOption", tag = "3")]
pub indexable_option: i32,
#[prost(enumeration = "field_config::DynamicFacetableOption", tag = "4")]
pub dynamic_facetable_option: i32,
#[prost(enumeration = "field_config::SearchableOption", tag = "5")]
pub searchable_option: i32,
#[prost(enumeration = "field_config::RetrievableOption", tag = "6")]
pub retrievable_option: i32,
#[prost(enumeration = "field_config::CompletableOption", tag = "8")]
pub completable_option: i32,
#[prost(enumeration = "field_config::FilterableOption", tag = "9")]
pub recs_filterable_option: i32,
#[prost(string, tag = "7")]
pub key_property_type: ::prost::alloc::string::String,
#[prost(enumeration = "field_config::AdvancedSiteSearchDataSource", repeated, tag = "10")]
pub advanced_site_search_data_sources: ::prost::alloc::vec::Vec<i32>,
#[prost(string, repeated, tag = "11")]
pub schema_org_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FieldConfig`.
pub mod field_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldType {
Unspecified = 0,
Object = 1,
String = 2,
Number = 3,
Integer = 4,
Boolean = 5,
Geolocation = 6,
Datetime = 7,
}
impl FieldType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FieldType::Unspecified => "FIELD_TYPE_UNSPECIFIED",
FieldType::Object => "OBJECT",
FieldType::String => "STRING",
FieldType::Number => "NUMBER",
FieldType::Integer => "INTEGER",
FieldType::Boolean => "BOOLEAN",
FieldType::Geolocation => "GEOLOCATION",
FieldType::Datetime => "DATETIME",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FIELD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"OBJECT" => Some(Self::Object),
"STRING" => Some(Self::String),
"NUMBER" => Some(Self::Number),
"INTEGER" => Some(Self::Integer),
"BOOLEAN" => Some(Self::Boolean),
"GEOLOCATION" => Some(Self::Geolocation),
"DATETIME" => Some(Self::Datetime),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexableOption {
Unspecified = 0,
IndexableEnabled = 1,
IndexableDisabled = 2,
}
impl IndexableOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
IndexableOption::Unspecified => "INDEXABLE_OPTION_UNSPECIFIED",
IndexableOption::IndexableEnabled => "INDEXABLE_ENABLED",
IndexableOption::IndexableDisabled => "INDEXABLE_DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INDEXABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"INDEXABLE_ENABLED" => Some(Self::IndexableEnabled),
"INDEXABLE_DISABLED" => Some(Self::IndexableDisabled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DynamicFacetableOption {
Unspecified = 0,
DynamicFacetableEnabled = 1,
DynamicFacetableDisabled = 2,
}
impl DynamicFacetableOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DynamicFacetableOption::Unspecified => "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED",
DynamicFacetableOption::DynamicFacetableEnabled => "DYNAMIC_FACETABLE_ENABLED",
DynamicFacetableOption::DynamicFacetableDisabled => "DYNAMIC_FACETABLE_DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DYNAMIC_FACETABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"DYNAMIC_FACETABLE_ENABLED" => Some(Self::DynamicFacetableEnabled),
"DYNAMIC_FACETABLE_DISABLED" => Some(Self::DynamicFacetableDisabled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchableOption {
Unspecified = 0,
SearchableEnabled = 1,
SearchableDisabled = 2,
}
impl SearchableOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SearchableOption::Unspecified => "SEARCHABLE_OPTION_UNSPECIFIED",
SearchableOption::SearchableEnabled => "SEARCHABLE_ENABLED",
SearchableOption::SearchableDisabled => "SEARCHABLE_DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEARCHABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"SEARCHABLE_ENABLED" => Some(Self::SearchableEnabled),
"SEARCHABLE_DISABLED" => Some(Self::SearchableDisabled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RetrievableOption {
Unspecified = 0,
RetrievableEnabled = 1,
RetrievableDisabled = 2,
}
impl RetrievableOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RetrievableOption::Unspecified => "RETRIEVABLE_OPTION_UNSPECIFIED",
RetrievableOption::RetrievableEnabled => "RETRIEVABLE_ENABLED",
RetrievableOption::RetrievableDisabled => "RETRIEVABLE_DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RETRIEVABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"RETRIEVABLE_ENABLED" => Some(Self::RetrievableEnabled),
"RETRIEVABLE_DISABLED" => Some(Self::RetrievableDisabled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompletableOption {
Unspecified = 0,
CompletableEnabled = 1,
CompletableDisabled = 2,
}
impl CompletableOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CompletableOption::Unspecified => "COMPLETABLE_OPTION_UNSPECIFIED",
CompletableOption::CompletableEnabled => "COMPLETABLE_ENABLED",
CompletableOption::CompletableDisabled => "COMPLETABLE_DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMPLETABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"COMPLETABLE_ENABLED" => Some(Self::CompletableEnabled),
"COMPLETABLE_DISABLED" => Some(Self::CompletableDisabled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FilterableOption {
Unspecified = 0,
FilterableEnabled = 1,
FilterableDisabled = 2,
}
impl FilterableOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FilterableOption::Unspecified => "FILTERABLE_OPTION_UNSPECIFIED",
FilterableOption::FilterableEnabled => "FILTERABLE_ENABLED",
FilterableOption::FilterableDisabled => "FILTERABLE_DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FILTERABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"FILTERABLE_ENABLED" => Some(Self::FilterableEnabled),
"FILTERABLE_DISABLED" => Some(Self::FilterableDisabled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdvancedSiteSearchDataSource {
Unspecified = 0,
Metatags = 1,
Pagemap = 2,
SchemaOrg = 4,
}
impl AdvancedSiteSearchDataSource {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AdvancedSiteSearchDataSource::Unspecified => "ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED",
AdvancedSiteSearchDataSource::Metatags => "METATAGS",
AdvancedSiteSearchDataSource::Pagemap => "PAGEMAP",
AdvancedSiteSearchDataSource::SchemaOrg => "SCHEMA_ORG",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
"METATAGS" => Some(Self::Metatags),
"PAGEMAP" => Some(Self::Pagemap),
"SCHEMA_ORG" => Some(Self::SchemaOrg),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleQuerySet {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "4")]
pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataStore {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "IndustryVertical", tag = "3")]
pub industry_vertical: i32,
#[prost(enumeration = "SolutionType", repeated, tag = "5")]
pub solution_types: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "7")]
pub default_schema_id: ::prost::alloc::string::String,
#[prost(enumeration = "data_store::ContentConfig", tag = "6")]
pub content_config: i32,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "21")]
pub idp_config: ::core::option::Option<IdpConfig>,
#[prost(bool, tag = "24")]
pub acl_enabled: bool,
#[prost(message, optional, tag = "27")]
pub document_processing_config: ::core::option::Option<DocumentProcessingConfig>,
#[prost(message, optional, tag = "28")]
pub starting_schema: ::core::option::Option<Schema>,
}
/// Nested message and enum types in `DataStore`.
pub mod data_store {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentConfig {
Unspecified = 0,
NoContent = 1,
ContentRequired = 2,
PublicWebsite = 3,
}
impl ContentConfig {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ContentConfig::Unspecified => "CONTENT_CONFIG_UNSPECIFIED",
ContentConfig::NoContent => "NO_CONTENT",
ContentConfig::ContentRequired => "CONTENT_REQUIRED",
ContentConfig::PublicWebsite => "PUBLIC_WEBSITE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CONTENT_CONFIG_UNSPECIFIED" => Some(Self::Unspecified),
"NO_CONTENT" => Some(Self::NoContent),
"CONTENT_REQUIRED" => Some(Self::ContentRequired),
"PUBLIC_WEBSITE" => Some(Self::PublicWebsite),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataStoreRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub data_store: ::core::option::Option<DataStore>,
#[prost(string, tag = "3")]
pub data_store_id: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub create_advanced_site_search: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataStoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateDataStoreMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataStoresRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataStoresResponse {
#[prost(message, repeated, tag = "1")]
pub data_stores: ::prost::alloc::vec::Vec<DataStore>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataStoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataStoreRequest {
#[prost(message, optional, tag = "1")]
pub data_store: ::core::option::Option<DataStore>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteDataStoreMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentProcessingConfigRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentProcessingConfigRequest {
#[prost(message, optional, tag = "1")]
pub document_processing_config: ::core::option::Option<DocumentProcessingConfig>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod data_store_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing
/// [DataStore][google.cloud.discoveryengine.v1alpha.DataStore] configuration.
#[derive(Debug, Clone)]
pub struct DataStoreServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DataStoreServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DataStoreServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DataStoreServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a [DataStore][google.cloud.discoveryengine.v1alpha.DataStore].
///
/// DataStore is for storing
/// [Documents][google.cloud.discoveryengine.v1alpha.Document]. To serve these
/// documents for Search, or Recommendation use case, an
/// [Engine][google.cloud.discoveryengine.v1alpha.Engine] needs to be created
/// separately.
pub async fn create_data_store(&mut self, request: impl tonic::IntoRequest<super::CreateDataStoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DataStoreService/CreateDataStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DataStoreService", "CreateDataStore"));
self.inner.unary(req, path, codec).await
}
/// Gets a [DataStore][google.cloud.discoveryengine.v1alpha.DataStore].
pub async fn get_data_store(&mut self, request: impl tonic::IntoRequest<super::GetDataStoreRequest>) -> std::result::Result<tonic::Response<super::DataStore>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DataStoreService/GetDataStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DataStoreService", "GetDataStore"));
self.inner.unary(req, path, codec).await
}
/// Lists all the [DataStore][google.cloud.discoveryengine.v1alpha.DataStore]s
/// associated with the project.
pub async fn list_data_stores(&mut self, request: impl tonic::IntoRequest<super::ListDataStoresRequest>) -> std::result::Result<tonic::Response<super::ListDataStoresResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DataStoreService/ListDataStores");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DataStoreService", "ListDataStores"));
self.inner.unary(req, path, codec).await
}
/// Deletes a [DataStore][google.cloud.discoveryengine.v1alpha.DataStore].
pub async fn delete_data_store(&mut self, request: impl tonic::IntoRequest<super::DeleteDataStoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DataStoreService/DeleteDataStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DataStoreService", "DeleteDataStore"));
self.inner.unary(req, path, codec).await
}
/// Updates a [DataStore][google.cloud.discoveryengine.v1alpha.DataStore]
pub async fn update_data_store(&mut self, request: impl tonic::IntoRequest<super::UpdateDataStoreRequest>) -> std::result::Result<tonic::Response<super::DataStore>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DataStoreService/UpdateDataStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DataStoreService", "UpdateDataStore"));
self.inner.unary(req, path, codec).await
}
/// Gets a
/// [DocumentProcessingConfig][google.cloud.discoveryengine.v1alpha.DocumentProcessingConfig].
pub async fn get_document_processing_config(&mut self, request: impl tonic::IntoRequest<super::GetDocumentProcessingConfigRequest>) -> std::result::Result<tonic::Response<super::DocumentProcessingConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DataStoreService/GetDocumentProcessingConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DataStoreService", "GetDocumentProcessingConfig"));
self.inner.unary(req, path, codec).await
}
/// Updates the
/// [DocumentProcessingConfig][google.cloud.discoveryengine.v1alpha.DocumentProcessingConfig].
/// [DocumentProcessingConfig][google.cloud.discoveryengine.v1alpha.DocumentProcessingConfig]
/// is a singleon resource of
/// [DataStore][google.cloud.discoveryengine.v1alpha.DataStore]. It's empty
/// when [DataStore][google.cloud.discoveryengine.v1alpha.DataStore] is
/// created. The first call to this method will set up
/// [DocumentProcessingConfig][google.cloud.discoveryengine.v1alpha.DocumentProcessingConfig].
pub async fn update_document_processing_config(&mut self, request: impl tonic::IntoRequest<super::UpdateDocumentProcessingConfigRequest>) -> std::result::Result<tonic::Response<super::DocumentProcessingConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DataStoreService/UpdateDocumentProcessingConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DataStoreService", "UpdateDocumentProcessingConfig"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChunkRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChunksRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChunksResponse {
#[prost(message, repeated, tag = "1")]
pub chunks: ::prost::alloc::vec::Vec<Chunk>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod chunk_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for displaying processed
/// [Chunk][google.cloud.discoveryengine.v1alpha.Chunk] information of the
/// customer's unstructured data.
#[derive(Debug, Clone)]
pub struct ChunkServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ChunkServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ChunkServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ChunkServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a [Document][google.cloud.discoveryengine.v1alpha.Document].
pub async fn get_chunk(&mut self, request: impl tonic::IntoRequest<super::GetChunkRequest>) -> std::result::Result<tonic::Response<super::Chunk>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ChunkService/GetChunk");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ChunkService", "GetChunk"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of [Chunk][google.cloud.discoveryengine.v1alpha.Chunk]s.
pub async fn list_chunks(&mut self, request: impl tonic::IntoRequest<super::ListChunksRequest>) -> std::result::Result<tonic::Response<super::ListChunksResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ChunkService/ListChunks");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ChunkService", "ListChunks"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSampleQueryRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSampleQueriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSampleQueriesResponse {
#[prost(message, repeated, tag = "1")]
pub sample_queries: ::prost::alloc::vec::Vec<SampleQuery>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSampleQueryRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub sample_query: ::core::option::Option<SampleQuery>,
#[prost(string, tag = "3")]
pub sample_query_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSampleQueryRequest {
#[prost(message, optional, tag = "1")]
pub sample_query: ::core::option::Option<SampleQuery>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSampleQueryRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sample_query_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing
/// [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]s,
#[derive(Debug, Clone)]
pub struct SampleQueryServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SampleQueryServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SampleQueryServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SampleQueryServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery].
pub async fn get_sample_query(&mut self, request: impl tonic::IntoRequest<super::GetSampleQueryRequest>) -> std::result::Result<tonic::Response<super::SampleQuery>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQueryService/GetSampleQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQueryService", "GetSampleQuery"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of
/// [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]s.
pub async fn list_sample_queries(&mut self, request: impl tonic::IntoRequest<super::ListSampleQueriesRequest>) -> std::result::Result<tonic::Response<super::ListSampleQueriesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQueryService/ListSampleQueries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQueryService", "ListSampleQueries"));
self.inner.unary(req, path, codec).await
}
/// Creates a [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]
pub async fn create_sample_query(&mut self, request: impl tonic::IntoRequest<super::CreateSampleQueryRequest>) -> std::result::Result<tonic::Response<super::SampleQuery>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQueryService/CreateSampleQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQueryService", "CreateSampleQuery"));
self.inner.unary(req, path, codec).await
}
/// Updates a [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery].
pub async fn update_sample_query(&mut self, request: impl tonic::IntoRequest<super::UpdateSampleQueryRequest>) -> std::result::Result<tonic::Response<super::SampleQuery>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQueryService/UpdateSampleQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQueryService", "UpdateSampleQuery"));
self.inner.unary(req, path, codec).await
}
/// Deletes a [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery].
pub async fn delete_sample_query(&mut self, request: impl tonic::IntoRequest<super::DeleteSampleQueryRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQueryService/DeleteSampleQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQueryService", "DeleteSampleQuery"));
self.inner.unary(req, path, codec).await
}
/// Bulk import of multiple
/// [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]s. Sample
/// queries that already exist may be deleted.
///
/// Note: It is possible for a subset of the
/// [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]s to be
/// successfully imported.
pub async fn import_sample_queries(&mut self, request: impl tonic::IntoRequest<super::ImportSampleQueriesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQueryService/ImportSampleQueries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQueryService", "ImportSampleQueries"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Engine {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, repeated, tag = "5")]
pub data_store_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "SolutionType", tag = "6")]
pub solution_type: i32,
#[prost(enumeration = "IndustryVertical", tag = "16")]
pub industry_vertical: i32,
#[prost(message, optional, tag = "15")]
pub common_config: ::core::option::Option<engine::CommonConfig>,
#[prost(oneof = "engine::EngineConfig", tags = "9, 11, 13, 14")]
pub engine_config: ::core::option::Option<engine::EngineConfig>,
#[prost(oneof = "engine::EngineMetadata", tags = "10, 12")]
pub engine_metadata: ::core::option::Option<engine::EngineMetadata>,
}
/// Nested message and enum types in `Engine`.
pub mod engine {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEngineConfig {
#[prost(enumeration = "super::SearchTier", tag = "1")]
pub search_tier: i32,
#[prost(enumeration = "super::SearchAddOn", repeated, tag = "2")]
pub search_add_ons: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SimilarDocumentsEngineConfig {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaRecommendationEngineConfig {
#[prost(string, tag = "1")]
pub r#type: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub optimization_objective: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub optimization_objective_config: ::core::option::Option<media_recommendation_engine_config::OptimizationObjectiveConfig>,
#[prost(enumeration = "media_recommendation_engine_config::TrainingState", tag = "4")]
pub training_state: i32,
}
/// Nested message and enum types in `MediaRecommendationEngineConfig`.
pub mod media_recommendation_engine_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptimizationObjectiveConfig {
#[prost(string, tag = "1")]
pub target_field: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub target_field_value_float: f32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TrainingState {
Unspecified = 0,
Paused = 1,
Training = 2,
}
impl TrainingState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TrainingState::Unspecified => "TRAINING_STATE_UNSPECIFIED",
TrainingState::Paused => "PAUSED",
TrainingState::Training => "TRAINING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TRAINING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PAUSED" => Some(Self::Paused),
"TRAINING" => Some(Self::Training),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatEngineConfig {
#[prost(message, optional, tag = "1")]
pub agent_creation_config: ::core::option::Option<chat_engine_config::AgentCreationConfig>,
#[prost(string, tag = "2")]
pub dialogflow_agent_to_link: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ChatEngineConfig`.
pub mod chat_engine_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCreationConfig {
#[prost(string, tag = "1")]
pub business: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub default_language_code: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub time_zone: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub location: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonConfig {
#[prost(string, tag = "1")]
pub company_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendationMetadata {
#[prost(enumeration = "recommendation_metadata::ServingState", tag = "1")]
pub serving_state: i32,
#[prost(enumeration = "recommendation_metadata::DataState", tag = "2")]
pub data_state: i32,
#[prost(message, optional, tag = "3")]
pub last_tune_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "4")]
pub tuning_operation: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RecommendationMetadata`.
pub mod recommendation_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServingState {
Unspecified = 0,
Inactive = 1,
Active = 2,
Tuned = 3,
}
impl ServingState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ServingState::Unspecified => "SERVING_STATE_UNSPECIFIED",
ServingState::Inactive => "INACTIVE",
ServingState::Active => "ACTIVE",
ServingState::Tuned => "TUNED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SERVING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"INACTIVE" => Some(Self::Inactive),
"ACTIVE" => Some(Self::Active),
"TUNED" => Some(Self::Tuned),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataState {
Unspecified = 0,
DataOk = 1,
DataError = 2,
}
impl DataState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DataState::Unspecified => "DATA_STATE_UNSPECIFIED",
DataState::DataOk => "DATA_OK",
DataState::DataError => "DATA_ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DATA_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"DATA_OK" => Some(Self::DataOk),
"DATA_ERROR" => Some(Self::DataError),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatEngineMetadata {
#[prost(string, tag = "1")]
pub dialogflow_agent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EngineConfig {
#[prost(message, tag = "9")]
SimilarDocumentsConfig(SimilarDocumentsEngineConfig),
#[prost(message, tag = "11")]
ChatEngineConfig(ChatEngineConfig),
#[prost(message, tag = "13")]
SearchEngineConfig(SearchEngineConfig),
#[prost(message, tag = "14")]
MediaRecommendationEngineConfig(MediaRecommendationEngineConfig),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EngineMetadata {
#[prost(message, tag = "10")]
RecommendationMetadata(RecommendationMetadata),
#[prost(message, tag = "12")]
ChatEngineMetadata(ChatEngineMetadata),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEngineRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub engine: ::core::option::Option<Engine>,
#[prost(string, tag = "3")]
pub engine_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateEngineMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEngineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteEngineMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEngineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnginesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnginesResponse {
#[prost(message, repeated, tag = "1")]
pub engines: ::prost::alloc::vec::Vec<Engine>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEngineRequest {
#[prost(message, optional, tag = "1")]
pub engine: ::core::option::Option<Engine>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseEngineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeEngineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuneEngineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuneEngineMetadata {
#[prost(string, tag = "1")]
pub engine: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TuneEngineResponse {}
/// Generated client implementations.
pub mod engine_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing [Engine][google.cloud.discoveryengine.v1alpha.Engine]
/// configuration.
#[derive(Debug, Clone)]
pub struct EngineServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> EngineServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> EngineServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
EngineServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a [Engine][google.cloud.discoveryengine.v1alpha.Engine].
pub async fn create_engine(&mut self, request: impl tonic::IntoRequest<super::CreateEngineRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/CreateEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "CreateEngine"));
self.inner.unary(req, path, codec).await
}
/// Deletes a [Engine][google.cloud.discoveryengine.v1alpha.Engine].
pub async fn delete_engine(&mut self, request: impl tonic::IntoRequest<super::DeleteEngineRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/DeleteEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "DeleteEngine"));
self.inner.unary(req, path, codec).await
}
/// Updates an [Engine][google.cloud.discoveryengine.v1alpha.Engine]
pub async fn update_engine(&mut self, request: impl tonic::IntoRequest<super::UpdateEngineRequest>) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/UpdateEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "UpdateEngine"));
self.inner.unary(req, path, codec).await
}
/// Gets a [Engine][google.cloud.discoveryengine.v1alpha.Engine].
pub async fn get_engine(&mut self, request: impl tonic::IntoRequest<super::GetEngineRequest>) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/GetEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "GetEngine"));
self.inner.unary(req, path, codec).await
}
/// Lists all the [Engine][google.cloud.discoveryengine.v1alpha.Engine]s
/// associated with the project.
pub async fn list_engines(&mut self, request: impl tonic::IntoRequest<super::ListEnginesRequest>) -> std::result::Result<tonic::Response<super::ListEnginesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/ListEngines");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "ListEngines"));
self.inner.unary(req, path, codec).await
}
/// Pauses the training of an existing engine. Only applicable if
/// [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
/// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
pub async fn pause_engine(&mut self, request: impl tonic::IntoRequest<super::PauseEngineRequest>) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/PauseEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "PauseEngine"));
self.inner.unary(req, path, codec).await
}
/// Resumes the training of an existing engine. Only applicable if
/// [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
/// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
pub async fn resume_engine(&mut self, request: impl tonic::IntoRequest<super::ResumeEngineRequest>) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/ResumeEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "ResumeEngine"));
self.inner.unary(req, path, codec).await
}
/// Tunes an existing engine. Only applicable if
/// [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
/// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
pub async fn tune_engine(&mut self, request: impl tonic::IntoRequest<super::TuneEngineRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EngineService/TuneEngine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EngineService", "TuneEngine"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingFact {
#[prost(string, tag = "1")]
pub fact_text: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "2")]
pub attributes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FactChunk {
#[prost(string, tag = "1")]
pub chunk_text: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub source: ::prost::alloc::string::String,
#[prost(int32, tag = "4")]
pub index: i32,
#[prost(map = "string, string", tag = "3")]
pub source_metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckGroundingSpec {
#[prost(double, optional, tag = "1")]
pub citation_threshold: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroundingRequest {
#[prost(string, tag = "1")]
pub grounding_config: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub answer_candidate: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub facts: ::prost::alloc::vec::Vec<GroundingFact>,
#[prost(message, optional, tag = "4")]
pub grounding_spec: ::core::option::Option<CheckGroundingSpec>,
#[prost(map = "string, string", tag = "5")]
pub user_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroundingResponse {
#[prost(float, optional, tag = "1")]
pub support_score: ::core::option::Option<f32>,
#[prost(message, repeated, tag = "3")]
pub cited_chunks: ::prost::alloc::vec::Vec<FactChunk>,
#[prost(message, repeated, tag = "4")]
pub claims: ::prost::alloc::vec::Vec<check_grounding_response::Claim>,
}
/// Nested message and enum types in `CheckGroundingResponse`.
pub mod check_grounding_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Claim {
#[prost(int32, optional, tag = "1")]
pub start_pos: ::core::option::Option<i32>,
#[prost(int32, optional, tag = "2")]
pub end_pos: ::core::option::Option<i32>,
#[prost(string, tag = "3")]
pub claim_text: ::prost::alloc::string::String,
#[prost(int32, repeated, tag = "4")]
pub citation_indices: ::prost::alloc::vec::Vec<i32>,
#[prost(bool, optional, tag = "6")]
pub grounding_check_required: ::core::option::Option<bool>,
}
}
/// Generated client implementations.
pub mod grounded_generation_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for grounded generation.
#[derive(Debug, Clone)]
pub struct GroundedGenerationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> GroundedGenerationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> GroundedGenerationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
GroundedGenerationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Performs a grounding check.
pub async fn check_grounding(&mut self, request: impl tonic::IntoRequest<super::CheckGroundingRequest>) -> std::result::Result<tonic::Response<super::CheckGroundingResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.GroundedGenerationService/CheckGrounding");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.GroundedGenerationService", "CheckGrounding"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
#[prost(message, repeated, tag = "1")]
pub documents: ::prost::alloc::vec::Vec<Document>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub document: ::core::option::Option<Document>,
#[prost(string, tag = "3")]
pub document_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
#[prost(message, optional, tag = "1")]
pub document: ::core::option::Option<Document>,
#[prost(bool, tag = "2")]
pub allow_missing: bool,
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProcessedDocumentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "get_processed_document_request::ProcessedDocumentType", tag = "2")]
pub processed_document_type: i32,
#[prost(enumeration = "get_processed_document_request::ProcessedDocumentFormat", tag = "3")]
pub processed_document_format: i32,
}
/// Nested message and enum types in `GetProcessedDocumentRequest`.
pub mod get_processed_document_request {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessedDocumentType {
Unspecified = 0,
ParsedDocument = 1,
ChunkedDocument = 2,
PngConvertedDocument = 3,
}
impl ProcessedDocumentType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ProcessedDocumentType::Unspecified => "PROCESSED_DOCUMENT_TYPE_UNSPECIFIED",
ProcessedDocumentType::ParsedDocument => "PARSED_DOCUMENT",
ProcessedDocumentType::ChunkedDocument => "CHUNKED_DOCUMENT",
ProcessedDocumentType::PngConvertedDocument => "PNG_CONVERTED_DOCUMENT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PROCESSED_DOCUMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PARSED_DOCUMENT" => Some(Self::ParsedDocument),
"CHUNKED_DOCUMENT" => Some(Self::ChunkedDocument),
"PNG_CONVERTED_DOCUMENT" => Some(Self::PngConvertedDocument),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessedDocumentFormat {
Unspecified = 0,
Json = 1,
}
impl ProcessedDocumentFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ProcessedDocumentFormat::Unspecified => "PROCESSED_DOCUMENT_FORMAT_UNSPECIFIED",
ProcessedDocumentFormat::Json => "JSON",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PROCESSED_DOCUMENT_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"JSON" => Some(Self::Json),
_ => None,
}
}
}
}
/// Generated client implementations.
pub mod document_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for ingesting
/// [Document][google.cloud.discoveryengine.v1alpha.Document] information of the
/// customer's website.
#[derive(Debug, Clone)]
pub struct DocumentServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DocumentServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DocumentServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DocumentServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a [Document][google.cloud.discoveryengine.v1alpha.Document].
pub async fn get_document(&mut self, request: impl tonic::IntoRequest<super::GetDocumentRequest>) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/GetDocument");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "GetDocument"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of [Document][google.cloud.discoveryengine.v1alpha.Document]s.
pub async fn list_documents(&mut self, request: impl tonic::IntoRequest<super::ListDocumentsRequest>) -> std::result::Result<tonic::Response<super::ListDocumentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/ListDocuments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "ListDocuments"));
self.inner.unary(req, path, codec).await
}
/// Creates a [Document][google.cloud.discoveryengine.v1alpha.Document].
pub async fn create_document(&mut self, request: impl tonic::IntoRequest<super::CreateDocumentRequest>) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/CreateDocument");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "CreateDocument"));
self.inner.unary(req, path, codec).await
}
/// Updates a [Document][google.cloud.discoveryengine.v1alpha.Document].
pub async fn update_document(&mut self, request: impl tonic::IntoRequest<super::UpdateDocumentRequest>) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/UpdateDocument");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "UpdateDocument"));
self.inner.unary(req, path, codec).await
}
/// Deletes a [Document][google.cloud.discoveryengine.v1alpha.Document].
pub async fn delete_document(&mut self, request: impl tonic::IntoRequest<super::DeleteDocumentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/DeleteDocument");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "DeleteDocument"));
self.inner.unary(req, path, codec).await
}
/// Bulk import of multiple
/// [Document][google.cloud.discoveryengine.v1alpha.Document]s. Request
/// processing may be synchronous. Non-existing items are created.
///
/// Note: It is possible for a subset of the
/// [Document][google.cloud.discoveryengine.v1alpha.Document]s to be
/// successfully updated.
pub async fn import_documents(&mut self, request: impl tonic::IntoRequest<super::ImportDocumentsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/ImportDocuments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "ImportDocuments"));
self.inner.unary(req, path, codec).await
}
/// Permanently deletes all selected
/// [Document][google.cloud.discoveryengine.v1alpha.Document]s in a branch.
///
/// This process is asynchronous. Depending on the number of
/// [Document][google.cloud.discoveryengine.v1alpha.Document]s to be deleted,
/// this operation can take hours to complete. Before the delete operation
/// completes, some [Document][google.cloud.discoveryengine.v1alpha.Document]s
/// might still be returned by
/// [DocumentService.GetDocument][google.cloud.discoveryengine.v1alpha.DocumentService.GetDocument]
/// or
/// [DocumentService.ListDocuments][google.cloud.discoveryengine.v1alpha.DocumentService.ListDocuments].
///
/// To get a list of the
/// [Document][google.cloud.discoveryengine.v1alpha.Document]s to be deleted,
/// set
/// [PurgeDocumentsRequest.force][google.cloud.discoveryengine.v1alpha.PurgeDocumentsRequest.force]
/// to false.
pub async fn purge_documents(&mut self, request: impl tonic::IntoRequest<super::PurgeDocumentsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/PurgeDocuments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "PurgeDocuments"));
self.inner.unary(req, path, codec).await
}
/// Gets the parsed layout information for a
/// [Document][google.cloud.discoveryengine.v1alpha.Document].
pub async fn get_processed_document(&mut self, request: impl tonic::IntoRequest<super::GetProcessedDocumentRequest>) -> std::result::Result<tonic::Response<super::ProcessedDocument>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.DocumentService/GetProcessedDocument");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.DocumentService", "GetProcessedDocument"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateDataSizeRequest {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(oneof = "estimate_data_size_request::DataSource", tags = "2, 3")]
pub data_source: ::core::option::Option<estimate_data_size_request::DataSource>,
}
/// Nested message and enum types in `EstimateDataSizeRequest`.
pub mod estimate_data_size_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebsiteDataSource {
#[prost(message, repeated, tag = "1")]
pub estimator_uri_patterns: ::prost::alloc::vec::Vec<website_data_source::EstimatorUriPattern>,
}
/// Nested message and enum types in `WebsiteDataSource`.
pub mod website_data_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimatorUriPattern {
#[prost(string, tag = "1")]
pub provided_uri_pattern: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub exact_match: bool,
#[prost(bool, tag = "3")]
pub exclusive: bool,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDataSource {
#[prost(oneof = "file_data_source::Source", tags = "1, 2")]
pub source: ::core::option::Option<file_data_source::Source>,
}
/// Nested message and enum types in `FileDataSource`.
pub mod file_data_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "1")]
GcsSource(super::super::GcsSource),
#[prost(message, tag = "2")]
BigquerySource(super::super::BigQuerySource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DataSource {
#[prost(message, tag = "2")]
WebsiteDataSource(WebsiteDataSource),
#[prost(message, tag = "3")]
FileDataSource(FileDataSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EstimateDataSizeResponse {
#[prost(int64, tag = "1")]
pub data_size_bytes: i64,
#[prost(int64, tag = "2")]
pub document_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EstimateDataSizeMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod estimate_billing_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing billing estimations resources.
#[derive(Debug, Clone)]
pub struct EstimateBillingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> EstimateBillingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> EstimateBillingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
EstimateBillingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Estimates the data size to be used by a customer.
pub async fn estimate_data_size(&mut self, request: impl tonic::IntoRequest<super::EstimateDataSizeRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EstimateBillingService/EstimateDataSize");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EstimateBillingService", "EstimateDataSize"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServingConfig {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "SolutionType", tag = "3")]
pub solution_type: i32,
#[prost(string, tag = "4")]
pub model_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub diversity_level: ::prost::alloc::string::String,
#[prost(message, optional, tag = "20")]
pub embedding_config: ::core::option::Option<EmbeddingConfig>,
#[prost(string, tag = "21")]
pub ranking_expression: ::prost::alloc::string::String,
#[prost(message, optional, tag = "22")]
pub guided_search_spec: ::core::option::Option<GuidedSearchSpec>,
#[prost(message, optional, tag = "24")]
pub custom_fine_tuning_spec: ::core::option::Option<CustomFineTuningSpec>,
#[prost(message, optional, tag = "8")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, repeated, tag = "11")]
pub filter_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "12")]
pub boost_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "14")]
pub redirect_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "15")]
pub synonyms_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "16")]
pub oneway_synonyms_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "17")]
pub dissociate_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "18")]
pub replacement_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "19")]
pub ignore_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(oneof = "serving_config::VerticalConfig", tags = "7, 10")]
pub vertical_config: ::core::option::Option<serving_config::VerticalConfig>,
}
/// Nested message and enum types in `ServingConfig`.
pub mod serving_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaConfig {
#[prost(string, tag = "1")]
pub demotion_event_type: ::prost::alloc::string::String,
#[prost(int32, tag = "4")]
pub content_freshness_cutoff_days: i32,
#[prost(oneof = "media_config::DemoteContentWatched", tags = "2, 5")]
pub demote_content_watched: ::core::option::Option<media_config::DemoteContentWatched>,
}
/// Nested message and enum types in `MediaConfig`.
pub mod media_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum DemoteContentWatched {
#[prost(float, tag = "2")]
ContentWatchedPercentageThreshold(f32),
#[prost(float, tag = "5")]
ContentWatchedSecondsThreshold(f32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericConfig {
#[prost(message, optional, tag = "1")]
pub content_search_spec: ::core::option::Option<super::search_request::ContentSearchSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum VerticalConfig {
#[prost(message, tag = "7")]
MediaConfig(MediaConfig),
#[prost(message, tag = "10")]
GenericConfig(GenericConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServingConfigRequest {
#[prost(message, optional, tag = "1")]
pub serving_config: ::core::option::Option<ServingConfig>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServingConfigRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServingConfigsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServingConfigsResponse {
#[prost(message, repeated, tag = "1")]
pub serving_configs: ::prost::alloc::vec::Vec<ServingConfig>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod serving_config_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for operations related to
/// [ServingConfig][google.cloud.discoveryengine.v1alpha.ServingConfig].
#[derive(Debug, Clone)]
pub struct ServingConfigServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ServingConfigServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ServingConfigServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ServingConfigServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Updates a ServingConfig.
///
/// Returns a NOT_FOUND error if the ServingConfig does not exist.
pub async fn update_serving_config(&mut self, request: impl tonic::IntoRequest<super::UpdateServingConfigRequest>) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ServingConfigService/UpdateServingConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ServingConfigService", "UpdateServingConfig"));
self.inner.unary(req, path, codec).await
}
/// Gets a ServingConfig.
///
/// Returns a NotFound error if the ServingConfig does not exist.
pub async fn get_serving_config(&mut self, request: impl tonic::IntoRequest<super::GetServingConfigRequest>) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ServingConfigService/GetServingConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ServingConfigService", "GetServingConfig"));
self.inner.unary(req, path, codec).await
}
/// Lists all ServingConfigs linked to this dataStore.
pub async fn list_serving_configs(&mut self, request: impl tonic::IntoRequest<super::ListServingConfigsRequest>) -> std::result::Result<tonic::Response<super::ListServingConfigsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ServingConfigService/ListServingConfigs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ServingConfigService", "ListServingConfigs"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
#[prost(message, repeated, tag = "2")]
pub query_terms: ::prost::alloc::vec::Vec<condition::QueryTerm>,
#[prost(message, repeated, tag = "3")]
pub active_time_range: ::prost::alloc::vec::Vec<condition::TimeRange>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTerm {
#[prost(string, tag = "1")]
pub value: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub full_match: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeRange {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Control {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub associated_serving_config_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "SolutionType", tag = "4")]
pub solution_type: i32,
#[prost(enumeration = "SearchUseCase", repeated, tag = "8")]
pub use_cases: ::prost::alloc::vec::Vec<i32>,
#[prost(message, repeated, tag = "5")]
pub conditions: ::prost::alloc::vec::Vec<Condition>,
#[prost(oneof = "control::Action", tags = "6, 7, 9, 10")]
pub action: ::core::option::Option<control::Action>,
}
/// Nested message and enum types in `Control`.
pub mod control {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoostAction {
#[prost(float, tag = "1")]
pub boost: f32,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub data_store: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterAction {
#[prost(string, tag = "1")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub data_store: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedirectAction {
#[prost(string, tag = "1")]
pub redirect_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynonymsAction {
#[prost(string, repeated, tag = "1")]
pub synonyms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Action {
#[prost(message, tag = "6")]
BoostAction(BoostAction),
#[prost(message, tag = "7")]
FilterAction(FilterAction),
#[prost(message, tag = "9")]
RedirectAction(RedirectAction),
#[prost(message, tag = "10")]
SynonymsAction(SynonymsAction),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasResponse {
#[prost(message, repeated, tag = "1")]
pub schemas: ::prost::alloc::vec::Vec<Schema>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSchemaRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub schema: ::core::option::Option<Schema>,
#[prost(string, tag = "3")]
pub schema_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSchemaRequest {
#[prost(message, optional, tag = "1")]
pub schema: ::core::option::Option<Schema>,
#[prost(bool, tag = "3")]
pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSchemaRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateSchemaMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateSchemaMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSchemaMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod schema_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing [Schema][google.cloud.discoveryengine.v1alpha.Schema]s.
#[derive(Debug, Clone)]
pub struct SchemaServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SchemaServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SchemaServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SchemaServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a [Schema][google.cloud.discoveryengine.v1alpha.Schema].
pub async fn get_schema(&mut self, request: impl tonic::IntoRequest<super::GetSchemaRequest>) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SchemaService/GetSchema");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SchemaService", "GetSchema"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of [Schema][google.cloud.discoveryengine.v1alpha.Schema]s.
pub async fn list_schemas(&mut self, request: impl tonic::IntoRequest<super::ListSchemasRequest>) -> std::result::Result<tonic::Response<super::ListSchemasResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SchemaService/ListSchemas");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SchemaService", "ListSchemas"));
self.inner.unary(req, path, codec).await
}
/// Creates a [Schema][google.cloud.discoveryengine.v1alpha.Schema].
pub async fn create_schema(&mut self, request: impl tonic::IntoRequest<super::CreateSchemaRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SchemaService/CreateSchema");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SchemaService", "CreateSchema"));
self.inner.unary(req, path, codec).await
}
/// Updates a [Schema][google.cloud.discoveryengine.v1alpha.Schema].
pub async fn update_schema(&mut self, request: impl tonic::IntoRequest<super::UpdateSchemaRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SchemaService/UpdateSchema");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SchemaService", "UpdateSchema"));
self.inner.unary(req, path, codec).await
}
/// Deletes a [Schema][google.cloud.discoveryengine.v1alpha.Schema].
pub async fn delete_schema(&mut self, request: impl tonic::IntoRequest<super::DeleteSchemaRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SchemaService/DeleteSchema");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SchemaService", "DeleteSchema"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSampleQuerySetRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSampleQuerySetsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSampleQuerySetsResponse {
#[prost(message, repeated, tag = "1")]
pub sample_query_sets: ::prost::alloc::vec::Vec<SampleQuerySet>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSampleQuerySetRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub sample_query_set: ::core::option::Option<SampleQuerySet>,
#[prost(string, tag = "3")]
pub sample_query_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSampleQuerySetRequest {
#[prost(message, optional, tag = "1")]
pub sample_query_set: ::core::option::Option<SampleQuerySet>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSampleQuerySetRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sample_query_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing
/// [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet]s,
#[derive(Debug, Clone)]
pub struct SampleQuerySetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SampleQuerySetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SampleQuerySetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SampleQuerySetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a
/// [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet].
pub async fn get_sample_query_set(&mut self, request: impl tonic::IntoRequest<super::GetSampleQuerySetRequest>) -> std::result::Result<tonic::Response<super::SampleQuerySet>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQuerySetService/GetSampleQuerySet");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQuerySetService", "GetSampleQuerySet"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of
/// [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet]s.
pub async fn list_sample_query_sets(&mut self, request: impl tonic::IntoRequest<super::ListSampleQuerySetsRequest>) -> std::result::Result<tonic::Response<super::ListSampleQuerySetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQuerySetService/ListSampleQuerySets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQuerySetService", "ListSampleQuerySets"));
self.inner.unary(req, path, codec).await
}
/// Creates a
/// [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet]
pub async fn create_sample_query_set(&mut self, request: impl tonic::IntoRequest<super::CreateSampleQuerySetRequest>) -> std::result::Result<tonic::Response<super::SampleQuerySet>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQuerySetService/CreateSampleQuerySet");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQuerySetService", "CreateSampleQuerySet"));
self.inner.unary(req, path, codec).await
}
/// Updates a
/// [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet].
pub async fn update_sample_query_set(&mut self, request: impl tonic::IntoRequest<super::UpdateSampleQuerySetRequest>) -> std::result::Result<tonic::Response<super::SampleQuerySet>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQuerySetService/UpdateSampleQuerySet");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQuerySetService", "UpdateSampleQuerySet"));
self.inner.unary(req, path, codec).await
}
/// Deletes a
/// [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet].
pub async fn delete_sample_query_set(&mut self, request: impl tonic::IntoRequest<super::DeleteSampleQuerySetRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.SampleQuerySetService/DeleteSampleQuerySet");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.SampleQuerySetService", "DeleteSampleQuerySet"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendRequest {
#[prost(string, tag = "1")]
pub serving_config: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub user_event: ::core::option::Option<UserEvent>,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(bool, tag = "5")]
pub validate_only: bool,
#[prost(map = "string, message", tag = "6")]
pub params: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Value>,
#[prost(map = "string, string", tag = "8")]
pub user_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<recommend_response::RecommendationResult>,
#[prost(string, tag = "2")]
pub attribution_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub missing_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
/// Nested message and enum types in `RecommendResponse`.
pub mod recommend_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendationResult {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub document: ::core::option::Option<super::Document>,
#[prost(map = "string, message", tag = "3")]
pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Value>,
}
}
/// Generated client implementations.
pub mod recommendation_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for making recommendations.
#[derive(Debug, Clone)]
pub struct RecommendationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> RecommendationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> RecommendationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
RecommendationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Makes a recommendation, which requires a contextual user event.
pub async fn recommend(&mut self, request: impl tonic::IntoRequest<super::RecommendRequest>) -> std::result::Result<tonic::Response<super::RecommendResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.RecommendationService/Recommend");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.RecommendationService", "Recommend"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateControlRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub control: ::core::option::Option<Control>,
#[prost(string, tag = "3")]
pub control_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateControlRequest {
#[prost(message, optional, tag = "1")]
pub control: ::core::option::Option<Control>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteControlRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetControlRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsResponse {
#[prost(message, repeated, tag = "1")]
pub controls: ::prost::alloc::vec::Vec<Control>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod control_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for performing CRUD operations on Controls.
/// Controls allow for custom logic to be implemented in the serving path.
/// Controls need to be attached to a Serving Config to be considered during a
/// request.
#[derive(Debug, Clone)]
pub struct ControlServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ControlServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ControlServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ControlServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a Control.
///
/// By default 1000 controls are allowed for a data store.
/// A request can be submitted to adjust this limit.
/// If the [Control][google.cloud.discoveryengine.v1alpha.Control] to create
/// already exists, an ALREADY_EXISTS error is returned.
pub async fn create_control(&mut self, request: impl tonic::IntoRequest<super::CreateControlRequest>) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ControlService/CreateControl");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ControlService", "CreateControl"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Control.
///
/// If the [Control][google.cloud.discoveryengine.v1alpha.Control] to delete
/// does not exist, a NOT_FOUND error is returned.
pub async fn delete_control(&mut self, request: impl tonic::IntoRequest<super::DeleteControlRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ControlService/DeleteControl");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ControlService", "DeleteControl"));
self.inner.unary(req, path, codec).await
}
/// Updates a Control.
///
/// [Control][google.cloud.discoveryengine.v1alpha.Control] action type cannot
/// be changed. If the [Control][google.cloud.discoveryengine.v1alpha.Control]
/// to update does not exist, a NOT_FOUND error is returned.
pub async fn update_control(&mut self, request: impl tonic::IntoRequest<super::UpdateControlRequest>) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ControlService/UpdateControl");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ControlService", "UpdateControl"));
self.inner.unary(req, path, codec).await
}
/// Gets a Control.
pub async fn get_control(&mut self, request: impl tonic::IntoRequest<super::GetControlRequest>) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ControlService/GetControl");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ControlService", "GetControl"));
self.inner.unary(req, path, codec).await
}
/// Lists all Controls by their parent
/// [DataStore][google.cloud.discoveryengine.v1alpha.DataStore].
pub async fn list_controls(&mut self, request: impl tonic::IntoRequest<super::ListControlsRequest>) -> std::result::Result<tonic::Response<super::ListControlsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ControlService/ListControls");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ControlService", "ListControls"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEvaluationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEvaluationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEvaluationsResponse {
#[prost(message, repeated, tag = "1")]
pub evaluations: ::prost::alloc::vec::Vec<Evaluation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEvaluationRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub evaluation: ::core::option::Option<Evaluation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateEvaluationMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEvaluationResultsRequest {
#[prost(string, tag = "1")]
pub evaluation: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEvaluationResultsResponse {
#[prost(message, repeated, tag = "1")]
pub evaluation_results: ::prost::alloc::vec::Vec<list_evaluation_results_response::EvaluationResult>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ListEvaluationResultsResponse`.
pub mod list_evaluation_results_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluationResult {
#[prost(message, optional, tag = "1")]
pub sample_query: ::core::option::Option<super::SampleQuery>,
#[prost(message, optional, tag = "2")]
pub quality_metrics: ::core::option::Option<super::QualityMetrics>,
}
}
/// Generated client implementations.
pub mod evaluation_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing
/// [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation]s,
#[derive(Debug, Clone)]
pub struct EvaluationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> EvaluationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> EvaluationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
EvaluationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation].
pub async fn get_evaluation(&mut self, request: impl tonic::IntoRequest<super::GetEvaluationRequest>) -> std::result::Result<tonic::Response<super::Evaluation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EvaluationService/GetEvaluation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EvaluationService", "GetEvaluation"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of
/// [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation]s.
pub async fn list_evaluations(&mut self, request: impl tonic::IntoRequest<super::ListEvaluationsRequest>) -> std::result::Result<tonic::Response<super::ListEvaluationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EvaluationService/ListEvaluations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EvaluationService", "ListEvaluations"));
self.inner.unary(req, path, codec).await
}
/// Creates a [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation].
///
/// Upon creation, the evaluation will be automatically triggered and begin
/// execution.
pub async fn create_evaluation(&mut self, request: impl tonic::IntoRequest<super::CreateEvaluationRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EvaluationService/CreateEvaluation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EvaluationService", "CreateEvaluation"));
self.inner.unary(req, path, codec).await
}
/// Gets a list of results for a given a
/// [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation].
pub async fn list_evaluation_results(&mut self, request: impl tonic::IntoRequest<super::ListEvaluationResultsRequest>) -> std::result::Result<tonic::Response<super::ListEvaluationResultsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.EvaluationService/ListEvaluationResults");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.EvaluationService", "ListEvaluationResults"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankingRecord {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub content: ::prost::alloc::string::String,
#[prost(float, tag = "4")]
pub score: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankRequest {
#[prost(string, tag = "1")]
pub ranking_config: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub model: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub top_n: i32,
#[prost(string, tag = "4")]
pub query: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "5")]
pub records: ::prost::alloc::vec::Vec<RankingRecord>,
#[prost(bool, tag = "6")]
pub ignore_record_details_in_response: bool,
#[prost(map = "string, string", tag = "7")]
pub user_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankResponse {
#[prost(message, repeated, tag = "5")]
pub records: ::prost::alloc::vec::Vec<RankingRecord>,
}
/// Generated client implementations.
pub mod rank_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for ranking text records.
#[derive(Debug, Clone)]
pub struct RankServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> RankServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> RankServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
RankServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Ranks a list of text records based on the given input query.
pub async fn rank(&mut self, request: impl tonic::IntoRequest<super::RankRequest>) -> std::result::Result<tonic::Response<super::RankResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.RankService/Rank");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.RankService", "Rank"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProjectRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionProjectRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub accept_data_use_terms: bool,
#[prost(string, tag = "3")]
pub data_use_terms_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProvisionProjectMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportConsentChangeRequest {
#[prost(enumeration = "report_consent_change_request::ConsentChangeAction", tag = "1")]
pub consent_change_action: i32,
#[prost(string, tag = "2")]
pub project: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub service_term_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub service_term_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ReportConsentChangeRequest`.
pub mod report_consent_change_request {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsentChangeAction {
Unspecified = 0,
Accept = 1,
}
impl ConsentChangeAction {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ConsentChangeAction::Unspecified => "CONSENT_CHANGE_ACTION_UNSPECIFIED",
ConsentChangeAction::Accept => "ACCEPT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CONSENT_CHANGE_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
"ACCEPT" => Some(Self::Accept),
_ => None,
}
}
}
}
/// Generated client implementations.
pub mod project_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for operations on the
/// [Project][google.cloud.discoveryengine.v1alpha.Project].
#[derive(Debug, Clone)]
pub struct ProjectServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ProjectServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ProjectServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ProjectServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a [Project][google.cloud.discoveryengine.v1alpha.Project].
/// Returns NOT_FOUND when the project is not yet created.
pub async fn get_project(&mut self, request: impl tonic::IntoRequest<super::GetProjectRequest>) -> std::result::Result<tonic::Response<super::Project>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ProjectService/GetProject");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ProjectService", "GetProject"));
self.inner.unary(req, path, codec).await
}
/// Provisions the project resource. During the
/// process, related systems will get prepared and initialized.
///
/// Caller must read the [Terms for data
/// use](https://cloud.google.com/retail/data-use-terms), and optionally
/// specify in request to provide consent to that service terms.
pub async fn provision_project(&mut self, request: impl tonic::IntoRequest<super::ProvisionProjectRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ProjectService/ProvisionProject");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ProjectService", "ProvisionProject"));
self.inner.unary(req, path, codec).await
}
/// Updates service terms for this project.
///
/// This method can be used to retroactively accept the latest terms.
///
/// Terms available for update:
///
/// * [Terms for data use](https://cloud.google.com/retail/data-use-terms)
pub async fn report_consent_change(&mut self, request: impl tonic::IntoRequest<super::ReportConsentChangeRequest>) -> std::result::Result<tonic::Response<super::Project>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.ProjectService/ReportConsentChange");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.ProjectService", "ReportConsentChange"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AclConfig {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub idp_config: ::core::option::Option<IdpConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAclConfigRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAclConfigRequest {
#[prost(message, optional, tag = "1")]
pub acl_config: ::core::option::Option<AclConfig>,
}
/// Generated client implementations.
pub mod acl_config_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for managing Acl Configuration.
#[derive(Debug, Clone)]
pub struct AclConfigServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AclConfigServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AclConfigServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AclConfigServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Default Acl Configuration for use in a location of a customer's project.
/// Updates will only reflect to new data stores. Existing data stores will
/// still use the old value.
pub async fn update_acl_config(&mut self, request: impl tonic::IntoRequest<super::UpdateAclConfigRequest>) -> std::result::Result<tonic::Response<super::AclConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.AclConfigService/UpdateAclConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.AclConfigService", "UpdateAclConfig"));
self.inner.unary(req, path, codec).await
}
/// Gets the [AclConfig][google.cloud.discoveryengine.v1alpha.AclConfig].
pub async fn get_acl_config(&mut self, request: impl tonic::IntoRequest<super::GetAclConfigRequest>) -> std::result::Result<tonic::Response<super::AclConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.discoveryengine.v1alpha.AclConfigService/GetAclConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.discoveryengine.v1alpha.AclConfigService", "GetAclConfig"));
self.inner.unary(req, path, codec).await
}
}
}
