// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Team {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTeamRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTeamsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTeamsResponse {
    #[prost(message, repeated, tag = "1")]
    pub teams: ::prost::alloc::vec::Vec<Team>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod team_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling Team objects.
    #[derive(Debug, Clone)]
    pub struct TeamServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TeamServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TeamServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TeamServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a Team object.
        pub async fn get_team(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTeamRequest>,
        ) -> std::result::Result<tonic::Response<super::Team>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/GetTeam",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.TeamService", "GetTeam"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of Team objects.
        pub async fn list_teams(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTeamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTeamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/ListTeams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.TeamService", "ListTeams"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdPartner {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdPartnerRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdPartnersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdPartnersResponse {
    #[prost(message, repeated, tag = "1")]
    pub ad_partners: ::prost::alloc::vec::Vec<AdPartner>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod ad_partner_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling AdPartner objects.
    #[derive(Debug, Clone)]
    pub struct AdPartnerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AdPartnerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdPartnerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AdPartnerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a AdPartner object.
        pub async fn get_ad_partner(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdPartnerRequest>,
        ) -> std::result::Result<tonic::Response<super::AdPartner>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdPartnerService/GetAdPartner",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdPartnerService",
                        "GetAdPartner",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of AdPartner objects.
        pub async fn list_ad_partners(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAdPartnersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAdPartnersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdPartnerService/ListAdPartners",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdPartnerService",
                        "ListAdPartners",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Size {
    #[prost(int32, tag = "1")]
    pub width: i32,
    #[prost(int32, tag = "2")]
    pub height: i32,
    #[prost(enumeration = "size_type_enum::SizeType", tag = "3")]
    pub size_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeTypeEnum {}
/// Nested message and enum types in `SizeTypeEnum`.
pub mod size_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SizeType {
        Unspecified = 0,
        Pixel = 1,
        AspectRatio = 2,
        Interstitial = 3,
        Ignored = 4,
        Native = 5,
        Fluid = 6,
        Audio = 7,
    }
    impl SizeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SizeType::Unspecified => "SIZE_TYPE_UNSPECIFIED",
                SizeType::Pixel => "PIXEL",
                SizeType::AspectRatio => "ASPECT_RATIO",
                SizeType::Interstitial => "INTERSTITIAL",
                SizeType::Ignored => "IGNORED",
                SizeType::Native => "NATIVE",
                SizeType::Fluid => "FLUID",
                SizeType::Audio => "AUDIO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SIZE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PIXEL" => Some(Self::Pixel),
                "ASPECT_RATIO" => Some(Self::AspectRatio),
                "INTERSTITIAL" => Some(Self::Interstitial),
                "IGNORED" => Some(Self::Ignored),
                "NATIVE" => Some(Self::Native),
                "FLUID" => Some(Self::Fluid),
                "AUDIO" => Some(Self::Audio),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Network {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub network_code: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub property_code: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub currency_code: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub secondary_currency_codes: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub effective_root_ad_unit: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub test_network: bool,
    #[prost(int64, tag = "11")]
    pub network_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod network_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling Network objects.
    #[derive(Debug, Clone)]
    pub struct NetworkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NetworkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NetworkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a Network object.
        pub async fn get_network(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Network>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.NetworkService/GetNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.NetworkService",
                        "GetNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlacementStatusEnum {}
/// Nested message and enum types in `PlacementStatusEnum`.
pub mod placement_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlacementStatus {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
        Archived = 3,
    }
    impl PlacementStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PlacementStatus::Unspecified => "PLACEMENT_STATUS_UNSPECIFIED",
                PlacementStatus::Active => "ACTIVE",
                PlacementStatus::Inactive => "INACTIVE",
                PlacementStatus::Archived => "ARCHIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PLACEMENT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "ARCHIVED" => Some(Self::Archived),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppliedAdsenseEnabledEnum {}
/// Nested message and enum types in `AppliedAdsenseEnabledEnum`.
pub mod applied_adsense_enabled_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppliedAdsenseEnabled {
        Unspecified = 0,
        True = 1,
        False = 2,
    }
    impl AppliedAdsenseEnabled {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppliedAdsenseEnabled::Unspecified => {
                    "APPLIED_ADSENSE_ENABLED_UNSPECIFIED"
                }
                AppliedAdsenseEnabled::True => "TRUE",
                AppliedAdsenseEnabled::False => "FALSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPLIED_ADSENSE_ENABLED_UNSPECIFIED" => Some(Self::Unspecified),
                "TRUE" => Some(Self::True),
                "FALSE" => Some(Self::False),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LineItemCostTypeEnum {}
/// Nested message and enum types in `LineItemCostTypeEnum`.
pub mod line_item_cost_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LineItemCostType {
        Unspecified = 0,
        Cpa = 1,
        Cpc = 2,
        Cpd = 3,
        Cpm = 4,
        Vcpm = 5,
        CpmInTarget = 6,
        Cpf = 7,
    }
    impl LineItemCostType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LineItemCostType::Unspecified => "LINE_ITEM_COST_TYPE_UNSPECIFIED",
                LineItemCostType::Cpa => "CPA",
                LineItemCostType::Cpc => "CPC",
                LineItemCostType::Cpd => "CPD",
                LineItemCostType::Cpm => "CPM",
                LineItemCostType::Vcpm => "VCPM",
                LineItemCostType::CpmInTarget => "CPM_IN_TARGET",
                LineItemCostType::Cpf => "CPF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LINE_ITEM_COST_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CPA" => Some(Self::Cpa),
                "CPC" => Some(Self::Cpc),
                "CPD" => Some(Self::Cpd),
                "CPM" => Some(Self::Cpm),
                "VCPM" => Some(Self::Vcpm),
                "CPM_IN_TARGET" => Some(Self::CpmInTarget),
                "CPF" => Some(Self::Cpf),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreativeRotationTypeEnum {}
/// Nested message and enum types in `CreativeRotationTypeEnum`.
pub mod creative_rotation_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreativeRotationType {
        Unspecified = 0,
        Evenly = 1,
        Optimized = 2,
        Weighted = 3,
        Sequential = 4,
    }
    impl CreativeRotationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CreativeRotationType::Unspecified => "CREATIVE_ROTATION_TYPE_UNSPECIFIED",
                CreativeRotationType::Evenly => "EVENLY",
                CreativeRotationType::Optimized => "OPTIMIZED",
                CreativeRotationType::Weighted => "WEIGHTED",
                CreativeRotationType::Sequential => "SEQUENTIAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREATIVE_ROTATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EVENLY" => Some(Self::Evenly),
                "OPTIMIZED" => Some(Self::Optimized),
                "WEIGHTED" => Some(Self::Weighted),
                "SEQUENTIAL" => Some(Self::Sequential),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeliveryRateTypeEnum {}
/// Nested message and enum types in `DeliveryRateTypeEnum`.
pub mod delivery_rate_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeliveryRateType {
        Unspecified = 0,
        Evenly = 1,
        Frontloaded = 2,
        AsFastAsPossible = 3,
    }
    impl DeliveryRateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeliveryRateType::Unspecified => "DELIVERY_RATE_TYPE_UNSPECIFIED",
                DeliveryRateType::Evenly => "EVENLY",
                DeliveryRateType::Frontloaded => "FRONTLOADED",
                DeliveryRateType::AsFastAsPossible => "AS_FAST_AS_POSSIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DELIVERY_RATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EVENLY" => Some(Self::Evenly),
                "FRONTLOADED" => Some(Self::Frontloaded),
                "AS_FAST_AS_POSSIBLE" => Some(Self::AsFastAsPossible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LineItemDiscountTypeEnum {}
/// Nested message and enum types in `LineItemDiscountTypeEnum`.
pub mod line_item_discount_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LineItemDiscountType {
        Unspecified = 0,
        AbsoluteValue = 1,
        Percentage = 2,
    }
    impl LineItemDiscountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LineItemDiscountType::Unspecified => {
                    "LINE_ITEM_DISCOUNT_TYPE_UNSPECIFIED"
                }
                LineItemDiscountType::AbsoluteValue => "ABSOLUTE_VALUE",
                LineItemDiscountType::Percentage => "PERCENTAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LINE_ITEM_DISCOUNT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ABSOLUTE_VALUE" => Some(Self::AbsoluteValue),
                "PERCENTAGE" => Some(Self::Percentage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LineItemTypeEnum {}
/// Nested message and enum types in `LineItemTypeEnum`.
pub mod line_item_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LineItemType {
        Unspecified = 0,
        Sponsorship = 12,
        Standard = 13,
        Network = 9,
        Bulk = 4,
        PricePriority = 11,
        House = 7,
        LegacyDfp = 8,
        ClickTracking = 6,
        Adsense = 2,
        AdExchange = 3,
        Bumper = 5,
        Admob = 1,
        PreferredDeal = 10,
    }
    impl LineItemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LineItemType::Unspecified => "LINE_ITEM_TYPE_UNSPECIFIED",
                LineItemType::Sponsorship => "SPONSORSHIP",
                LineItemType::Standard => "STANDARD",
                LineItemType::Network => "NETWORK",
                LineItemType::Bulk => "BULK",
                LineItemType::PricePriority => "PRICE_PRIORITY",
                LineItemType::House => "HOUSE",
                LineItemType::LegacyDfp => "LEGACY_DFP",
                LineItemType::ClickTracking => "CLICK_TRACKING",
                LineItemType::Adsense => "ADSENSE",
                LineItemType::AdExchange => "AD_EXCHANGE",
                LineItemType::Bumper => "BUMPER",
                LineItemType::Admob => "ADMOB",
                LineItemType::PreferredDeal => "PREFERRED_DEAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LINE_ITEM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SPONSORSHIP" => Some(Self::Sponsorship),
                "STANDARD" => Some(Self::Standard),
                "NETWORK" => Some(Self::Network),
                "BULK" => Some(Self::Bulk),
                "PRICE_PRIORITY" => Some(Self::PricePriority),
                "HOUSE" => Some(Self::House),
                "LEGACY_DFP" => Some(Self::LegacyDfp),
                "CLICK_TRACKING" => Some(Self::ClickTracking),
                "ADSENSE" => Some(Self::Adsense),
                "AD_EXCHANGE" => Some(Self::AdExchange),
                "BUMPER" => Some(Self::Bumper),
                "ADMOB" => Some(Self::Admob),
                "PREFERRED_DEAL" => Some(Self::PreferredDeal),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReservationStatusEnum {}
/// Nested message and enum types in `ReservationStatusEnum`.
pub mod reservation_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReservationStatus {
        Unspecified = 0,
        Reserved = 1,
        Unreserved = 2,
    }
    impl ReservationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReservationStatus::Unspecified => "RESERVATION_STATUS_UNSPECIFIED",
                ReservationStatus::Reserved => "RESERVED",
                ReservationStatus::Unreserved => "UNRESERVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVATION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "RESERVED" => Some(Self::Reserved),
                "UNRESERVED" => Some(Self::Unreserved),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnvironmentTypeEnum {}
/// Nested message and enum types in `EnvironmentTypeEnum`.
pub mod environment_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnvironmentType {
        Unspecified = 0,
        Browser = 1,
        VideoPlayer = 2,
    }
    impl EnvironmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EnvironmentType::Unspecified => "ENVIRONMENT_TYPE_UNSPECIFIED",
                EnvironmentType::Browser => "BROWSER",
                EnvironmentType::VideoPlayer => "VIDEO_PLAYER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENVIRONMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BROWSER" => Some(Self::Browser),
                "VIDEO_PLAYER" => Some(Self::VideoPlayer),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdUnitSize {
    #[prost(message, optional, tag = "1")]
    pub size: ::core::option::Option<Size>,
    #[prost(enumeration = "environment_type_enum::EnvironmentType", tag = "2")]
    pub environment_type: i32,
    #[prost(message, repeated, tag = "3")]
    pub companions: ::prost::alloc::vec::Vec<Size>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ComputedStatusEnum {}
/// Nested message and enum types in `ComputedStatusEnum`.
pub mod computed_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ComputedStatus {
        Unspecified = 0,
        DeliveryExtended = 1,
        Delivering = 2,
        Ready = 3,
        Paused = 4,
        Inactive = 5,
        PausedInventoryReleased = 6,
        PendingApproval = 7,
        Completed = 8,
        Disapproved = 9,
        Draft = 10,
        Canceled = 11,
    }
    impl ComputedStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ComputedStatus::Unspecified => "COMPUTED_STATUS_UNSPECIFIED",
                ComputedStatus::DeliveryExtended => "DELIVERY_EXTENDED",
                ComputedStatus::Delivering => "DELIVERING",
                ComputedStatus::Ready => "READY",
                ComputedStatus::Paused => "PAUSED",
                ComputedStatus::Inactive => "INACTIVE",
                ComputedStatus::PausedInventoryReleased => "PAUSED_INVENTORY_RELEASED",
                ComputedStatus::PendingApproval => "PENDING_APPROVAL",
                ComputedStatus::Completed => "COMPLETED",
                ComputedStatus::Disapproved => "DISAPPROVED",
                ComputedStatus::Draft => "DRAFT",
                ComputedStatus::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPUTED_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "DELIVERY_EXTENDED" => Some(Self::DeliveryExtended),
                "DELIVERING" => Some(Self::Delivering),
                "READY" => Some(Self::Ready),
                "PAUSED" => Some(Self::Paused),
                "INACTIVE" => Some(Self::Inactive),
                "PAUSED_INVENTORY_RELEASED" => Some(Self::PausedInventoryReleased),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "COMPLETED" => Some(Self::Completed),
                "DISAPPROVED" => Some(Self::Disapproved),
                "DRAFT" => Some(Self::Draft),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompanyCreditStatusEnum {}
/// Nested message and enum types in `CompanyCreditStatusEnum`.
pub mod company_credit_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompanyCreditStatus {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
        OnHold = 3,
        Stop = 4,
        Blocked = 5,
    }
    impl CompanyCreditStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompanyCreditStatus::Unspecified => "COMPANY_CREDIT_STATUS_UNSPECIFIED",
                CompanyCreditStatus::Active => "ACTIVE",
                CompanyCreditStatus::Inactive => "INACTIVE",
                CompanyCreditStatus::OnHold => "ON_HOLD",
                CompanyCreditStatus::Stop => "STOP",
                CompanyCreditStatus::Blocked => "BLOCKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPANY_CREDIT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "ON_HOLD" => Some(Self::OnHold),
                "STOP" => Some(Self::Stop),
                "BLOCKED" => Some(Self::Blocked),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdManagerError {
    #[prost(string, tag = "1")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub field_path: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub trigger: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub stack_trace: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub details: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Report {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportSavedReportRequest {
    #[prost(string, tag = "1")]
    pub report: ::prost::alloc::string::String,
    #[prost(enumeration = "export_saved_report_request::Format", tag = "2")]
    pub format: i32,
    #[prost(bool, tag = "3")]
    pub include_report_properties: bool,
    #[prost(bool, tag = "4")]
    pub include_ids: bool,
    #[prost(bool, tag = "5")]
    pub include_totals_row: bool,
    #[prost(string, tag = "6")]
    pub file_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExportSavedReportRequest`.
pub mod export_saved_report_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        Unspecified = 0,
        CsvDump = 2,
        Xlsx = 5,
        Xml = 6,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Format::Unspecified => "FORMAT_UNSPECIFIED",
                Format::CsvDump => "CSV_DUMP",
                Format::Xlsx => "XLSX",
                Format::Xml => "XML",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "CSV_DUMP" => Some(Self::CsvDump),
                "XLSX" => Some(Self::Xlsx),
                "XML" => Some(Self::Xml),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportSavedReportMetadata {
    #[prost(int64, tag = "1")]
    pub result_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportSavedReportResponse {
    #[prost(string, tag = "1")]
    pub download_url: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod report_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for interacting with Reports.
    #[derive(Debug, Clone)]
    pub struct ReportServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ReportServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReportServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ReportServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Initiates the execution and export of a report asynchronously. Users can
        /// get the report by polling this operation via
        /// OperationsService.GetOperation.
        /// Intervals of at least 2 seconds are recommended, with an exponential
        /// backoff. Once a report is complete, the operation will contain a
        /// ExportSavedReportResponse in its response field.
        pub async fn export_saved_report(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportSavedReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ReportService/ExportSavedReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ReportService",
                        "ExportSavedReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppliedLabel {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub negated: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Role {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolesResponse {
    #[prost(message, repeated, tag = "1")]
    pub roles: ::prost::alloc::vec::Vec<Role>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod role_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling Role objects.
    #[derive(Debug, Clone)]
    pub struct RoleServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RoleServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RoleServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RoleServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a Role object.
        pub async fn get_role(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::Role>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.RoleService/GetRole",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.RoleService", "GetRole"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of Role objects.
        pub async fn list_roles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRolesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRolesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.RoleService/ListRoles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.RoleService", "ListRoles"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub contact_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContactRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContactsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContactsResponse {
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod contact_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling Contact objects.
    #[derive(Debug, Clone)]
    pub struct ContactServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ContactServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContactServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ContactServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a Contact object.
        pub async fn get_contact(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContactRequest>,
        ) -> std::result::Result<tonic::Response<super::Contact>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/GetContact",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "GetContact",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of Contact objects.
        pub async fn list_contacts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContactsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContactsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/ListContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "ListContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreativePlaceholder {
    #[prost(message, optional, tag = "1")]
    pub size: ::core::option::Option<Size>,
    #[prost(message, repeated, tag = "2")]
    pub companion_sizes: ::prost::alloc::vec::Vec<Size>,
    #[prost(int32, tag = "3")]
    pub expected_creative_count: i32,
    #[prost(message, repeated, tag = "4")]
    pub applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    #[prost(bool, tag = "5")]
    pub amp_only: bool,
    #[prost(string, tag = "6")]
    pub creative_targeting_display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Goal {
    #[prost(enumeration = "goal_type_enum::GoalType", tag = "1")]
    pub goal_type: i32,
    #[prost(enumeration = "unit_type_enum::UnitType", tag = "2")]
    pub unit_type: i32,
    #[prost(int64, tag = "3")]
    pub units: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoalTypeEnum {}
/// Nested message and enum types in `GoalTypeEnum`.
pub mod goal_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoalType {
        Unspecified = 0,
        None = 1,
        Lifetime = 2,
        Daily = 3,
    }
    impl GoalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GoalType::Unspecified => "GOAL_TYPE_UNSPECIFIED",
                GoalType::None => "NONE",
                GoalType::Lifetime => "LIFETIME",
                GoalType::Daily => "DAILY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GOAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "LIFETIME" => Some(Self::Lifetime),
                "DAILY" => Some(Self::Daily),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnitTypeEnum {}
/// Nested message and enum types in `UnitTypeEnum`.
pub mod unit_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnitType {
        Unspecified = 0,
        Impressions = 1,
        Clicks = 2,
        ClickThroughCpaConversions = 3,
        ViewThroughCpaConversions = 4,
        TotalCpaConversions = 5,
        ViewableImpressions = 6,
        InTargetImpressions = 7,
    }
    impl UnitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UnitType::Unspecified => "UNIT_TYPE_UNSPECIFIED",
                UnitType::Impressions => "IMPRESSIONS",
                UnitType::Clicks => "CLICKS",
                UnitType::ClickThroughCpaConversions => "CLICK_THROUGH_CPA_CONVERSIONS",
                UnitType::ViewThroughCpaConversions => "VIEW_THROUGH_CPA_CONVERSIONS",
                UnitType::TotalCpaConversions => "TOTAL_CPA_CONVERSIONS",
                UnitType::ViewableImpressions => "VIEWABLE_IMPRESSIONS",
                UnitType::InTargetImpressions => "IN_TARGET_IMPRESSIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPRESSIONS" => Some(Self::Impressions),
                "CLICKS" => Some(Self::Clicks),
                "CLICK_THROUGH_CPA_CONVERSIONS" => Some(Self::ClickThroughCpaConversions),
                "VIEW_THROUGH_CPA_CONVERSIONS" => Some(Self::ViewThroughCpaConversions),
                "TOTAL_CPA_CONVERSIONS" => Some(Self::TotalCpaConversions),
                "VIEWABLE_IMPRESSIONS" => Some(Self::ViewableImpressions),
                "IN_TARGET_IMPRESSIONS" => Some(Self::InTargetImpressions),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineItem {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "14")]
    pub archived: bool,
    #[prost(int64, tag = "18")]
    pub contracted_units_bought: i64,
    #[prost(message, optional, tag = "15")]
    pub cost_per_unit: ::core::option::Option<super::super::super::r#type::Money>,
    #[prost(enumeration = "line_item_cost_type_enum::LineItemCostType", tag = "19")]
    pub cost_type: i32,
    #[prost(message, optional, tag = "12")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "31")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(
        enumeration = "creative_rotation_type_enum::CreativeRotationType",
        tag = "22"
    )]
    pub creative_rotation_type: i32,
    #[prost(enumeration = "delivery_rate_type_enum::DeliveryRateType", tag = "23")]
    pub delivery_rate_type: i32,
    #[prost(double, tag = "13")]
    pub discount: f64,
    #[prost(
        enumeration = "line_item_discount_type_enum::LineItemDiscountType",
        tag = "24"
    )]
    pub discount_type: i32,
    #[prost(enumeration = "environment_type_enum::EnvironmentType", tag = "25")]
    pub environment_type: i32,
    #[prost(string, tag = "5")]
    pub external_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "8")]
    pub auto_extension_days: i32,
    #[prost(bool, tag = "9")]
    pub unlimited_end_time: bool,
    #[prost(string, tag = "17")]
    pub last_modified_by_app: ::prost::alloc::string::String,
    #[prost(enumeration = "line_item_type_enum::LineItemType", tag = "10")]
    pub line_item_type: i32,
    #[prost(bool, tag = "16")]
    pub missing_creatives: bool,
    #[prost(string, tag = "20")]
    pub notes: ::prost::alloc::string::String,
    #[prost(int64, tag = "11")]
    pub priority: i64,
    #[prost(enumeration = "reservation_status_enum::ReservationStatus", tag = "26")]
    pub reservation_status: i32,
    #[prost(string, tag = "21")]
    pub web_property_code: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "27")]
    pub creative_placeholders: ::prost::alloc::vec::Vec<CreativePlaceholder>,
    #[prost(enumeration = "computed_status_enum::ComputedStatus", tag = "28")]
    pub status: i32,
    #[prost(message, optional, tag = "29")]
    pub primary_goal: ::core::option::Option<Goal>,
    #[prost(message, optional, tag = "30")]
    pub impression_limit: ::core::option::Option<Goal>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLineItemRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLineItemsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLineItemsResponse {
    #[prost(message, repeated, tag = "1")]
    pub line_items: ::prost::alloc::vec::Vec<LineItem>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod line_item_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling LineItem objects.
    #[derive(Debug, Clone)]
    pub struct LineItemServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> LineItemServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LineItemServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            LineItemServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a LineItem object.
        pub async fn get_line_item(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLineItemRequest>,
        ) -> std::result::Result<tonic::Response<super::LineItem>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.LineItemService/GetLineItem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.LineItemService",
                        "GetLineItem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of LineItem objects.
        pub async fn list_line_items(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLineItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLineItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.LineItemService/ListLineItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.LineItemService",
                        "ListLineItems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub order_id: i64,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub programmatic: bool,
    #[prost(string, tag = "23")]
    pub trafficker: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub advertiser_contacts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub advertiser: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub agency_contacts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub agency: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub applied_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "28")]
    pub effective_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "10")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub currency_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "19")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "13")]
    pub external_order_id: i64,
    #[prost(bool, tag = "14")]
    pub archived: bool,
    #[prost(string, tag = "15")]
    pub last_modified_by_app: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "17")]
    pub notes: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub po_number: ::prost::alloc::string::String,
    #[prost(enumeration = "order::Status", tag = "20")]
    pub status: i32,
    #[prost(string, tag = "21")]
    pub salesperson: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "22")]
    pub secondary_salespeople: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "24")]
    pub secondary_traffickers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "25")]
    pub applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    #[prost(message, repeated, tag = "26")]
    pub effective_applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
}
/// Nested message and enum types in `Order`.
pub mod order {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        Draft = 2,
        PendingApproval = 3,
        Approved = 4,
        Disapproved = 5,
        Paused = 6,
        Canceled = 7,
        Deleted = 8,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unspecified => "STATUS_UNSPECIFIED",
                Status::Draft => "DRAFT",
                Status::PendingApproval => "PENDING_APPROVAL",
                Status::Approved => "APPROVED",
                Status::Disapproved => "DISAPPROVED",
                Status::Paused => "PAUSED",
                Status::Canceled => "CANCELED",
                Status::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "APPROVED" => Some(Self::Approved),
                "DISAPPROVED" => Some(Self::Disapproved),
                "PAUSED" => Some(Self::Paused),
                "CANCELED" => Some(Self::Canceled),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrderRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersResponse {
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod order_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Order` objects.
    #[derive(Debug, Clone)]
    pub struct OrderServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> OrderServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OrderServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            OrderServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve an Order object.
        pub async fn get_order(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::Order>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OrderService/GetOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.OrderService", "GetOrder"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Order` objects.
        ///
        /// Fields used for literal matching in filter string:
        /// * `order_id`
        /// * `display_name`
        /// * `external_order_id`
        pub async fn list_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrdersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OrderService/ListOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.OrderService", "ListOrders"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompanyTypeEnum {}
/// Nested message and enum types in `CompanyTypeEnum`.
pub mod company_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompanyType {
        Unspecified = 0,
        Advertiser = 1,
        HouseAdvertiser = 2,
        Agency = 3,
        HouseAgency = 4,
        AdNetwork = 5,
        ViewabilityProvider = 6,
    }
    impl CompanyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompanyType::Unspecified => "COMPANY_TYPE_UNSPECIFIED",
                CompanyType::Advertiser => "ADVERTISER",
                CompanyType::HouseAdvertiser => "HOUSE_ADVERTISER",
                CompanyType::Agency => "AGENCY",
                CompanyType::HouseAgency => "HOUSE_AGENCY",
                CompanyType::AdNetwork => "AD_NETWORK",
                CompanyType::ViewabilityProvider => "VIEWABILITY_PROVIDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPANY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADVERTISER" => Some(Self::Advertiser),
                "HOUSE_ADVERTISER" => Some(Self::HouseAdvertiser),
                "AGENCY" => Some(Self::Agency),
                "HOUSE_AGENCY" => Some(Self::HouseAgency),
                "AD_NETWORK" => Some(Self::AdNetwork),
                "VIEWABILITY_PROVIDER" => Some(Self::ViewabilityProvider),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomFieldDataTypeEnum {}
/// Nested message and enum types in `CustomFieldDataTypeEnum`.
pub mod custom_field_data_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldDataType {
        Unspecified = 0,
        String = 1,
        Number = 2,
        Toggle = 3,
        DropDown = 4,
    }
    impl CustomFieldDataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomFieldDataType::Unspecified => "CUSTOM_FIELD_DATA_TYPE_UNSPECIFIED",
                CustomFieldDataType::String => "STRING",
                CustomFieldDataType::Number => "NUMBER",
                CustomFieldDataType::Toggle => "TOGGLE",
                CustomFieldDataType::DropDown => "DROP_DOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "NUMBER" => Some(Self::Number),
                "TOGGLE" => Some(Self::Toggle),
                "DROP_DOWN" => Some(Self::DropDown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomFieldEntityTypeEnum {}
/// Nested message and enum types in `CustomFieldEntityTypeEnum`.
pub mod custom_field_entity_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldEntityType {
        Unspecified = 0,
        LineItem = 1,
        Order = 2,
        Creative = 3,
        Proposal = 4,
        ProposalLineItem = 5,
    }
    impl CustomFieldEntityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomFieldEntityType::Unspecified => {
                    "CUSTOM_FIELD_ENTITY_TYPE_UNSPECIFIED"
                }
                CustomFieldEntityType::LineItem => "LINE_ITEM",
                CustomFieldEntityType::Order => "ORDER",
                CustomFieldEntityType::Creative => "CREATIVE",
                CustomFieldEntityType::Proposal => "PROPOSAL",
                CustomFieldEntityType::ProposalLineItem => "PROPOSAL_LINE_ITEM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LINE_ITEM" => Some(Self::LineItem),
                "ORDER" => Some(Self::Order),
                "CREATIVE" => Some(Self::Creative),
                "PROPOSAL" => Some(Self::Proposal),
                "PROPOSAL_LINE_ITEM" => Some(Self::ProposalLineItem),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomFieldStatusEnum {}
/// Nested message and enum types in `CustomFieldStatusEnum`.
pub mod custom_field_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldStatus {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
    }
    impl CustomFieldStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomFieldStatus::Unspecified => "CUSTOM_FIELD_STATUS_UNSPECIFIED",
                CustomFieldStatus::Active => "ACTIVE",
                CustomFieldStatus::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomFieldVisibilityEnum {}
/// Nested message and enum types in `CustomFieldVisibilityEnum`.
pub mod custom_field_visibility_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldVisibility {
        Unspecified = 0,
        Hidden = 1,
        ReadOnly = 2,
        Editable = 3,
    }
    impl CustomFieldVisibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomFieldVisibility::Unspecified => {
                    "CUSTOM_FIELD_VISIBILITY_UNSPECIFIED"
                }
                CustomFieldVisibility::Hidden => "HIDDEN",
                CustomFieldVisibility::ReadOnly => "READ_ONLY",
                CustomFieldVisibility::Editable => "EDITABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_VISIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "HIDDEN" => Some(Self::Hidden),
                "READ_ONLY" => Some(Self::ReadOnly),
                "EDITABLE" => Some(Self::Editable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomField {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub custom_field_id: i64,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "custom_field_status_enum::CustomFieldStatus", tag = "5")]
    pub status: i32,
    #[prost(
        enumeration = "custom_field_entity_type_enum::CustomFieldEntityType",
        tag = "7"
    )]
    pub entity_type: i32,
    #[prost(enumeration = "custom_field_data_type_enum::CustomFieldDataType", tag = "8")]
    pub data_type: i32,
    #[prost(
        enumeration = "custom_field_visibility_enum::CustomFieldVisibility",
        tag = "9"
    )]
    pub visibility: i32,
    #[prost(message, repeated, tag = "10")]
    pub options: ::prost::alloc::vec::Vec<CustomFieldOption>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomFieldOption {
    #[prost(int64, tag = "1")]
    pub custom_field_option_id: i64,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomFieldRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomFieldsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomFieldsResponse {
    #[prost(message, repeated, tag = "1")]
    pub custom_fields: ::prost::alloc::vec::Vec<CustomField>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod custom_field_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CustomField` objects.
    #[derive(Debug, Clone)]
    pub struct CustomFieldServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CustomFieldServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CustomFieldServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CustomFieldServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CustomField` object.
        pub async fn get_custom_field(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomFieldRequest>,
        ) -> std::result::Result<tonic::Response<super::CustomField>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/GetCustomField",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "GetCustomField",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CustomField` objects.
        pub async fn list_custom_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomFieldsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/ListCustomFields",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "ListCustomFields",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCap {
    #[prost(int64, optional, tag = "1")]
    pub max_impressions: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub time_amount: ::core::option::Option<i64>,
    #[prost(enumeration = "time_unit_enum::TimeUnit", optional, tag = "3")]
    pub time_unit: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeUnitEnum {}
/// Nested message and enum types in `TimeUnitEnum`.
pub mod time_unit_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeUnit {
        Unspecified = 0,
        Minute = 1,
        Hour = 2,
        Day = 3,
        Week = 4,
        Month = 5,
        Lifetime = 6,
        Pod = 7,
        Stream = 8,
    }
    impl TimeUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TimeUnit::Unspecified => "TIME_UNIT_UNSPECIFIED",
                TimeUnit::Minute => "MINUTE",
                TimeUnit::Hour => "HOUR",
                TimeUnit::Day => "DAY",
                TimeUnit::Week => "WEEK",
                TimeUnit::Month => "MONTH",
                TimeUnit::Lifetime => "LIFETIME",
                TimeUnit::Pod => "POD",
                TimeUnit::Stream => "STREAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "MINUTE" => Some(Self::Minute),
                "HOUR" => Some(Self::Hour),
                "DAY" => Some(Self::Day),
                "WEEK" => Some(Self::Week),
                "MONTH" => Some(Self::Month),
                "LIFETIME" => Some(Self::Lifetime),
                "POD" => Some(Self::Pod),
                "STREAM" => Some(Self::Stream),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdUnit {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "15")]
    pub ad_unit_id: i64,
    #[prost(string, tag = "10")]
    pub parent_ad_unit: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub parent_path: ::prost::alloc::vec::Vec<AdUnitParent>,
    #[prost(string, tag = "9")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ad_unit_code: ::prost::alloc::string::String,
    #[prost(enumeration = "ad_unit::Status", tag = "13")]
    pub status: i32,
    #[prost(enumeration = "target_window_enum::TargetWindow", tag = "12")]
    pub target_window: i32,
    #[prost(string, repeated, tag = "3")]
    pub applied_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub explicitly_targeted: bool,
    #[prost(bool, tag = "7")]
    pub has_children: bool,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "14")]
    pub ad_unit_sizes: ::prost::alloc::vec::Vec<AdUnitSize>,
    #[prost(string, tag = "17")]
    pub external_set_top_box_channel_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "19")]
    pub refresh_delay: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "20")]
    pub ctv_application_id: i64,
    #[prost(message, repeated, tag = "21")]
    pub applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    #[prost(message, repeated, tag = "22")]
    pub effective_applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    #[prost(message, repeated, tag = "23")]
    pub applied_label_frequency_caps: ::prost::alloc::vec::Vec<LabelFrequencyCap>,
    #[prost(message, repeated, tag = "24")]
    pub effective_label_frequency_caps: ::prost::alloc::vec::Vec<LabelFrequencyCap>,
    #[prost(enumeration = "smart_size_mode_enum::SmartSizeMode", tag = "25")]
    pub smart_size_mode: i32,
    #[prost(
        enumeration = "applied_adsense_enabled_enum::AppliedAdsenseEnabled",
        tag = "26"
    )]
    pub applied_adsense_enabled: i32,
    #[prost(bool, tag = "27")]
    pub effective_adsense_enabled: bool,
}
/// Nested message and enum types in `AdUnit`.
pub mod ad_unit {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
        Archived = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unspecified => "STATUS_UNSPECIFIED",
                Status::Active => "ACTIVE",
                Status::Inactive => "INACTIVE",
                Status::Archived => "ARCHIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "ARCHIVED" => Some(Self::Archived),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdUnitParent {
    #[prost(string, tag = "1")]
    pub parent_ad_unit: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ad_unit_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetWindowEnum {}
/// Nested message and enum types in `TargetWindowEnum`.
pub mod target_window_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetWindow {
        Unspecified = 0,
        Top = 1,
        Blank = 2,
    }
    impl TargetWindow {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetWindow::Unspecified => "TARGET_WINDOW_UNSPECIFIED",
                TargetWindow::Top => "TOP",
                TargetWindow::Blank => "BLANK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_WINDOW_UNSPECIFIED" => Some(Self::Unspecified),
                "TOP" => Some(Self::Top),
                "BLANK" => Some(Self::Blank),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelFrequencyCap {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub frequency_cap: ::core::option::Option<FrequencyCap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartSizeModeEnum {}
/// Nested message and enum types in `SmartSizeModeEnum`.
pub mod smart_size_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartSizeMode {
        Unspecified = 0,
        None = 1,
        SmartBanner = 2,
        DynamicSize = 3,
    }
    impl SmartSizeMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SmartSizeMode::Unspecified => "SMART_SIZE_MODE_UNSPECIFIED",
                SmartSizeMode::None => "NONE",
                SmartSizeMode::SmartBanner => "SMART_BANNER",
                SmartSizeMode::DynamicSize => "DYNAMIC_SIZE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SMART_SIZE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "SMART_BANNER" => Some(Self::SmartBanner),
                "DYNAMIC_SIZE" => Some(Self::DynamicSize),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdUnitRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdUnitsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdUnitsResponse {
    #[prost(message, repeated, tag = "1")]
    pub ad_units: ::prost::alloc::vec::Vec<AdUnit>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod ad_unit_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling AdUnit objects.
    #[derive(Debug, Clone)]
    pub struct AdUnitServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AdUnitServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdUnitServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AdUnitServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve an AdUnit object.
        pub async fn get_ad_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdUnitRequest>,
        ) -> std::result::Result<tonic::Response<super::AdUnit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/GetAdUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.AdUnitService", "GetAdUnit"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of AdUnit objects.
        pub async fn list_ad_units(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAdUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAdUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/ListAdUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "ListAdUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "10")]
    pub user_id: i64,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub role: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub active: bool,
    #[prost(string, tag = "7")]
    pub external_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub service_account: bool,
    #[prost(string, tag = "9")]
    pub orders_ui_local_time_zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersResponse {
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod user_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling User objects.
    #[derive(Debug, Clone)]
    pub struct UserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> UserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            UserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a User object.
        pub async fn get_user(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserRequest>,
        ) -> std::result::Result<tonic::Response<super::User>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.UserService/GetUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.UserService", "GetUser"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of User objects.
        pub async fn list_users(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUsersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.UserService/ListUsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.UserService", "ListUsers"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdPartnerDeclaration {
    #[prost(enumeration = "declaration_type_enum::DeclarationType", tag = "1")]
    pub r#type: i32,
    #[prost(string, repeated, tag = "2")]
    pub ad_partners: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeclarationTypeEnum {}
/// Nested message and enum types in `DeclarationTypeEnum`.
pub mod declaration_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeclarationType {
        Unspecified = 0,
        None = 1,
        Declared = 2,
    }
    impl DeclarationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeclarationType::Unspecified => "DECLARATION_TYPE_UNSPECIFIED",
                DeclarationType::None => "NONE",
                DeclarationType::Declared => "DECLARED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DECLARATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "DECLARED" => Some(Self::Declared),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomTargetingKeyStatusEnum {}
/// Nested message and enum types in `CustomTargetingKeyStatusEnum`.
pub mod custom_targeting_key_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingKeyStatus {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
    }
    impl CustomTargetingKeyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomTargetingKeyStatus::Unspecified => {
                    "CUSTOM_TARGETING_KEY_STATUS_UNSPECIFIED"
                }
                CustomTargetingKeyStatus::Active => "ACTIVE",
                CustomTargetingKeyStatus::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_KEY_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomTargetingKeyTypeEnum {}
/// Nested message and enum types in `CustomTargetingKeyTypeEnum`.
pub mod custom_targeting_key_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingKeyType {
        Unspecified = 0,
        Predefined = 1,
        Freeform = 2,
    }
    impl CustomTargetingKeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomTargetingKeyType::Unspecified => {
                    "CUSTOM_TARGETING_KEY_TYPE_UNSPECIFIED"
                }
                CustomTargetingKeyType::Predefined => "PREDEFINED",
                CustomTargetingKeyType::Freeform => "FREEFORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_KEY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PREDEFINED" => Some(Self::Predefined),
                "FREEFORM" => Some(Self::Freeform),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomTargetingKeyReportableTypeEnum {}
/// Nested message and enum types in `CustomTargetingKeyReportableTypeEnum`.
pub mod custom_targeting_key_reportable_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingKeyReportableType {
        Unspecified = 0,
        Off = 1,
        On = 2,
        CustomDimension = 3,
    }
    impl CustomTargetingKeyReportableType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomTargetingKeyReportableType::Unspecified => {
                    "CUSTOM_TARGETING_KEY_REPORTABLE_TYPE_UNSPECIFIED"
                }
                CustomTargetingKeyReportableType::Off => "OFF",
                CustomTargetingKeyReportableType::On => "ON",
                CustomTargetingKeyReportableType::CustomDimension => "CUSTOM_DIMENSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_KEY_REPORTABLE_TYPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "OFF" => Some(Self::Off),
                "ON" => Some(Self::On),
                "CUSTOM_DIMENSION" => Some(Self::CustomDimension),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetingKey {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub custom_targeting_key_id: i64,
    #[prost(string, tag = "3")]
    pub ad_tag_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(
        enumeration = "custom_targeting_key_type_enum::CustomTargetingKeyType",
        tag = "5"
    )]
    pub r#type: i32,
    #[prost(
        enumeration = "custom_targeting_key_status_enum::CustomTargetingKeyStatus",
        tag = "6"
    )]
    pub status: i32,
    #[prost(
        enumeration = "custom_targeting_key_reportable_type_enum::CustomTargetingKeyReportableType",
        tag = "7"
    )]
    pub reportable_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomTargetingKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetingKeysRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetingKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_keys: ::prost::alloc::vec::Vec<CustomTargetingKey>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod custom_targeting_key_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CustomTargetingKey` objects.
    #[derive(Debug, Clone)]
    pub struct CustomTargetingKeyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CustomTargetingKeyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CustomTargetingKeyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CustomTargetingKeyServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CustomTargetingKey` object.
        pub async fn get_custom_targeting_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomTargetingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomTargetingKey>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/GetCustomTargetingKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "GetCustomTargetingKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CustomTargetingKey` objects.
        pub async fn list_custom_targeting_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomTargetingKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomTargetingKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/ListCustomTargetingKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "ListCustomTargetingKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomTargetingValueStatusEnum {}
/// Nested message and enum types in `CustomTargetingValueStatusEnum`.
pub mod custom_targeting_value_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingValueStatus {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
    }
    impl CustomTargetingValueStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomTargetingValueStatus::Unspecified => {
                    "CUSTOM_TARGETING_VALUE_STATUS_UNSPECIFIED"
                }
                CustomTargetingValueStatus::Active => "ACTIVE",
                CustomTargetingValueStatus::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_VALUE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomTargetingValueMatchTypeEnum {}
/// Nested message and enum types in `CustomTargetingValueMatchTypeEnum`.
pub mod custom_targeting_value_match_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingValueMatchType {
        Unspecified = 0,
        Exact = 1,
        Broad = 2,
        Prefix = 3,
        BroadPrefix = 4,
        Suffix = 5,
        Contains = 6,
    }
    impl CustomTargetingValueMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomTargetingValueMatchType::Unspecified => {
                    "CUSTOM_TARGETING_VALUE_MATCH_TYPE_UNSPECIFIED"
                }
                CustomTargetingValueMatchType::Exact => "EXACT",
                CustomTargetingValueMatchType::Broad => "BROAD",
                CustomTargetingValueMatchType::Prefix => "PREFIX",
                CustomTargetingValueMatchType::BroadPrefix => "BROAD_PREFIX",
                CustomTargetingValueMatchType::Suffix => "SUFFIX",
                CustomTargetingValueMatchType::Contains => "CONTAINS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_VALUE_MATCH_TYPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "EXACT" => Some(Self::Exact),
                "BROAD" => Some(Self::Broad),
                "PREFIX" => Some(Self::Prefix),
                "BROAD_PREFIX" => Some(Self::BroadPrefix),
                "SUFFIX" => Some(Self::Suffix),
                "CONTAINS" => Some(Self::Contains),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetingValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ad_tag_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(
        enumeration = "custom_targeting_value_match_type_enum::CustomTargetingValueMatchType",
        tag = "6"
    )]
    pub match_type: i32,
    #[prost(
        enumeration = "custom_targeting_value_status_enum::CustomTargetingValueStatus",
        tag = "7"
    )]
    pub status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomTargetingValueRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetingValuesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetingValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_values: ::prost::alloc::vec::Vec<CustomTargetingValue>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod custom_targeting_value_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CustomTargetingValue` objects.
    #[derive(Debug, Clone)]
    pub struct CustomTargetingValueServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CustomTargetingValueServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CustomTargetingValueServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CustomTargetingValueServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CustomTargetingValue` object.
        pub async fn get_custom_targeting_value(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomTargetingValueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomTargetingValue>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingValueService/GetCustomTargetingValue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingValueService",
                        "GetCustomTargetingValue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CustomTargetingValue` objects.
        pub async fn list_custom_targeting_values(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomTargetingValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomTargetingValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingValueService/ListCustomTargetingValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingValueService",
                        "ListCustomTargetingValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Placement {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub placement_id: i64,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub placement_code: ::prost::alloc::string::String,
    #[prost(enumeration = "placement_status_enum::PlacementStatus", tag = "6")]
    pub status: i32,
    #[prost(string, repeated, tag = "7")]
    pub targeted_ad_units: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlacementRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlacementsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlacementsResponse {
    #[prost(message, repeated, tag = "1")]
    pub placements: ::prost::alloc::vec::Vec<Placement>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod placement_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Placement` objects.
    #[derive(Debug, Clone)]
    pub struct PlacementServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> PlacementServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PlacementServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PlacementServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Placement` object.
        pub async fn get_placement(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPlacementRequest>,
        ) -> std::result::Result<tonic::Response<super::Placement>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/GetPlacement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "GetPlacement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Placement` objects.
        pub async fn list_placements(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPlacementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPlacementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/ListPlacements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "ListPlacements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Company {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub company_id: i64,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "company_type_enum::CompanyType", tag = "4")]
    pub r#type: i32,
    #[prost(string, tag = "5")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub fax: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub phone: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub external_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub comment: ::prost::alloc::string::String,
    #[prost(enumeration = "company_credit_status_enum::CompanyCreditStatus", tag = "11")]
    pub credit_status: i32,
    #[prost(message, repeated, tag = "12")]
    pub applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    #[prost(string, optional, tag = "13")]
    pub primary_contact: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "14")]
    pub applied_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompanyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCompaniesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCompaniesResponse {
    #[prost(message, repeated, tag = "1")]
    pub companies: ::prost::alloc::vec::Vec<Company>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod company_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Company` objects.
    #[derive(Debug, Clone)]
    pub struct CompanyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CompanyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CompanyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CompanyServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Company` object.
        pub async fn get_company(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCompanyRequest>,
        ) -> std::result::Result<tonic::Response<super::Company>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CompanyService/GetCompany",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CompanyService",
                        "GetCompany",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Company` objects.
        pub async fn list_companies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCompaniesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCompaniesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CompanyService/ListCompanies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CompanyService",
                        "ListCompanies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Creative {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub creative_id: i64,
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub advertiser: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub preview_url: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub size_label: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub ad_partner_declaration: ::core::option::Option<AdPartnerDeclaration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCreativeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCreativesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCreativesResponse {
    #[prost(message, repeated, tag = "1")]
    pub creatives: ::prost::alloc::vec::Vec<Creative>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod creative_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling Creative objects.
    #[derive(Debug, Clone)]
    pub struct CreativeServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CreativeServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CreativeServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CreativeServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a Creative object.
        pub async fn get_creative(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCreativeRequest>,
        ) -> std::result::Result<tonic::Response<super::Creative>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CreativeService/GetCreative",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CreativeService",
                        "GetCreative",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of Creative objects.
        pub async fn list_creatives(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCreativesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCreativesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CreativeService/ListCreatives",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CreativeService",
                        "ListCreatives",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Label {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLabelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLabelsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLabelsResponse {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<Label>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod label_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling Label objects.
    #[derive(Debug, Clone)]
    pub struct LabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> LabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LabelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            LabelServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a Label object.
        pub async fn get_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLabelRequest>,
        ) -> std::result::Result<tonic::Response<super::Label>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.LabelService/GetLabel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.LabelService", "GetLabel"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of Label objects.
        pub async fn list_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLabelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.LabelService/ListLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.LabelService", "ListLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
