// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElementaryStream {
#[prost(string, tag = "4")]
pub key: ::prost::alloc::string::String,
#[prost(oneof = "elementary_stream::ElementaryStream", tags = "1, 2, 3")]
pub elementary_stream: ::core::option::Option<elementary_stream::ElementaryStream>,
}
/// Nested message and enum types in `ElementaryStream`.
pub mod elementary_stream {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ElementaryStream {
#[prost(message, tag = "1")]
VideoStream(super::VideoStream),
#[prost(message, tag = "2")]
AudioStream(super::AudioStream),
#[prost(message, tag = "3")]
TextStream(super::TextStream),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuxStream {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub container: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub elementary_streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "5")]
pub segment_settings: ::core::option::Option<SegmentSettings>,
#[prost(string, tag = "6")]
pub encryption_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
#[prost(string, tag = "1")]
pub file_name: ::prost::alloc::string::String,
#[prost(enumeration = "manifest::ManifestType", tag = "2")]
pub r#type: i32,
#[prost(string, repeated, tag = "3")]
pub mux_streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int32, tag = "4")]
pub max_segment_count: i32,
#[prost(message, optional, tag = "5")]
pub segment_keep_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(bool, tag = "6")]
pub use_timecode_as_timeline: bool,
#[prost(string, tag = "7")]
pub key: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Manifest`.
pub mod manifest {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ManifestType {
Unspecified = 0,
Hls = 1,
Dash = 2,
}
impl ManifestType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ManifestType::Unspecified => "MANIFEST_TYPE_UNSPECIFIED",
ManifestType::Hls => "HLS",
ManifestType::Dash => "DASH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MANIFEST_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"HLS" => Some(Self::Hls),
"DASH" => Some(Self::Dash),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpriteSheet {
#[prost(string, tag = "1")]
pub format: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub file_prefix: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub sprite_width_pixels: i32,
#[prost(int32, tag = "4")]
pub sprite_height_pixels: i32,
#[prost(int32, tag = "5")]
pub column_count: i32,
#[prost(int32, tag = "6")]
pub row_count: i32,
#[prost(message, optional, tag = "7")]
pub interval: ::core::option::Option<::prost_types::Duration>,
#[prost(int32, tag = "8")]
pub quality: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PreprocessingConfig {
#[prost(message, optional, tag = "1")]
pub audio: ::core::option::Option<preprocessing_config::Audio>,
#[prost(message, optional, tag = "2")]
pub crop: ::core::option::Option<preprocessing_config::Crop>,
#[prost(message, optional, tag = "3")]
pub pad: ::core::option::Option<preprocessing_config::Pad>,
}
/// Nested message and enum types in `PreprocessingConfig`.
pub mod preprocessing_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Audio {
#[prost(double, tag = "1")]
pub lufs: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Crop {
#[prost(int32, tag = "1")]
pub top_pixels: i32,
#[prost(int32, tag = "2")]
pub bottom_pixels: i32,
#[prost(int32, tag = "3")]
pub left_pixels: i32,
#[prost(int32, tag = "4")]
pub right_pixels: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Pad {
#[prost(int32, tag = "1")]
pub top_pixels: i32,
#[prost(int32, tag = "2")]
pub bottom_pixels: i32,
#[prost(int32, tag = "3")]
pub left_pixels: i32,
#[prost(int32, tag = "4")]
pub right_pixels: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoStream {
#[prost(oneof = "video_stream::CodecSettings", tags = "20")]
pub codec_settings: ::core::option::Option<video_stream::CodecSettings>,
}
/// Nested message and enum types in `VideoStream`.
pub mod video_stream {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct H264CodecSettings {
#[prost(int32, tag = "1")]
pub width_pixels: i32,
#[prost(int32, tag = "2")]
pub height_pixels: i32,
#[prost(double, tag = "3")]
pub frame_rate: f64,
#[prost(int32, tag = "4")]
pub bitrate_bps: i32,
#[prost(bool, tag = "6")]
pub allow_open_gop: bool,
#[prost(int32, tag = "9")]
pub vbv_size_bits: i32,
#[prost(int32, tag = "10")]
pub vbv_fullness_bits: i32,
#[prost(string, tag = "11")]
pub entropy_coder: ::prost::alloc::string::String,
#[prost(bool, tag = "12")]
pub b_pyramid: bool,
#[prost(int32, tag = "13")]
pub b_frame_count: i32,
#[prost(double, tag = "14")]
pub aq_strength: f64,
#[prost(string, tag = "15")]
pub profile: ::prost::alloc::string::String,
#[prost(string, tag = "16")]
pub tune: ::prost::alloc::string::String,
#[prost(oneof = "h264_codec_settings::GopMode", tags = "7, 8")]
pub gop_mode: ::core::option::Option<h264_codec_settings::GopMode>,
}
/// Nested message and enum types in `H264CodecSettings`.
pub mod h264_codec_settings {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum GopMode {
#[prost(int32, tag = "7")]
GopFrameCount(i32),
#[prost(message, tag = "8")]
GopDuration(::prost_types::Duration),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum CodecSettings {
#[prost(message, tag = "20")]
H264(H264CodecSettings),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioStream {
#[prost(bool, tag = "8")]
pub transmux: bool,
#[prost(string, tag = "1")]
pub codec: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub bitrate_bps: i32,
#[prost(int32, tag = "3")]
pub channel_count: i32,
#[prost(string, repeated, tag = "4")]
pub channel_layout: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "5")]
pub mapping: ::prost::alloc::vec::Vec<audio_stream::AudioMapping>,
#[prost(int32, tag = "6")]
pub sample_rate_hertz: i32,
}
/// Nested message and enum types in `AudioStream`.
pub mod audio_stream {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioMapping {
#[prost(string, tag = "6")]
pub input_key: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub input_track: i32,
#[prost(int32, tag = "3")]
pub input_channel: i32,
#[prost(int32, tag = "4")]
pub output_channel: i32,
#[prost(double, tag = "5")]
pub gain_db: f64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextStream {
#[prost(string, tag = "1")]
pub codec: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SegmentSettings {
#[prost(message, optional, tag = "1")]
pub segment_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimecodeConfig {
#[prost(enumeration = "timecode_config::TimecodeSource", tag = "1")]
pub source: i32,
#[prost(oneof = "timecode_config::TimeOffset", tags = "2, 3")]
pub time_offset: ::core::option::Option<timecode_config::TimeOffset>,
}
/// Nested message and enum types in `TimecodeConfig`.
pub mod timecode_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimecodeSource {
Unspecified = 0,
MediaTimestamp = 1,
EmbeddedTimecode = 2,
}
impl TimecodeSource {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TimecodeSource::Unspecified => "TIMECODE_SOURCE_UNSPECIFIED",
TimecodeSource::MediaTimestamp => "MEDIA_TIMESTAMP",
TimecodeSource::EmbeddedTimecode => "EMBEDDED_TIMECODE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TIMECODE_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
"MEDIA_TIMESTAMP" => Some(Self::MediaTimestamp),
"EMBEDDED_TIMECODE" => Some(Self::EmbeddedTimecode),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TimeOffset {
#[prost(message, tag = "2")]
UtcOffset(::prost_types::Duration),
#[prost(message, tag = "3")]
TimeZone(super::super::super::super::super::r#type::TimeZone),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(map = "string, string", tag = "4")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(enumeration = "input::Type", tag = "5")]
pub r#type: i32,
#[prost(enumeration = "input::Tier", tag = "14")]
pub tier: i32,
#[prost(string, tag = "6")]
pub uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub preprocessing_config: ::core::option::Option<PreprocessingConfig>,
#[prost(message, optional, tag = "12")]
pub security_rules: ::core::option::Option<input::SecurityRule>,
#[prost(message, optional, tag = "15")]
pub input_stream_property: ::core::option::Option<InputStreamProperty>,
}
/// Nested message and enum types in `Input`.
pub mod input {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityRule {
#[prost(string, repeated, tag = "1")]
pub ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
RtmpPush = 1,
SrtPush = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::RtmpPush => "RTMP_PUSH",
Type::SrtPush => "SRT_PUSH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"RTMP_PUSH" => Some(Self::RtmpPush),
"SRT_PUSH" => Some(Self::SrtPush),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Tier {
Unspecified = 0,
Sd = 1,
Hd = 2,
Uhd = 3,
}
impl Tier {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Tier::Unspecified => "TIER_UNSPECIFIED",
Tier::Sd => "SD",
Tier::Hd => "HD",
Tier::Uhd => "UHD",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TIER_UNSPECIFIED" => Some(Self::Unspecified),
"SD" => Some(Self::Sd),
"HD" => Some(Self::Hd),
"UHD" => Some(Self::Uhd),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Channel {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(map = "string, string", tag = "4")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, repeated, tag = "16")]
pub input_attachments: ::prost::alloc::vec::Vec<InputAttachment>,
#[prost(string, tag = "6")]
pub active_input: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub output: ::core::option::Option<channel::Output>,
#[prost(message, repeated, tag = "10")]
pub elementary_streams: ::prost::alloc::vec::Vec<ElementaryStream>,
#[prost(message, repeated, tag = "11")]
pub mux_streams: ::prost::alloc::vec::Vec<MuxStream>,
#[prost(message, repeated, tag = "12")]
pub manifests: ::prost::alloc::vec::Vec<Manifest>,
#[prost(message, repeated, tag = "13")]
pub sprite_sheets: ::prost::alloc::vec::Vec<SpriteSheet>,
#[prost(enumeration = "channel::StreamingState", tag = "14")]
pub streaming_state: i32,
#[prost(message, optional, tag = "18")]
pub streaming_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, optional, tag = "19")]
pub log_config: ::core::option::Option<LogConfig>,
#[prost(message, optional, tag = "21")]
pub timecode_config: ::core::option::Option<TimecodeConfig>,
#[prost(message, repeated, tag = "24")]
pub encryptions: ::prost::alloc::vec::Vec<Encryption>,
#[prost(message, optional, tag = "25")]
pub input_config: ::core::option::Option<InputConfig>,
#[prost(message, optional, tag = "26")]
pub retention_config: ::core::option::Option<RetentionConfig>,
#[prost(message, repeated, tag = "27")]
pub static_overlays: ::prost::alloc::vec::Vec<StaticOverlay>,
}
/// Nested message and enum types in `Channel`.
pub mod channel {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamingState {
Unspecified = 0,
Streaming = 1,
AwaitingInput = 2,
StreamingError = 4,
StreamingNoInput = 5,
Stopped = 6,
Starting = 7,
Stopping = 8,
}
impl StreamingState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
StreamingState::Unspecified => "STREAMING_STATE_UNSPECIFIED",
StreamingState::Streaming => "STREAMING",
StreamingState::AwaitingInput => "AWAITING_INPUT",
StreamingState::StreamingError => "STREAMING_ERROR",
StreamingState::StreamingNoInput => "STREAMING_NO_INPUT",
StreamingState::Stopped => "STOPPED",
StreamingState::Starting => "STARTING",
StreamingState::Stopping => "STOPPING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STREAMING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"STREAMING" => Some(Self::Streaming),
"AWAITING_INPUT" => Some(Self::AwaitingInput),
"STREAMING_ERROR" => Some(Self::StreamingError),
"STREAMING_NO_INPUT" => Some(Self::StreamingNoInput),
"STOPPED" => Some(Self::Stopped),
"STARTING" => Some(Self::Starting),
"STOPPING" => Some(Self::Stopping),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedCoordinate {
#[prost(double, tag = "1")]
pub x: f64,
#[prost(double, tag = "2")]
pub y: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedResolution {
#[prost(double, tag = "1")]
pub w: f64,
#[prost(double, tag = "2")]
pub h: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticOverlay {
#[prost(string, tag = "1")]
pub asset: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub resolution: ::core::option::Option<NormalizedResolution>,
#[prost(message, optional, tag = "3")]
pub position: ::core::option::Option<NormalizedCoordinate>,
#[prost(double, tag = "4")]
pub opacity: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InputConfig {
#[prost(enumeration = "input_config::InputSwitchMode", tag = "1")]
pub input_switch_mode: i32,
}
/// Nested message and enum types in `InputConfig`.
pub mod input_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InputSwitchMode {
Unspecified = 0,
FailoverPreferPrimary = 1,
Manual = 3,
}
impl InputSwitchMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
InputSwitchMode::Unspecified => "INPUT_SWITCH_MODE_UNSPECIFIED",
InputSwitchMode::FailoverPreferPrimary => "FAILOVER_PREFER_PRIMARY",
InputSwitchMode::Manual => "MANUAL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INPUT_SWITCH_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"FAILOVER_PREFER_PRIMARY" => Some(Self::FailoverPreferPrimary),
"MANUAL" => Some(Self::Manual),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LogConfig {
#[prost(enumeration = "log_config::LogSeverity", tag = "1")]
pub log_severity: i32,
}
/// Nested message and enum types in `LogConfig`.
pub mod log_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogSeverity {
Unspecified = 0,
Off = 1,
Debug = 100,
Info = 200,
Warning = 400,
Error = 500,
}
impl LogSeverity {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LogSeverity::Unspecified => "LOG_SEVERITY_UNSPECIFIED",
LogSeverity::Off => "OFF",
LogSeverity::Debug => "DEBUG",
LogSeverity::Info => "INFO",
LogSeverity::Warning => "WARNING",
LogSeverity::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOG_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
"OFF" => Some(Self::Off),
"DEBUG" => Some(Self::Debug),
"INFO" => Some(Self::Info),
"WARNING" => Some(Self::Warning),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetentionConfig {
#[prost(message, optional, tag = "1")]
pub retention_window_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputStreamProperty {
#[prost(message, optional, tag = "1")]
pub last_establish_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, repeated, tag = "2")]
pub video_streams: ::prost::alloc::vec::Vec<VideoStreamProperty>,
#[prost(message, repeated, tag = "3")]
pub audio_streams: ::prost::alloc::vec::Vec<AudioStreamProperty>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoStreamProperty {
#[prost(int32, tag = "1")]
pub index: i32,
#[prost(message, optional, tag = "2")]
pub video_format: ::core::option::Option<VideoFormat>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoFormat {
#[prost(string, tag = "1")]
pub codec: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub width_pixels: i32,
#[prost(int32, tag = "3")]
pub height_pixels: i32,
#[prost(double, tag = "4")]
pub frame_rate: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioStreamProperty {
#[prost(int32, tag = "1")]
pub index: i32,
#[prost(message, optional, tag = "2")]
pub audio_format: ::core::option::Option<AudioFormat>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioFormat {
#[prost(string, tag = "1")]
pub codec: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub channel_count: i32,
#[prost(string, repeated, tag = "3")]
pub channel_layout: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputAttachment {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub input: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub automatic_failover: ::core::option::Option<input_attachment::AutomaticFailover>,
}
/// Nested message and enum types in `InputAttachment`.
pub mod input_attachment {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomaticFailover {
#[prost(string, repeated, tag = "1")]
pub input_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(map = "string, string", tag = "4")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(bool, tag = "9")]
pub execute_now: bool,
#[prost(message, optional, tag = "10")]
pub execution_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "event::State", tag = "11")]
pub state: i32,
#[prost(message, optional, tag = "12")]
pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(oneof = "event::Task", tags = "5, 6, 13, 14, 15, 16")]
pub task: ::core::option::Option<event::Task>,
}
/// Nested message and enum types in `Event`.
pub mod event {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputSwitchTask {
#[prost(string, tag = "1")]
pub input_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdBreakTask {
#[prost(message, optional, tag = "1")]
pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlateTask {
#[prost(message, optional, tag = "1")]
pub duration: ::core::option::Option<::prost_types::Duration>,
#[prost(string, tag = "2")]
pub asset: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReturnToProgramTask {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuteTask {
#[prost(message, optional, tag = "1")]
pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnmuteTask {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Scheduled = 1,
Running = 2,
Succeeded = 3,
Failed = 4,
Pending = 5,
Stopped = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Scheduled => "SCHEDULED",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Pending => "PENDING",
State::Stopped => "STOPPED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"SCHEDULED" => Some(Self::Scheduled),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"PENDING" => Some(Self::Pending),
"STOPPED" => Some(Self::Stopped),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Task {
#[prost(message, tag = "5")]
InputSwitch(InputSwitchTask),
#[prost(message, tag = "6")]
AdBreak(AdBreakTask),
#[prost(message, tag = "13")]
ReturnToProgram(ReturnToProgramTask),
#[prost(message, tag = "14")]
Slate(SlateTask),
#[prost(message, tag = "15")]
Mute(MuteTask),
#[prost(message, tag = "16")]
Unmute(UnmuteTask),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Clip {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(map = "string, string", tag = "5")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(enumeration = "clip::State", tag = "6")]
pub state: i32,
#[prost(string, tag = "7")]
pub output_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "10")]
pub slices: ::prost::alloc::vec::Vec<clip::Slice>,
#[prost(message, repeated, tag = "12")]
pub clip_manifests: ::prost::alloc::vec::Vec<clip::ClipManifest>,
}
/// Nested message and enum types in `Clip`.
pub mod clip {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeSlice {
#[prost(message, optional, tag = "1")]
pub markin_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub markout_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Slice {
#[prost(oneof = "slice::Kind", tags = "1")]
pub kind: ::core::option::Option<slice::Kind>,
}
/// Nested message and enum types in `Slice`.
pub mod slice {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(message, tag = "1")]
TimeSlice(super::TimeSlice),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClipManifest {
#[prost(string, tag = "1")]
pub manifest_key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub output_uri: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Creating = 2,
Succeeded = 3,
Failed = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Creating => "CREATING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"CREATING" => Some(Self::Creating),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(map = "string, string", tag = "4")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub crc32c: ::prost::alloc::string::String,
#[prost(enumeration = "asset::State", tag = "8")]
pub state: i32,
#[prost(message, optional, tag = "9")]
pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(oneof = "asset::Resource", tags = "5, 6")]
pub resource: ::core::option::Option<asset::Resource>,
}
/// Nested message and enum types in `Asset`.
pub mod asset {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoAsset {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageAsset {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Active = 2,
Deleting = 3,
Error = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Active => "ACTIVE",
State::Deleting => "DELETING",
State::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"ACTIVE" => Some(Self::Active),
"DELETING" => Some(Self::Deleting),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Resource {
#[prost(message, tag = "5")]
Video(VideoAsset),
#[prost(message, tag = "6")]
Image(ImageAsset),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Encryption {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub drm_systems: ::core::option::Option<encryption::DrmSystems>,
#[prost(oneof = "encryption::SecretSource", tags = "7")]
pub secret_source: ::core::option::Option<encryption::SecretSource>,
#[prost(oneof = "encryption::EncryptionMode", tags = "4, 5, 6")]
pub encryption_mode: ::core::option::Option<encryption::EncryptionMode>,
}
/// Nested message and enum types in `Encryption`.
pub mod encryption {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretManagerSource {
#[prost(string, tag = "1")]
pub secret_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Widevine {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Fairplay {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Playready {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Clearkey {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DrmSystems {
#[prost(message, optional, tag = "1")]
pub widevine: ::core::option::Option<Widevine>,
#[prost(message, optional, tag = "2")]
pub fairplay: ::core::option::Option<Fairplay>,
#[prost(message, optional, tag = "3")]
pub playready: ::core::option::Option<Playready>,
#[prost(message, optional, tag = "4")]
pub clearkey: ::core::option::Option<Clearkey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Aes128Encryption {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SampleAesEncryption {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MpegCommonEncryption {
#[prost(string, tag = "1")]
pub scheme: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum SecretSource {
#[prost(message, tag = "7")]
SecretManagerKeySource(SecretManagerSource),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EncryptionMode {
#[prost(message, tag = "4")]
Aes128(Aes128Encryption),
#[prost(message, tag = "5")]
SampleAes(SampleAesEncryption),
#[prost(message, tag = "6")]
MpegCenc(MpegCommonEncryption),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pool {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(map = "string, string", tag = "4")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "5")]
pub network_config: ::core::option::Option<pool::NetworkConfig>,
}
/// Nested message and enum types in `Pool`.
pub mod pool {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
#[prost(string, tag = "1")]
pub peered_network: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssetRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub asset: ::core::option::Option<Asset>,
#[prost(string, tag = "3")]
pub asset_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAssetRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsResponse {
#[prost(message, repeated, tag = "1")]
pub assets: ::prost::alloc::vec::Vec<Asset>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChannelRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub channel: ::core::option::Option<Channel>,
#[prost(string, tag = "3")]
pub channel_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelsResponse {
#[prost(message, repeated, tag = "1")]
pub channels: ::prost::alloc::vec::Vec<Channel>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChannelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteChannelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateChannelRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub channel: ::core::option::Option<Channel>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChannelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopChannelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInputRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub input: ::core::option::Option<Input>,
#[prost(string, tag = "3")]
pub input_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInputsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInputsResponse {
#[prost(message, repeated, tag = "1")]
pub inputs: ::prost::alloc::vec::Vec<Input>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInputRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInputRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInputRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub input: ::core::option::Option<Input>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEventRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub event: ::core::option::Option<Event>,
#[prost(string, tag = "3")]
pub event_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventsResponse {
#[prost(message, repeated, tag = "1")]
pub events: ::prost::alloc::vec::Vec<Event>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEventRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelOperationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClipsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClipsResponse {
#[prost(message, repeated, tag = "1")]
pub clips: ::prost::alloc::vec::Vec<Clip>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClipRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClipRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub clip_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub clip: ::core::option::Option<Clip>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteClipRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "3")]
pub target: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub verb: ::prost::alloc::string::String,
#[prost(bool, tag = "5")]
pub requested_cancellation: bool,
#[prost(string, tag = "6")]
pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePoolRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub pool: ::core::option::Option<Pool>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod livestream_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Using Live Stream API, you can generate live streams in the various
/// renditions and streaming formats. The streaming format include HTTP Live
/// Streaming (HLS) and Dynamic Adaptive Streaming over HTTP (DASH). You can send
/// a source stream in the various ways, including Real-Time Messaging
/// Protocol (RTMP) and Secure Reliable Transport (SRT).
#[derive(Debug, Clone)]
pub struct LivestreamServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> LivestreamServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> LivestreamServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
LivestreamServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a channel with the provided unique ID in the specified
/// region.
pub async fn create_channel(&mut self, request: impl tonic::IntoRequest<super::CreateChannelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/CreateChannel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "CreateChannel"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all channels in the specified region.
pub async fn list_channels(&mut self, request: impl tonic::IntoRequest<super::ListChannelsRequest>) -> std::result::Result<tonic::Response<super::ListChannelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/ListChannels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "ListChannels"));
self.inner.unary(req, path, codec).await
}
/// Returns the specified channel.
pub async fn get_channel(&mut self, request: impl tonic::IntoRequest<super::GetChannelRequest>) -> std::result::Result<tonic::Response<super::Channel>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/GetChannel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "GetChannel"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified channel.
pub async fn delete_channel(&mut self, request: impl tonic::IntoRequest<super::DeleteChannelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/DeleteChannel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "DeleteChannel"));
self.inner.unary(req, path, codec).await
}
/// Updates the specified channel.
pub async fn update_channel(&mut self, request: impl tonic::IntoRequest<super::UpdateChannelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/UpdateChannel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "UpdateChannel"));
self.inner.unary(req, path, codec).await
}
/// Starts the specified channel. Part of the video pipeline will be created
/// only when the StartChannel request is received by the server.
pub async fn start_channel(&mut self, request: impl tonic::IntoRequest<super::StartChannelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/StartChannel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "StartChannel"));
self.inner.unary(req, path, codec).await
}
/// Stops the specified channel. Part of the video pipeline will be released
/// when the StopChannel request is received by the server.
pub async fn stop_channel(&mut self, request: impl tonic::IntoRequest<super::StopChannelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/StopChannel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "StopChannel"));
self.inner.unary(req, path, codec).await
}
/// Creates an input with the provided unique ID in the specified region.
pub async fn create_input(&mut self, request: impl tonic::IntoRequest<super::CreateInputRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/CreateInput");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "CreateInput"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all inputs in the specified region.
pub async fn list_inputs(&mut self, request: impl tonic::IntoRequest<super::ListInputsRequest>) -> std::result::Result<tonic::Response<super::ListInputsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/ListInputs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "ListInputs"));
self.inner.unary(req, path, codec).await
}
/// Returns the specified input.
pub async fn get_input(&mut self, request: impl tonic::IntoRequest<super::GetInputRequest>) -> std::result::Result<tonic::Response<super::Input>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/GetInput");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "GetInput"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified input.
pub async fn delete_input(&mut self, request: impl tonic::IntoRequest<super::DeleteInputRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/DeleteInput");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "DeleteInput"));
self.inner.unary(req, path, codec).await
}
/// Updates the specified input.
pub async fn update_input(&mut self, request: impl tonic::IntoRequest<super::UpdateInputRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/UpdateInput");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "UpdateInput"));
self.inner.unary(req, path, codec).await
}
/// Creates an event with the provided unique ID in the specified channel.
pub async fn create_event(&mut self, request: impl tonic::IntoRequest<super::CreateEventRequest>) -> std::result::Result<tonic::Response<super::Event>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/CreateEvent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "CreateEvent"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all events in the specified channel.
pub async fn list_events(&mut self, request: impl tonic::IntoRequest<super::ListEventsRequest>) -> std::result::Result<tonic::Response<super::ListEventsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/ListEvents");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "ListEvents"));
self.inner.unary(req, path, codec).await
}
/// Returns the specified event.
pub async fn get_event(&mut self, request: impl tonic::IntoRequest<super::GetEventRequest>) -> std::result::Result<tonic::Response<super::Event>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/GetEvent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "GetEvent"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified event.
pub async fn delete_event(&mut self, request: impl tonic::IntoRequest<super::DeleteEventRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/DeleteEvent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "DeleteEvent"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all clips in the specified channel.
pub async fn list_clips(&mut self, request: impl tonic::IntoRequest<super::ListClipsRequest>) -> std::result::Result<tonic::Response<super::ListClipsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/ListClips");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "ListClips"));
self.inner.unary(req, path, codec).await
}
/// Returns the specified clip.
pub async fn get_clip(&mut self, request: impl tonic::IntoRequest<super::GetClipRequest>) -> std::result::Result<tonic::Response<super::Clip>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/GetClip");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "GetClip"));
self.inner.unary(req, path, codec).await
}
/// Creates a clip with the provided clip ID in the specified channel.
pub async fn create_clip(&mut self, request: impl tonic::IntoRequest<super::CreateClipRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/CreateClip");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "CreateClip"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified clip job resource. This method only deletes the clip
/// job and does not delete the VOD clip stored in the GCS.
pub async fn delete_clip(&mut self, request: impl tonic::IntoRequest<super::DeleteClipRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/DeleteClip");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "DeleteClip"));
self.inner.unary(req, path, codec).await
}
/// Creates a Asset with the provided unique ID in the specified
/// region.
pub async fn create_asset(&mut self, request: impl tonic::IntoRequest<super::CreateAssetRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/CreateAsset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "CreateAsset"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified asset if it is not used.
pub async fn delete_asset(&mut self, request: impl tonic::IntoRequest<super::DeleteAssetRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/DeleteAsset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "DeleteAsset"));
self.inner.unary(req, path, codec).await
}
/// Returns the specified asset.
pub async fn get_asset(&mut self, request: impl tonic::IntoRequest<super::GetAssetRequest>) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/GetAsset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "GetAsset"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all assets in the specified region.
pub async fn list_assets(&mut self, request: impl tonic::IntoRequest<super::ListAssetsRequest>) -> std::result::Result<tonic::Response<super::ListAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/ListAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "ListAssets"));
self.inner.unary(req, path, codec).await
}
/// Returns the specified pool.
pub async fn get_pool(&mut self, request: impl tonic::IntoRequest<super::GetPoolRequest>) -> std::result::Result<tonic::Response<super::Pool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/GetPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "GetPool"));
self.inner.unary(req, path, codec).await
}
/// Updates the specified pool.
pub async fn update_pool(&mut self, request: impl tonic::IntoRequest<super::UpdatePoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.video.livestream.v1.LivestreamService/UpdatePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.video.livestream.v1.LivestreamService", "UpdatePool"));
self.inner.unary(req, path, codec).await
}
}
}
