// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigqueryMapping {
    #[prost(string, tag = "1")]
    pub timestamp_column: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id_column: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub dimension_column: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSource {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub bq_mapping: ::core::option::Option<BigqueryMapping>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub data_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub data_sources: ::prost::alloc::vec::Vec<DataSource>,
    #[prost(enumeration = "data_set::State", tag = "4")]
    pub state: i32,
    #[prost(message, optional, tag = "5")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "6")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `DataSet`.
pub mod data_set {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Loading = 3,
        Loaded = 4,
        Unloading = 5,
        Unloaded = 6,
        Failed = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Unknown => "UNKNOWN",
                State::Pending => "PENDING",
                State::Loading => "LOADING",
                State::Loaded => "LOADED",
                State::Unloading => "UNLOADING",
                State::Unloaded => "UNLOADED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "LOADING" => Some(Self::Loading),
                "LOADED" => Some(Self::Loaded),
                "UNLOADING" => Some(Self::Unloading),
                "UNLOADED" => Some(Self::Unloaded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventDimension {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "event_dimension::Value", tags = "2, 3, 4, 5")]
    pub value: ::core::option::Option<event_dimension::Value>,
}
/// Nested message and enum types in `EventDimension`.
pub mod event_dimension {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "2")]
        StringVal(::prost::alloc::string::String),
        #[prost(int64, tag = "3")]
        LongVal(i64),
        #[prost(bool, tag = "4")]
        BoolVal(bool),
        #[prost(double, tag = "5")]
        DoubleVal(f64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, repeated, tag = "1")]
    pub dimensions: ::prost::alloc::vec::Vec<EventDimension>,
    #[prost(int64, tag = "2")]
    pub group_id: i64,
    #[prost(message, optional, tag = "3")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEventsRequest {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    #[prost(string, tag = "2")]
    pub dataset: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub dropped_events: ::prost::alloc::vec::Vec<Event>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataSetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub dataset: ::core::option::Option<DataSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub datasets: ::prost::alloc::vec::Vec<DataSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PinnedDimension {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "pinned_dimension::Value", tags = "2, 3")]
    pub value: ::core::option::Option<pinned_dimension::Value>,
}
/// Nested message and enum types in `PinnedDimension`.
pub mod pinned_dimension {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "2")]
        StringVal(::prost::alloc::string::String),
        #[prost(bool, tag = "3")]
        BoolVal(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForecastParams {
    #[prost(double, optional, tag = "12")]
    pub noise_threshold: ::core::option::Option<f64>,
    #[prost(enumeration = "forecast_params::Period", tag = "10")]
    pub seasonality_hint: i32,
    #[prost(message, optional, tag = "13")]
    pub horizon_duration: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `ForecastParams`.
pub mod forecast_params {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Period {
        Unspecified = 0,
        Hourly = 5,
        Daily = 1,
        Weekly = 2,
        Monthly = 3,
        Yearly = 4,
    }
    impl Period {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Period::Unspecified => "PERIOD_UNSPECIFIED",
                Period::Hourly => "HOURLY",
                Period::Daily => "DAILY",
                Period::Weekly => "WEEKLY",
                Period::Monthly => "MONTHLY",
                Period::Yearly => "YEARLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERIOD_UNSPECIFIED" => Some(Self::Unspecified),
                "HOURLY" => Some(Self::Hourly),
                "DAILY" => Some(Self::Daily),
                "WEEKLY" => Some(Self::Weekly),
                "MONTHLY" => Some(Self::Monthly),
                "YEARLY" => Some(Self::Yearly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeseriesPoint {
    #[prost(message, optional, tag = "1")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(double, optional, tag = "2")]
    pub value: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Timeseries {
    #[prost(message, repeated, tag = "1")]
    pub point: ::prost::alloc::vec::Vec<TimeseriesPoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluatedSlice {
    #[prost(message, repeated, tag = "1")]
    pub dimensions: ::prost::alloc::vec::Vec<PinnedDimension>,
    #[prost(double, optional, tag = "11")]
    pub detection_point_actual: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "12")]
    pub detection_point_forecast: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "16")]
    pub expected_deviation: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "17")]
    pub anomaly_score: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "5")]
    pub history: ::core::option::Option<Timeseries>,
    #[prost(message, optional, tag = "10")]
    pub forecast: ::core::option::Option<Timeseries>,
    #[prost(message, optional, tag = "18")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlicingParams {
    #[prost(string, repeated, tag = "1")]
    pub dimension_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub pinned_dimensions: ::prost::alloc::vec::Vec<PinnedDimension>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeseriesParams {
    #[prost(message, optional, tag = "1")]
    pub forecast_history: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub granularity: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, optional, tag = "4")]
    pub metric: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "timeseries_params::AggregationMethod", tag = "5")]
    pub metric_aggregation_method: i32,
}
/// Nested message and enum types in `TimeseriesParams`.
pub mod timeseries_params {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AggregationMethod {
        Unspecified = 0,
        Sum = 1,
        Average = 2,
    }
    impl AggregationMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AggregationMethod::Unspecified => "AGGREGATION_METHOD_UNSPECIFIED",
                AggregationMethod::Sum => "SUM",
                AggregationMethod::Average => "AVERAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AGGREGATION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "SUM" => Some(Self::Sum),
                "AVERAGE" => Some(Self::Average),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDataSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub detection_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, optional, tag = "13")]
    pub num_returned_slices: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub slicing_params: ::core::option::Option<SlicingParams>,
    #[prost(message, optional, tag = "10")]
    pub timeseries_params: ::core::option::Option<TimeseriesParams>,
    #[prost(message, optional, tag = "5")]
    pub forecast_params: ::core::option::Option<ForecastParams>,
    #[prost(bool, tag = "8")]
    pub return_timeseries: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDataSetResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub slices: ::prost::alloc::vec::Vec<EvaluatedSlice>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluateSliceRequest {
    #[prost(string, tag = "1")]
    pub dataset: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub pinned_dimensions: ::prost::alloc::vec::Vec<PinnedDimension>,
    #[prost(message, optional, tag = "3")]
    pub detection_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub timeseries_params: ::core::option::Option<TimeseriesParams>,
    #[prost(message, optional, tag = "5")]
    pub forecast_params: ::core::option::Option<ForecastParams>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluateTimeseriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub timeseries: ::core::option::Option<Timeseries>,
    #[prost(message, optional, tag = "3")]
    pub granularity: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub forecast_params: ::core::option::Option<ForecastParams>,
}
/// Generated client implementations.
pub mod timeseries_insights_controller_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct TimeseriesInsightsControllerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TimeseriesInsightsControllerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TimeseriesInsightsControllerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            TimeseriesInsightsControllerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists [DataSets][google.cloud.timeseriesinsights.v1.DataSet] under the project.
        ///
        /// The order of the results is unspecified but deterministic. Newly created
        /// [DataSets][google.cloud.timeseriesinsights.v1.DataSet] will not necessarily be added to the end
        /// of this list.
        pub async fn list_data_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataSetsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListDataSetsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.timeseriesinsights.v1.TimeseriesInsightsController/ListDataSets",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.timeseriesinsights.v1.TimeseriesInsightsController",
                "ListDataSets",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Create a [DataSet][google.cloud.timeseriesinsights.v1.DataSet] from data stored on Cloud
        /// Storage.
        ///
        /// The data must stay immutable while we process the
        /// [DataSet][google.cloud.timeseriesinsights.v1.DataSet] creation; otherwise, undefined outcomes
        /// might result.  For more information, see [DataSet][google.cloud.timeseriesinsights.v1.DataSet].
        pub async fn create_data_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataSetRequest>,
        ) -> std::result::Result<tonic::Response<super::DataSet>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.timeseriesinsights.v1.TimeseriesInsightsController/CreateDataSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.timeseriesinsights.v1.TimeseriesInsightsController",
                "CreateDataSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a [DataSet][google.cloud.timeseriesinsights.v1.DataSet] from the system.
        ///
        /// **NOTE**: If the [DataSet][google.cloud.timeseriesinsights.v1.DataSet] is still being
        /// processed, it will be aborted and deleted.
        pub async fn delete_data_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.timeseriesinsights.v1.TimeseriesInsightsController/DeleteDataSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.timeseriesinsights.v1.TimeseriesInsightsController",
                "DeleteDataSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Append events to a `LOADED` [DataSet][google.cloud.timeseriesinsights.v1.DataSet].
        pub async fn append_events(
            &mut self,
            request: impl tonic::IntoRequest<super::AppendEventsRequest>,
        ) -> std::result::Result<tonic::Response<super::AppendEventsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.timeseriesinsights.v1.TimeseriesInsightsController/AppendEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.timeseriesinsights.v1.TimeseriesInsightsController",
                "AppendEvents",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Execute a Timeseries Insights query over a loaded
        /// [DataSet][google.cloud.timeseriesinsights.v1.DataSet].
        pub async fn query_data_set(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryDataSetRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryDataSetResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.timeseriesinsights.v1.TimeseriesInsightsController/QueryDataSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.timeseriesinsights.v1.TimeseriesInsightsController",
                "QueryDataSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Evaluate an explicit slice from a loaded [DataSet][google.cloud.timeseriesinsights.v1.DataSet].
        pub async fn evaluate_slice(
            &mut self,
            request: impl tonic::IntoRequest<super::EvaluateSliceRequest>,
        ) -> std::result::Result<tonic::Response<super::EvaluatedSlice>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.timeseriesinsights.v1.TimeseriesInsightsController/EvaluateSlice",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.timeseriesinsights.v1.TimeseriesInsightsController",
                "EvaluateSlice",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Evaluate an explicit timeseries.
        pub async fn evaluate_timeseries(
            &mut self,
            request: impl tonic::IntoRequest<super::EvaluateTimeseriesRequest>,
        ) -> std::result::Result<tonic::Response<super::EvaluatedSlice>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.timeseriesinsights.v1.TimeseriesInsightsController/EvaluateTimeseries");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.timeseriesinsights.v1.TimeseriesInsightsController",
                "EvaluateTimeseries",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
