// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Barcode {
#[prost(string, tag = "1")]
pub format: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub value_format: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub raw_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vertex {
#[prost(int32, tag = "1")]
pub x: i32,
#[prost(int32, tag = "2")]
pub y: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedVertex {
#[prost(float, tag = "1")]
pub x: f32,
#[prost(float, tag = "2")]
pub y: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoundingPoly {
#[prost(message, repeated, tag = "1")]
pub vertices: ::prost::alloc::vec::Vec<Vertex>,
#[prost(message, repeated, tag = "2")]
pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
#[prost(string, tag = "3")]
pub mime_type: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub text: ::prost::alloc::string::String,
#[deprecated]
#[prost(message, repeated, tag = "5")]
pub text_styles: ::prost::alloc::vec::Vec<document::Style>,
#[prost(message, repeated, tag = "6")]
pub pages: ::prost::alloc::vec::Vec<document::Page>,
#[prost(message, repeated, tag = "7")]
pub entities: ::prost::alloc::vec::Vec<document::Entity>,
#[prost(message, repeated, tag = "8")]
pub entity_relations: ::prost::alloc::vec::Vec<document::EntityRelation>,
#[prost(message, repeated, tag = "14")]
pub text_changes: ::prost::alloc::vec::Vec<document::TextChange>,
#[prost(message, optional, tag = "9")]
pub shard_info: ::core::option::Option<document::ShardInfo>,
#[prost(message, repeated, tag = "11")]
pub labels: ::prost::alloc::vec::Vec<document::Label>,
#[prost(message, optional, tag = "10")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "13")]
pub revisions: ::prost::alloc::vec::Vec<document::Revision>,
#[prost(oneof = "document::Source", tags = "1, 2")]
pub source: ::core::option::Option<document::Source>,
}
/// Nested message and enum types in `Document`.
pub mod document {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShardInfo {
#[prost(int64, tag = "1")]
pub shard_index: i64,
#[prost(int64, tag = "2")]
pub shard_count: i64,
#[prost(int64, tag = "3")]
pub text_offset: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Label {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(float, tag = "3")]
pub confidence: f32,
#[prost(oneof = "label::Source", tags = "2")]
pub source: ::core::option::Option<label::Source>,
}
/// Nested message and enum types in `Label`.
pub mod label {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(string, tag = "2")]
AutomlModel(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Style {
#[prost(message, optional, tag = "1")]
pub text_anchor: ::core::option::Option<TextAnchor>,
#[prost(message, optional, tag = "2")]
pub color: ::core::option::Option<super::super::super::super::r#type::Color>,
#[prost(message, optional, tag = "3")]
pub background_color: ::core::option::Option<super::super::super::super::r#type::Color>,
#[prost(string, tag = "4")]
pub font_weight: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub text_style: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub text_decoration: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub font_size: ::core::option::Option<style::FontSize>,
#[prost(string, tag = "8")]
pub font_family: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Style`.
pub mod style {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FontSize {
#[prost(float, tag = "1")]
pub size: f32,
#[prost(string, tag = "2")]
pub unit: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Page {
#[prost(int32, tag = "1")]
pub page_number: i32,
#[prost(message, optional, tag = "13")]
pub image: ::core::option::Option<page::Image>,
#[prost(message, repeated, tag = "14")]
pub transforms: ::prost::alloc::vec::Vec<page::Matrix>,
#[prost(message, optional, tag = "2")]
pub dimension: ::core::option::Option<page::Dimension>,
#[prost(message, optional, tag = "3")]
pub layout: ::core::option::Option<page::Layout>,
#[prost(message, repeated, tag = "4")]
pub detected_languages: ::prost::alloc::vec::Vec<page::DetectedLanguage>,
#[prost(message, repeated, tag = "5")]
pub blocks: ::prost::alloc::vec::Vec<page::Block>,
#[prost(message, repeated, tag = "6")]
pub paragraphs: ::prost::alloc::vec::Vec<page::Paragraph>,
#[prost(message, repeated, tag = "7")]
pub lines: ::prost::alloc::vec::Vec<page::Line>,
#[prost(message, repeated, tag = "8")]
pub tokens: ::prost::alloc::vec::Vec<page::Token>,
#[prost(message, repeated, tag = "9")]
pub visual_elements: ::prost::alloc::vec::Vec<page::VisualElement>,
#[prost(message, repeated, tag = "10")]
pub tables: ::prost::alloc::vec::Vec<page::Table>,
#[prost(message, repeated, tag = "11")]
pub form_fields: ::prost::alloc::vec::Vec<page::FormField>,
#[prost(message, repeated, tag = "12")]
pub symbols: ::prost::alloc::vec::Vec<page::Symbol>,
#[prost(message, repeated, tag = "15")]
pub detected_barcodes: ::prost::alloc::vec::Vec<page::DetectedBarcode>,
#[prost(message, optional, tag = "17")]
pub image_quality_scores: ::core::option::Option<page::ImageQualityScores>,
#[deprecated]
#[prost(message, optional, tag = "16")]
pub provenance: ::core::option::Option<Provenance>,
}
/// Nested message and enum types in `Page`.
pub mod page {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dimension {
#[prost(float, tag = "1")]
pub width: f32,
#[prost(float, tag = "2")]
pub height: f32,
#[prost(string, tag = "3")]
pub unit: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
#[prost(bytes = "vec", tag = "1")]
pub content: ::prost::alloc::vec::Vec<u8>,
#[prost(string, tag = "2")]
pub mime_type: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub width: i32,
#[prost(int32, tag = "4")]
pub height: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Matrix {
#[prost(int32, tag = "1")]
pub rows: i32,
#[prost(int32, tag = "2")]
pub cols: i32,
#[prost(int32, tag = "3")]
pub r#type: i32,
#[prost(bytes = "vec", tag = "4")]
pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Layout {
#[prost(message, optional, tag = "1")]
pub text_anchor: ::core::option::Option<super::TextAnchor>,
#[prost(float, tag = "2")]
pub confidence: f32,
#[prost(message, optional, tag = "3")]
pub bounding_poly: ::core::option::Option<super::super::BoundingPoly>,
#[prost(enumeration = "layout::Orientation", tag = "4")]
pub orientation: i32,
}
/// Nested message and enum types in `Layout`.
pub mod layout {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Orientation {
Unspecified = 0,
PageUp = 1,
PageRight = 2,
PageDown = 3,
PageLeft = 4,
}
impl Orientation {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Orientation::Unspecified => "ORIENTATION_UNSPECIFIED",
Orientation::PageUp => "PAGE_UP",
Orientation::PageRight => "PAGE_RIGHT",
Orientation::PageDown => "PAGE_DOWN",
Orientation::PageLeft => "PAGE_LEFT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ORIENTATION_UNSPECIFIED" => Some(Self::Unspecified),
"PAGE_UP" => Some(Self::PageUp),
"PAGE_RIGHT" => Some(Self::PageRight),
"PAGE_DOWN" => Some(Self::PageDown),
"PAGE_LEFT" => Some(Self::PageLeft),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(message, repeated, tag = "2")]
pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
#[deprecated]
#[prost(message, optional, tag = "3")]
pub provenance: ::core::option::Option<super::Provenance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Paragraph {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(message, repeated, tag = "2")]
pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
#[deprecated]
#[prost(message, optional, tag = "3")]
pub provenance: ::core::option::Option<super::Provenance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Line {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(message, repeated, tag = "2")]
pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
#[deprecated]
#[prost(message, optional, tag = "3")]
pub provenance: ::core::option::Option<super::Provenance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Token {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(message, optional, tag = "2")]
pub detected_break: ::core::option::Option<token::DetectedBreak>,
#[prost(message, repeated, tag = "3")]
pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
#[deprecated]
#[prost(message, optional, tag = "4")]
pub provenance: ::core::option::Option<super::Provenance>,
#[prost(message, optional, tag = "5")]
pub style_info: ::core::option::Option<token::StyleInfo>,
}
/// Nested message and enum types in `Token`.
pub mod token {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DetectedBreak {
#[prost(enumeration = "detected_break::Type", tag = "1")]
pub r#type: i32,
}
/// Nested message and enum types in `DetectedBreak`.
pub mod detected_break {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Space = 1,
WideSpace = 2,
Hyphen = 3,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Space => "SPACE",
Type::WideSpace => "WIDE_SPACE",
Type::Hyphen => "HYPHEN",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"SPACE" => Some(Self::Space),
"WIDE_SPACE" => Some(Self::WideSpace),
"HYPHEN" => Some(Self::Hyphen),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StyleInfo {
#[prost(int32, tag = "1")]
pub font_size: i32,
#[prost(double, tag = "2")]
pub pixel_font_size: f64,
#[prost(double, tag = "3")]
pub letter_spacing: f64,
#[prost(string, tag = "4")]
pub font_type: ::prost::alloc::string::String,
#[prost(bool, tag = "5")]
pub bold: bool,
#[prost(bool, tag = "6")]
pub italic: bool,
#[prost(bool, tag = "7")]
pub underlined: bool,
#[prost(bool, tag = "8")]
pub strikeout: bool,
#[prost(bool, tag = "9")]
pub subscript: bool,
#[prost(bool, tag = "10")]
pub superscript: bool,
#[prost(bool, tag = "11")]
pub smallcaps: bool,
#[prost(int32, tag = "12")]
pub font_weight: i32,
#[prost(bool, tag = "13")]
pub handwritten: bool,
#[prost(message, optional, tag = "14")]
pub text_color: ::core::option::Option<super::super::super::super::super::super::r#type::Color>,
#[prost(message, optional, tag = "15")]
pub background_color: ::core::option::Option<super::super::super::super::super::super::r#type::Color>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Symbol {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(message, repeated, tag = "2")]
pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VisualElement {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(string, tag = "2")]
pub r#type: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Table {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(message, repeated, tag = "2")]
pub header_rows: ::prost::alloc::vec::Vec<table::TableRow>,
#[prost(message, repeated, tag = "3")]
pub body_rows: ::prost::alloc::vec::Vec<table::TableRow>,
#[prost(message, repeated, tag = "4")]
pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
#[deprecated]
#[prost(message, optional, tag = "5")]
pub provenance: ::core::option::Option<super::Provenance>,
}
/// Nested message and enum types in `Table`.
pub mod table {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRow {
#[prost(message, repeated, tag = "1")]
pub cells: ::prost::alloc::vec::Vec<TableCell>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableCell {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<super::Layout>,
#[prost(int32, tag = "2")]
pub row_span: i32,
#[prost(int32, tag = "3")]
pub col_span: i32,
#[prost(message, repeated, tag = "4")]
pub detected_languages: ::prost::alloc::vec::Vec<super::DetectedLanguage>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormField {
#[prost(message, optional, tag = "1")]
pub field_name: ::core::option::Option<Layout>,
#[prost(message, optional, tag = "2")]
pub field_value: ::core::option::Option<Layout>,
#[prost(message, repeated, tag = "3")]
pub name_detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
#[prost(message, repeated, tag = "4")]
pub value_detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
#[prost(string, tag = "5")]
pub value_type: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub corrected_key_text: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub corrected_value_text: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub provenance: ::core::option::Option<super::Provenance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectedBarcode {
#[prost(message, optional, tag = "1")]
pub layout: ::core::option::Option<Layout>,
#[prost(message, optional, tag = "2")]
pub barcode: ::core::option::Option<super::super::Barcode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectedLanguage {
#[prost(string, tag = "1")]
pub language_code: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageQualityScores {
#[prost(float, tag = "1")]
pub quality_score: f32,
#[prost(message, repeated, tag = "2")]
pub detected_defects: ::prost::alloc::vec::Vec<image_quality_scores::DetectedDefect>,
}
/// Nested message and enum types in `ImageQualityScores`.
pub mod image_quality_scores {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectedDefect {
#[prost(string, tag = "1")]
pub r#type: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub confidence: f32,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
#[prost(message, optional, tag = "1")]
pub text_anchor: ::core::option::Option<TextAnchor>,
#[prost(string, tag = "2")]
pub r#type: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub mention_text: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub mention_id: ::prost::alloc::string::String,
#[prost(float, tag = "5")]
pub confidence: f32,
#[prost(message, optional, tag = "6")]
pub page_anchor: ::core::option::Option<PageAnchor>,
#[prost(string, tag = "7")]
pub id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub normalized_value: ::core::option::Option<entity::NormalizedValue>,
#[prost(message, repeated, tag = "10")]
pub properties: ::prost::alloc::vec::Vec<Entity>,
#[prost(message, optional, tag = "11")]
pub provenance: ::core::option::Option<Provenance>,
#[prost(bool, tag = "12")]
pub redacted: bool,
}
/// Nested message and enum types in `Entity`.
pub mod entity {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedValue {
#[prost(string, tag = "1")]
pub text: ::prost::alloc::string::String,
#[prost(oneof = "normalized_value::StructuredValue", tags = "2, 3, 4, 5, 6, 7, 8")]
pub structured_value: ::core::option::Option<normalized_value::StructuredValue>,
}
/// Nested message and enum types in `NormalizedValue`.
pub mod normalized_value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum StructuredValue {
#[prost(message, tag = "2")]
MoneyValue(super::super::super::super::super::super::r#type::Money),
#[prost(message, tag = "3")]
DateValue(super::super::super::super::super::super::r#type::Date),
#[prost(message, tag = "4")]
DatetimeValue(super::super::super::super::super::super::r#type::DateTime),
#[prost(message, tag = "5")]
AddressValue(super::super::super::super::super::super::r#type::PostalAddress),
#[prost(bool, tag = "6")]
BooleanValue(bool),
#[prost(int32, tag = "7")]
IntegerValue(i32),
#[prost(float, tag = "8")]
FloatValue(f32),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityRelation {
#[prost(string, tag = "1")]
pub subject_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub object_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub relation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextAnchor {
#[prost(message, repeated, tag = "1")]
pub text_segments: ::prost::alloc::vec::Vec<text_anchor::TextSegment>,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TextAnchor`.
pub mod text_anchor {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TextSegment {
#[prost(int64, tag = "1")]
pub start_index: i64,
#[prost(int64, tag = "2")]
pub end_index: i64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageAnchor {
#[prost(message, repeated, tag = "1")]
pub page_refs: ::prost::alloc::vec::Vec<page_anchor::PageRef>,
}
/// Nested message and enum types in `PageAnchor`.
pub mod page_anchor {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageRef {
#[prost(int64, tag = "1")]
pub page: i64,
#[prost(enumeration = "page_ref::LayoutType", tag = "2")]
pub layout_type: i32,
#[deprecated]
#[prost(string, tag = "3")]
pub layout_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub bounding_poly: ::core::option::Option<super::super::BoundingPoly>,
#[prost(float, tag = "5")]
pub confidence: f32,
}
/// Nested message and enum types in `PageRef`.
pub mod page_ref {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LayoutType {
Unspecified = 0,
Block = 1,
Paragraph = 2,
Line = 3,
Token = 4,
VisualElement = 5,
Table = 6,
FormField = 7,
}
impl LayoutType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LayoutType::Unspecified => "LAYOUT_TYPE_UNSPECIFIED",
LayoutType::Block => "BLOCK",
LayoutType::Paragraph => "PARAGRAPH",
LayoutType::Line => "LINE",
LayoutType::Token => "TOKEN",
LayoutType::VisualElement => "VISUAL_ELEMENT",
LayoutType::Table => "TABLE",
LayoutType::FormField => "FORM_FIELD",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LAYOUT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"BLOCK" => Some(Self::Block),
"PARAGRAPH" => Some(Self::Paragraph),
"LINE" => Some(Self::Line),
"TOKEN" => Some(Self::Token),
"VISUAL_ELEMENT" => Some(Self::VisualElement),
"TABLE" => Some(Self::Table),
"FORM_FIELD" => Some(Self::FormField),
_ => None,
}
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Provenance {
#[deprecated]
#[prost(int32, tag = "1")]
pub revision: i32,
#[deprecated]
#[prost(int32, tag = "2")]
pub id: i32,
#[prost(message, repeated, tag = "3")]
pub parents: ::prost::alloc::vec::Vec<provenance::Parent>,
#[prost(enumeration = "provenance::OperationType", tag = "4")]
pub r#type: i32,
}
/// Nested message and enum types in `Provenance`.
pub mod provenance {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Parent {
#[prost(int32, tag = "1")]
pub revision: i32,
#[prost(int32, tag = "3")]
pub index: i32,
#[deprecated]
#[prost(int32, tag = "2")]
pub id: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationType {
Unspecified = 0,
Add = 1,
Remove = 2,
Update = 7,
Replace = 3,
EvalRequested = 4,
EvalApproved = 5,
EvalSkipped = 6,
}
impl OperationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OperationType::Unspecified => "OPERATION_TYPE_UNSPECIFIED",
OperationType::Add => "ADD",
OperationType::Remove => "REMOVE",
OperationType::Update => "UPDATE",
OperationType::Replace => "REPLACE",
OperationType::EvalRequested => "EVAL_REQUESTED",
OperationType::EvalApproved => "EVAL_APPROVED",
OperationType::EvalSkipped => "EVAL_SKIPPED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ADD" => Some(Self::Add),
"REMOVE" => Some(Self::Remove),
"UPDATE" => Some(Self::Update),
"REPLACE" => Some(Self::Replace),
"EVAL_REQUESTED" => Some(Self::EvalRequested),
"EVAL_APPROVED" => Some(Self::EvalApproved),
"EVAL_SKIPPED" => Some(Self::EvalSkipped),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Revision {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[deprecated]
#[prost(int32, repeated, packed = "false", tag = "2")]
pub parent: ::prost::alloc::vec::Vec<i32>,
#[prost(string, repeated, tag = "7")]
pub parent_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub human_review: ::core::option::Option<revision::HumanReview>,
#[prost(oneof = "revision::Source", tags = "4, 5")]
pub source: ::core::option::Option<revision::Source>,
}
/// Nested message and enum types in `Revision`.
pub mod revision {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HumanReview {
#[prost(string, tag = "1")]
pub state: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub state_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(string, tag = "4")]
Agent(::prost::alloc::string::String),
#[prost(string, tag = "5")]
Processor(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextChange {
#[prost(message, optional, tag = "1")]
pub text_anchor: ::core::option::Option<TextAnchor>,
#[prost(string, tag = "2")]
pub changed_text: ::prost::alloc::string::String,
#[deprecated]
#[prost(message, repeated, tag = "3")]
pub provenance: ::prost::alloc::vec::Vec<Provenance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(string, tag = "1")]
Uri(::prost::alloc::string::String),
#[prost(bytes, tag = "2")]
Content(::prost::alloc::vec::Vec<u8>),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchProcessDocumentsRequest {
#[prost(message, repeated, tag = "1")]
pub requests: ::prost::alloc::vec::Vec<ProcessDocumentRequest>,
#[prost(string, tag = "2")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessDocumentRequest {
#[prost(string, tag = "9")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "1")]
pub input_config: ::core::option::Option<InputConfig>,
#[prost(message, optional, tag = "2")]
pub output_config: ::core::option::Option<OutputConfig>,
#[prost(string, tag = "3")]
pub document_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub table_extraction_params: ::core::option::Option<TableExtractionParams>,
#[prost(message, optional, tag = "5")]
pub form_extraction_params: ::core::option::Option<FormExtractionParams>,
#[prost(message, optional, tag = "6")]
pub entity_extraction_params: ::core::option::Option<EntityExtractionParams>,
#[prost(message, optional, tag = "7")]
pub ocr_params: ::core::option::Option<OcrParams>,
#[prost(message, optional, tag = "8")]
pub automl_params: ::core::option::Option<AutoMlParams>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchProcessDocumentsResponse {
#[prost(message, repeated, tag = "1")]
pub responses: ::prost::alloc::vec::Vec<ProcessDocumentResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessDocumentResponse {
#[prost(message, optional, tag = "1")]
pub input_config: ::core::option::Option<InputConfig>,
#[prost(message, optional, tag = "2")]
pub output_config: ::core::option::Option<OutputConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OcrParams {
#[prost(string, repeated, tag = "1")]
pub language_hints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableExtractionParams {
#[prost(bool, tag = "1")]
pub enabled: bool,
#[prost(message, repeated, tag = "2")]
pub table_bound_hints: ::prost::alloc::vec::Vec<TableBoundHint>,
#[prost(string, repeated, tag = "3")]
pub header_hints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub model_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableBoundHint {
#[prost(int32, tag = "1")]
pub page_number: i32,
#[prost(message, optional, tag = "2")]
pub bounding_box: ::core::option::Option<BoundingPoly>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormExtractionParams {
#[prost(bool, tag = "1")]
pub enabled: bool,
#[prost(message, repeated, tag = "2")]
pub key_value_pair_hints: ::prost::alloc::vec::Vec<KeyValuePairHint>,
#[prost(string, tag = "3")]
pub model_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValuePairHint {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub value_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityExtractionParams {
#[prost(bool, tag = "1")]
pub enabled: bool,
#[prost(string, tag = "2")]
pub model_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoMlParams {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputConfig {
#[prost(string, tag = "2")]
pub mime_type: ::prost::alloc::string::String,
#[prost(oneof = "input_config::Source", tags = "1, 3")]
pub source: ::core::option::Option<input_config::Source>,
}
/// Nested message and enum types in `InputConfig`.
pub mod input_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "1")]
GcsSource(super::GcsSource),
#[prost(bytes, tag = "3")]
Contents(::prost::alloc::vec::Vec<u8>),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputConfig {
#[prost(int32, tag = "2")]
pub pages_per_shard: i32,
#[prost(oneof = "output_config::Destination", tags = "1")]
pub destination: ::core::option::Option<output_config::Destination>,
}
/// Nested message and enum types in `OutputConfig`.
pub mod output_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(message, tag = "1")]
GcsDestination(super::GcsDestination),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsDestination {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
#[prost(enumeration = "operation_metadata::State", tag = "1")]
pub state: i32,
#[prost(string, tag = "2")]
pub state_message: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `OperationMetadata`.
pub mod operation_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Accepted = 1,
Waiting = 2,
Running = 3,
Succeeded = 4,
Cancelled = 5,
Failed = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Accepted => "ACCEPTED",
State::Waiting => "WAITING",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::Cancelled => "CANCELLED",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ACCEPTED" => Some(Self::Accepted),
"WAITING" => Some(Self::Waiting),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"CANCELLED" => Some(Self::Cancelled),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
/// Generated client implementations.
pub mod document_understanding_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to parse structured information from unstructured or semi-structured
/// documents using state-of-the-art Google AI such as natural language,
/// computer vision, and translation.
#[derive(Debug, Clone)]
pub struct DocumentUnderstandingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DocumentUnderstandingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DocumentUnderstandingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DocumentUnderstandingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// LRO endpoint to batch process many documents. The output is written
/// to Cloud Storage as JSON in the [Document] format.
pub async fn batch_process_documents(&mut self, request: impl tonic::IntoRequest<super::BatchProcessDocumentsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.documentai.v1beta2.DocumentUnderstandingService/BatchProcessDocuments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.documentai.v1beta2.DocumentUnderstandingService", "BatchProcessDocuments"));
self.inner.unary(req, path, codec).await
}
/// Processes a single document.
pub async fn process_document(&mut self, request: impl tonic::IntoRequest<super::ProcessDocumentRequest>) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.documentai.v1beta2.DocumentUnderstandingService/ProcessDocument");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.documentai.v1beta2.DocumentUnderstandingService", "ProcessDocument"));
self.inner.unary(req, path, codec).await
}
}
}
