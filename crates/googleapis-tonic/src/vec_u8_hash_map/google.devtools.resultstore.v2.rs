// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct File {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub length: ::core::option::Option<i64>,
    #[prost(string, tag = "4")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub archive_entry: ::core::option::Option<ArchiveEntry>,
    #[prost(string, tag = "6")]
    pub content_viewer: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub hidden: bool,
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub digest: ::prost::alloc::string::String,
    #[prost(enumeration = "file::HashType", tag = "10")]
    pub hash_type: i32,
}
/// Nested message and enum types in `File`.
pub mod file {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HashType {
        Unspecified = 0,
        Md5 = 1,
        Sha1 = 2,
        Sha256 = 3,
    }
    impl HashType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HashType::Unspecified => "HASH_TYPE_UNSPECIFIED",
                HashType::Md5 => "MD5",
                HashType::Sha1 => "SHA1",
                HashType::Sha256 => "SHA256",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HASH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MD5" => Some(Self::Md5),
                "SHA1" => Some(Self::Sha1),
                "SHA256" => Some(Self::Sha256),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchiveEntry {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub length: ::core::option::Option<i64>,
    #[prost(string, tag = "3")]
    pub content_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusAttributes {
    #[prost(enumeration = "Status", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Timing {
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dependency {
    #[prost(message, optional, tag = "5")]
    pub id: ::core::option::Option<dependency::Id>,
    #[prost(string, tag = "4")]
    pub label: ::prost::alloc::string::String,
    #[prost(oneof = "dependency::Resource", tags = "1, 2, 3")]
    pub resource: ::core::option::Option<dependency::Resource>,
}
/// Nested message and enum types in `Dependency`.
pub mod dependency {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "2")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub configuration_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub action_id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Resource {
        #[prost(string, tag = "1")]
        Target(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        ConfiguredTarget(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        Action(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Language {
    Unspecified = 0,
    None = 1,
    Android = 2,
    As = 3,
    Cc = 4,
    Css = 5,
    Dart = 6,
    Go = 7,
    Gwt = 8,
    Haskell = 9,
    Java = 10,
    Js = 11,
    Lisp = 12,
    Objc = 13,
    Py = 14,
    Sh = 15,
    Swift = 16,
    Ts = 18,
    Web = 19,
    Scala = 20,
    Proto = 21,
    Xml = 22,
}
impl Language {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Language::Unspecified => "LANGUAGE_UNSPECIFIED",
            Language::None => "NONE",
            Language::Android => "ANDROID",
            Language::As => "AS",
            Language::Cc => "CC",
            Language::Css => "CSS",
            Language::Dart => "DART",
            Language::Go => "GO",
            Language::Gwt => "GWT",
            Language::Haskell => "HASKELL",
            Language::Java => "JAVA",
            Language::Js => "JS",
            Language::Lisp => "LISP",
            Language::Objc => "OBJC",
            Language::Py => "PY",
            Language::Sh => "SH",
            Language::Swift => "SWIFT",
            Language::Ts => "TS",
            Language::Web => "WEB",
            Language::Scala => "SCALA",
            Language::Proto => "PROTO",
            Language::Xml => "XML",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LANGUAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "NONE" => Some(Self::None),
            "ANDROID" => Some(Self::Android),
            "AS" => Some(Self::As),
            "CC" => Some(Self::Cc),
            "CSS" => Some(Self::Css),
            "DART" => Some(Self::Dart),
            "GO" => Some(Self::Go),
            "GWT" => Some(Self::Gwt),
            "HASKELL" => Some(Self::Haskell),
            "JAVA" => Some(Self::Java),
            "JS" => Some(Self::Js),
            "LISP" => Some(Self::Lisp),
            "OBJC" => Some(Self::Objc),
            "PY" => Some(Self::Py),
            "SH" => Some(Self::Sh),
            "SWIFT" => Some(Self::Swift),
            "TS" => Some(Self::Ts),
            "WEB" => Some(Self::Web),
            "SCALA" => Some(Self::Scala),
            "PROTO" => Some(Self::Proto),
            "XML" => Some(Self::Xml),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Unspecified = 0,
    Building = 1,
    Built = 2,
    FailedToBuild = 3,
    Testing = 4,
    Passed = 5,
    Failed = 6,
    TimedOut = 7,
    Cancelled = 8,
    ToolFailed = 9,
    Incomplete = 10,
    Flaky = 11,
    Unknown = 12,
    Skipped = 13,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Status::Unspecified => "STATUS_UNSPECIFIED",
            Status::Building => "BUILDING",
            Status::Built => "BUILT",
            Status::FailedToBuild => "FAILED_TO_BUILD",
            Status::Testing => "TESTING",
            Status::Passed => "PASSED",
            Status::Failed => "FAILED",
            Status::TimedOut => "TIMED_OUT",
            Status::Cancelled => "CANCELLED",
            Status::ToolFailed => "TOOL_FAILED",
            Status::Incomplete => "INCOMPLETE",
            Status::Flaky => "FLAKY",
            Status::Unknown => "UNKNOWN",
            Status::Skipped => "SKIPPED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "BUILDING" => Some(Self::Building),
            "BUILT" => Some(Self::Built),
            "FAILED_TO_BUILD" => Some(Self::FailedToBuild),
            "TESTING" => Some(Self::Testing),
            "PASSED" => Some(Self::Passed),
            "FAILED" => Some(Self::Failed),
            "TIMED_OUT" => Some(Self::TimedOut),
            "CANCELLED" => Some(Self::Cancelled),
            "TOOL_FAILED" => Some(Self::ToolFailed),
            "INCOMPLETE" => Some(Self::Incomplete),
            "FLAKY" => Some(Self::Flaky),
            "UNKNOWN" => Some(Self::Unknown),
            "SKIPPED" => Some(Self::Skipped),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UploadStatus {
    Unspecified = 0,
    Uploading = 1,
    PostProcessing = 2,
    Immutable = 3,
}
impl UploadStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UploadStatus::Unspecified => "UPLOAD_STATUS_UNSPECIFIED",
            UploadStatus::Uploading => "UPLOADING",
            UploadStatus::PostProcessing => "POST_PROCESSING",
            UploadStatus::Immutable => "IMMUTABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPLOAD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "UPLOADING" => Some(Self::Uploading),
            "POST_PROCESSING" => Some(Self::PostProcessing),
            "IMMUTABLE" => Some(Self::Immutable),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineCoverage {
    #[prost(bytes = "vec", tag = "1")]
    pub instrumented_lines: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub executed_lines: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BranchCoverage {
    #[prost(bytes = "vec", tag = "1")]
    pub branch_present: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, repeated, tag = "2")]
    pub branches_in_line: ::prost::alloc::vec::Vec<i32>,
    #[prost(bytes = "vec", tag = "3")]
    pub executed: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub taken: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileCoverage {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub line_coverage: ::core::option::Option<LineCoverage>,
    #[prost(message, optional, tag = "3")]
    pub branch_coverage: ::core::option::Option<BranchCoverage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionCoverage {
    #[prost(message, repeated, tag = "2")]
    pub file_coverages: ::prost::alloc::vec::Vec<FileCoverage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateCoverage {
    #[prost(message, repeated, tag = "1")]
    pub file_coverages: ::prost::alloc::vec::Vec<FileCoverage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileProcessingErrors {
    #[prost(string, tag = "1")]
    pub file_uid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub file_processing_errors: ::prost::alloc::vec::Vec<FileProcessingError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileProcessingError {
    #[prost(enumeration = "FileProcessingErrorType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileProcessingErrorType {
    Unspecified = 0,
    GenericReadError = 1,
    GenericParseError = 2,
    FileTooLarge = 3,
    OutputTooLarge = 4,
    AccessDenied = 5,
    DeadlineExceeded = 6,
    NotFound = 7,
    FileEmpty = 8,
}
impl FileProcessingErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FileProcessingErrorType::Unspecified => {
                "FILE_PROCESSING_ERROR_TYPE_UNSPECIFIED"
            }
            FileProcessingErrorType::GenericReadError => "GENERIC_READ_ERROR",
            FileProcessingErrorType::GenericParseError => "GENERIC_PARSE_ERROR",
            FileProcessingErrorType::FileTooLarge => "FILE_TOO_LARGE",
            FileProcessingErrorType::OutputTooLarge => "OUTPUT_TOO_LARGE",
            FileProcessingErrorType::AccessDenied => "ACCESS_DENIED",
            FileProcessingErrorType::DeadlineExceeded => "DEADLINE_EXCEEDED",
            FileProcessingErrorType::NotFound => "NOT_FOUND",
            FileProcessingErrorType::FileEmpty => "FILE_EMPTY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILE_PROCESSING_ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "GENERIC_READ_ERROR" => Some(Self::GenericReadError),
            "GENERIC_PARSE_ERROR" => Some(Self::GenericParseError),
            "FILE_TOO_LARGE" => Some(Self::FileTooLarge),
            "OUTPUT_TOO_LARGE" => Some(Self::OutputTooLarge),
            "ACCESS_DENIED" => Some(Self::AccessDenied),
            "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
            "NOT_FOUND" => Some(Self::NotFound),
            "FILE_EMPTY" => Some(Self::FileEmpty),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestSuite {
    #[prost(string, tag = "1")]
    pub suite_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub tests: ::prost::alloc::vec::Vec<Test>,
    #[prost(message, repeated, tag = "3")]
    pub failures: ::prost::alloc::vec::Vec<TestFailure>,
    #[prost(message, repeated, tag = "4")]
    pub errors: ::prost::alloc::vec::Vec<TestError>,
    #[prost(message, optional, tag = "6")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, repeated, tag = "7")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(message, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<File>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Test {
    #[prost(oneof = "test::TestType", tags = "1, 2")]
    pub test_type: ::core::option::Option<test::TestType>,
}
/// Nested message and enum types in `Test`.
pub mod test {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TestType {
        #[prost(message, tag = "1")]
        TestCase(super::TestCase),
        #[prost(message, tag = "2")]
        TestSuite(super::TestSuite),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestCase {
    #[prost(string, tag = "1")]
    pub case_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub class_name: ::prost::alloc::string::String,
    #[prost(enumeration = "test_case::Result", tag = "3")]
    pub result: i32,
    #[prost(message, repeated, tag = "4")]
    pub failures: ::prost::alloc::vec::Vec<TestFailure>,
    #[prost(message, repeated, tag = "5")]
    pub errors: ::prost::alloc::vec::Vec<TestError>,
    #[prost(message, optional, tag = "7")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, repeated, tag = "8")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(message, repeated, tag = "9")]
    pub files: ::prost::alloc::vec::Vec<File>,
    #[prost(int32, tag = "10")]
    pub retry_number: i32,
    #[prost(int32, tag = "11")]
    pub repeat_number: i32,
}
/// Nested message and enum types in `TestCase`.
pub mod test_case {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        Unspecified = 0,
        Completed = 1,
        Interrupted = 2,
        Cancelled = 3,
        Filtered = 4,
        Skipped = 5,
        Suppressed = 6,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::Unspecified => "RESULT_UNSPECIFIED",
                Result::Completed => "COMPLETED",
                Result::Interrupted => "INTERRUPTED",
                Result::Cancelled => "CANCELLED",
                Result::Filtered => "FILTERED",
                Result::Skipped => "SKIPPED",
                Result::Suppressed => "SUPPRESSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPLETED" => Some(Self::Completed),
                "INTERRUPTED" => Some(Self::Interrupted),
                "CANCELLED" => Some(Self::Cancelled),
                "FILTERED" => Some(Self::Filtered),
                "SKIPPED" => Some(Self::Skipped),
                "SUPPRESSED" => Some(Self::Suppressed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestFailure {
    #[prost(string, tag = "1")]
    pub failure_message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exception_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub stack_trace: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub expected: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub actual: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestError {
    #[prost(string, tag = "1")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exception_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub stack_trace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<action::Id>,
    #[prost(message, optional, tag = "3")]
    pub status_attributes: ::core::option::Option<StatusAttributes>,
    #[prost(message, optional, tag = "4")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, optional, tag = "5")]
    pub action_attributes: ::core::option::Option<ActionAttributes>,
    #[prost(message, repeated, tag = "14")]
    pub action_dependencies: ::prost::alloc::vec::Vec<Dependency>,
    #[prost(message, repeated, tag = "7")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(message, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<File>,
    #[prost(string, repeated, tag = "15")]
    pub file_sets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "11")]
    pub coverage: ::core::option::Option<ActionCoverage>,
    #[prost(message, repeated, tag = "13")]
    pub file_processing_errors: ::prost::alloc::vec::Vec<FileProcessingErrors>,
    #[prost(oneof = "action::ActionType", tags = "9, 10")]
    pub action_type: ::core::option::Option<action::ActionType>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "1")]
        pub invocation_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub configuration_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub action_id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ActionType {
        #[prost(message, tag = "9")]
        BuildAction(super::BuildAction),
        #[prost(message, tag = "10")]
        TestAction(super::TestAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildAction {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub primary_input_path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub primary_output_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestAction {
    #[prost(message, optional, tag = "1")]
    pub test_timing: ::core::option::Option<TestTiming>,
    #[prost(int32, tag = "2")]
    pub shard_number: i32,
    #[prost(int32, tag = "3")]
    pub run_number: i32,
    #[prost(int32, tag = "4")]
    pub attempt_number: i32,
    #[prost(message, optional, tag = "5")]
    pub test_suite: ::core::option::Option<TestSuite>,
    #[prost(message, repeated, tag = "8")]
    pub warnings: ::prost::alloc::vec::Vec<TestWarning>,
    #[prost(int64, tag = "10")]
    pub estimated_memory_bytes: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionAttributes {
    #[prost(enumeration = "ExecutionStrategy", tag = "1")]
    pub execution_strategy: i32,
    #[prost(int32, tag = "2")]
    pub exit_code: i32,
    #[prost(string, tag = "3")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub input_file_info: ::core::option::Option<InputFileInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InputFileInfo {
    #[prost(int64, tag = "1")]
    pub count: i64,
    #[prost(int64, tag = "2")]
    pub distinct_count: i64,
    #[prost(int64, tag = "3")]
    pub count_limit: i64,
    #[prost(int64, tag = "4")]
    pub distinct_bytes: i64,
    #[prost(int64, tag = "5")]
    pub distinct_byte_limit: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalTestTiming {
    #[prost(message, optional, tag = "1")]
    pub test_process_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoteTestAttemptTiming {
    #[prost(message, optional, tag = "1")]
    pub queue_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub upload_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "3")]
    pub machine_setup_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub test_process_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "5")]
    pub download_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteTestTiming {
    #[prost(message, optional, tag = "1")]
    pub local_analysis_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, repeated, tag = "2")]
    pub attempts: ::prost::alloc::vec::Vec<RemoteTestAttemptTiming>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestTiming {
    #[prost(message, optional, tag = "3")]
    pub system_time_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub user_time_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "TestCaching", tag = "5")]
    pub test_caching: i32,
    #[prost(oneof = "test_timing::Location", tags = "1, 2")]
    pub location: ::core::option::Option<test_timing::Location>,
}
/// Nested message and enum types in `TestTiming`.
pub mod test_timing {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Location {
        #[prost(message, tag = "1")]
        Local(super::LocalTestTiming),
        #[prost(message, tag = "2")]
        Remote(super::RemoteTestTiming),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestWarning {
    #[prost(string, tag = "1")]
    pub warning_message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStrategy {
    Unspecified = 0,
    OtherEnvironment = 1,
    RemoteService = 2,
    LocalParallel = 3,
    LocalSequential = 4,
}
impl ExecutionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExecutionStrategy::Unspecified => "EXECUTION_STRATEGY_UNSPECIFIED",
            ExecutionStrategy::OtherEnvironment => "OTHER_ENVIRONMENT",
            ExecutionStrategy::RemoteService => "REMOTE_SERVICE",
            ExecutionStrategy::LocalParallel => "LOCAL_PARALLEL",
            ExecutionStrategy::LocalSequential => "LOCAL_SEQUENTIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXECUTION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
            "OTHER_ENVIRONMENT" => Some(Self::OtherEnvironment),
            "REMOTE_SERVICE" => Some(Self::RemoteService),
            "LOCAL_PARALLEL" => Some(Self::LocalParallel),
            "LOCAL_SEQUENTIAL" => Some(Self::LocalSequential),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestCaching {
    Unspecified = 0,
    LocalCacheHit = 1,
    RemoteCacheHit = 2,
    CacheMiss = 3,
}
impl TestCaching {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TestCaching::Unspecified => "TEST_CACHING_UNSPECIFIED",
            TestCaching::LocalCacheHit => "LOCAL_CACHE_HIT",
            TestCaching::RemoteCacheHit => "REMOTE_CACHE_HIT",
            TestCaching::CacheMiss => "CACHE_MISS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEST_CACHING_UNSPECIFIED" => Some(Self::Unspecified),
            "LOCAL_CACHE_HIT" => Some(Self::LocalCacheHit),
            "REMOTE_CACHE_HIT" => Some(Self::RemoteCacheHit),
            "CACHE_MISS" => Some(Self::CacheMiss),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Configuration {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<configuration::Id>,
    #[prost(message, optional, tag = "3")]
    pub status_attributes: ::core::option::Option<StatusAttributes>,
    #[prost(message, optional, tag = "5")]
    pub configuration_attributes: ::core::option::Option<ConfigurationAttributes>,
    #[prost(message, repeated, tag = "6")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Configuration`.
pub mod configuration {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "1")]
        pub invocation_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub configuration_id: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigurationAttributes {
    #[prost(string, tag = "1")]
    pub cpu: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfiguredTarget {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<configured_target::Id>,
    #[prost(message, optional, tag = "3")]
    pub status_attributes: ::core::option::Option<StatusAttributes>,
    #[prost(message, optional, tag = "4")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, optional, tag = "6")]
    pub test_attributes: ::core::option::Option<ConfiguredTestAttributes>,
    #[prost(message, repeated, tag = "7")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(message, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<File>,
}
/// Nested message and enum types in `ConfiguredTarget`.
pub mod configured_target {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "1")]
        pub invocation_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub configuration_id: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfiguredTestAttributes {
    #[prost(int32, tag = "2")]
    pub total_run_count: i32,
    #[prost(int32, tag = "3")]
    pub total_shard_count: i32,
    #[prost(message, optional, tag = "5")]
    pub timeout_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadMetadata {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "UploadStatus", tag = "2")]
    pub upload_status: i32,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub finalize_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub immutable_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileSet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<file_set::Id>,
    #[prost(string, repeated, tag = "3")]
    pub file_sets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub files: ::prost::alloc::vec::Vec<File>,
}
/// Nested message and enum types in `FileSet`.
pub mod file_set {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "1")]
        pub invocation_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub file_set_id: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LineCoverageSummary {
    #[prost(int32, tag = "1")]
    pub instrumented_line_count: i32,
    #[prost(int32, tag = "2")]
    pub executed_line_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BranchCoverageSummary {
    #[prost(int32, tag = "1")]
    pub total_branch_count: i32,
    #[prost(int32, tag = "2")]
    pub executed_branch_count: i32,
    #[prost(int32, tag = "3")]
    pub taken_branch_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanguageCoverageSummary {
    #[prost(enumeration = "Language", tag = "1")]
    pub language: i32,
    #[prost(message, optional, tag = "2")]
    pub line_summary: ::core::option::Option<LineCoverageSummary>,
    #[prost(message, optional, tag = "3")]
    pub branch_summary: ::core::option::Option<BranchCoverageSummary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Invocation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<invocation::Id>,
    #[prost(message, optional, tag = "3")]
    pub status_attributes: ::core::option::Option<StatusAttributes>,
    #[prost(message, optional, tag = "4")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, optional, tag = "5")]
    pub invocation_attributes: ::core::option::Option<InvocationAttributes>,
    #[prost(message, optional, tag = "6")]
    pub workspace_info: ::core::option::Option<WorkspaceInfo>,
    #[prost(message, repeated, tag = "7")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(message, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<File>,
    #[prost(message, repeated, tag = "9")]
    pub coverage_summaries: ::prost::alloc::vec::Vec<LanguageCoverageSummary>,
    #[prost(message, optional, tag = "10")]
    pub aggregate_coverage: ::core::option::Option<AggregateCoverage>,
    #[prost(message, repeated, tag = "11")]
    pub file_processing_errors: ::prost::alloc::vec::Vec<FileProcessingErrors>,
}
/// Nested message and enum types in `Invocation`.
pub mod invocation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "1")]
        pub invocation_id: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkspaceContext {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkspaceInfo {
    #[prost(message, optional, tag = "1")]
    pub workspace_context: ::core::option::Option<WorkspaceContext>,
    #[prost(string, tag = "3")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub working_directory: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tool_tag: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub command_lines: ::prost::alloc::vec::Vec<CommandLine>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandLine {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tool: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub command: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvocationAttributes {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub users: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub invocation_contexts: ::prost::alloc::vec::Vec<InvocationContext>,
    #[prost(int32, tag = "7")]
    pub exit_code: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvocationContext {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<target::Id>,
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub status_attributes: ::core::option::Option<StatusAttributes>,
    #[prost(message, optional, tag = "4")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, optional, tag = "5")]
    pub target_attributes: ::core::option::Option<TargetAttributes>,
    #[prost(message, optional, tag = "6")]
    pub test_attributes: ::core::option::Option<TestAttributes>,
    #[prost(message, repeated, tag = "7")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(message, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<File>,
    #[prost(bool, tag = "10")]
    pub visible: bool,
}
/// Nested message and enum types in `Target`.
pub mod target {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "1")]
        pub invocation_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub target_id: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetAttributes {
    #[prost(enumeration = "TargetType", tag = "1")]
    pub r#type: i32,
    #[prost(enumeration = "Language", tag = "2")]
    pub language: i32,
    #[prost(string, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TestAttributes {
    #[prost(enumeration = "TestSize", tag = "1")]
    pub size: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TargetType {
    Unspecified = 0,
    Application = 1,
    Binary = 2,
    Library = 3,
    Package = 4,
    Test = 5,
}
impl TargetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TargetType::Unspecified => "TARGET_TYPE_UNSPECIFIED",
            TargetType::Application => "APPLICATION",
            TargetType::Binary => "BINARY",
            TargetType::Library => "LIBRARY",
            TargetType::Package => "PACKAGE",
            TargetType::Test => "TEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TARGET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "APPLICATION" => Some(Self::Application),
            "BINARY" => Some(Self::Binary),
            "LIBRARY" => Some(Self::Library),
            "PACKAGE" => Some(Self::Package),
            "TEST" => Some(Self::Test),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestSize {
    Unspecified = 0,
    Small = 1,
    Medium = 2,
    Large = 3,
    Enormous = 4,
    OtherSize = 5,
}
impl TestSize {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TestSize::Unspecified => "TEST_SIZE_UNSPECIFIED",
            TestSize::Small => "SMALL",
            TestSize::Medium => "MEDIUM",
            TestSize::Large => "LARGE",
            TestSize::Enormous => "ENORMOUS",
            TestSize::OtherSize => "OTHER_SIZE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEST_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
            "SMALL" => Some(Self::Small),
            "MEDIUM" => Some(Self::Medium),
            "LARGE" => Some(Self::Large),
            "ENORMOUS" => Some(Self::Enormous),
            "OTHER_SIZE" => Some(Self::OtherSize),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInvocationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchInvocationsRequest {
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub exact_match: bool,
    #[prost(oneof = "search_invocations_request::PageStart", tags = "2, 3")]
    pub page_start: ::core::option::Option<search_invocations_request::PageStart>,
}
/// Nested message and enum types in `SearchInvocationsRequest`.
pub mod search_invocations_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "2")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "3")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchInvocationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub invocations: ::prost::alloc::vec::Vec<Invocation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportInvocationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "6")]
    pub targets_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub configured_targets_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub actions_filter: ::prost::alloc::string::String,
    #[prost(oneof = "export_invocation_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<export_invocation_request::PageStart>,
}
/// Nested message and enum types in `ExportInvocationRequest`.
pub mod export_invocation_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportInvocationResponse {
    #[prost(message, optional, tag = "1")]
    pub invocation: ::core::option::Option<Invocation>,
    #[prost(message, optional, tag = "8")]
    pub download_metadata: ::core::option::Option<DownloadMetadata>,
    #[prost(message, repeated, tag = "2")]
    pub targets: ::prost::alloc::vec::Vec<Target>,
    #[prost(message, repeated, tag = "3")]
    pub configurations: ::prost::alloc::vec::Vec<Configuration>,
    #[prost(message, repeated, tag = "4")]
    pub configured_targets: ::prost::alloc::vec::Vec<ConfiguredTarget>,
    #[prost(message, repeated, tag = "5")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(message, repeated, tag = "6")]
    pub file_sets: ::prost::alloc::vec::Vec<FileSet>,
    #[prost(string, tag = "7")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInvocationDownloadMetadataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigurationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConfigurationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(oneof = "list_configurations_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<list_configurations_request::PageStart>,
}
/// Nested message and enum types in `ListConfigurationsRequest`.
pub mod list_configurations_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConfigurationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub configurations: ::prost::alloc::vec::Vec<Configuration>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(oneof = "list_targets_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<list_targets_request::PageStart>,
}
/// Nested message and enum types in `ListTargetsRequest`.
pub mod list_targets_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub targets: ::prost::alloc::vec::Vec<Target>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfiguredTargetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConfiguredTargetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(oneof = "list_configured_targets_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<list_configured_targets_request::PageStart>,
}
/// Nested message and enum types in `ListConfiguredTargetsRequest`.
pub mod list_configured_targets_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConfiguredTargetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub configured_targets: ::prost::alloc::vec::Vec<ConfiguredTarget>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchConfiguredTargetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub exact_match: bool,
    #[prost(oneof = "search_configured_targets_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<search_configured_targets_request::PageStart>,
}
/// Nested message and enum types in `SearchConfiguredTargetsRequest`.
pub mod search_configured_targets_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchConfiguredTargetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub configured_targets: ::prost::alloc::vec::Vec<ConfiguredTarget>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(oneof = "list_actions_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<list_actions_request::PageStart>,
}
/// Nested message and enum types in `ListActionsRequest`.
pub mod list_actions_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchListActionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub configured_targets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "6")]
    pub filter: ::prost::alloc::string::String,
    #[prost(oneof = "batch_list_actions_request::PageStart", tags = "4, 5")]
    pub page_start: ::core::option::Option<batch_list_actions_request::PageStart>,
}
/// Nested message and enum types in `BatchListActionsRequest`.
pub mod batch_list_actions_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "4")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "5")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchListActionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub not_found: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFileSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(oneof = "list_file_sets_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<list_file_sets_request::PageStart>,
}
/// Nested message and enum types in `ListFileSetsRequest`.
pub mod list_file_sets_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFileSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub file_sets: ::prost::alloc::vec::Vec<FileSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraverseFileSetsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(oneof = "traverse_file_sets_request::PageStart", tags = "3, 4")]
    pub page_start: ::core::option::Option<traverse_file_sets_request::PageStart>,
}
/// Nested message and enum types in `TraverseFileSetsRequest`.
pub mod traverse_file_sets_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PageStart {
        #[prost(string, tag = "3")]
        PageToken(::prost::alloc::string::String),
        #[prost(int64, tag = "4")]
        Offset(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraverseFileSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub file_sets: ::prost::alloc::vec::Vec<FileSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod result_store_download_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This is the interface used to download information from the ResultStore
    /// database.
    ///
    /// Clients are encourage to use ExportInvocation for most traffic.
    ///
    /// Most APIs require setting a response FieldMask via the 'fields' URL query
    /// parameter or the X-Goog-FieldMask HTTP/gRPC header.
    #[derive(Debug, Clone)]
    pub struct ResultStoreDownloadClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ResultStoreDownloadClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResultStoreDownloadClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ResultStoreDownloadClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Exports the invocation with the given name and its child resources.
        ///
        /// The order in which resources are returned is defined as follows,
        /// invocation; download_metadata; configurations; targets interleaving
        /// configured_targets and actions; file_sets.
        ///
        /// * Invocation
        /// * DownloadMetadata
        /// * Configurations
        /// * Targets
        ///  └─ ConfiguredTargets
        ///  └─Actions
        /// * FileSets
        ///
        /// All child resources will be returned before the next parent
        /// resource is returned. For example, all actions under a configured_target
        /// will be returned before the next configured_target is returned.
        /// The order in which results within a given resource type are returned is
        /// undefined, but stable.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation is not found.
        /// * If the given invocation name is badly formatted.
        /// * If no field mask was given.
        pub async fn export_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportInvocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExportInvocationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/ExportInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "ExportInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the invocation with the given name.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation is not found.
        /// * If the given invocation name is badly formatted.
        /// * If no field mask was given.
        pub async fn get_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInvocationRequest>,
        ) -> std::result::Result<tonic::Response<super::Invocation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/GetInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "GetInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for invocations matching the given query parameters. Results will
        /// be ordered by timing.start_time with most recent first, but total ordering
        /// of results is not guaranteed when difference in timestamps is very small.
        /// Results may be stale. Results may be omitted.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If a query string is not provided
        /// * If no field mask was given.
        pub async fn search_invocations(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchInvocationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchInvocationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/SearchInvocations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "SearchInvocations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the metadata for an invocation with the given name.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation is not found.
        /// * If the given invocation name is badly formatted.
        pub async fn get_invocation_download_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInvocationDownloadMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DownloadMetadata>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/GetInvocationDownloadMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "GetInvocationDownloadMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the configuration with the given name.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the configuration or its parent invocation is not found.
        /// * If the given configuration name is badly formatted.
        /// * If no field mask was given.
        pub async fn get_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigurationRequest>,
        ) -> std::result::Result<tonic::Response<super::Configuration>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/GetConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "GetConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves all configurations for a parent invocation.
        /// This might be limited by user or server,
        /// in which case a continuation token is provided.
        /// The order in which results are returned is undefined, but stable.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the parent invocation is not found.
        /// * If the given parent invocation name is badly formatted.
        /// * If no field mask was given.
        pub async fn list_configurations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConfigurationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConfigurationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/ListConfigurations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "ListConfigurations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the target with the given name.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the target or its parent invocation is not found.
        /// * If the given target name is badly formatted.
        /// * If no field mask was given.
        pub async fn get_target(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetRequest>,
        ) -> std::result::Result<tonic::Response<super::Target>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/GetTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "GetTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves all targets for a parent invocation.  This might be limited by
        /// user or server, in which case a continuation token is provided.
        /// The order in which results are returned is undefined, but stable.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the parent is not found.
        /// * If the given parent name is badly formatted.
        /// * If no field mask was given.
        pub async fn list_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTargetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/ListTargets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "ListTargets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the configured target with the given name.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the configured target is not found.
        /// * If the given name is badly formatted.
        /// * If no field mask was given.
        pub async fn get_configured_target(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfiguredTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfiguredTarget>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/GetConfiguredTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "GetConfiguredTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves all configured targets for a parent invocation/target.
        /// This might be limited by user or server, in which case a continuation
        /// token is provided. Supports '-' for targetId meaning all targets.
        /// The order in which results are returned is undefined, but stable and
        /// consistent with ListTargets and ListConfigurations.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the parent is not found.
        /// * If the given parent name is badly formatted.
        /// * If no field mask was given.
        pub async fn list_configured_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConfiguredTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConfiguredTargetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/ListConfiguredTargets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "ListConfiguredTargets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for ConfiguredTargets matching the given query parameters. Results
        /// will be ordered by timing.start_time with most recent first, but total
        /// ordering of results is not guaranteed when difference in timestamps is
        /// very small. Results may be stale. Results may be omitted.
        ///
        /// Field masks are supported for only these fields and their subfields:
        ///
        /// * configured_targets.name
        /// * configured_targets.id
        /// * configured_targets.status_attributes
        /// * configured_targets.timing
        /// * next_page_token
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If a query string is not provided
        /// * If no field mask was given.
        pub async fn search_configured_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchConfiguredTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchConfiguredTargetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/SearchConfiguredTargets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "SearchConfiguredTargets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the action with the given name.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the action is not found.
        /// * If the given name is badly formatted.
        /// * If no field mask was given.
        pub async fn get_action(
            &mut self,
            request: impl tonic::IntoRequest<super::GetActionRequest>,
        ) -> std::result::Result<tonic::Response<super::Action>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/GetAction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "GetAction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves all actions for a parent invocation/target/configuration.
        /// This might be limited by user or server, in which case a continuation
        /// token is provided. Supports '-' for configurationId to mean all
        /// actions for all configurations for a target, or '-' for targetId and
        /// configurationId to mean all actions for all configurations and all targets.
        /// Does not support targetId '-' with a specified configuration.
        /// The order in which results are returned is undefined, but stable and
        /// consistent with ListConfiguredTargets.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the parent is not found.
        /// * If the given parent name is badly formatted.
        /// * If no field mask was given.
        pub async fn list_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/ListActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "ListActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of actions for a parent invocation or multiple parents
        /// target/configuration. This might be limited by user or server, in which
        /// case a continuation token is provided. The order in which results are
        /// returned is undefined, but stable and consistent with
        /// ListConfiguredTargets.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the given parent name is badly formatted.
        /// * If no field mask was given.
        pub async fn batch_list_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchListActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/BatchListActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "BatchListActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the file set with the given name.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the file set or its parent invocation is not found.
        /// * If the given file set name is badly formatted.
        /// * If no field mask was given.
        pub async fn get_file_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFileSetRequest>,
        ) -> std::result::Result<tonic::Response<super::FileSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/GetFileSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "GetFileSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves all file sets for a parent invocation.
        /// This might be limited by user or server,
        /// in which case a continuation token is provided.
        /// The order in which results are returned is undefined, but stable.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the parent invocation is not found.
        /// * If the given parent invocation name is badly formatted.
        /// * If no field mask was given.
        pub async fn list_file_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFileSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFileSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/ListFileSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "ListFileSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the transitive closure of FileSets. This might be limited by user
        /// or server, in which case a continuation token is provided.
        /// The order in which results are returned is undefined, and unstable.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If page_token is too large to continue the calculation.
        /// * If the resource is not found.
        /// * If the given resource name is badly formatted.
        /// * If no field mask was given.
        pub async fn traverse_file_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::TraverseFileSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TraverseFileSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreDownload/TraverseFileSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreDownload",
                        "TraverseFileSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadMetadata {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub resume_token: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub uploader_state: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInvocationRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub invocation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub invocation: ::core::option::Option<Invocation>,
    #[prost(string, tag = "4")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub auto_finalize_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "7")]
    pub initial_resume_token: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "8")]
    pub uploader_state: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInvocationRequest {
    #[prost(message, optional, tag = "3")]
    pub invocation: ::core::option::Option<Invocation>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeInvocationRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub invocation: ::core::option::Option<Invocation>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TouchInvocationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TouchInvocationResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<invocation::Id>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInvocationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeInvocationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeInvocationResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<invocation::Id>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTargetRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub target: ::core::option::Option<Target>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTargetRequest {
    #[prost(message, optional, tag = "3")]
    pub target: ::core::option::Option<Target>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeTargetRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub target: ::core::option::Option<Target>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeTargetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeTargetResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<target::Id>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConfiguredTargetRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub config_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub configured_target: ::core::option::Option<ConfiguredTarget>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConfiguredTargetRequest {
    #[prost(message, optional, tag = "3")]
    pub configured_target: ::core::option::Option<ConfiguredTarget>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeConfiguredTargetRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub configured_target: ::core::option::Option<ConfiguredTarget>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeConfiguredTargetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeConfiguredTargetResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<configured_target::Id>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateActionRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub action_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub action: ::core::option::Option<Action>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateActionRequest {
    #[prost(message, optional, tag = "3")]
    pub action: ::core::option::Option<Action>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeActionRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub action: ::core::option::Option<Action>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConfigurationRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub config_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub configuration: ::core::option::Option<Configuration>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConfigurationRequest {
    #[prost(message, optional, tag = "3")]
    pub configuration: ::core::option::Option<Configuration>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFileSetRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub file_set_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub file_set: ::core::option::Option<FileSet>,
    #[prost(string, tag = "5")]
    pub authorization_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFileSetRequest {
    #[prost(message, optional, tag = "1")]
    pub file_set: ::core::option::Option<FileSet>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "3")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeFileSetRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub file_set: ::core::option::Option<FileSet>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "4")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub create_if_not_found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadBatchRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub next_resume_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub resume_token: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "6")]
    pub uploader_state: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "5")]
    pub upload_requests: ::prost::alloc::vec::Vec<UploadRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UploadBatchResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadRequest {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<upload_request::Id>,
    #[prost(enumeration = "upload_request::UploadOperation", tag = "2")]
    pub upload_operation: i32,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "10")]
    pub create_if_not_found: bool,
    #[prost(oneof = "upload_request::Resource", tags = "4, 5, 6, 7, 8, 9")]
    pub resource: ::core::option::Option<upload_request::Resource>,
}
/// Nested message and enum types in `UploadRequest`.
pub mod upload_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(string, tag = "1")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub configuration_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub action_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub file_set_id: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UploadOperation {
        Unspecified = 0,
        Create = 1,
        Update = 2,
        Merge = 3,
        Finalize = 4,
    }
    impl UploadOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UploadOperation::Unspecified => "UPLOAD_OPERATION_UNSPECIFIED",
                UploadOperation::Create => "CREATE",
                UploadOperation::Update => "UPDATE",
                UploadOperation::Merge => "MERGE",
                UploadOperation::Finalize => "FINALIZE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UPLOAD_OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "MERGE" => Some(Self::Merge),
                "FINALIZE" => Some(Self::Finalize),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Resource {
        #[prost(message, tag = "4")]
        Invocation(super::Invocation),
        #[prost(message, tag = "5")]
        Target(super::Target),
        #[prost(message, tag = "6")]
        Configuration(super::Configuration),
        #[prost(message, tag = "7")]
        ConfiguredTarget(super::ConfiguredTarget),
        #[prost(message, tag = "8")]
        Action(super::Action),
        #[prost(message, tag = "9")]
        FileSet(super::FileSet),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInvocationUploadMetadataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod result_store_upload_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This is the interface used to upload information to the ResultStore database,
    /// to update that information as necessary, and to make it immutable at the end.
    ///
    /// This interface intentionally does not support user read-modify-write
    /// operations. They may corrupt data, and are too expensive. For the same
    /// reason, all upload RPCs will return no resource fields except name and ID. An
    /// uploader should hold as little state as possible in memory to avoid running
    /// out of memory.
    #[derive(Debug, Clone)]
    pub struct ResultStoreUploadClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ResultStoreUploadClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResultStoreUploadClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ResultStoreUploadClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates the given invocation.
        ///
        /// This is not an implicitly idempotent API, so a request id is required to
        /// make it idempotent.
        ///
        /// Returns an empty Invocation proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If an invocation with the same ID already exists.
        pub async fn create_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInvocationRequest>,
        ) -> std::result::Result<tonic::Response<super::Invocation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/CreateInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "CreateInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a standard update to the invocation identified by the given proto's
        /// name.  For all types of fields (primitive, message, or repeated), replaces
        /// them with the given proto fields if they are under the given field mask
        /// paths.  Fields that match the mask but aren't populated in the given
        /// invocation are cleared. This is an implicitly idempotent API.
        ///
        /// Returns an empty Invocation proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation does not exist.
        /// * If the invocation is finalized.
        /// * If no field mask was given.
        pub async fn update_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInvocationRequest>,
        ) -> std::result::Result<tonic::Response<super::Invocation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/UpdateInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "UpdateInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a merge update to the invocation identified by the given proto's
        /// name.  For primitive and message fields, replaces them with the ones in
        /// the given proto if they are covered under the field mask paths.  For
        /// repeated fields, merges to them with the given ones if they are covered
        /// under the field mask paths. This is not an implicitly idempotent API, so a
        /// request id is required to make it idempotent.
        ///
        /// Returns an empty Invocation proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation does not exist.
        /// * If the invocation is finalized.
        /// * If no field mask was given.
        pub async fn merge_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeInvocationRequest>,
        ) -> std::result::Result<tonic::Response<super::Invocation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/MergeInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "MergeInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Touches the invocation identified by the given proto's name.
        ///
        /// This is useful when you need to notify ResultStore that you haven't
        /// abandoned the upload, since abandoned uploads will be automatically
        /// finalized after a set period.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation does not exist.
        /// * If the invocation is finalized.
        pub async fn touch_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::TouchInvocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TouchInvocationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/TouchInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "TouchInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Declares the invocation with the given name as finalized and immutable by
        /// the user. It may still be mutated by post-processing. This is an implicitly
        /// idempotent API.
        ///
        /// If an Invocation is not updated for 24 hours, some time after that
        /// this will be called automatically.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation does not exist.
        pub async fn finalize_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeInvocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FinalizeInvocationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/FinalizeInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "FinalizeInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an immutable invocation (permanently)
        /// Note: this does not delete indirect data, e.g. files stored in other
        /// services.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the invocation does not exist.
        /// * If the invocation is not finalized.  This can be retried until it is.
        pub async fn delete_invocation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInvocationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/DeleteInvocation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "DeleteInvocation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates the given target under the given parent invocation. The given
        /// target ID is URL encoded, converted to the full resource name, and assigned
        /// to the target's name field. This is not an implicitly idempotent API, so a
        /// request id is required to make it idempotent.
        ///
        /// Returns an empty Target proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If no target ID is provided.
        /// * If the parent invocation does not exist.
        /// * If the parent invocation is finalized.
        /// * If a target with the same name already exists.
        pub async fn create_target(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTargetRequest>,
        ) -> std::result::Result<tonic::Response<super::Target>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/CreateTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "CreateTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a standard update to the target identified by the given proto's
        /// name. For all types of fields (primitive, message, or repeated), replaces
        /// them with the given proto fields if they are under the given field mask
        /// paths. Fields that match the mask but aren't populated in the given
        /// target are cleared. This is an implicitly idempotent API.
        ///
        /// Returns an empty Target proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the target does not exist.
        /// * If the target or parent invocation is finalized.
        /// * If no field mask was given.
        pub async fn update_target(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTargetRequest>,
        ) -> std::result::Result<tonic::Response<super::Target>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/UpdateTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "UpdateTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a merge update to the target identified by the given proto's
        /// name. For primitive and message fields, replaces them with the ones in the
        /// given proto if they are covered under the field mask paths.  For repeated
        /// fields, merges to them with the given ones if they are covered under the
        /// field mask paths. This is not an implicitly idempotent API, so a request
        /// id is required to make it idempotent.
        ///
        /// Returns an empty Target proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the target does not exist.
        /// * If the target or parent invocation is finalized.
        /// * If no field mask was given.
        pub async fn merge_target(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeTargetRequest>,
        ) -> std::result::Result<tonic::Response<super::Target>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/MergeTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "MergeTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Declares the target with the given name as finalized and immutable by the
        /// user. It may still be mutated by post-processing. This is an implicitly
        /// idempotent API.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the target does not exist.
        pub async fn finalize_target(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FinalizeTargetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/FinalizeTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "FinalizeTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates the given configured target under the given parent target.
        /// The given configured target ID is URL encoded, converted to the full
        /// resource name, and assigned to the configured target's name field.
        /// This is not an implicitly idempotent API, so a request id is required
        /// to make it idempotent.
        ///
        /// Returns an empty ConfiguredTarget proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If no config ID is provided.
        /// * If a configured target with the same ID already exists.
        /// * If the parent target does not exist.
        /// * If the parent target or invocation is finalized.
        pub async fn create_configured_target(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConfiguredTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfiguredTarget>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/CreateConfiguredTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "CreateConfiguredTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a standard update to the configured target identified by the given
        /// proto's name. For all types of fields (primitive, message, or repeated),
        /// replaces them with the given proto fields if they are under the given
        /// field mask paths. Fields that match the mask but aren't populated in the
        /// given configured target are cleared. This is an implicitly idempotent API.
        ///
        /// Returns an empty ConfiguredTarget proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the configured target does not exist.
        /// * If the parent target or invocation is finalized.
        /// * If no field mask was given.
        pub async fn update_configured_target(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConfiguredTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfiguredTarget>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/UpdateConfiguredTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "UpdateConfiguredTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a merge update to the configured target identified by the given
        /// proto's name. For primitive and message fields, replaces them with the
        /// ones in the given proto if they are covered under the field mask paths.
        /// For repeated fields, merges to them with the given ones if they are
        /// covered under the field mask paths. This is not an implicitly idempotent
        /// API, so a request id is required to make it idempotent.
        ///
        /// Returns an empty ConfiguredTarget proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the configured target does not exist.
        /// * If the parent target or invocation is finalized.
        /// * If no field mask was given.
        pub async fn merge_configured_target(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeConfiguredTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfiguredTarget>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/MergeConfiguredTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "MergeConfiguredTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Declares the configured target with the given name as finalized and
        /// immutable by the user. It may still be mutated by post-processing. This is
        /// an implicitly idempotent API.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the configured target does not exist.
        pub async fn finalize_configured_target(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeConfiguredTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FinalizeConfiguredTargetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/FinalizeConfiguredTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "FinalizeConfiguredTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates the given action under the given configured target. The given
        /// action ID is URL encoded, converted to the full resource name, and
        /// assigned to the action's name field. This is not an implicitly
        /// idempotent API, so a request id is required to make it idempotent.
        ///
        /// Returns an empty Action proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If no action ID provided.
        /// * If the parent configured target does not exist.
        /// * If the parent target or invocation is finalized.
        /// * If an action  with the same name already exists.
        pub async fn create_action(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateActionRequest>,
        ) -> std::result::Result<tonic::Response<super::Action>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/CreateAction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "CreateAction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a standard update to the action identified by the given
        /// proto's name.  For all types of fields (primitive, message, or repeated),
        /// replaces them with the given proto fields if they are under the given
        /// field mask paths.  Fields that match the mask but aren't populated in the
        /// given action are cleared.  This is an implicitly idempotent API.
        ///
        /// Returns an empty Action proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the action does not exist.
        /// * If the parent target or invocation is finalized.
        /// * If no field mask was given.
        pub async fn update_action(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateActionRequest>,
        ) -> std::result::Result<tonic::Response<super::Action>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/UpdateAction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "UpdateAction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a merge update to the action identified by the given
        /// proto's name.  For primitive and message fields, replaces them with the
        /// ones in the given proto if they are covered under the field mask paths.
        /// For repeated fields, merges to them with the given ones if they are
        /// covered under the field mask paths. This is not an implicitly idempotent
        /// API, so a request id is required to make it idempotent.
        ///
        /// Returns an empty Action proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the action does not exist.
        /// * If the parent target or invocation is finalized.
        /// * If no field mask was given.
        pub async fn merge_action(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeActionRequest>,
        ) -> std::result::Result<tonic::Response<super::Action>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/MergeAction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "MergeAction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates the given configuration under the given parent invocation. The
        /// given configuration ID is URL encoded, converted to the full resource name,
        /// and assigned to the configuration's name field. The configuration ID of
        /// "default" should be preferred for the default configuration in a
        /// single-config invocation. This is not an implicitly idempotent API, so a
        /// request id is required to make it idempotent.
        ///
        /// Returns an empty Configuration proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If no configuration ID is provided.
        /// * If the parent invocation does not exist.
        /// * If the parent invocation is finalized.
        /// * If a configuration with the same name already exists.
        pub async fn create_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConfigurationRequest>,
        ) -> std::result::Result<tonic::Response<super::Configuration>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/CreateConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "CreateConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a standard update to the configuration identified by the given
        /// proto's name. For all types of fields (primitive, message, or repeated),
        /// replaces them with the given proto fields if they are under the given field
        /// mask paths. Fields that match the mask but aren't populated in the given
        /// configuration are cleared. This is an implicitly idempotent API.
        ///
        /// Returns an empty Configuration proto with only the name and ID fields
        /// populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the configuration does not exist.
        /// * If the parent invocation is finalized.
        /// * If no field mask was given.
        /// * If a given field mask path is not valid.
        pub async fn update_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConfigurationRequest>,
        ) -> std::result::Result<tonic::Response<super::Configuration>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/UpdateConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "UpdateConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates the given file set under the given parent invocation. The given
        /// file set ID is URL encoded, converted to the full resource name, and
        /// assigned to the file set's name field. This is not an implicitly idempotent
        /// API, so a request id is required to make it idempotent.
        ///
        /// Returns an empty FileSet proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If no file set ID is provided.
        /// * If a file set with the same name already exists.
        /// * If the parent invocation does not exist.
        /// * If the parent invocation is finalized.
        pub async fn create_file_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFileSetRequest>,
        ) -> std::result::Result<tonic::Response<super::FileSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/CreateFileSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "CreateFileSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a standard update to the file set identified by the given proto's
        /// name. For all types of fields (primitive, message, or repeated), replaces
        /// them with the given proto fields if they are under the given field mask
        /// paths. Fields that match the mask but aren't populated in the given
        /// configuration are cleared. This is an implicitly idempotent API.
        ///
        /// Returns an empty FileSet proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the file set does not exist.
        /// * If the parent invocation is finalized.
        /// * If no field mask was given.
        /// * If a given field mask path is not valid.
        pub async fn update_file_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFileSetRequest>,
        ) -> std::result::Result<tonic::Response<super::FileSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/UpdateFileSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "UpdateFileSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a merge update to the file set identified by the given proto's
        /// name. For primitive and message fields, updates them with the ones in the
        /// given proto if they are covered under the field mask paths. For repeated
        /// fields, merges to them with the given ones if they are covered under the
        /// field mask paths. This is not an implicitly idempotent API, so a request
        /// id is required to make it idempotent.
        ///
        /// Returns an empty FileSet proto with only the name and ID fields populated.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the file set does not exist.
        /// * If the parent invocation is finalized.
        /// * If a given field mask path is not valid.
        /// * If no field mask was given.
        pub async fn merge_file_set(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeFileSetRequest>,
        ) -> std::result::Result<tonic::Response<super::FileSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/MergeFileSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "MergeFileSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// This is the RPC used for batch upload. It supports uploading multiple
        /// resources for an invocation in a transaction safe manner.
        ///
        /// To use this RPC, the CreateInvocationRequest must have been provided a
        /// resume_token.
        ///
        /// Combining batch upload with normal upload on a single Invocation is not
        /// supported. If an Invocation is created with a resume_token, all further
        /// calls must be through UploadBatch. If an Invocation is created without
        /// resume_token normal upload, all further upload calls must be through normal
        /// upload RPCs.
        ///
        /// The recommend total size of UploadBatchRequest is 10 MiB. If
        /// it is too large, it may be rejected.
        pub async fn upload_batch(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadBatchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadBatchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/UploadBatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "UploadBatch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Provides a way to read the metadata for an invocation.
        /// The UploadMetadata could still be retrieved by this RPC even the Invocation
        /// has been finalized.
        /// This API requires setting a response FieldMask via 'fields' URL query
        /// parameter or X-Goog-FieldMask HTTP/gRPC header.
        ///
        /// An error will be reported in the following case:
        ///
        /// * If the invocation does not exist.
        /// * If no field mask was given.
        pub async fn get_invocation_upload_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInvocationUploadMetadataRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadMetadata>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreUpload/GetInvocationUploadMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreUpload",
                        "GetInvocationUploadMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileRequest {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub read_offset: i64,
    #[prost(int64, tag = "3")]
    pub read_limit: i64,
    #[prost(string, tag = "4")]
    pub archive_entry: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileTailRequest {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub read_offset: i64,
    #[prost(int64, tag = "3")]
    pub read_limit: i64,
    #[prost(string, tag = "4")]
    pub archive_entry: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileTailResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Generated client implementations.
pub mod result_store_file_download_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This API allows download of File messages referenced in
    /// ResultStore resources.
    #[derive(Debug, Clone)]
    pub struct ResultStoreFileDownloadClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ResultStoreFileDownloadClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResultStoreFileDownloadClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ResultStoreFileDownloadClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the File with the given uri.
        /// returns a stream of bytes to be stitched together in order.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the File is not found.
        /// * If the given File uri is badly formatted.
        pub async fn get_file(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFileRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetFileResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreFileDownload/GetFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreFileDownload",
                        "GetFile",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Retrieves the tail of a File with the given uri.
        ///
        /// An error will be reported in the following cases:
        ///
        /// * If the File is not found.
        /// * If the given File uri is badly formatted.
        pub async fn get_file_tail(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFileTailRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFileTailResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.resultstore.v2.ResultStoreFileDownload/GetFileTail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.resultstore.v2.ResultStoreFileDownload",
                        "GetFileTail",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
