// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComponentSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ComponentEnablementState", tag = "2")]
    pub state: i32,
    #[prost(string, tag = "3")]
    pub project_service_account: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "4")]
    pub detector_settings: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        component_settings::DetectorSettings,
    >,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(
        oneof = "component_settings::SpecificSettings",
        tags = "41, 42, 44, 40"
    )]
    pub specific_settings: ::core::option::Option<component_settings::SpecificSettings>,
}
/// Nested message and enum types in `ComponentSettings`.
pub mod component_settings {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DetectorSettings {
        #[prost(enumeration = "super::ComponentEnablementState", tag = "1")]
        pub state: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SpecificSettings {
        #[prost(message, tag = "41")]
        ContainerThreatDetectionSettings(super::ContainerThreatDetectionSettings),
        #[prost(message, tag = "42")]
        EventThreatDetectionSettings(super::EventThreatDetectionSettings),
        #[prost(message, tag = "44")]
        SecurityHealthAnalyticsSettings(super::SecurityHealthAnalyticsSettings),
        #[prost(message, tag = "40")]
        WebSecurityScannerSettings(super::WebSecurityScanner),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebSecurityScanner {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContainerThreatDetectionSettings {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventThreatDetectionSettings {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityHealthAnalyticsSettings {
    #[prost(message, optional, tag = "1")]
    pub non_org_iam_member_settings:
        ::core::option::Option<security_health_analytics_settings::NonOrgIamMemberSettings>,
    #[prost(message, optional, tag = "2")]
    pub admin_service_account_settings:
        ::core::option::Option<security_health_analytics_settings::AdminServiceAccountSettings>,
}
/// Nested message and enum types in `SecurityHealthAnalyticsSettings`.
pub mod security_health_analytics_settings {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NonOrgIamMemberSettings {
        #[prost(string, repeated, tag = "1")]
        pub approved_identities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdminServiceAccountSettings {
        #[prost(string, repeated, tag = "1")]
        pub approved_identities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComponentEnablementState {
    Unspecified = 0,
    Disable = 1,
    Enable = 2,
    Inherit = 3,
}
impl ComponentEnablementState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ComponentEnablementState::Unspecified => "COMPONENT_ENABLEMENT_STATE_UNSPECIFIED",
            ComponentEnablementState::Disable => "DISABLE",
            ComponentEnablementState::Enable => "ENABLE",
            ComponentEnablementState::Inherit => "INHERIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPONENT_ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "DISABLE" => Some(Self::Disable),
            "ENABLE" => Some(Self::Enable),
            "INHERIT" => Some(Self::Inherit),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BillingSettings {
    #[prost(enumeration = "BillingTier", tag = "1")]
    pub billing_tier: i32,
    #[prost(enumeration = "BillingType", tag = "2")]
    pub billing_type: i32,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BillingTier {
    Unspecified = 0,
    Standard = 1,
    Premium = 2,
}
impl BillingTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BillingTier::Unspecified => "BILLING_TIER_UNSPECIFIED",
            BillingTier::Standard => "STANDARD",
            BillingTier::Premium => "PREMIUM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BILLING_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "STANDARD" => Some(Self::Standard),
            "PREMIUM" => Some(Self::Premium),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BillingType {
    Unspecified = 0,
    Subscription = 1,
    TrialSubscription = 2,
    Alpha = 3,
}
impl BillingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BillingType::Unspecified => "BILLING_TYPE_UNSPECIFIED",
            BillingType::Subscription => "SUBSCRIPTION",
            BillingType::TrialSubscription => "TRIAL_SUBSCRIPTION",
            BillingType::Alpha => "ALPHA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BILLING_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SUBSCRIPTION" => Some(Self::Subscription),
            "TRIAL_SUBSCRIPTION" => Some(Self::TrialSubscription),
            "ALPHA" => Some(Self::Alpha),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SinkSettings {
    #[prost(string, tag = "1")]
    pub logging_sink_project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub billing_settings: ::core::option::Option<BillingSettings>,
    #[prost(enumeration = "settings::OnboardingState", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "5")]
    pub org_service_account: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub sink_settings: ::core::option::Option<SinkSettings>,
    #[prost(map = "string, message", tag = "7")]
    pub component_settings:
        ::std::collections::HashMap<::prost::alloc::string::String, ComponentSettings>,
    #[prost(map = "string, message", tag = "8")]
    pub detector_group_settings: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        settings::DetectorGroupSettings,
    >,
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Settings`.
pub mod settings {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DetectorGroupSettings {
        #[prost(enumeration = "super::ComponentEnablementState", tag = "1")]
        pub state: i32,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum OnboardingState {
        Unspecified = 0,
        Enabled = 1,
        Disabled = 2,
        BillingSelected = 3,
        ProvidersSelected = 4,
        ResourcesSelected = 5,
        OrgServiceAccountCreated = 6,
    }
    impl OnboardingState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OnboardingState::Unspecified => "ONBOARDING_STATE_UNSPECIFIED",
                OnboardingState::Enabled => "ENABLED",
                OnboardingState::Disabled => "DISABLED",
                OnboardingState::BillingSelected => "BILLING_SELECTED",
                OnboardingState::ProvidersSelected => "PROVIDERS_SELECTED",
                OnboardingState::ResourcesSelected => "RESOURCES_SELECTED",
                OnboardingState::OrgServiceAccountCreated => "ORG_SERVICE_ACCOUNT_CREATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ONBOARDING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                "BILLING_SELECTED" => Some(Self::BillingSelected),
                "PROVIDERS_SELECTED" => Some(Self::ProvidersSelected),
                "RESOURCES_SELECTED" => Some(Self::ResourcesSelected),
                "ORG_SERVICE_ACCOUNT_CREATED" => Some(Self::OrgServiceAccountCreated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Detector {
    #[prost(string, tag = "1")]
    pub detector: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub component: ::prost::alloc::string::String,
    #[prost(enumeration = "BillingTier", tag = "3")]
    pub billing_tier: i32,
    #[prost(string, repeated, tag = "4")]
    pub detector_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceAccountRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccount {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub service_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub settings: ::core::option::Option<Settings>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetSettingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetSettingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub settings: ::prost::alloc::vec::Vec<Settings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateEffectiveSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCalculateEffectiveSettingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CalculateEffectiveSettingsRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCalculateEffectiveSettingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub settings: ::prost::alloc::vec::Vec<Settings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetComponentSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateComponentSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub component_settings: ::core::option::Option<ComponentSettings>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetComponentSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateEffectiveComponentSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDetectorsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDetectorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub detectors: ::prost::alloc::vec::Vec<Detector>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListComponentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListComponentsResponse {
    #[prost(string, repeated, tag = "1")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod security_center_settings_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// ## API Overview
    ///
    /// The SecurityCenterSettingsService is a sub-api of
    /// `securitycenter.googleapis.com`. The service provides methods to manage
    /// Security Center Settings, and Component Settings for GCP organizations,
    /// folders, projects, and clusters.
    #[derive(Debug, Clone)]
    pub struct SecurityCenterSettingsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SecurityCenterSettingsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SecurityCenterSettingsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            SecurityCenterSettingsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the organizations service account, if it exists, otherwise it
        /// creates the organization service account. This API is idempotent and
        /// will only create a service account once. On subsequent calls it will
        /// return the previously created service account.  SHA, SCC and CTD Infra
        /// Automation will use this SA.  This SA will not have any permissions when
        /// created.  The UI will provision this via IAM or the user will using
        /// their own internal process. This API only creates SAs on the organization.
        /// Folders are not supported and projects will use per-project SAs associated
        /// with APIs enabled on a project. This API will be called by the UX
        /// onboarding workflow.
        pub async fn get_service_account(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceAccount>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/GetServiceAccount");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "GetServiceAccount",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the Settings.
        pub async fn get_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/GetSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "GetSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the Settings.
        pub async fn update_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/UpdateSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "UpdateSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Reset the organization, folder or project's settings and return
        /// the settings of just that resource to the default.
        ///
        /// Settings are present at the organization, folder, project, and cluster
        /// levels. Using Reset on a sub-organization level will remove that resource's
        /// override and result in the parent's settings being used (eg: if Reset on a
        /// cluster, project settings will be used).
        ///
        /// Using Reset on organization will remove the override that was set and
        /// result in default settings being used.
        pub async fn reset_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetSettingsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/ResetSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "ResetSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of settings.
        pub async fn batch_get_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::BatchGetSettingsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/BatchGetSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "BatchGetSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// CalculateEffectiveSettings looks up all of the Security Center
        /// Settings resources in the GCP resource hierarchy, and calculates the
        /// effective settings on that resource by applying the following rules:
        ///  * Settings provided closer to the target resource take precedence over
        ///    those further away (e.g. folder will override organization level
        ///    settings).
        ///  * Product defaults can be overridden at org, folder, project, and cluster
        ///  levels.
        ///  * Detectors will be filtered out if they belong to a billing tier the
        ///  customer
        ///    has not configured.
        pub async fn calculate_effective_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::CalculateEffectiveSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/CalculateEffectiveSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "CalculateEffectiveSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of effective settings.
        pub async fn batch_calculate_effective_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCalculateEffectiveSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCalculateEffectiveSettingsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/BatchCalculateEffectiveSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "BatchCalculateEffectiveSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the Component Settings.
        pub async fn get_component_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetComponentSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::ComponentSettings>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/GetComponentSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "GetComponentSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the Component Settings.
        pub async fn update_component_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateComponentSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::ComponentSettings>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/UpdateComponentSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "UpdateComponentSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Reset the organization, folder or project's component settings and return
        /// the settings to the default. Settings are present at the
        /// organization, folder and project levels. Using Reset for a folder or
        /// project will remove the override that was set and result in the
        /// organization-level settings being used.
        pub async fn reset_component_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetComponentSettingsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/ResetComponentSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "ResetComponentSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the Effective Component Settings.
        pub async fn calculate_effective_component_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::CalculateEffectiveComponentSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::ComponentSettings>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/CalculateEffectiveComponentSettings");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "CalculateEffectiveComponentSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an unordered list of available detectors.
        pub async fn list_detectors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDetectorsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListDetectorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/ListDetectors");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "ListDetectors",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an unordered list of available SCC components.
        pub async fn list_components(
            &mut self,
            request: impl tonic::IntoRequest<super::ListComponentsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListComponentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService/ListComponents");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.securitycenter.settings.v1beta1.SecurityCenterSettingsService",
                "ListComponents",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
