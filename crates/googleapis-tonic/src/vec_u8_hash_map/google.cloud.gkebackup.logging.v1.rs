// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedRestore {
    #[prost(string, tag = "1")]
    pub backup: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "logged_restore::State", tag = "4")]
    pub state: i32,
    #[prost(string, tag = "5")]
    pub state_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LoggedRestore`.
pub mod logged_restore {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        InProgress = 2,
        Succeeded = 3,
        Failed = 4,
        Deleting = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::InProgress => "IN_PROGRESS",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Namespaces {
    #[prost(string, repeated, tag = "1")]
    pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespacedName {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespacedNames {
    #[prost(message, repeated, tag = "1")]
    pub namespaced_names: ::prost::alloc::vec::Vec<NamespacedName>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionKey {
    #[prost(string, tag = "1")]
    pub gcp_kms_encryption_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedRestorePlan {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub backup_plan: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub cluster: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub restore_config: ::core::option::Option<RestoreConfig>,
    #[prost(map = "string, string", tag = "5")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreConfig {
    #[prost(enumeration = "restore_config::VolumeDataRestorePolicy", tag = "1")]
    pub volume_data_restore_policy: i32,
    #[prost(
        enumeration = "restore_config::ClusterResourceConflictPolicy",
        tag = "2"
    )]
    pub cluster_resource_conflict_policy: i32,
    #[prost(
        enumeration = "restore_config::NamespacedResourceRestoreMode",
        tag = "3"
    )]
    pub namespaced_resource_restore_mode: i32,
    #[prost(message, optional, tag = "4")]
    pub cluster_resource_restore_scope:
        ::core::option::Option<restore_config::ClusterResourceRestoreScope>,
    #[prost(message, repeated, tag = "8")]
    pub substitution_rules: ::prost::alloc::vec::Vec<restore_config::SubstitutionRule>,
    #[prost(
        oneof = "restore_config::NamespacedResourceRestoreScope",
        tags = "5, 6, 7"
    )]
    pub namespaced_resource_restore_scope:
        ::core::option::Option<restore_config::NamespacedResourceRestoreScope>,
}
/// Nested message and enum types in `RestoreConfig`.
pub mod restore_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupKind {
        #[prost(string, tag = "1")]
        pub resource_group: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub resource_kind: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusterResourceRestoreScope {
        #[prost(message, repeated, tag = "1")]
        pub selected_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubstitutionRule {
        #[prost(string, repeated, tag = "1")]
        pub target_namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub target_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
        #[prost(string, tag = "3")]
        pub target_json_path: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub original_value_pattern: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub new_value: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum VolumeDataRestorePolicy {
        Unspecified = 0,
        RestoreVolumeDataFromBackup = 1,
        ReuseVolumeHandleFromBackup = 2,
        NoVolumeDataRestoration = 3,
    }
    impl VolumeDataRestorePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VolumeDataRestorePolicy::Unspecified => "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED",
                VolumeDataRestorePolicy::RestoreVolumeDataFromBackup => {
                    "RESTORE_VOLUME_DATA_FROM_BACKUP"
                }
                VolumeDataRestorePolicy::ReuseVolumeHandleFromBackup => {
                    "REUSE_VOLUME_HANDLE_FROM_BACKUP"
                }
                VolumeDataRestorePolicy::NoVolumeDataRestoration => "NO_VOLUME_DATA_RESTORATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "RESTORE_VOLUME_DATA_FROM_BACKUP" => Some(Self::RestoreVolumeDataFromBackup),
                "REUSE_VOLUME_HANDLE_FROM_BACKUP" => Some(Self::ReuseVolumeHandleFromBackup),
                "NO_VOLUME_DATA_RESTORATION" => Some(Self::NoVolumeDataRestoration),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ClusterResourceConflictPolicy {
        Unspecified = 0,
        UseExistingVersion = 1,
        UseBackupVersion = 2,
    }
    impl ClusterResourceConflictPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClusterResourceConflictPolicy::Unspecified => {
                    "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED"
                }
                ClusterResourceConflictPolicy::UseExistingVersion => "USE_EXISTING_VERSION",
                ClusterResourceConflictPolicy::UseBackupVersion => "USE_BACKUP_VERSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "USE_EXISTING_VERSION" => Some(Self::UseExistingVersion),
                "USE_BACKUP_VERSION" => Some(Self::UseBackupVersion),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum NamespacedResourceRestoreMode {
        Unspecified = 0,
        DeleteAndRestore = 1,
        FailOnConflict = 2,
    }
    impl NamespacedResourceRestoreMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NamespacedResourceRestoreMode::Unspecified => {
                    "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED"
                }
                NamespacedResourceRestoreMode::DeleteAndRestore => "DELETE_AND_RESTORE",
                NamespacedResourceRestoreMode::FailOnConflict => "FAIL_ON_CONFLICT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DELETE_AND_RESTORE" => Some(Self::DeleteAndRestore),
                "FAIL_ON_CONFLICT" => Some(Self::FailOnConflict),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NamespacedResourceRestoreScope {
        #[prost(bool, tag = "5")]
        AllNamespaces(bool),
        #[prost(message, tag = "6")]
        SelectedNamespaces(super::Namespaces),
        #[prost(message, tag = "7")]
        SelectedApplications(super::NamespacedNames),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedBackup {
    #[prost(map = "string, string", tag = "1")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(int32, tag = "2")]
    pub delete_lock_days: i32,
    #[prost(int32, tag = "3")]
    pub retain_days: i32,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "logged_backup::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub state_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LoggedBackup`.
pub mod logged_backup {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        InProgress = 2,
        Succeeded = 3,
        Failed = 4,
        Deleting = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::InProgress => "IN_PROGRESS",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedBackupPlan {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cluster: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub retention_policy: ::core::option::Option<logged_backup_plan::RetentionPolicy>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub backup_schedule: ::core::option::Option<logged_backup_plan::Schedule>,
    #[prost(bool, tag = "6")]
    pub deactivated: bool,
    #[prost(message, optional, tag = "7")]
    pub backup_config: ::core::option::Option<logged_backup_plan::BackupConfig>,
}
/// Nested message and enum types in `LoggedBackupPlan`.
pub mod logged_backup_plan {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RetentionPolicy {
        #[prost(int32, tag = "1")]
        pub backup_delete_lock_days: i32,
        #[prost(int32, tag = "2")]
        pub backup_retain_days: i32,
        #[prost(bool, tag = "3")]
        pub locked: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Schedule {
        #[prost(string, tag = "1")]
        pub cron_schedule: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub paused: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BackupConfig {
        #[prost(bool, tag = "4")]
        pub include_volume_data: bool,
        #[prost(bool, tag = "5")]
        pub include_secrets: bool,
        #[prost(message, optional, tag = "6")]
        pub encryption_key: ::core::option::Option<super::EncryptionKey>,
        #[prost(oneof = "backup_config::BackupScope", tags = "1, 2, 3")]
        pub backup_scope: ::core::option::Option<backup_config::BackupScope>,
    }
    /// Nested message and enum types in `BackupConfig`.
    pub mod backup_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum BackupScope {
            #[prost(bool, tag = "1")]
            AllNamespaces(bool),
            #[prost(message, tag = "2")]
            SelectedNamespaces(super::super::Namespaces),
            #[prost(message, tag = "3")]
            SelectedApplications(super::super::NamespacedNames),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlanChange {
    #[prost(string, tag = "1")]
    pub backup_plan: ::prost::alloc::string::String,
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "4")]
    pub input_backup_plan: ::core::option::Option<LoggedBackupPlan>,
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupChange {
    #[prost(string, tag = "1")]
    pub backup: ::prost::alloc::string::String,
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    #[prost(bool, tag = "3")]
    pub scheduled: bool,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "5")]
    pub input_backup: ::core::option::Option<LoggedBackup>,
    #[prost(message, optional, tag = "6")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlanChange {
    #[prost(string, tag = "1")]
    pub restore_plan: ::prost::alloc::string::String,
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "4")]
    pub input_restore_plan: ::core::option::Option<LoggedRestorePlan>,
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreChange {
    #[prost(string, tag = "1")]
    pub restore: ::prost::alloc::string::String,
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "4")]
    pub input_restore: ::core::option::Option<LoggedRestore>,
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangeType {
    Unspecified = 0,
    Creation = 1,
    Update = 2,
    Deletion = 3,
}
impl ChangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChangeType::Unspecified => "CHANGE_TYPE_UNSPECIFIED",
            ChangeType::Creation => "CREATION",
            ChangeType::Update => "UPDATE",
            ChangeType::Deletion => "DELETION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CREATION" => Some(Self::Creation),
            "UPDATE" => Some(Self::Update),
            "DELETION" => Some(Self::Deletion),
            _ => None,
        }
    }
}
