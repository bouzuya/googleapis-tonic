// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Constraint {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(enumeration = "constraint::ConstraintDefault", tag = "4")]
pub constraint_default: i32,
#[prost(bool, tag = "7")]
pub supports_dry_run: bool,
#[prost(oneof = "constraint::ConstraintType", tags = "5, 6")]
pub constraint_type: ::core::option::Option<constraint::ConstraintType>,
}
/// Nested message and enum types in `Constraint`.
pub mod constraint {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListConstraint {
#[prost(bool, tag = "1")]
pub supports_in: bool,
#[prost(bool, tag = "2")]
pub supports_under: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BooleanConstraint {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConstraintDefault {
Unspecified = 0,
Allow = 1,
Deny = 2,
}
impl ConstraintDefault {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ConstraintDefault::Unspecified => "CONSTRAINT_DEFAULT_UNSPECIFIED",
ConstraintDefault::Allow => "ALLOW",
ConstraintDefault::Deny => "DENY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CONSTRAINT_DEFAULT_UNSPECIFIED" => Some(Self::Unspecified),
"ALLOW" => Some(Self::Allow),
"DENY" => Some(Self::Deny),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum ConstraintType {
#[prost(message, tag = "5")]
ListConstraint(ListConstraint),
#[prost(message, tag = "6")]
BooleanConstraint(BooleanConstraint),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomConstraint {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub resource_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "custom_constraint::MethodType", repeated, tag = "3")]
pub method_types: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "4")]
pub condition: ::prost::alloc::string::String,
#[prost(enumeration = "custom_constraint::ActionType", tag = "5")]
pub action_type: i32,
#[prost(string, tag = "6")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `CustomConstraint`.
pub mod custom_constraint {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MethodType {
Unspecified = 0,
Create = 1,
Update = 2,
Delete = 3,
}
impl MethodType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MethodType::Unspecified => "METHOD_TYPE_UNSPECIFIED",
MethodType::Create => "CREATE",
MethodType::Update => "UPDATE",
MethodType::Delete => "DELETE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"METHOD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATE" => Some(Self::Create),
"UPDATE" => Some(Self::Update),
"DELETE" => Some(Self::Delete),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActionType {
Unspecified = 0,
Allow = 1,
Deny = 2,
}
impl ActionType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ActionType::Unspecified => "ACTION_TYPE_UNSPECIFIED",
ActionType::Allow => "ALLOW",
ActionType::Deny => "DENY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ALLOW" => Some(Self::Allow),
"DENY" => Some(Self::Deny),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Policy {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub spec: ::core::option::Option<PolicySpec>,
#[deprecated]
#[prost(message, optional, tag = "3")]
pub alternate: ::core::option::Option<AlternatePolicySpec>,
#[prost(message, optional, tag = "4")]
pub dry_run_spec: ::core::option::Option<PolicySpec>,
#[prost(string, tag = "5")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlternatePolicySpec {
#[prost(string, tag = "1")]
pub launch: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub spec: ::core::option::Option<PolicySpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicySpec {
#[prost(string, tag = "1")]
pub etag: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, repeated, tag = "3")]
pub rules: ::prost::alloc::vec::Vec<policy_spec::PolicyRule>,
#[prost(bool, tag = "4")]
pub inherit_from_parent: bool,
#[prost(bool, tag = "5")]
pub reset: bool,
}
/// Nested message and enum types in `PolicySpec`.
pub mod policy_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyRule {
#[prost(message, optional, tag = "5")]
pub condition: ::core::option::Option<super::super::super::super::r#type::Expr>,
#[prost(oneof = "policy_rule::Kind", tags = "1, 2, 3, 4")]
pub kind: ::core::option::Option<policy_rule::Kind>,
}
/// Nested message and enum types in `PolicyRule`.
pub mod policy_rule {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringValues {
#[prost(string, repeated, tag = "1")]
pub allowed_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "2")]
pub denied_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(message, tag = "1")]
Values(StringValues),
#[prost(bool, tag = "2")]
AllowAll(bool),
#[prost(bool, tag = "3")]
DenyAll(bool),
#[prost(bool, tag = "4")]
Enforce(bool),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConstraintsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConstraintsResponse {
#[prost(message, repeated, tag = "1")]
pub constraints: ::prost::alloc::vec::Vec<Constraint>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoliciesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoliciesResponse {
#[prost(message, repeated, tag = "1")]
pub policies: ::prost::alloc::vec::Vec<Policy>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPolicyRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectivePolicyRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePolicyRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub policy: ::core::option::Option<Policy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePolicyRequest {
#[prost(message, optional, tag = "1")]
pub policy: ::core::option::Option<Policy>,
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePolicyRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomConstraintRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub custom_constraint: ::core::option::Option<CustomConstraint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomConstraintRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomConstraintsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomConstraintsResponse {
#[prost(message, repeated, tag = "1")]
pub custom_constraints: ::prost::alloc::vec::Vec<CustomConstraint>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomConstraintRequest {
#[prost(message, optional, tag = "1")]
pub custom_constraint: ::core::option::Option<CustomConstraint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomConstraintRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod org_policy_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// An interface for managing organization policies.
///
/// The Organization Policy Service provides a simple mechanism for
/// organizations to restrict the allowed configurations across their entire
/// resource hierarchy.
///
/// You can use a policy to configure restrictions on resources. For
/// example, you can enforce a policy that restricts which Google
/// Cloud APIs can be activated in a certain part of your resource
/// hierarchy, or prevents serial port access to VM instances in a
/// particular folder.
///
/// Policies are inherited down through the resource hierarchy. A policy
/// applied to a parent resource automatically applies to all its child resources
/// unless overridden with a policy lower in the hierarchy.
///
/// A constraint defines an aspect of a resource's configuration that can be
/// controlled by an organization's policy administrator. Policies are a
/// collection of constraints that defines their allowable configuration on a
/// particular resource and its child resources.
#[derive(Debug, Clone)]
pub struct OrgPolicyClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> OrgPolicyClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> OrgPolicyClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
OrgPolicyClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Lists constraints that could be applied on the specified resource.
pub async fn list_constraints(&mut self, request: impl tonic::IntoRequest<super::ListConstraintsRequest>) -> std::result::Result<tonic::Response<super::ListConstraintsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/ListConstraints");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "ListConstraints"));
self.inner.unary(req, path, codec).await
}
/// Retrieves all of the policies that exist on a particular resource.
pub async fn list_policies(&mut self, request: impl tonic::IntoRequest<super::ListPoliciesRequest>) -> std::result::Result<tonic::Response<super::ListPoliciesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/ListPolicies");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "ListPolicies"));
self.inner.unary(req, path, codec).await
}
/// Gets a policy on a resource.
///
/// If no policy is set on the resource, `NOT_FOUND` is returned. The
/// `etag` value can be used with `UpdatePolicy()` to update a
/// policy during read-modify-write.
pub async fn get_policy(&mut self, request: impl tonic::IntoRequest<super::GetPolicyRequest>) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/GetPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "GetPolicy"));
self.inner.unary(req, path, codec).await
}
/// Gets the effective policy on a resource. This is the result of merging
/// policies in the resource hierarchy and evaluating conditions. The
/// returned policy will not have an `etag` or `condition` set because it is
/// an evaluated policy across multiple resources.
/// Subtrees of Resource Manager resource hierarchy with 'under:' prefix will
/// not be expanded.
pub async fn get_effective_policy(&mut self, request: impl tonic::IntoRequest<super::GetEffectivePolicyRequest>) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/GetEffectivePolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "GetEffectivePolicy"));
self.inner.unary(req, path, codec).await
}
/// Creates a policy.
///
/// Returns a `google.rpc.Status` with `google.rpc.Code.NOT_FOUND` if the
/// constraint does not exist.
/// Returns a `google.rpc.Status` with `google.rpc.Code.ALREADY_EXISTS` if the
/// policy already exists on the given Google Cloud resource.
pub async fn create_policy(&mut self, request: impl tonic::IntoRequest<super::CreatePolicyRequest>) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/CreatePolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "CreatePolicy"));
self.inner.unary(req, path, codec).await
}
/// Updates a policy.
///
/// Returns a `google.rpc.Status` with `google.rpc.Code.NOT_FOUND` if the
/// constraint or the policy do not exist.
/// Returns a `google.rpc.Status` with `google.rpc.Code.ABORTED` if the etag
/// supplied in the request does not match the persisted etag of the policy
///
/// Note: the supplied policy will perform a full overwrite of all
/// fields.
pub async fn update_policy(&mut self, request: impl tonic::IntoRequest<super::UpdatePolicyRequest>) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/UpdatePolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "UpdatePolicy"));
self.inner.unary(req, path, codec).await
}
/// Deletes a policy.
///
/// Returns a `google.rpc.Status` with `google.rpc.Code.NOT_FOUND` if the
/// constraint or organization policy does not exist.
pub async fn delete_policy(&mut self, request: impl tonic::IntoRequest<super::DeletePolicyRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/DeletePolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "DeletePolicy"));
self.inner.unary(req, path, codec).await
}
/// Creates a custom constraint.
///
/// Returns a `google.rpc.Status` with `google.rpc.Code.NOT_FOUND` if the
/// organization does not exist.
/// Returns a `google.rpc.Status` with `google.rpc.Code.ALREADY_EXISTS` if the
/// constraint already exists on the given organization.
pub async fn create_custom_constraint(&mut self, request: impl tonic::IntoRequest<super::CreateCustomConstraintRequest>) -> std::result::Result<tonic::Response<super::CustomConstraint>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/CreateCustomConstraint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "CreateCustomConstraint"));
self.inner.unary(req, path, codec).await
}
/// Updates a custom constraint.
///
/// Returns a `google.rpc.Status` with `google.rpc.Code.NOT_FOUND` if the
/// constraint does not exist.
///
/// Note: the supplied policy will perform a full overwrite of all
/// fields.
pub async fn update_custom_constraint(&mut self, request: impl tonic::IntoRequest<super::UpdateCustomConstraintRequest>) -> std::result::Result<tonic::Response<super::CustomConstraint>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/UpdateCustomConstraint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "UpdateCustomConstraint"));
self.inner.unary(req, path, codec).await
}
/// Gets a custom constraint.
///
/// Returns a `google.rpc.Status` with `google.rpc.Code.NOT_FOUND` if the
/// custom constraint does not exist.
pub async fn get_custom_constraint(&mut self, request: impl tonic::IntoRequest<super::GetCustomConstraintRequest>) -> std::result::Result<tonic::Response<super::CustomConstraint>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/GetCustomConstraint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "GetCustomConstraint"));
self.inner.unary(req, path, codec).await
}
/// Retrieves all of the custom constraints that exist on a particular
/// organization resource.
pub async fn list_custom_constraints(&mut self, request: impl tonic::IntoRequest<super::ListCustomConstraintsRequest>) -> std::result::Result<tonic::Response<super::ListCustomConstraintsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/ListCustomConstraints");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "ListCustomConstraints"));
self.inner.unary(req, path, codec).await
}
/// Deletes a custom constraint.
///
/// Returns a `google.rpc.Status` with `google.rpc.Code.NOT_FOUND` if the
/// constraint does not exist.
pub async fn delete_custom_constraint(&mut self, request: impl tonic::IntoRequest<super::DeleteCustomConstraintRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.orgpolicy.v2.OrgPolicy/DeleteCustomConstraint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.orgpolicy.v2.OrgPolicy", "DeleteCustomConstraint"));
self.inner.unary(req, path, codec).await
}
}
}
