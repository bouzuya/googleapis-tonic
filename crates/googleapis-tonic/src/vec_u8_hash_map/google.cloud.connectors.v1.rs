// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigVariableTemplate {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(enumeration = "config_variable_template::ValueType", tag = "2")]
    pub value_type: i32,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub validation_regex: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub required: bool,
    #[prost(message, optional, tag = "7")]
    pub role_grant: ::core::option::Option<RoleGrant>,
    #[prost(message, repeated, tag = "8")]
    pub enum_options: ::prost::alloc::vec::Vec<EnumOption>,
    #[prost(message, optional, tag = "9")]
    pub authorization_code_link: ::core::option::Option<AuthorizationCodeLink>,
    #[prost(enumeration = "config_variable_template::State", tag = "10")]
    pub state: i32,
    #[prost(bool, tag = "11")]
    pub is_advanced: bool,
}
/// Nested message and enum types in `ConfigVariableTemplate`.
pub mod config_variable_template {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ValueType {
        Unspecified = 0,
        String = 1,
        Int = 2,
        Bool = 3,
        Secret = 4,
        Enum = 5,
        AuthorizationCode = 6,
    }
    impl ValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ValueType::Unspecified => "VALUE_TYPE_UNSPECIFIED",
                ValueType::String => "STRING",
                ValueType::Int => "INT",
                ValueType::Bool => "BOOL",
                ValueType::Secret => "SECRET",
                ValueType::Enum => "ENUM",
                ValueType::AuthorizationCode => "AUTHORIZATION_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "INT" => Some(Self::Int),
                "BOOL" => Some(Self::Bool),
                "SECRET" => Some(Self::Secret),
                "ENUM" => Some(Self::Enum),
                "AUTHORIZATION_CODE" => Some(Self::AuthorizationCode),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Deprecated = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Deprecated => "DEPRECATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "DEPRECATED" => Some(Self::Deprecated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
    #[prost(string, tag = "1")]
    pub secret_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumOption {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigVariable {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(oneof = "config_variable::Value", tags = "2, 3, 4, 5")]
    pub value: ::core::option::Option<config_variable::Value>,
}
/// Nested message and enum types in `ConfigVariable`.
pub mod config_variable {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "2")]
        IntValue(i64),
        #[prost(bool, tag = "3")]
        BoolValue(bool),
        #[prost(string, tag = "4")]
        StringValue(::prost::alloc::string::String),
        #[prost(message, tag = "5")]
        SecretValue(super::Secret),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoleGrant {
    #[prost(enumeration = "role_grant::Principal", tag = "1")]
    pub principal: i32,
    #[prost(string, repeated, tag = "2")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub resource: ::core::option::Option<role_grant::Resource>,
    #[prost(string, tag = "4")]
    pub helper_text_template: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RoleGrant`.
pub mod role_grant {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Resource {
        #[prost(enumeration = "resource::Type", tag = "1")]
        pub r#type: i32,
        #[prost(string, tag = "3")]
        pub path_template: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Resource`.
    pub mod resource {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            GcpProject = 1,
            GcpResource = 2,
            GcpSecretmanagerSecret = 3,
            GcpSecretmanagerSecretVersion = 4,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::GcpProject => "GCP_PROJECT",
                    Type::GcpResource => "GCP_RESOURCE",
                    Type::GcpSecretmanagerSecret => "GCP_SECRETMANAGER_SECRET",
                    Type::GcpSecretmanagerSecretVersion => "GCP_SECRETMANAGER_SECRET_VERSION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "GCP_PROJECT" => Some(Self::GcpProject),
                    "GCP_RESOURCE" => Some(Self::GcpResource),
                    "GCP_SECRETMANAGER_SECRET" => Some(Self::GcpSecretmanagerSecret),
                    "GCP_SECRETMANAGER_SECRET_VERSION" => Some(Self::GcpSecretmanagerSecretVersion),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Principal {
        Unspecified = 0,
        ConnectorSa = 1,
    }
    impl Principal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Principal::Unspecified => "PRINCIPAL_UNSPECIFIED",
                Principal::ConnectorSa => "CONNECTOR_SA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRINCIPAL_UNSPECIFIED" => Some(Self::Unspecified),
                "CONNECTOR_SA" => Some(Self::ConnectorSa),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorizationCodeLink {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub enable_pkce: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LaunchStage {
    Unspecified = 0,
    Preview = 1,
    Ga = 2,
    Deprecated = 3,
    PrivatePreview = 5,
}
impl LaunchStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LaunchStage::Unspecified => "LAUNCH_STAGE_UNSPECIFIED",
            LaunchStage::Preview => "PREVIEW",
            LaunchStage::Ga => "GA",
            LaunchStage::Deprecated => "DEPRECATED",
            LaunchStage::PrivatePreview => "PRIVATE_PREVIEW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LAUNCH_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "PREVIEW" => Some(Self::Preview),
            "GA" => Some(Self::Ga),
            "DEPRECATED" => Some(Self::Deprecated),
            "PRIVATE_PREVIEW" => Some(Self::PrivatePreview),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthConfig {
    #[prost(enumeration = "AuthType", tag = "1")]
    pub auth_type: i32,
    #[prost(message, repeated, tag = "5")]
    pub additional_variables: ::prost::alloc::vec::Vec<ConfigVariable>,
    #[prost(oneof = "auth_config::Type", tags = "2, 3, 4, 6")]
    pub r#type: ::core::option::Option<auth_config::Type>,
}
/// Nested message and enum types in `AuthConfig`.
pub mod auth_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserPassword {
        #[prost(string, tag = "1")]
        pub username: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub password: ::core::option::Option<super::Secret>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Oauth2JwtBearer {
        #[prost(message, optional, tag = "1")]
        pub client_key: ::core::option::Option<super::Secret>,
        #[prost(message, optional, tag = "2")]
        pub jwt_claims: ::core::option::Option<oauth2_jwt_bearer::JwtClaims>,
    }
    /// Nested message and enum types in `Oauth2JwtBearer`.
    pub mod oauth2_jwt_bearer {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JwtClaims {
            #[prost(string, tag = "1")]
            pub issuer: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub subject: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub audience: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Oauth2ClientCredentials {
        #[prost(string, tag = "1")]
        pub client_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub client_secret: ::core::option::Option<super::Secret>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SshPublicKey {
        #[prost(string, tag = "1")]
        pub username: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub ssh_client_cert: ::core::option::Option<super::Secret>,
        #[prost(string, tag = "4")]
        pub cert_type: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub ssh_client_cert_pass: ::core::option::Option<super::Secret>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "2")]
        UserPassword(UserPassword),
        #[prost(message, tag = "3")]
        Oauth2JwtBearer(Oauth2JwtBearer),
        #[prost(message, tag = "4")]
        Oauth2ClientCredentials(Oauth2ClientCredentials),
        #[prost(message, tag = "6")]
        SshPublicKey(SshPublicKey),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthConfigTemplate {
    #[prost(enumeration = "AuthType", tag = "1")]
    pub auth_type: i32,
    #[prost(message, repeated, tag = "2")]
    pub config_variable_templates: ::prost::alloc::vec::Vec<ConfigVariableTemplate>,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthType {
    Unspecified = 0,
    UserPassword = 1,
    Oauth2JwtBearer = 2,
    Oauth2ClientCredentials = 3,
    SshPublicKey = 4,
    Oauth2AuthCodeFlow = 5,
}
impl AuthType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuthType::Unspecified => "AUTH_TYPE_UNSPECIFIED",
            AuthType::UserPassword => "USER_PASSWORD",
            AuthType::Oauth2JwtBearer => "OAUTH2_JWT_BEARER",
            AuthType::Oauth2ClientCredentials => "OAUTH2_CLIENT_CREDENTIALS",
            AuthType::SshPublicKey => "SSH_PUBLIC_KEY",
            AuthType::Oauth2AuthCodeFlow => "OAUTH2_AUTH_CODE_FLOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_PASSWORD" => Some(Self::UserPassword),
            "OAUTH2_JWT_BEARER" => Some(Self::Oauth2JwtBearer),
            "OAUTH2_CLIENT_CREDENTIALS" => Some(Self::Oauth2ClientCredentials),
            "SSH_PUBLIC_KEY" => Some(Self::SshPublicKey),
            "OAUTH2_AUTH_CODE_FLOW" => Some(Self::Oauth2AuthCodeFlow),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslConfigTemplate {
    #[prost(enumeration = "SslType", tag = "1")]
    pub ssl_type: i32,
    #[prost(bool, tag = "2")]
    pub is_tls_mandatory: bool,
    #[prost(enumeration = "CertType", repeated, tag = "3")]
    pub server_cert_type: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "CertType", repeated, tag = "4")]
    pub client_cert_type: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "5")]
    pub additional_variables: ::prost::alloc::vec::Vec<ConfigVariableTemplate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslConfig {
    #[prost(enumeration = "SslType", tag = "1")]
    pub r#type: i32,
    #[prost(enumeration = "ssl_config::TrustModel", tag = "2")]
    pub trust_model: i32,
    #[prost(message, optional, tag = "3")]
    pub private_server_certificate: ::core::option::Option<Secret>,
    #[prost(message, optional, tag = "4")]
    pub client_certificate: ::core::option::Option<Secret>,
    #[prost(message, optional, tag = "5")]
    pub client_private_key: ::core::option::Option<Secret>,
    #[prost(message, optional, tag = "6")]
    pub client_private_key_pass: ::core::option::Option<Secret>,
    #[prost(enumeration = "CertType", tag = "7")]
    pub server_cert_type: i32,
    #[prost(enumeration = "CertType", tag = "8")]
    pub client_cert_type: i32,
    #[prost(bool, tag = "9")]
    pub use_ssl: bool,
    #[prost(message, repeated, tag = "10")]
    pub additional_variables: ::prost::alloc::vec::Vec<ConfigVariable>,
}
/// Nested message and enum types in `SslConfig`.
pub mod ssl_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TrustModel {
        Public = 0,
        Private = 1,
        Insecure = 2,
    }
    impl TrustModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TrustModel::Public => "PUBLIC",
                TrustModel::Private => "PRIVATE",
                TrustModel::Insecure => "INSECURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PUBLIC" => Some(Self::Public),
                "PRIVATE" => Some(Self::Private),
                "INSECURE" => Some(Self::Insecure),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SslType {
    Unspecified = 0,
    Tls = 1,
    Mtls = 2,
}
impl SslType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SslType::Unspecified => "SSL_TYPE_UNSPECIFIED",
            SslType::Tls => "TLS",
            SslType::Mtls => "MTLS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SSL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TLS" => Some(Self::Tls),
            "MTLS" => Some(Self::Mtls),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CertType {
    Unspecified = 0,
    Pem = 1,
}
impl CertType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CertType::Unspecified => "CERT_TYPE_UNSPECIFIED",
            CertType::Pem => "PEM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CERT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PEM" => Some(Self::Pem),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectorVersion {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(enumeration = "LaunchStage", tag = "6")]
    pub launch_stage: i32,
    #[prost(string, tag = "7")]
    pub release_version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub auth_config_templates: ::prost::alloc::vec::Vec<AuthConfigTemplate>,
    #[prost(message, repeated, tag = "9")]
    pub config_variable_templates: ::prost::alloc::vec::Vec<ConfigVariableTemplate>,
    #[prost(message, optional, tag = "10")]
    pub supported_runtime_features: ::core::option::Option<SupportedRuntimeFeatures>,
    #[prost(string, tag = "11")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub egress_control_config: ::core::option::Option<EgressControlConfig>,
    #[prost(message, repeated, tag = "14")]
    pub role_grants: ::prost::alloc::vec::Vec<RoleGrant>,
    #[prost(message, optional, tag = "15")]
    pub role_grant: ::core::option::Option<RoleGrant>,
    #[prost(message, optional, tag = "17")]
    pub ssl_config_template: ::core::option::Option<SslConfigTemplate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectorVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ConnectorVersionView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectorVersionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "ConnectorVersionView", tag = "4")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectorVersionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connector_versions: ::prost::alloc::vec::Vec<ConnectorVersion>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SupportedRuntimeFeatures {
    #[prost(bool, tag = "1")]
    pub entity_apis: bool,
    #[prost(bool, tag = "2")]
    pub action_apis: bool,
    #[prost(bool, tag = "3")]
    pub sql_query: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgressControlConfig {
    #[prost(oneof = "egress_control_config::OneofBackends", tags = "1, 2")]
    pub oneof_backends: ::core::option::Option<egress_control_config::OneofBackends>,
}
/// Nested message and enum types in `EgressControlConfig`.
pub mod egress_control_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneofBackends {
        #[prost(string, tag = "1")]
        Backends(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        ExtractionRules(super::ExtractionRules),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtractionRules {
    #[prost(message, repeated, tag = "1")]
    pub extraction_rule: ::prost::alloc::vec::Vec<ExtractionRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtractionRule {
    #[prost(message, optional, tag = "1")]
    pub source: ::core::option::Option<extraction_rule::Source>,
    #[prost(string, tag = "2")]
    pub extraction_regex: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExtractionRule`.
pub mod extraction_rule {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Source {
        #[prost(enumeration = "SourceType", tag = "1")]
        pub source_type: i32,
        #[prost(string, tag = "2")]
        pub field_id: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SourceType {
        Unspecified = 0,
        ConfigVariable = 1,
    }
    impl SourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceType::Unspecified => "SOURCE_TYPE_UNSPECIFIED",
                SourceType::ConfigVariable => "CONFIG_VARIABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONFIG_VARIABLE" => Some(Self::ConfigVariable),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectorVersionView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl ConnectorVersionView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ConnectorVersionView::Unspecified => "CONNECTOR_VERSION_VIEW_UNSPECIFIED",
            ConnectorVersionView::Basic => "CONNECTOR_VERSION_VIEW_BASIC",
            ConnectorVersionView::Full => "CONNECTOR_VERSION_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECTOR_VERSION_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "CONNECTOR_VERSION_VIEW_BASIC" => Some(Self::Basic),
            "CONNECTOR_VERSION_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Connector {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub documentation_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub external_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub web_assets_location: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "LaunchStage", tag = "11")]
    pub launch_stage: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectorsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connectors: ::prost::alloc::vec::Vec<Connector>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub vpcsc: bool,
    #[prost(bool, tag = "3")]
    pub payg: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestinationConfig {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub destinations: ::prost::alloc::vec::Vec<Destination>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Destination {
    #[prost(int32, tag = "3")]
    pub port: i32,
    #[prost(oneof = "destination::Destination", tags = "1, 2")]
    pub destination: ::core::option::Option<destination::Destination>,
}
/// Nested message and enum types in `Destination`.
pub mod destination {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(string, tag = "1")]
        ServiceAttachment(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        Host(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Connection {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub connector_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub status: ::core::option::Option<ConnectionStatus>,
    #[prost(message, repeated, tag = "8")]
    pub config_variables: ::prost::alloc::vec::Vec<ConfigVariable>,
    #[prost(message, optional, tag = "9")]
    pub auth_config: ::core::option::Option<AuthConfig>,
    #[prost(message, optional, tag = "10")]
    pub lock_config: ::core::option::Option<LockConfig>,
    #[prost(message, repeated, tag = "18")]
    pub destination_configs: ::prost::alloc::vec::Vec<DestinationConfig>,
    #[prost(string, tag = "11")]
    pub image_location: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub service_directory: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub envoy_image_location: ::prost::alloc::string::String,
    #[prost(bool, tag = "17")]
    pub suspended: bool,
    #[prost(message, optional, tag = "19")]
    pub node_config: ::core::option::Option<NodeConfig>,
    #[prost(message, optional, tag = "21")]
    pub ssl_config: ::core::option::Option<SslConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodeConfig {
    #[prost(int32, tag = "1")]
    pub min_node_count: i32,
    #[prost(int32, tag = "2")]
    pub max_node_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionSchemaMetadata {
    #[prost(string, repeated, tag = "1")]
    pub entities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub refresh_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "connection_schema_metadata::State", tag = "6")]
    pub state: i32,
}
/// Nested message and enum types in `ConnectionSchemaMetadata`.
pub mod connection_schema_metadata {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Refreshing = 1,
        Updated = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Refreshing => "REFRESHING",
                State::Updated => "UPDATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REFRESHING" => Some(Self::Refreshing),
                "UPDATED" => Some(Self::Updated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeEntitySchema {
    #[prost(string, tag = "1")]
    pub entity: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<runtime_entity_schema::Field>,
}
/// Nested message and enum types in `RuntimeEntitySchema`.
pub mod runtime_entity_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Field {
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(enumeration = "super::DataType", tag = "3")]
        pub data_type: i32,
        #[prost(bool, tag = "4")]
        pub key: bool,
        #[prost(bool, tag = "5")]
        pub readonly: bool,
        #[prost(bool, tag = "6")]
        pub nullable: bool,
        #[prost(message, optional, tag = "7")]
        pub default_value: ::core::option::Option<::prost_types::Value>,
        #[prost(message, optional, tag = "8")]
        pub additional_details: ::core::option::Option<::prost_types::Struct>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeActionSchema {
    #[prost(string, tag = "1")]
    pub action: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub input_parameters: ::prost::alloc::vec::Vec<runtime_action_schema::InputParameter>,
    #[prost(message, repeated, tag = "3")]
    pub result_metadata: ::prost::alloc::vec::Vec<runtime_action_schema::ResultMetadata>,
}
/// Nested message and enum types in `RuntimeActionSchema`.
pub mod runtime_action_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputParameter {
        #[prost(string, tag = "1")]
        pub parameter: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(enumeration = "super::DataType", tag = "3")]
        pub data_type: i32,
        #[prost(bool, tag = "4")]
        pub nullable: bool,
        #[prost(message, optional, tag = "5")]
        pub default_value: ::core::option::Option<::prost_types::Value>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResultMetadata {
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(enumeration = "super::DataType", tag = "3")]
        pub data_type: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockConfig {
    #[prost(bool, tag = "1")]
    pub locked: bool,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(enumeration = "ConnectionView", tag = "6")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connections: ::prost::alloc::vec::Vec<Connection>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ConnectionView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConnectionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub connection_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub connection: ::core::option::Option<Connection>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConnectionRequest {
    #[prost(message, optional, tag = "1")]
    pub connection: ::core::option::Option<Connection>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConnectionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectionSchemaMetadataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshConnectionSchemaMetadataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeEntitySchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeEntitySchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub runtime_entity_schemas: ::prost::alloc::vec::Vec<RuntimeEntitySchema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeActionSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeActionSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub runtime_action_schemas: ::prost::alloc::vec::Vec<RuntimeActionSchema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionStatus {
    #[prost(enumeration = "connection_status::State", tag = "1")]
    pub state: i32,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ConnectionStatus`.
pub mod connection_status {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Inactive = 3,
        Deleting = 4,
        Updating = 5,
        Error = 6,
        AuthorizationRequired = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Inactive => "INACTIVE",
                State::Deleting => "DELETING",
                State::Updating => "UPDATING",
                State::Error => "ERROR",
                State::AuthorizationRequired => "AUTHORIZATION_REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "DELETING" => Some(Self::Deleting),
                "UPDATING" => Some(Self::Updating),
                "ERROR" => Some(Self::Error),
                "AUTHORIZATION_REQUIRED" => Some(Self::AuthorizationRequired),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataType {
    Unspecified = 0,
    Int = 1,
    Smallint = 2,
    Double = 3,
    Date = 4,
    Datetime = 5,
    Time = 6,
    String = 7,
    Long = 8,
    Boolean = 9,
    Decimal = 10,
    Uuid = 11,
    Blob = 12,
    Bit = 13,
    Tinyint = 14,
    Integer = 15,
    Bigint = 16,
    Float = 17,
    Real = 18,
    Numeric = 19,
    Char = 20,
    Varchar = 21,
    Longvarchar = 22,
    Timestamp = 23,
    Nchar = 24,
    Nvarchar = 25,
    Longnvarchar = 26,
    Null = 27,
    Other = 28,
    JavaObject = 29,
    Distinct = 30,
    Struct = 31,
    Array = 32,
    Clob = 33,
    Ref = 34,
    Datalink = 35,
    Rowid = 36,
    Binary = 37,
    Varbinary = 38,
    Longvarbinary = 39,
    Nclob = 40,
    Sqlxml = 41,
    RefCursor = 42,
    TimeWithTimezone = 43,
    TimestampWithTimezone = 44,
}
impl DataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DataType::Unspecified => "DATA_TYPE_UNSPECIFIED",
            DataType::Int => "DATA_TYPE_INT",
            DataType::Smallint => "DATA_TYPE_SMALLINT",
            DataType::Double => "DATA_TYPE_DOUBLE",
            DataType::Date => "DATA_TYPE_DATE",
            DataType::Datetime => "DATA_TYPE_DATETIME",
            DataType::Time => "DATA_TYPE_TIME",
            DataType::String => "DATA_TYPE_STRING",
            DataType::Long => "DATA_TYPE_LONG",
            DataType::Boolean => "DATA_TYPE_BOOLEAN",
            DataType::Decimal => "DATA_TYPE_DECIMAL",
            DataType::Uuid => "DATA_TYPE_UUID",
            DataType::Blob => "DATA_TYPE_BLOB",
            DataType::Bit => "DATA_TYPE_BIT",
            DataType::Tinyint => "DATA_TYPE_TINYINT",
            DataType::Integer => "DATA_TYPE_INTEGER",
            DataType::Bigint => "DATA_TYPE_BIGINT",
            DataType::Float => "DATA_TYPE_FLOAT",
            DataType::Real => "DATA_TYPE_REAL",
            DataType::Numeric => "DATA_TYPE_NUMERIC",
            DataType::Char => "DATA_TYPE_CHAR",
            DataType::Varchar => "DATA_TYPE_VARCHAR",
            DataType::Longvarchar => "DATA_TYPE_LONGVARCHAR",
            DataType::Timestamp => "DATA_TYPE_TIMESTAMP",
            DataType::Nchar => "DATA_TYPE_NCHAR",
            DataType::Nvarchar => "DATA_TYPE_NVARCHAR",
            DataType::Longnvarchar => "DATA_TYPE_LONGNVARCHAR",
            DataType::Null => "DATA_TYPE_NULL",
            DataType::Other => "DATA_TYPE_OTHER",
            DataType::JavaObject => "DATA_TYPE_JAVA_OBJECT",
            DataType::Distinct => "DATA_TYPE_DISTINCT",
            DataType::Struct => "DATA_TYPE_STRUCT",
            DataType::Array => "DATA_TYPE_ARRAY",
            DataType::Clob => "DATA_TYPE_CLOB",
            DataType::Ref => "DATA_TYPE_REF",
            DataType::Datalink => "DATA_TYPE_DATALINK",
            DataType::Rowid => "DATA_TYPE_ROWID",
            DataType::Binary => "DATA_TYPE_BINARY",
            DataType::Varbinary => "DATA_TYPE_VARBINARY",
            DataType::Longvarbinary => "DATA_TYPE_LONGVARBINARY",
            DataType::Nclob => "DATA_TYPE_NCLOB",
            DataType::Sqlxml => "DATA_TYPE_SQLXML",
            DataType::RefCursor => "DATA_TYPE_REF_CURSOR",
            DataType::TimeWithTimezone => "DATA_TYPE_TIME_WITH_TIMEZONE",
            DataType::TimestampWithTimezone => "DATA_TYPE_TIMESTAMP_WITH_TIMEZONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_TYPE_INT" => Some(Self::Int),
            "DATA_TYPE_SMALLINT" => Some(Self::Smallint),
            "DATA_TYPE_DOUBLE" => Some(Self::Double),
            "DATA_TYPE_DATE" => Some(Self::Date),
            "DATA_TYPE_DATETIME" => Some(Self::Datetime),
            "DATA_TYPE_TIME" => Some(Self::Time),
            "DATA_TYPE_STRING" => Some(Self::String),
            "DATA_TYPE_LONG" => Some(Self::Long),
            "DATA_TYPE_BOOLEAN" => Some(Self::Boolean),
            "DATA_TYPE_DECIMAL" => Some(Self::Decimal),
            "DATA_TYPE_UUID" => Some(Self::Uuid),
            "DATA_TYPE_BLOB" => Some(Self::Blob),
            "DATA_TYPE_BIT" => Some(Self::Bit),
            "DATA_TYPE_TINYINT" => Some(Self::Tinyint),
            "DATA_TYPE_INTEGER" => Some(Self::Integer),
            "DATA_TYPE_BIGINT" => Some(Self::Bigint),
            "DATA_TYPE_FLOAT" => Some(Self::Float),
            "DATA_TYPE_REAL" => Some(Self::Real),
            "DATA_TYPE_NUMERIC" => Some(Self::Numeric),
            "DATA_TYPE_CHAR" => Some(Self::Char),
            "DATA_TYPE_VARCHAR" => Some(Self::Varchar),
            "DATA_TYPE_LONGVARCHAR" => Some(Self::Longvarchar),
            "DATA_TYPE_TIMESTAMP" => Some(Self::Timestamp),
            "DATA_TYPE_NCHAR" => Some(Self::Nchar),
            "DATA_TYPE_NVARCHAR" => Some(Self::Nvarchar),
            "DATA_TYPE_LONGNVARCHAR" => Some(Self::Longnvarchar),
            "DATA_TYPE_NULL" => Some(Self::Null),
            "DATA_TYPE_OTHER" => Some(Self::Other),
            "DATA_TYPE_JAVA_OBJECT" => Some(Self::JavaObject),
            "DATA_TYPE_DISTINCT" => Some(Self::Distinct),
            "DATA_TYPE_STRUCT" => Some(Self::Struct),
            "DATA_TYPE_ARRAY" => Some(Self::Array),
            "DATA_TYPE_CLOB" => Some(Self::Clob),
            "DATA_TYPE_REF" => Some(Self::Ref),
            "DATA_TYPE_DATALINK" => Some(Self::Datalink),
            "DATA_TYPE_ROWID" => Some(Self::Rowid),
            "DATA_TYPE_BINARY" => Some(Self::Binary),
            "DATA_TYPE_VARBINARY" => Some(Self::Varbinary),
            "DATA_TYPE_LONGVARBINARY" => Some(Self::Longvarbinary),
            "DATA_TYPE_NCLOB" => Some(Self::Nclob),
            "DATA_TYPE_SQLXML" => Some(Self::Sqlxml),
            "DATA_TYPE_REF_CURSOR" => Some(Self::RefCursor),
            "DATA_TYPE_TIME_WITH_TIMEZONE" => Some(Self::TimeWithTimezone),
            "DATA_TYPE_TIMESTAMP_WITH_TIMEZONE" => Some(Self::TimestampWithTimezone),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectionView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl ConnectionView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ConnectionView::Unspecified => "CONNECTION_VIEW_UNSPECIFIED",
            ConnectionView::Basic => "BASIC",
            ConnectionView::Full => "FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECTION_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIC" => Some(Self::Basic),
            "FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Provider {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub documentation_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub external_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub web_assets_location: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "LaunchStage", tag = "11")]
    pub launch_stage: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProviderRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProvidersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProvidersResponse {
    #[prost(message, repeated, tag = "1")]
    pub providers: ::prost::alloc::vec::Vec<Provider>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuntimeConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeConfig {
    #[prost(string, tag = "1")]
    pub location_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub connd_topic: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub connd_subscription: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub control_plane_topic: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub control_plane_subscription: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub runtime_endpoint: ::prost::alloc::string::String,
    #[prost(enumeration = "runtime_config::State", tag = "7")]
    pub state: i32,
    #[prost(string, tag = "8")]
    pub schema_gcs_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub service_directory: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RuntimeConfig`.
pub mod runtime_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Inactive = 1,
        Activating = 2,
        Active = 3,
        Creating = 4,
        Deleting = 5,
        Updating = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Inactive => "INACTIVE",
                State::Activating => "ACTIVATING",
                State::Active => "ACTIVE",
                State::Creating => "CREATING",
                State::Deleting => "DELETING",
                State::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "ACTIVATING" => Some(Self::Activating),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod connectors_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Connectors is the interface for managing Connectors.
    #[derive(Debug, Clone)]
    pub struct ConnectorsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ConnectorsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConnectorsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ConnectorsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Connections in a given project and location.
        pub async fn list_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConnectionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListConnectionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/ListConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "ListConnections",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Connection.
        pub async fn get_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectionRequest>,
        ) -> std::result::Result<tonic::Response<super::Connection>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/GetConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "GetConnection",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Connection in a given project and location.
        pub async fn create_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/CreateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "CreateConnection",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Connection.
        pub async fn update_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/UpdateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "UpdateConnection",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Connection.
        pub async fn delete_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/DeleteConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "DeleteConnection",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists Providers in a given project and location.
        pub async fn list_providers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProvidersRequest>,
        ) -> std::result::Result<tonic::Response<super::ListProvidersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/ListProviders",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "ListProviders",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a provider.
        pub async fn get_provider(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProviderRequest>,
        ) -> std::result::Result<tonic::Response<super::Provider>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/GetProvider",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "GetProvider",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists Connectors in a given project and location.
        pub async fn list_connectors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConnectorsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListConnectorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/ListConnectors",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "ListConnectors",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Connector.
        pub async fn get_connector(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectorRequest>,
        ) -> std::result::Result<tonic::Response<super::Connector>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/GetConnector",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "GetConnector",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists Connector Versions in a given project and location.
        pub async fn list_connector_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConnectorVersionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListConnectorVersionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/ListConnectorVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "ListConnectorVersions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single connector version.
        pub async fn get_connector_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectorVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::ConnectorVersion>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/GetConnectorVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "GetConnectorVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets schema metadata of a connection.
        /// SchemaMetadata is a singleton resource for each connection.
        pub async fn get_connection_schema_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectionSchemaMetadataRequest>,
        ) -> std::result::Result<tonic::Response<super::ConnectionSchemaMetadata>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/GetConnectionSchemaMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "GetConnectionSchemaMetadata",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Refresh runtime schema of a connection.
        pub async fn refresh_connection_schema_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::RefreshConnectionSchemaMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/RefreshConnectionSchemaMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "RefreshConnectionSchemaMetadata",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List schema of a runtime entities filtered by entity name.
        pub async fn list_runtime_entity_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRuntimeEntitySchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRuntimeEntitySchemasResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/ListRuntimeEntitySchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "ListRuntimeEntitySchemas",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List schema of a runtime actions filtered by action name.
        pub async fn list_runtime_action_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRuntimeActionSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRuntimeActionSchemasResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/ListRuntimeActionSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "ListRuntimeActionSchemas",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the runtimeConfig of a location.
        /// RuntimeConfig is a singleton resource for each location.
        pub async fn get_runtime_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuntimeConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::RuntimeConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/GetRuntimeConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "GetRuntimeConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetGlobalSettings gets settings of a project.
        /// GlobalSettings is a singleton resource.
        pub async fn get_global_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGlobalSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.connectors.v1.Connectors/GetGlobalSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.connectors.v1.Connectors",
                "GetGlobalSettings",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
