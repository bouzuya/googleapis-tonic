// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FindClosestBuildingInsightsRequest {
#[prost(message, optional, tag = "1")]
pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(enumeration = "ImageryQuality", tag = "3")]
pub required_quality: i32,
#[prost(bool, tag = "4")]
pub exact_quality_required: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LatLngBox {
#[prost(message, optional, tag = "1")]
pub sw: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(message, optional, tag = "2")]
pub ne: ::core::option::Option<super::super::super::r#type::LatLng>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildingInsights {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub center: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(message, optional, tag = "9")]
pub bounding_box: ::core::option::Option<LatLngBox>,
#[prost(message, optional, tag = "3")]
pub imagery_date: ::core::option::Option<super::super::super::r#type::Date>,
#[prost(message, optional, tag = "11")]
pub imagery_processed_date: ::core::option::Option<super::super::super::r#type::Date>,
#[prost(string, tag = "4")]
pub postal_code: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub administrative_area: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub statistical_area: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub region_code: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub solar_potential: ::core::option::Option<SolarPotential>,
#[prost(enumeration = "ImageryQuality", tag = "10")]
pub imagery_quality: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SolarPotential {
#[prost(int32, tag = "1")]
pub max_array_panels_count: i32,
#[prost(float, tag = "9")]
pub panel_capacity_watts: f32,
#[prost(float, tag = "10")]
pub panel_height_meters: f32,
#[prost(float, tag = "11")]
pub panel_width_meters: f32,
#[prost(int32, tag = "12")]
pub panel_lifetime_years: i32,
#[prost(float, tag = "2")]
pub max_array_area_meters2: f32,
#[prost(float, tag = "3")]
pub max_sunshine_hours_per_year: f32,
#[prost(float, tag = "4")]
pub carbon_offset_factor_kg_per_mwh: f32,
#[prost(message, optional, tag = "5")]
pub whole_roof_stats: ::core::option::Option<SizeAndSunshineStats>,
#[prost(message, optional, tag = "13")]
pub building_stats: ::core::option::Option<SizeAndSunshineStats>,
#[prost(message, repeated, tag = "6")]
pub roof_segment_stats: ::prost::alloc::vec::Vec<RoofSegmentSizeAndSunshineStats>,
#[prost(message, repeated, tag = "14")]
pub solar_panels: ::prost::alloc::vec::Vec<SolarPanel>,
#[prost(message, repeated, tag = "7")]
pub solar_panel_configs: ::prost::alloc::vec::Vec<SolarPanelConfig>,
#[prost(message, repeated, tag = "8")]
pub financial_analyses: ::prost::alloc::vec::Vec<FinancialAnalysis>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoofSegmentSizeAndSunshineStats {
#[prost(float, optional, tag = "1")]
pub pitch_degrees: ::core::option::Option<f32>,
#[prost(float, optional, tag = "2")]
pub azimuth_degrees: ::core::option::Option<f32>,
#[prost(message, optional, tag = "3")]
pub stats: ::core::option::Option<SizeAndSunshineStats>,
#[prost(message, optional, tag = "4")]
pub center: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(message, optional, tag = "5")]
pub bounding_box: ::core::option::Option<LatLngBox>,
#[prost(float, optional, tag = "6")]
pub plane_height_at_center_meters: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SizeAndSunshineStats {
#[prost(float, tag = "1")]
pub area_meters2: f32,
#[prost(float, repeated, tag = "2")]
pub sunshine_quantiles: ::prost::alloc::vec::Vec<f32>,
#[prost(float, tag = "3")]
pub ground_area_meters2: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SolarPanel {
#[prost(message, optional, tag = "1")]
pub center: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(enumeration = "SolarPanelOrientation", tag = "2")]
pub orientation: i32,
#[prost(float, tag = "3")]
pub yearly_energy_dc_kwh: f32,
#[prost(int32, optional, tag = "4")]
pub segment_index: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SolarPanelConfig {
#[prost(int32, tag = "1")]
pub panels_count: i32,
#[prost(float, tag = "2")]
pub yearly_energy_dc_kwh: f32,
#[prost(message, repeated, tag = "4")]
pub roof_segment_summaries: ::prost::alloc::vec::Vec<RoofSegmentSummary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoofSegmentSummary {
#[prost(float, optional, tag = "2")]
pub pitch_degrees: ::core::option::Option<f32>,
#[prost(float, optional, tag = "3")]
pub azimuth_degrees: ::core::option::Option<f32>,
#[prost(int32, tag = "7")]
pub panels_count: i32,
#[prost(float, tag = "8")]
pub yearly_energy_dc_kwh: f32,
#[prost(int32, optional, tag = "9")]
pub segment_index: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinancialAnalysis {
#[prost(message, optional, tag = "3")]
pub monthly_bill: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(bool, tag = "4")]
pub default_bill: bool,
#[prost(float, tag = "5")]
pub average_kwh_per_month: f32,
#[prost(int32, optional, tag = "6")]
pub panel_config_index: ::core::option::Option<i32>,
#[prost(message, optional, tag = "7")]
pub financial_details: ::core::option::Option<FinancialDetails>,
#[prost(message, optional, tag = "8")]
pub leasing_savings: ::core::option::Option<LeasingSavings>,
#[prost(message, optional, tag = "9")]
pub cash_purchase_savings: ::core::option::Option<CashPurchaseSavings>,
#[prost(message, optional, tag = "10")]
pub financed_purchase_savings: ::core::option::Option<FinancedPurchaseSavings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinancialDetails {
#[prost(float, tag = "1")]
pub initial_ac_kwh_per_year: f32,
#[prost(message, optional, tag = "2")]
pub remaining_lifetime_utility_bill: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "3")]
pub federal_incentive: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "4")]
pub state_incentive: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "5")]
pub utility_incentive: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "6")]
pub lifetime_srec_total: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "7")]
pub cost_of_electricity_without_solar: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(bool, tag = "8")]
pub net_metering_allowed: bool,
#[prost(float, optional, tag = "9")]
pub solar_percentage: ::core::option::Option<f32>,
#[prost(float, optional, tag = "10")]
pub percentage_exported_to_grid: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavingsOverTime {
#[prost(message, optional, tag = "1")]
pub savings_year1: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "2")]
pub savings_year20: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "3")]
pub present_value_of_savings_year20: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "5")]
pub savings_lifetime: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "6")]
pub present_value_of_savings_lifetime: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(bool, tag = "4")]
pub financially_viable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeasingSavings {
#[prost(bool, tag = "1")]
pub leases_allowed: bool,
#[prost(bool, tag = "2")]
pub leases_supported: bool,
#[prost(message, optional, tag = "3")]
pub annual_leasing_cost: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "4")]
pub savings: ::core::option::Option<SavingsOverTime>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CashPurchaseSavings {
#[prost(message, optional, tag = "1")]
pub out_of_pocket_cost: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "2")]
pub upfront_cost: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "3")]
pub rebate_value: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(float, optional, tag = "4")]
pub payback_years: ::core::option::Option<f32>,
#[prost(message, optional, tag = "5")]
pub savings: ::core::option::Option<SavingsOverTime>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinancedPurchaseSavings {
#[prost(message, optional, tag = "1")]
pub annual_loan_payment: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "2")]
pub rebate_value: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(float, tag = "3")]
pub loan_interest_rate: f32,
#[prost(message, optional, tag = "4")]
pub savings: ::core::option::Option<SavingsOverTime>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDataLayersRequest {
#[prost(message, optional, tag = "1")]
pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
#[prost(float, tag = "2")]
pub radius_meters: f32,
#[prost(enumeration = "DataLayerView", tag = "3")]
pub view: i32,
#[prost(enumeration = "ImageryQuality", tag = "5")]
pub required_quality: i32,
#[prost(float, tag = "6")]
pub pixel_size_meters: f32,
#[prost(bool, tag = "7")]
pub exact_quality_required: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataLayers {
#[prost(message, optional, tag = "1")]
pub imagery_date: ::core::option::Option<super::super::super::r#type::Date>,
#[prost(message, optional, tag = "2")]
pub imagery_processed_date: ::core::option::Option<super::super::super::r#type::Date>,
#[prost(string, tag = "3")]
pub dsm_url: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub rgb_url: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub mask_url: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub annual_flux_url: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub monthly_flux_url: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "8")]
pub hourly_shade_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "ImageryQuality", tag = "9")]
pub imagery_quality: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGeoTiffRequest {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataLayerView {
Unspecified = 0,
DsmLayer = 1,
ImageryLayers = 2,
ImageryAndAnnualFluxLayers = 3,
ImageryAndAllFluxLayers = 4,
FullLayers = 5,
}
impl DataLayerView {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DataLayerView::Unspecified => "DATA_LAYER_VIEW_UNSPECIFIED",
DataLayerView::DsmLayer => "DSM_LAYER",
DataLayerView::ImageryLayers => "IMAGERY_LAYERS",
DataLayerView::ImageryAndAnnualFluxLayers => "IMAGERY_AND_ANNUAL_FLUX_LAYERS",
DataLayerView::ImageryAndAllFluxLayers => "IMAGERY_AND_ALL_FLUX_LAYERS",
DataLayerView::FullLayers => "FULL_LAYERS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DATA_LAYER_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
"DSM_LAYER" => Some(Self::DsmLayer),
"IMAGERY_LAYERS" => Some(Self::ImageryLayers),
"IMAGERY_AND_ANNUAL_FLUX_LAYERS" => Some(Self::ImageryAndAnnualFluxLayers),
"IMAGERY_AND_ALL_FLUX_LAYERS" => Some(Self::ImageryAndAllFluxLayers),
"FULL_LAYERS" => Some(Self::FullLayers),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImageryQuality {
Unspecified = 0,
High = 1,
Medium = 2,
Low = 3,
}
impl ImageryQuality {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ImageryQuality::Unspecified => "IMAGERY_QUALITY_UNSPECIFIED",
ImageryQuality::High => "HIGH",
ImageryQuality::Medium => "MEDIUM",
ImageryQuality::Low => "LOW",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"IMAGERY_QUALITY_UNSPECIFIED" => Some(Self::Unspecified),
"HIGH" => Some(Self::High),
"MEDIUM" => Some(Self::Medium),
"LOW" => Some(Self::Low),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolarPanelOrientation {
Unspecified = 0,
Landscape = 1,
Portrait = 2,
}
impl SolarPanelOrientation {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SolarPanelOrientation::Unspecified => "SOLAR_PANEL_ORIENTATION_UNSPECIFIED",
SolarPanelOrientation::Landscape => "LANDSCAPE",
SolarPanelOrientation::Portrait => "PORTRAIT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SOLAR_PANEL_ORIENTATION_UNSPECIFIED" => Some(Self::Unspecified),
"LANDSCAPE" => Some(Self::Landscape),
"PORTRAIT" => Some(Self::Portrait),
_ => None,
}
}
}
/// Generated client implementations.
pub mod solar_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service definition for the Solar API.
#[derive(Debug, Clone)]
pub struct SolarClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SolarClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SolarClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SolarClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Locates the closest building to a query point. Returns an error with
/// code `NOT_FOUND` if there are no buildings within approximately 50m of the
/// query point.
pub async fn find_closest_building_insights(&mut self, request: impl tonic::IntoRequest<super::FindClosestBuildingInsightsRequest>) -> std::result::Result<tonic::Response<super::BuildingInsights>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.maps.solar.v1.Solar/FindClosestBuildingInsights");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.maps.solar.v1.Solar", "FindClosestBuildingInsights"));
self.inner.unary(req, path, codec).await
}
/// Gets solar information for a region surrounding a location.
/// Returns an error with code `NOT_FOUND` if the location is outside
/// the coverage area.
pub async fn get_data_layers(&mut self, request: impl tonic::IntoRequest<super::GetDataLayersRequest>) -> std::result::Result<tonic::Response<super::DataLayers>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.maps.solar.v1.Solar/GetDataLayers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.maps.solar.v1.Solar", "GetDataLayers"));
self.inner.unary(req, path, codec).await
}
/// Returns an image by its ID.
pub async fn get_geo_tiff(&mut self, request: impl tonic::IntoRequest<super::GetGeoTiffRequest>) -> std::result::Result<tonic::Response<super::super::super::super::api::HttpBody>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.maps.solar.v1.Solar/GetGeoTiff");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.maps.solar.v1.Solar", "GetGeoTiff"));
self.inner.unary(req, path, codec).await
}
}
}
