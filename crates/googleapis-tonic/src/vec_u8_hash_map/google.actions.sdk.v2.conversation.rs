// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Intent {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "2")]
    pub params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        IntentParameterValue,
    >,
    #[prost(string, tag = "3")]
    pub query: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentParameterValue {
    #[prost(string, tag = "1")]
    pub original: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub resolved: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Canvas {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub data: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(bool, tag = "3")]
    pub suppress_mic: bool,
    #[prost(bool, tag = "8")]
    pub enable_full_screen: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub alt: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub height: i32,
    #[prost(int32, tag = "4")]
    pub width: i32,
}
/// Nested message and enum types in `Image`.
pub mod image {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageFill {
        Unspecified = 0,
        Gray = 1,
        White = 2,
        Cropped = 3,
    }
    impl ImageFill {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImageFill::Unspecified => "UNSPECIFIED",
                ImageFill::Gray => "GRAY",
                ImageFill::White => "WHITE",
                ImageFill::Cropped => "CROPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "GRAY" => Some(Self::Gray),
                "WHITE" => Some(Self::White),
                "CROPPED" => Some(Self::Cropped),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Link {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub open: ::core::option::Option<OpenUrl>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenUrl {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(enumeration = "UrlHint", tag = "2")]
    pub hint: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UrlHint {
    LinkUnspecified = 0,
    Amp = 1,
}
impl UrlHint {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UrlHint::LinkUnspecified => "LINK_UNSPECIFIED",
            UrlHint::Amp => "AMP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_UNSPECIFIED" => Some(Self::LinkUnspecified),
            "AMP" => Some(Self::Amp),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Card {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub image: ::core::option::Option<Image>,
    #[prost(enumeration = "image::ImageFill", tag = "5")]
    pub image_fill: i32,
    #[prost(message, optional, tag = "6")]
    pub button: ::core::option::Option<Link>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Collection {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<collection::CollectionItem>,
    #[prost(enumeration = "image::ImageFill", tag = "4")]
    pub image_fill: i32,
}
/// Nested message and enum types in `Collection`.
pub mod collection {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CollectionItem {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct List {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<list::ListItem>,
}
/// Nested message and enum types in `List`.
pub mod list {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListItem {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Media {
    #[prost(enumeration = "media::MediaType", tag = "8")]
    pub media_type: i32,
    #[prost(message, optional, tag = "5")]
    pub start_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "media::OptionalMediaControls", repeated, tag = "6")]
    pub optional_media_controls: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "7")]
    pub media_objects: ::prost::alloc::vec::Vec<MediaObject>,
}
/// Nested message and enum types in `Media`.
pub mod media {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaType {
        Unspecified = 0,
        Audio = 1,
        MediaStatusAck = 2,
    }
    impl MediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaType::Unspecified => "MEDIA_TYPE_UNSPECIFIED",
                MediaType::Audio => "AUDIO",
                MediaType::MediaStatusAck => "MEDIA_STATUS_ACK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEDIA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUDIO" => Some(Self::Audio),
                "MEDIA_STATUS_ACK" => Some(Self::MediaStatusAck),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptionalMediaControls {
        Unspecified = 0,
        Paused = 1,
        Stopped = 2,
    }
    impl OptionalMediaControls {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OptionalMediaControls::Unspecified => {
                    "OPTIONAL_MEDIA_CONTROLS_UNSPECIFIED"
                }
                OptionalMediaControls::Paused => "PAUSED",
                OptionalMediaControls::Stopped => "STOPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPTIONAL_MEDIA_CONTROLS_UNSPECIFIED" => Some(Self::Unspecified),
                "PAUSED" => Some(Self::Paused),
                "STOPPED" => Some(Self::Stopped),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaObject {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub image: ::core::option::Option<MediaImage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaImage {
    #[prost(oneof = "media_image::Image", tags = "1, 2")]
    pub image: ::core::option::Option<media_image::Image>,
}
/// Nested message and enum types in `MediaImage`.
pub mod media_image {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Image {
        #[prost(message, tag = "1")]
        Large(super::Image),
        #[prost(message, tag = "2")]
        Icon(super::Image),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Table {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub image: ::core::option::Option<Image>,
    #[prost(message, repeated, tag = "5")]
    pub columns: ::prost::alloc::vec::Vec<TableColumn>,
    #[prost(message, repeated, tag = "6")]
    pub rows: ::prost::alloc::vec::Vec<TableRow>,
    #[prost(message, optional, tag = "7")]
    pub button: ::core::option::Option<Link>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableColumn {
    #[prost(string, tag = "1")]
    pub header: ::prost::alloc::string::String,
    #[prost(enumeration = "table_column::HorizontalAlignment", tag = "2")]
    pub align: i32,
}
/// Nested message and enum types in `TableColumn`.
pub mod table_column {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HorizontalAlignment {
        Unspecified = 0,
        Leading = 1,
        Center = 2,
        Trailing = 3,
    }
    impl HorizontalAlignment {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HorizontalAlignment::Unspecified => "UNSPECIFIED",
                HorizontalAlignment::Leading => "LEADING",
                HorizontalAlignment::Center => "CENTER",
                HorizontalAlignment::Trailing => "TRAILING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "LEADING" => Some(Self::Leading),
                "CENTER" => Some(Self::Center),
                "TRAILING" => Some(Self::Trailing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableCell {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRow {
    #[prost(message, repeated, tag = "1")]
    pub cells: ::prost::alloc::vec::Vec<TableCell>,
    #[prost(bool, tag = "2")]
    pub divider: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    #[prost(oneof = "content::Content", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub content: ::core::option::Option<content::Content>,
}
/// Nested message and enum types in `Content`.
pub mod content {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "1")]
        Card(super::Card),
        #[prost(message, tag = "2")]
        Image(super::Image),
        #[prost(message, tag = "3")]
        Table(super::Table),
        #[prost(message, tag = "4")]
        Media(super::Media),
        #[prost(message, tag = "5")]
        Canvas(super::Canvas),
        #[prost(message, tag = "6")]
        Collection(super::Collection),
        #[prost(message, tag = "7")]
        List(super::List),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Simple {
    #[prost(string, tag = "1")]
    pub speech: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Suggestion {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Prompt {
    #[deprecated]
    #[prost(bool, tag = "1")]
    pub append: bool,
    #[prost(bool, tag = "8")]
    pub r#override: bool,
    #[prost(message, optional, tag = "2")]
    pub first_simple: ::core::option::Option<Simple>,
    #[prost(message, optional, tag = "3")]
    pub content: ::core::option::Option<Content>,
    #[prost(message, optional, tag = "4")]
    pub last_simple: ::core::option::Option<Simple>,
    #[prost(message, repeated, tag = "5")]
    pub suggestions: ::prost::alloc::vec::Vec<Suggestion>,
    #[prost(message, optional, tag = "6")]
    pub link: ::core::option::Option<Link>,
    #[prost(message, optional, tag = "9")]
    pub canvas: ::core::option::Option<Canvas>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Slot {
    #[prost(enumeration = "slot::SlotMode", tag = "1")]
    pub mode: i32,
    #[prost(enumeration = "slot::SlotStatus", tag = "2")]
    pub status: i32,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<::prost_types::Value>,
    #[prost(bool, tag = "4")]
    pub updated: bool,
    #[prost(message, optional, tag = "5")]
    pub prompt: ::core::option::Option<Prompt>,
}
/// Nested message and enum types in `Slot`.
pub mod slot {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SlotMode {
        ModeUnspecified = 0,
        Optional = 1,
        Required = 2,
    }
    impl SlotMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SlotMode::ModeUnspecified => "MODE_UNSPECIFIED",
                SlotMode::Optional => "OPTIONAL",
                SlotMode::Required => "REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::ModeUnspecified),
                "OPTIONAL" => Some(Self::Optional),
                "REQUIRED" => Some(Self::Required),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SlotStatus {
        SlotUnspecified = 0,
        Empty = 1,
        Invalid = 2,
        Filled = 3,
    }
    impl SlotStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SlotStatus::SlotUnspecified => "SLOT_UNSPECIFIED",
                SlotStatus::Empty => "EMPTY",
                SlotStatus::Invalid => "INVALID",
                SlotStatus::Filled => "FILLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SLOT_UNSPECIFIED" => Some(Self::SlotUnspecified),
                "EMPTY" => Some(Self::Empty),
                "INVALID" => Some(Self::Invalid),
                "FILLED" => Some(Self::Filled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SlotFillingStatus {
    Unspecified = 0,
    Initialized = 1,
    Collecting = 2,
    Final = 4,
}
impl SlotFillingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SlotFillingStatus::Unspecified => "UNSPECIFIED",
            SlotFillingStatus::Initialized => "INITIALIZED",
            SlotFillingStatus::Collecting => "COLLECTING",
            SlotFillingStatus::Final => "FINAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "INITIALIZED" => Some(Self::Initialized),
            "COLLECTING" => Some(Self::Collecting),
            "FINAL" => Some(Self::Final),
            _ => None,
        }
    }
}
