// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAutokeyConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub autokey_config: ::core::option::Option<AutokeyConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAutokeyConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutokeyConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key_project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowEffectiveAutokeyConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowEffectiveAutokeyConfigResponse {
    #[prost(string, tag = "1")]
    pub key_project: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod autokey_admin_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Provides interfaces for managing Cloud KMS Autokey folder-level
    /// configurations. A configuration is inherited by all descendent projects. A
    /// configuration at one folder overrides any other configurations in its
    /// ancestry. Setting a configuration on a folder is a prerequisite for Cloud KMS
    /// Autokey, so that users working in a descendant project can request
    /// provisioned [CryptoKeys][google.cloud.kms.v1.CryptoKey], ready for Customer
    /// Managed Encryption Key (CMEK) use, on-demand.
    #[derive(Debug, Clone)]
    pub struct AutokeyAdminClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AutokeyAdminClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AutokeyAdminClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AutokeyAdminClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Updates the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
        /// folder. The caller must have both `cloudkms.autokeyConfigs.update`
        /// permission on the parent folder and `cloudkms.cryptoKeys.setIamPolicy`
        /// permission on the provided key project. A
        /// [KeyHandle][google.cloud.kms.v1.KeyHandle] creation in the folder's
        /// descendant projects will use this configuration to determine where to
        /// create the resulting [CryptoKey][google.cloud.kms.v1.CryptoKey].
        pub async fn update_autokey_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAutokeyConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::AutokeyConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.AutokeyAdmin/UpdateAutokeyConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.AutokeyAdmin",
                "UpdateAutokeyConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
        /// folder.
        pub async fn get_autokey_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAutokeyConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::AutokeyConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.AutokeyAdmin/GetAutokeyConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.AutokeyAdmin",
                "GetAutokeyConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the effective Cloud KMS Autokey configuration for a given project.
        pub async fn show_effective_autokey_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ShowEffectiveAutokeyConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShowEffectiveAutokeyConfigResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.AutokeyAdmin/ShowEffectiveAutokeyConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.AutokeyAdmin",
                "ShowEffectiveAutokeyConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyRing {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CryptoKey {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub primary: ::core::option::Option<CryptoKeyVersion>,
    #[prost(enumeration = "crypto_key::CryptoKeyPurpose", tag = "3")]
    pub purpose: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub next_rotation_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub version_template: ::core::option::Option<CryptoKeyVersionTemplate>,
    #[prost(map = "string, string", tag = "10")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(bool, tag = "13")]
    pub import_only: bool,
    #[prost(message, optional, tag = "14")]
    pub destroy_scheduled_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "15")]
    pub crypto_key_backend: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "17")]
    pub key_access_justifications_policy: ::core::option::Option<KeyAccessJustificationsPolicy>,
    #[prost(oneof = "crypto_key::RotationSchedule", tags = "8")]
    pub rotation_schedule: ::core::option::Option<crypto_key::RotationSchedule>,
}
/// Nested message and enum types in `CryptoKey`.
pub mod crypto_key {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CryptoKeyPurpose {
        Unspecified = 0,
        EncryptDecrypt = 1,
        AsymmetricSign = 5,
        AsymmetricDecrypt = 6,
        RawEncryptDecrypt = 7,
        Mac = 9,
    }
    impl CryptoKeyPurpose {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CryptoKeyPurpose::Unspecified => "CRYPTO_KEY_PURPOSE_UNSPECIFIED",
                CryptoKeyPurpose::EncryptDecrypt => "ENCRYPT_DECRYPT",
                CryptoKeyPurpose::AsymmetricSign => "ASYMMETRIC_SIGN",
                CryptoKeyPurpose::AsymmetricDecrypt => "ASYMMETRIC_DECRYPT",
                CryptoKeyPurpose::RawEncryptDecrypt => "RAW_ENCRYPT_DECRYPT",
                CryptoKeyPurpose::Mac => "MAC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CRYPTO_KEY_PURPOSE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENCRYPT_DECRYPT" => Some(Self::EncryptDecrypt),
                "ASYMMETRIC_SIGN" => Some(Self::AsymmetricSign),
                "ASYMMETRIC_DECRYPT" => Some(Self::AsymmetricDecrypt),
                "RAW_ENCRYPT_DECRYPT" => Some(Self::RawEncryptDecrypt),
                "MAC" => Some(Self::Mac),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum RotationSchedule {
        #[prost(message, tag = "8")]
        RotationPeriod(::prost_types::Duration),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CryptoKeyVersionTemplate {
    #[prost(enumeration = "ProtectionLevel", tag = "1")]
    pub protection_level: i32,
    #[prost(
        enumeration = "crypto_key_version::CryptoKeyVersionAlgorithm",
        tag = "3"
    )]
    pub algorithm: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyOperationAttestation {
    #[prost(
        enumeration = "key_operation_attestation::AttestationFormat",
        tag = "4"
    )]
    pub format: i32,
    #[prost(bytes = "vec", tag = "5")]
    pub content: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "6")]
    pub cert_chains: ::core::option::Option<key_operation_attestation::CertificateChains>,
}
/// Nested message and enum types in `KeyOperationAttestation`.
pub mod key_operation_attestation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CertificateChains {
        #[prost(string, repeated, tag = "1")]
        pub cavium_certs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub google_card_certs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub google_partition_certs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AttestationFormat {
        Unspecified = 0,
        CaviumV1Compressed = 3,
        CaviumV2Compressed = 4,
    }
    impl AttestationFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttestationFormat::Unspecified => "ATTESTATION_FORMAT_UNSPECIFIED",
                AttestationFormat::CaviumV1Compressed => "CAVIUM_V1_COMPRESSED",
                AttestationFormat::CaviumV2Compressed => "CAVIUM_V2_COMPRESSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ATTESTATION_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "CAVIUM_V1_COMPRESSED" => Some(Self::CaviumV1Compressed),
                "CAVIUM_V2_COMPRESSED" => Some(Self::CaviumV2Compressed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CryptoKeyVersion {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "crypto_key_version::CryptoKeyVersionState", tag = "3")]
    pub state: i32,
    #[prost(enumeration = "ProtectionLevel", tag = "7")]
    pub protection_level: i32,
    #[prost(
        enumeration = "crypto_key_version::CryptoKeyVersionAlgorithm",
        tag = "10"
    )]
    pub algorithm: i32,
    #[prost(message, optional, tag = "8")]
    pub attestation: ::core::option::Option<KeyOperationAttestation>,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub generate_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub destroy_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub destroy_event_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "14")]
    pub import_job: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub import_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "16")]
    pub import_failure_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub generation_failure_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub external_destruction_failure_reason: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "17")]
    pub external_protection_level_options: ::core::option::Option<ExternalProtectionLevelOptions>,
    #[prost(bool, tag = "18")]
    pub reimport_eligible: bool,
}
/// Nested message and enum types in `CryptoKeyVersion`.
pub mod crypto_key_version {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CryptoKeyVersionAlgorithm {
        Unspecified = 0,
        GoogleSymmetricEncryption = 1,
        Aes128Gcm = 41,
        Aes256Gcm = 19,
        Aes128Cbc = 42,
        Aes256Cbc = 43,
        Aes128Ctr = 44,
        Aes256Ctr = 45,
        RsaSignPss2048Sha256 = 2,
        RsaSignPss3072Sha256 = 3,
        RsaSignPss4096Sha256 = 4,
        RsaSignPss4096Sha512 = 15,
        RsaSignPkcs12048Sha256 = 5,
        RsaSignPkcs13072Sha256 = 6,
        RsaSignPkcs14096Sha256 = 7,
        RsaSignPkcs14096Sha512 = 16,
        RsaSignRawPkcs12048 = 28,
        RsaSignRawPkcs13072 = 29,
        RsaSignRawPkcs14096 = 30,
        RsaDecryptOaep2048Sha256 = 8,
        RsaDecryptOaep3072Sha256 = 9,
        RsaDecryptOaep4096Sha256 = 10,
        RsaDecryptOaep4096Sha512 = 17,
        RsaDecryptOaep2048Sha1 = 37,
        RsaDecryptOaep3072Sha1 = 38,
        RsaDecryptOaep4096Sha1 = 39,
        EcSignP256Sha256 = 12,
        EcSignP384Sha384 = 13,
        EcSignSecp256k1Sha256 = 31,
        EcSignEd25519 = 40,
        HmacSha256 = 32,
        HmacSha1 = 33,
        HmacSha384 = 34,
        HmacSha512 = 35,
        HmacSha224 = 36,
        ExternalSymmetricEncryption = 18,
    }
    impl CryptoKeyVersionAlgorithm {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CryptoKeyVersionAlgorithm::Unspecified => {
                    "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED"
                }
                CryptoKeyVersionAlgorithm::GoogleSymmetricEncryption => {
                    "GOOGLE_SYMMETRIC_ENCRYPTION"
                }
                CryptoKeyVersionAlgorithm::Aes128Gcm => "AES_128_GCM",
                CryptoKeyVersionAlgorithm::Aes256Gcm => "AES_256_GCM",
                CryptoKeyVersionAlgorithm::Aes128Cbc => "AES_128_CBC",
                CryptoKeyVersionAlgorithm::Aes256Cbc => "AES_256_CBC",
                CryptoKeyVersionAlgorithm::Aes128Ctr => "AES_128_CTR",
                CryptoKeyVersionAlgorithm::Aes256Ctr => "AES_256_CTR",
                CryptoKeyVersionAlgorithm::RsaSignPss2048Sha256 => "RSA_SIGN_PSS_2048_SHA256",
                CryptoKeyVersionAlgorithm::RsaSignPss3072Sha256 => "RSA_SIGN_PSS_3072_SHA256",
                CryptoKeyVersionAlgorithm::RsaSignPss4096Sha256 => "RSA_SIGN_PSS_4096_SHA256",
                CryptoKeyVersionAlgorithm::RsaSignPss4096Sha512 => "RSA_SIGN_PSS_4096_SHA512",
                CryptoKeyVersionAlgorithm::RsaSignPkcs12048Sha256 => "RSA_SIGN_PKCS1_2048_SHA256",
                CryptoKeyVersionAlgorithm::RsaSignPkcs13072Sha256 => "RSA_SIGN_PKCS1_3072_SHA256",
                CryptoKeyVersionAlgorithm::RsaSignPkcs14096Sha256 => "RSA_SIGN_PKCS1_4096_SHA256",
                CryptoKeyVersionAlgorithm::RsaSignPkcs14096Sha512 => "RSA_SIGN_PKCS1_4096_SHA512",
                CryptoKeyVersionAlgorithm::RsaSignRawPkcs12048 => "RSA_SIGN_RAW_PKCS1_2048",
                CryptoKeyVersionAlgorithm::RsaSignRawPkcs13072 => "RSA_SIGN_RAW_PKCS1_3072",
                CryptoKeyVersionAlgorithm::RsaSignRawPkcs14096 => "RSA_SIGN_RAW_PKCS1_4096",
                CryptoKeyVersionAlgorithm::RsaDecryptOaep2048Sha256 => {
                    "RSA_DECRYPT_OAEP_2048_SHA256"
                }
                CryptoKeyVersionAlgorithm::RsaDecryptOaep3072Sha256 => {
                    "RSA_DECRYPT_OAEP_3072_SHA256"
                }
                CryptoKeyVersionAlgorithm::RsaDecryptOaep4096Sha256 => {
                    "RSA_DECRYPT_OAEP_4096_SHA256"
                }
                CryptoKeyVersionAlgorithm::RsaDecryptOaep4096Sha512 => {
                    "RSA_DECRYPT_OAEP_4096_SHA512"
                }
                CryptoKeyVersionAlgorithm::RsaDecryptOaep2048Sha1 => "RSA_DECRYPT_OAEP_2048_SHA1",
                CryptoKeyVersionAlgorithm::RsaDecryptOaep3072Sha1 => "RSA_DECRYPT_OAEP_3072_SHA1",
                CryptoKeyVersionAlgorithm::RsaDecryptOaep4096Sha1 => "RSA_DECRYPT_OAEP_4096_SHA1",
                CryptoKeyVersionAlgorithm::EcSignP256Sha256 => "EC_SIGN_P256_SHA256",
                CryptoKeyVersionAlgorithm::EcSignP384Sha384 => "EC_SIGN_P384_SHA384",
                CryptoKeyVersionAlgorithm::EcSignSecp256k1Sha256 => "EC_SIGN_SECP256K1_SHA256",
                CryptoKeyVersionAlgorithm::EcSignEd25519 => "EC_SIGN_ED25519",
                CryptoKeyVersionAlgorithm::HmacSha256 => "HMAC_SHA256",
                CryptoKeyVersionAlgorithm::HmacSha1 => "HMAC_SHA1",
                CryptoKeyVersionAlgorithm::HmacSha384 => "HMAC_SHA384",
                CryptoKeyVersionAlgorithm::HmacSha512 => "HMAC_SHA512",
                CryptoKeyVersionAlgorithm::HmacSha224 => "HMAC_SHA224",
                CryptoKeyVersionAlgorithm::ExternalSymmetricEncryption => {
                    "EXTERNAL_SYMMETRIC_ENCRYPTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_SYMMETRIC_ENCRYPTION" => Some(Self::GoogleSymmetricEncryption),
                "AES_128_GCM" => Some(Self::Aes128Gcm),
                "AES_256_GCM" => Some(Self::Aes256Gcm),
                "AES_128_CBC" => Some(Self::Aes128Cbc),
                "AES_256_CBC" => Some(Self::Aes256Cbc),
                "AES_128_CTR" => Some(Self::Aes128Ctr),
                "AES_256_CTR" => Some(Self::Aes256Ctr),
                "RSA_SIGN_PSS_2048_SHA256" => Some(Self::RsaSignPss2048Sha256),
                "RSA_SIGN_PSS_3072_SHA256" => Some(Self::RsaSignPss3072Sha256),
                "RSA_SIGN_PSS_4096_SHA256" => Some(Self::RsaSignPss4096Sha256),
                "RSA_SIGN_PSS_4096_SHA512" => Some(Self::RsaSignPss4096Sha512),
                "RSA_SIGN_PKCS1_2048_SHA256" => Some(Self::RsaSignPkcs12048Sha256),
                "RSA_SIGN_PKCS1_3072_SHA256" => Some(Self::RsaSignPkcs13072Sha256),
                "RSA_SIGN_PKCS1_4096_SHA256" => Some(Self::RsaSignPkcs14096Sha256),
                "RSA_SIGN_PKCS1_4096_SHA512" => Some(Self::RsaSignPkcs14096Sha512),
                "RSA_SIGN_RAW_PKCS1_2048" => Some(Self::RsaSignRawPkcs12048),
                "RSA_SIGN_RAW_PKCS1_3072" => Some(Self::RsaSignRawPkcs13072),
                "RSA_SIGN_RAW_PKCS1_4096" => Some(Self::RsaSignRawPkcs14096),
                "RSA_DECRYPT_OAEP_2048_SHA256" => Some(Self::RsaDecryptOaep2048Sha256),
                "RSA_DECRYPT_OAEP_3072_SHA256" => Some(Self::RsaDecryptOaep3072Sha256),
                "RSA_DECRYPT_OAEP_4096_SHA256" => Some(Self::RsaDecryptOaep4096Sha256),
                "RSA_DECRYPT_OAEP_4096_SHA512" => Some(Self::RsaDecryptOaep4096Sha512),
                "RSA_DECRYPT_OAEP_2048_SHA1" => Some(Self::RsaDecryptOaep2048Sha1),
                "RSA_DECRYPT_OAEP_3072_SHA1" => Some(Self::RsaDecryptOaep3072Sha1),
                "RSA_DECRYPT_OAEP_4096_SHA1" => Some(Self::RsaDecryptOaep4096Sha1),
                "EC_SIGN_P256_SHA256" => Some(Self::EcSignP256Sha256),
                "EC_SIGN_P384_SHA384" => Some(Self::EcSignP384Sha384),
                "EC_SIGN_SECP256K1_SHA256" => Some(Self::EcSignSecp256k1Sha256),
                "EC_SIGN_ED25519" => Some(Self::EcSignEd25519),
                "HMAC_SHA256" => Some(Self::HmacSha256),
                "HMAC_SHA1" => Some(Self::HmacSha1),
                "HMAC_SHA384" => Some(Self::HmacSha384),
                "HMAC_SHA512" => Some(Self::HmacSha512),
                "HMAC_SHA224" => Some(Self::HmacSha224),
                "EXTERNAL_SYMMETRIC_ENCRYPTION" => Some(Self::ExternalSymmetricEncryption),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CryptoKeyVersionState {
        Unspecified = 0,
        PendingGeneration = 5,
        Enabled = 1,
        Disabled = 2,
        Destroyed = 3,
        DestroyScheduled = 4,
        PendingImport = 6,
        ImportFailed = 7,
        GenerationFailed = 8,
        PendingExternalDestruction = 9,
        ExternalDestructionFailed = 10,
    }
    impl CryptoKeyVersionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CryptoKeyVersionState::Unspecified => "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED",
                CryptoKeyVersionState::PendingGeneration => "PENDING_GENERATION",
                CryptoKeyVersionState::Enabled => "ENABLED",
                CryptoKeyVersionState::Disabled => "DISABLED",
                CryptoKeyVersionState::Destroyed => "DESTROYED",
                CryptoKeyVersionState::DestroyScheduled => "DESTROY_SCHEDULED",
                CryptoKeyVersionState::PendingImport => "PENDING_IMPORT",
                CryptoKeyVersionState::ImportFailed => "IMPORT_FAILED",
                CryptoKeyVersionState::GenerationFailed => "GENERATION_FAILED",
                CryptoKeyVersionState::PendingExternalDestruction => "PENDING_EXTERNAL_DESTRUCTION",
                CryptoKeyVersionState::ExternalDestructionFailed => "EXTERNAL_DESTRUCTION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING_GENERATION" => Some(Self::PendingGeneration),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                "DESTROYED" => Some(Self::Destroyed),
                "DESTROY_SCHEDULED" => Some(Self::DestroyScheduled),
                "PENDING_IMPORT" => Some(Self::PendingImport),
                "IMPORT_FAILED" => Some(Self::ImportFailed),
                "GENERATION_FAILED" => Some(Self::GenerationFailed),
                "PENDING_EXTERNAL_DESTRUCTION" => Some(Self::PendingExternalDestruction),
                "EXTERNAL_DESTRUCTION_FAILED" => Some(Self::ExternalDestructionFailed),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CryptoKeyVersionView {
        Unspecified = 0,
        Full = 1,
    }
    impl CryptoKeyVersionView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CryptoKeyVersionView::Unspecified => "CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED",
                CryptoKeyVersionView::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKey {
    #[prost(string, tag = "1")]
    pub pem: ::prost::alloc::string::String,
    #[prost(
        enumeration = "crypto_key_version::CryptoKeyVersionAlgorithm",
        tag = "2"
    )]
    pub algorithm: i32,
    #[prost(message, optional, tag = "3")]
    pub pem_crc32c: ::core::option::Option<i64>,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ProtectionLevel", tag = "5")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "import_job::ImportMethod", tag = "2")]
    pub import_method: i32,
    #[prost(enumeration = "ProtectionLevel", tag = "9")]
    pub protection_level: i32,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub generate_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub expire_event_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "import_job::ImportJobState", tag = "6")]
    pub state: i32,
    #[prost(message, optional, tag = "7")]
    pub public_key: ::core::option::Option<import_job::WrappingPublicKey>,
    #[prost(message, optional, tag = "8")]
    pub attestation: ::core::option::Option<KeyOperationAttestation>,
}
/// Nested message and enum types in `ImportJob`.
pub mod import_job {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WrappingPublicKey {
        #[prost(string, tag = "1")]
        pub pem: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ImportMethod {
        Unspecified = 0,
        RsaOaep3072Sha1Aes256 = 1,
        RsaOaep4096Sha1Aes256 = 2,
        RsaOaep3072Sha256Aes256 = 3,
        RsaOaep4096Sha256Aes256 = 4,
        RsaOaep3072Sha256 = 5,
        RsaOaep4096Sha256 = 6,
    }
    impl ImportMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImportMethod::Unspecified => "IMPORT_METHOD_UNSPECIFIED",
                ImportMethod::RsaOaep3072Sha1Aes256 => "RSA_OAEP_3072_SHA1_AES_256",
                ImportMethod::RsaOaep4096Sha1Aes256 => "RSA_OAEP_4096_SHA1_AES_256",
                ImportMethod::RsaOaep3072Sha256Aes256 => "RSA_OAEP_3072_SHA256_AES_256",
                ImportMethod::RsaOaep4096Sha256Aes256 => "RSA_OAEP_4096_SHA256_AES_256",
                ImportMethod::RsaOaep3072Sha256 => "RSA_OAEP_3072_SHA256",
                ImportMethod::RsaOaep4096Sha256 => "RSA_OAEP_4096_SHA256",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMPORT_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "RSA_OAEP_3072_SHA1_AES_256" => Some(Self::RsaOaep3072Sha1Aes256),
                "RSA_OAEP_4096_SHA1_AES_256" => Some(Self::RsaOaep4096Sha1Aes256),
                "RSA_OAEP_3072_SHA256_AES_256" => Some(Self::RsaOaep3072Sha256Aes256),
                "RSA_OAEP_4096_SHA256_AES_256" => Some(Self::RsaOaep4096Sha256Aes256),
                "RSA_OAEP_3072_SHA256" => Some(Self::RsaOaep3072Sha256),
                "RSA_OAEP_4096_SHA256" => Some(Self::RsaOaep4096Sha256),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ImportJobState {
        Unspecified = 0,
        PendingGeneration = 1,
        Active = 2,
        Expired = 3,
    }
    impl ImportJobState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImportJobState::Unspecified => "IMPORT_JOB_STATE_UNSPECIFIED",
                ImportJobState::PendingGeneration => "PENDING_GENERATION",
                ImportJobState::Active => "ACTIVE",
                ImportJobState::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMPORT_JOB_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING_GENERATION" => Some(Self::PendingGeneration),
                "ACTIVE" => Some(Self::Active),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalProtectionLevelOptions {
    #[prost(string, tag = "1")]
    pub external_key_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ekm_connection_key_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyAccessJustificationsPolicy {
    #[prost(enumeration = "AccessReason", repeated, tag = "1")]
    pub allowed_access_reasons: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtectionLevel {
    Unspecified = 0,
    Software = 1,
    Hsm = 2,
    External = 3,
    ExternalVpc = 4,
}
impl ProtectionLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProtectionLevel::Unspecified => "PROTECTION_LEVEL_UNSPECIFIED",
            ProtectionLevel::Software => "SOFTWARE",
            ProtectionLevel::Hsm => "HSM",
            ProtectionLevel::External => "EXTERNAL",
            ProtectionLevel::ExternalVpc => "EXTERNAL_VPC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTECTION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "SOFTWARE" => Some(Self::Software),
            "HSM" => Some(Self::Hsm),
            "EXTERNAL" => Some(Self::External),
            "EXTERNAL_VPC" => Some(Self::ExternalVpc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AccessReason {
    ReasonUnspecified = 0,
    CustomerInitiatedSupport = 1,
    GoogleInitiatedService = 2,
    ThirdPartyDataRequest = 3,
    GoogleInitiatedReview = 4,
    CustomerInitiatedAccess = 5,
    GoogleInitiatedSystemOperation = 6,
    ReasonNotExpected = 7,
    ModifiedCustomerInitiatedAccess = 8,
    ModifiedGoogleInitiatedSystemOperation = 9,
    GoogleResponseToProductionAlert = 10,
    CustomerAuthorizedWorkflowServicing = 11,
}
impl AccessReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AccessReason::ReasonUnspecified => "REASON_UNSPECIFIED",
            AccessReason::CustomerInitiatedSupport => "CUSTOMER_INITIATED_SUPPORT",
            AccessReason::GoogleInitiatedService => "GOOGLE_INITIATED_SERVICE",
            AccessReason::ThirdPartyDataRequest => "THIRD_PARTY_DATA_REQUEST",
            AccessReason::GoogleInitiatedReview => "GOOGLE_INITIATED_REVIEW",
            AccessReason::CustomerInitiatedAccess => "CUSTOMER_INITIATED_ACCESS",
            AccessReason::GoogleInitiatedSystemOperation => "GOOGLE_INITIATED_SYSTEM_OPERATION",
            AccessReason::ReasonNotExpected => "REASON_NOT_EXPECTED",
            AccessReason::ModifiedCustomerInitiatedAccess => "MODIFIED_CUSTOMER_INITIATED_ACCESS",
            AccessReason::ModifiedGoogleInitiatedSystemOperation => {
                "MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION"
            }
            AccessReason::GoogleResponseToProductionAlert => "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT",
            AccessReason::CustomerAuthorizedWorkflowServicing => {
                "CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REASON_UNSPECIFIED" => Some(Self::ReasonUnspecified),
            "CUSTOMER_INITIATED_SUPPORT" => Some(Self::CustomerInitiatedSupport),
            "GOOGLE_INITIATED_SERVICE" => Some(Self::GoogleInitiatedService),
            "THIRD_PARTY_DATA_REQUEST" => Some(Self::ThirdPartyDataRequest),
            "GOOGLE_INITIATED_REVIEW" => Some(Self::GoogleInitiatedReview),
            "CUSTOMER_INITIATED_ACCESS" => Some(Self::CustomerInitiatedAccess),
            "GOOGLE_INITIATED_SYSTEM_OPERATION" => Some(Self::GoogleInitiatedSystemOperation),
            "REASON_NOT_EXPECTED" => Some(Self::ReasonNotExpected),
            "MODIFIED_CUSTOMER_INITIATED_ACCESS" => Some(Self::ModifiedCustomerInitiatedAccess),
            "MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION" => {
                Some(Self::ModifiedGoogleInitiatedSystemOperation)
            }
            "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT" => Some(Self::GoogleResponseToProductionAlert),
            "CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING" => {
                Some(Self::CustomerAuthorizedWorkflowServicing)
            }
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEkmConnectionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEkmConnectionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub ekm_connections: ::prost::alloc::vec::Vec<EkmConnection>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEkmConnectionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEkmConnectionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ekm_connection_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub ekm_connection: ::core::option::Option<EkmConnection>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEkmConnectionRequest {
    #[prost(message, optional, tag = "1")]
    pub ekm_connection: ::core::option::Option<EkmConnection>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEkmConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEkmConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub ekm_config: ::core::option::Option<EkmConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Certificate {
    #[prost(bytes = "vec", tag = "1")]
    pub raw_der: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub parsed: bool,
    #[prost(string, tag = "3")]
    pub issuer: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub subject: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub subject_alternative_dns_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub not_before_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub not_after_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "8")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub sha256_fingerprint: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EkmConnection {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "3")]
    pub service_resolvers: ::prost::alloc::vec::Vec<ekm_connection::ServiceResolver>,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    #[prost(enumeration = "ekm_connection::KeyManagementMode", tag = "6")]
    pub key_management_mode: i32,
    #[prost(string, tag = "7")]
    pub crypto_space_path: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EkmConnection`.
pub mod ekm_connection {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceResolver {
        #[prost(string, tag = "1")]
        pub service_directory_service: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub endpoint_filter: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub hostname: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub server_certificates: ::prost::alloc::vec::Vec<super::Certificate>,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum KeyManagementMode {
        Unspecified = 0,
        Manual = 1,
        CloudKms = 2,
    }
    impl KeyManagementMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeyManagementMode::Unspecified => "KEY_MANAGEMENT_MODE_UNSPECIFIED",
                KeyManagementMode::Manual => "MANUAL",
                KeyManagementMode::CloudKms => "CLOUD_KMS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KEY_MANAGEMENT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MANUAL" => Some(Self::Manual),
                "CLOUD_KMS" => Some(Self::CloudKms),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EkmConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub default_ekm_connection: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyConnectivityRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerifyConnectivityResponse {}
/// Generated client implementations.
pub mod ekm_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Google Cloud Key Management EKM Service
    ///
    /// Manages external cryptographic keys and operations using those keys.
    /// Implements a REST model with the following objects:
    /// * [EkmConnection][google.cloud.kms.v1.EkmConnection]
    #[derive(Debug, Clone)]
    pub struct EkmServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> EkmServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EkmServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            EkmServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists [EkmConnections][google.cloud.kms.v1.EkmConnection].
        pub async fn list_ekm_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEkmConnectionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListEkmConnectionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.EkmService/ListEkmConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.EkmService",
                "ListEkmConnections",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns metadata for a given
        /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
        pub async fn get_ekm_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEkmConnectionRequest>,
        ) -> std::result::Result<tonic::Response<super::EkmConnection>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.EkmService/GetEkmConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.EkmService",
                "GetEkmConnection",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new [EkmConnection][google.cloud.kms.v1.EkmConnection] in a given
        /// Project and Location.
        pub async fn create_ekm_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEkmConnectionRequest>,
        ) -> std::result::Result<tonic::Response<super::EkmConnection>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.EkmService/CreateEkmConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.EkmService",
                "CreateEkmConnection",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an [EkmConnection][google.cloud.kms.v1.EkmConnection]'s metadata.
        pub async fn update_ekm_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEkmConnectionRequest>,
        ) -> std::result::Result<tonic::Response<super::EkmConnection>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.EkmService/UpdateEkmConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.EkmService",
                "UpdateEkmConnection",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
        /// for a given project and location.
        pub async fn get_ekm_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEkmConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::EkmConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.EkmService/GetEkmConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.EkmService",
                "GetEkmConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
        /// for a given project and location.
        pub async fn update_ekm_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEkmConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::EkmConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.EkmService/UpdateEkmConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.EkmService",
                "UpdateEkmConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Verifies that Cloud KMS can successfully connect to the external key
        /// manager specified by an [EkmConnection][google.cloud.kms.v1.EkmConnection].
        /// If there is an error connecting to the EKM, this method returns a
        /// FAILED_PRECONDITION status containing structured information as described
        /// at https://cloud.google.com/kms/docs/reference/ekm_errors.
        pub async fn verify_connectivity(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifyConnectivityRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifyConnectivityResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.EkmService/VerifyConnectivity",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.EkmService",
                "VerifyConnectivity",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeyRingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCryptoKeysRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "crypto_key_version::CryptoKeyVersionView", tag = "4")]
    pub version_view: i32,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCryptoKeyVersionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "crypto_key_version::CryptoKeyVersionView", tag = "4")]
    pub view: i32,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImportJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeyRingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub key_rings: ::prost::alloc::vec::Vec<KeyRing>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCryptoKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub crypto_keys: ::prost::alloc::vec::Vec<CryptoKey>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCryptoKeyVersionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub crypto_key_versions: ::prost::alloc::vec::Vec<CryptoKeyVersion>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImportJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub import_jobs: ::prost::alloc::vec::Vec<ImportJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyRingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCryptoKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCryptoKeyVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublicKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImportJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateKeyRingRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key_ring_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub key_ring: ::core::option::Option<KeyRing>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCryptoKeyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub crypto_key_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub crypto_key: ::core::option::Option<CryptoKey>,
    #[prost(bool, tag = "5")]
    pub skip_initial_version_creation: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCryptoKeyVersionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub crypto_key_version: ::core::option::Option<CryptoKeyVersion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCryptoKeyVersionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub crypto_key_version: ::prost::alloc::string::String,
    #[prost(
        enumeration = "crypto_key_version::CryptoKeyVersionAlgorithm",
        tag = "2"
    )]
    pub algorithm: i32,
    #[prost(string, tag = "4")]
    pub import_job: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "8")]
    pub wrapped_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(
        oneof = "import_crypto_key_version_request::WrappedKeyMaterial",
        tags = "5"
    )]
    pub wrapped_key_material:
        ::core::option::Option<import_crypto_key_version_request::WrappedKeyMaterial>,
}
/// Nested message and enum types in `ImportCryptoKeyVersionRequest`.
pub mod import_crypto_key_version_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WrappedKeyMaterial {
        #[prost(bytes, tag = "5")]
        RsaAesWrappedKey(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateImportJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub import_job_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub import_job: ::core::option::Option<ImportJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCryptoKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub crypto_key: ::core::option::Option<CryptoKey>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCryptoKeyVersionRequest {
    #[prost(message, optional, tag = "1")]
    pub crypto_key_version: ::core::option::Option<CryptoKeyVersion>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCryptoKeyPrimaryVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub crypto_key_version_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestroyCryptoKeyVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreCryptoKeyVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub plaintext: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub additional_authenticated_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "7")]
    pub plaintext_crc32c: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "8")]
    pub additional_authenticated_data_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub additional_authenticated_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub ciphertext_crc32c: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "6")]
    pub additional_authenticated_data_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawEncryptRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub plaintext: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub additional_authenticated_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub plaintext_crc32c: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "5")]
    pub additional_authenticated_data_crc32c: ::core::option::Option<i64>,
    #[prost(bytes = "vec", tag = "6")]
    pub initialization_vector: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "7")]
    pub initialization_vector_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawDecryptRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub additional_authenticated_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub initialization_vector: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, tag = "5")]
    pub tag_length: i32,
    #[prost(message, optional, tag = "6")]
    pub ciphertext_crc32c: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "7")]
    pub additional_authenticated_data_crc32c: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "8")]
    pub initialization_vector_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsymmetricSignRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub digest: ::core::option::Option<Digest>,
    #[prost(message, optional, tag = "4")]
    pub digest_crc32c: ::core::option::Option<i64>,
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "7")]
    pub data_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsymmetricDecryptRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub ciphertext_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MacSignRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub data_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MacVerifyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub data_crc32c: ::core::option::Option<i64>,
    #[prost(bytes = "vec", tag = "4")]
    pub mac: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub mac_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateRandomBytesRequest {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub length_bytes: i32,
    #[prost(enumeration = "ProtectionLevel", tag = "3")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub ciphertext_crc32c: ::core::option::Option<i64>,
    #[prost(bool, tag = "5")]
    pub verified_plaintext_crc32c: bool,
    #[prost(bool, tag = "6")]
    pub verified_additional_authenticated_data_crc32c: bool,
    #[prost(enumeration = "ProtectionLevel", tag = "7")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub plaintext: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub plaintext_crc32c: ::core::option::Option<i64>,
    #[prost(bool, tag = "3")]
    pub used_primary: bool,
    #[prost(enumeration = "ProtectionLevel", tag = "4")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawEncryptResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub initialization_vector: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, tag = "3")]
    pub tag_length: i32,
    #[prost(message, optional, tag = "4")]
    pub ciphertext_crc32c: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "5")]
    pub initialization_vector_crc32c: ::core::option::Option<i64>,
    #[prost(bool, tag = "6")]
    pub verified_plaintext_crc32c: bool,
    #[prost(bool, tag = "7")]
    pub verified_additional_authenticated_data_crc32c: bool,
    #[prost(bool, tag = "10")]
    pub verified_initialization_vector_crc32c: bool,
    #[prost(string, tag = "8")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ProtectionLevel", tag = "9")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawDecryptResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub plaintext: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub plaintext_crc32c: ::core::option::Option<i64>,
    #[prost(enumeration = "ProtectionLevel", tag = "3")]
    pub protection_level: i32,
    #[prost(bool, tag = "4")]
    pub verified_ciphertext_crc32c: bool,
    #[prost(bool, tag = "5")]
    pub verified_additional_authenticated_data_crc32c: bool,
    #[prost(bool, tag = "6")]
    pub verified_initialization_vector_crc32c: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsymmetricSignResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub signature_crc32c: ::core::option::Option<i64>,
    #[prost(bool, tag = "3")]
    pub verified_digest_crc32c: bool,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub verified_data_crc32c: bool,
    #[prost(enumeration = "ProtectionLevel", tag = "6")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsymmetricDecryptResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub plaintext: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub plaintext_crc32c: ::core::option::Option<i64>,
    #[prost(bool, tag = "3")]
    pub verified_ciphertext_crc32c: bool,
    #[prost(enumeration = "ProtectionLevel", tag = "4")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MacSignResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub mac: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub mac_crc32c: ::core::option::Option<i64>,
    #[prost(bool, tag = "4")]
    pub verified_data_crc32c: bool,
    #[prost(enumeration = "ProtectionLevel", tag = "5")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MacVerifyResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub success: bool,
    #[prost(bool, tag = "3")]
    pub verified_data_crc32c: bool,
    #[prost(bool, tag = "4")]
    pub verified_mac_crc32c: bool,
    #[prost(bool, tag = "5")]
    pub verified_success_integrity: bool,
    #[prost(enumeration = "ProtectionLevel", tag = "6")]
    pub protection_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateRandomBytesResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub data_crc32c: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Digest {
    #[prost(oneof = "digest::Digest", tags = "1, 2, 3")]
    pub digest: ::core::option::Option<digest::Digest>,
}
/// Nested message and enum types in `Digest`.
pub mod digest {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Digest {
        #[prost(bytes, tag = "1")]
        Sha256(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "2")]
        Sha384(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "3")]
        Sha512(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationMetadata {
    #[prost(bool, tag = "1")]
    pub hsm_available: bool,
    #[prost(bool, tag = "2")]
    pub ekm_available: bool,
}
/// Generated client implementations.
pub mod key_management_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Google Cloud Key Management Service
    ///
    /// Manages cryptographic keys and operations using those keys. Implements a REST
    /// model with the following objects:
    ///
    /// * [KeyRing][google.cloud.kms.v1.KeyRing]
    /// * [CryptoKey][google.cloud.kms.v1.CryptoKey]
    /// * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// * [ImportJob][google.cloud.kms.v1.ImportJob]
    ///
    /// If you are using manual gRPC libraries, see
    /// [Using gRPC with Cloud KMS](https://cloud.google.com/kms/docs/grpc).
    #[derive(Debug, Clone)]
    pub struct KeyManagementServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> KeyManagementServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> KeyManagementServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            KeyManagementServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists [KeyRings][google.cloud.kms.v1.KeyRing].
        pub async fn list_key_rings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKeyRingsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListKeyRingsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/ListKeyRings",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "ListKeyRings",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists [CryptoKeys][google.cloud.kms.v1.CryptoKey].
        pub async fn list_crypto_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCryptoKeysRequest>,
        ) -> std::result::Result<tonic::Response<super::ListCryptoKeysResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/ListCryptoKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "ListCryptoKeys",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
        pub async fn list_crypto_key_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCryptoKeyVersionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListCryptoKeyVersionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/ListCryptoKeyVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "ListCryptoKeyVersions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists [ImportJobs][google.cloud.kms.v1.ImportJob].
        pub async fn list_import_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListImportJobsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListImportJobsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/ListImportJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "ListImportJobs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns metadata for a given [KeyRing][google.cloud.kms.v1.KeyRing].
        pub async fn get_key_ring(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeyRingRequest>,
        ) -> std::result::Result<tonic::Response<super::KeyRing>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/GetKeyRing",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "GetKeyRing",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns metadata for a given [CryptoKey][google.cloud.kms.v1.CryptoKey], as
        /// well as its [primary][google.cloud.kms.v1.CryptoKey.primary]
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
        pub async fn get_crypto_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCryptoKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKey>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/GetCryptoKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "GetCryptoKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns metadata for a given
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
        pub async fn get_crypto_key_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCryptoKeyVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKeyVersion>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/GetCryptoKeyVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "GetCryptoKeyVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the public key for the given
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. The
        /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
        /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]
        /// or
        /// [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
        pub async fn get_public_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPublicKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::PublicKey>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/GetPublicKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "GetPublicKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns metadata for a given [ImportJob][google.cloud.kms.v1.ImportJob].
        pub async fn get_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetImportJobRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportJob>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/GetImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "GetImportJob",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new [KeyRing][google.cloud.kms.v1.KeyRing] in a given Project and
        /// Location.
        pub async fn create_key_ring(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateKeyRingRequest>,
        ) -> std::result::Result<tonic::Response<super::KeyRing>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/CreateKeyRing",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "CreateKeyRing",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new [CryptoKey][google.cloud.kms.v1.CryptoKey] within a
        /// [KeyRing][google.cloud.kms.v1.KeyRing].
        ///
        /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] and
        /// [CryptoKey.version_template.algorithm][google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]
        /// are required.
        pub async fn create_crypto_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCryptoKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKey>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/CreateCryptoKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "CreateCryptoKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in a
        /// [CryptoKey][google.cloud.kms.v1.CryptoKey].
        ///
        /// The server will assign the next sequential id. If unset,
        /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED].
        pub async fn create_crypto_key_version(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCryptoKeyVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKeyVersion>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/CreateCryptoKeyVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "CreateCryptoKeyVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Import wrapped key material into a
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
        ///
        /// All requests must specify a [CryptoKey][google.cloud.kms.v1.CryptoKey]. If
        /// a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] is additionally
        /// specified in the request, key material will be reimported into that
        /// version. Otherwise, a new version will be created, and will be assigned the
        /// next sequential id within the [CryptoKey][google.cloud.kms.v1.CryptoKey].
        pub async fn import_crypto_key_version(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportCryptoKeyVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKeyVersion>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/ImportCryptoKeyVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "ImportCryptoKeyVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new [ImportJob][google.cloud.kms.v1.ImportJob] within a
        /// [KeyRing][google.cloud.kms.v1.KeyRing].
        ///
        /// [ImportJob.import_method][google.cloud.kms.v1.ImportJob.import_method] is
        /// required.
        pub async fn create_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateImportJobRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportJob>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/CreateImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "CreateImportJob",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Update a [CryptoKey][google.cloud.kms.v1.CryptoKey].
        pub async fn update_crypto_key(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCryptoKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKey>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/UpdateCryptoKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "UpdateCryptoKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Update a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s
        /// metadata.
        ///
        /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] may be changed between
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// and
        /// [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
        /// using this method. See
        /// [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]
        /// and
        /// [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
        /// to move between other states.
        pub async fn update_crypto_key_version(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCryptoKeyVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKeyVersion>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/UpdateCryptoKeyVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "UpdateCryptoKeyVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Update the version of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that
        /// will be used in
        /// [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
        ///
        /// Returns an error if called on a key whose purpose is not
        /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
        pub async fn update_crypto_key_primary_version(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCryptoKeyPrimaryVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKey>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/UpdateCryptoKeyPrimaryVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "UpdateCryptoKeyPrimaryVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Schedule a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] for
        /// destruction.
        ///
        /// Upon calling this method,
        /// [CryptoKeyVersion.state][google.cloud.kms.v1.CryptoKeyVersion.state] will
        /// be set to
        /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED],
        /// and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
        /// be set to the time
        /// [destroy_scheduled_duration][google.cloud.kms.v1.CryptoKey.destroy_scheduled_duration]
        /// in the future. At that time, the
        /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] will automatically
        /// change to
        /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED],
        /// and the key material will be irrevocably destroyed.
        ///
        /// Before the
        /// [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] is
        /// reached,
        /// [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
        /// may be called to reverse the process.
        pub async fn destroy_crypto_key_version(
            &mut self,
            request: impl tonic::IntoRequest<super::DestroyCryptoKeyVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKeyVersion>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/DestroyCryptoKeyVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "DestroyCryptoKeyVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Restore a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the
        /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
        /// state.
        ///
        /// Upon restoration of the CryptoKeyVersion,
        /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
        /// [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED],
        /// and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
        /// be cleared.
        pub async fn restore_crypto_key_version(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreCryptoKeyVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::CryptoKeyVersion>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/RestoreCryptoKeyVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "RestoreCryptoKeyVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Encrypts data, so that it can only be recovered by a call to
        /// [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt]. The
        /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
        /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
        pub async fn encrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::EncryptRequest>,
        ) -> std::result::Result<tonic::Response<super::EncryptResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/Encrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "Encrypt",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Decrypts data that was protected by
        /// [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt]. The
        /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
        /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
        pub async fn decrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::DecryptRequest>,
        ) -> std::result::Result<tonic::Response<super::DecryptResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/Decrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "Decrypt",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Encrypts data using portable cryptographic primitives. Most users should
        /// choose [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
        /// [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt] rather than
        /// their raw counterparts. The
        /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
        /// [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
        pub async fn raw_encrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::RawEncryptRequest>,
        ) -> std::result::Result<tonic::Response<super::RawEncryptResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/RawEncrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "RawEncrypt",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Decrypts data that was originally encrypted using a raw cryptographic
        /// mechanism. The [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
        /// must be
        /// [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
        pub async fn raw_decrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::RawDecryptRequest>,
        ) -> std::result::Result<tonic::Response<super::RawDecryptResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/RawDecrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "RawDecrypt",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
        /// with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
        /// ASYMMETRIC_SIGN, producing a signature that can be verified with the public
        /// key retrieved from
        /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
        pub async fn asymmetric_sign(
            &mut self,
            request: impl tonic::IntoRequest<super::AsymmetricSignRequest>,
        ) -> std::result::Result<tonic::Response<super::AsymmetricSignResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/AsymmetricSign",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "AsymmetricSign",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Decrypts data that was encrypted with a public key retrieved from
        /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey]
        /// corresponding to a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
        /// with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
        /// ASYMMETRIC_DECRYPT.
        pub async fn asymmetric_decrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::AsymmetricDecryptRequest>,
        ) -> std::result::Result<tonic::Response<super::AsymmetricDecryptResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/AsymmetricDecrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "AsymmetricDecrypt",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
        /// with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC,
        /// producing a tag that can be verified by another source with the same key.
        pub async fn mac_sign(
            &mut self,
            request: impl tonic::IntoRequest<super::MacSignRequest>,
        ) -> std::result::Result<tonic::Response<super::MacSignResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/MacSign",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "MacSign",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Verifies MAC tag using a
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
        /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC, and returns
        /// a response that indicates whether or not the verification was successful.
        pub async fn mac_verify(
            &mut self,
            request: impl tonic::IntoRequest<super::MacVerifyRequest>,
        ) -> std::result::Result<tonic::Response<super::MacVerifyResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/MacVerify",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "MacVerify",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Generate random bytes using the Cloud KMS randomness source in the provided
        /// location.
        pub async fn generate_random_bytes(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateRandomBytesRequest>,
        ) -> std::result::Result<tonic::Response<super::GenerateRandomBytesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.KeyManagementService/GenerateRandomBytes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.KeyManagementService",
                "GenerateRandomBytes",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateKeyHandleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key_handle_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub key_handle: ::core::option::Option<KeyHandle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyHandleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyHandle {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub kms_key: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub resource_type_selector: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateKeyHandleMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeyHandlesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeyHandlesResponse {
    #[prost(message, repeated, tag = "1")]
    pub key_handles: ::prost::alloc::vec::Vec<KeyHandle>,
}
/// Generated client implementations.
pub mod autokey_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Provides interfaces for using Cloud KMS Autokey to provision new
    /// [CryptoKeys][google.cloud.kms.v1.CryptoKey], ready for Customer Managed
    /// Encryption Key (CMEK) use, on-demand. To support certain client tooling, this
    /// feature is modeled around a [KeyHandle][google.cloud.kms.v1.KeyHandle]
    /// resource: creating a [KeyHandle][google.cloud.kms.v1.KeyHandle] in a resource
    /// project and given location triggers Cloud KMS Autokey to provision a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] in the configured key project and
    /// the same location.
    ///
    /// Prior to use in a given resource project,
    /// [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig]
    /// should have been called on an ancestor folder, setting the key project where
    /// Cloud KMS Autokey should create new
    /// [CryptoKeys][google.cloud.kms.v1.CryptoKey]. See documentation for additional
    /// prerequisites. To check what key project, if any, is currently configured on
    /// a resource project's ancestor folder, see
    /// [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
    #[derive(Debug, Clone)]
    pub struct AutokeyClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AutokeyClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AutokeyClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AutokeyClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new [KeyHandle][google.cloud.kms.v1.KeyHandle], triggering the
        /// provisioning of a new [CryptoKey][google.cloud.kms.v1.CryptoKey] for CMEK
        /// use with the given resource type in the configured key project and the same
        /// location. [GetOperation][Operations.GetOperation] should be used to resolve
        /// the resulting long-running operation and get the resulting
        /// [KeyHandle][google.cloud.kms.v1.KeyHandle] and
        /// [CryptoKey][google.cloud.kms.v1.CryptoKey].
        pub async fn create_key_handle(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateKeyHandleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.kms.v1.Autokey/CreateKeyHandle",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.Autokey",
                "CreateKeyHandle",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the [KeyHandle][google.cloud.kms.v1.KeyHandle].
        pub async fn get_key_handle(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeyHandleRequest>,
        ) -> std::result::Result<tonic::Response<super::KeyHandle>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/google.cloud.kms.v1.Autokey/GetKeyHandle");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.Autokey",
                "GetKeyHandle",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists [KeyHandles][google.cloud.kms.v1.KeyHandle].
        pub async fn list_key_handles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKeyHandlesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListKeyHandlesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/google.cloud.kms.v1.Autokey/ListKeyHandles");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.kms.v1.Autokey",
                "ListKeyHandles",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
