// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperationProgress {
#[prost(int32, tag = "1")]
pub progress_percent: i32,
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentPeriod {
Unspecified = 0,
Normal = 1,
Extended = 2,
}
impl FulfillmentPeriod {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FulfillmentPeriod::Unspecified => "FULFILLMENT_PERIOD_UNSPECIFIED",
FulfillmentPeriod::Normal => "FULFILLMENT_PERIOD_NORMAL",
FulfillmentPeriod::Extended => "FULFILLMENT_PERIOD_EXTENDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FULFILLMENT_PERIOD_UNSPECIFIED" => Some(Self::Unspecified),
"FULFILLMENT_PERIOD_NORMAL" => Some(Self::Normal),
"FULFILLMENT_PERIOD_EXTENDED" => Some(Self::Extended),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicaInfo {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(enumeration = "replica_info::ReplicaType", tag = "2")]
pub r#type: i32,
#[prost(bool, tag = "3")]
pub default_leader_location: bool,
}
/// Nested message and enum types in `ReplicaInfo`.
pub mod replica_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplicaType {
TypeUnspecified = 0,
ReadWrite = 1,
ReadOnly = 2,
Witness = 3,
}
impl ReplicaType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ReplicaType::TypeUnspecified => "TYPE_UNSPECIFIED",
ReplicaType::ReadWrite => "READ_WRITE",
ReplicaType::ReadOnly => "READ_ONLY",
ReplicaType::Witness => "WITNESS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::TypeUnspecified),
"READ_WRITE" => Some(Self::ReadWrite),
"READ_ONLY" => Some(Self::ReadOnly),
"WITNESS" => Some(Self::Witness),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceConfig {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "instance_config::Type", tag = "5")]
pub config_type: i32,
#[prost(message, repeated, tag = "3")]
pub replicas: ::prost::alloc::vec::Vec<ReplicaInfo>,
#[prost(message, repeated, tag = "6")]
pub optional_replicas: ::prost::alloc::vec::Vec<ReplicaInfo>,
#[prost(string, tag = "7")]
pub base_config: ::prost::alloc::string::String,
#[prost(map = "string, string", tag = "8")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "9")]
pub etag: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub leader_options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "10")]
pub reconciling: bool,
#[prost(enumeration = "instance_config::State", tag = "11")]
pub state: i32,
}
/// Nested message and enum types in `InstanceConfig`.
pub mod instance_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
GoogleManaged = 1,
UserManaged = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::GoogleManaged => "GOOGLE_MANAGED",
Type::UserManaged => "USER_MANAGED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"GOOGLE_MANAGED" => Some(Self::GoogleManaged),
"USER_MANAGED" => Some(Self::UserManaged),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Ready = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Ready => "READY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"READY" => Some(Self::Ready),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoscalingConfig {
#[prost(message, optional, tag = "1")]
pub autoscaling_limits: ::core::option::Option<autoscaling_config::AutoscalingLimits>,
#[prost(message, optional, tag = "2")]
pub autoscaling_targets: ::core::option::Option<autoscaling_config::AutoscalingTargets>,
}
/// Nested message and enum types in `AutoscalingConfig`.
pub mod autoscaling_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoscalingLimits {
#[prost(oneof = "autoscaling_limits::MinLimit", tags = "1, 2")]
pub min_limit: ::core::option::Option<autoscaling_limits::MinLimit>,
#[prost(oneof = "autoscaling_limits::MaxLimit", tags = "3, 4")]
pub max_limit: ::core::option::Option<autoscaling_limits::MaxLimit>,
}
/// Nested message and enum types in `AutoscalingLimits`.
pub mod autoscaling_limits {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum MinLimit {
#[prost(int32, tag = "1")]
MinNodes(i32),
#[prost(int32, tag = "2")]
MinProcessingUnits(i32),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum MaxLimit {
#[prost(int32, tag = "3")]
MaxNodes(i32),
#[prost(int32, tag = "4")]
MaxProcessingUnits(i32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoscalingTargets {
#[prost(int32, tag = "1")]
pub high_priority_cpu_utilization_percent: i32,
#[prost(int32, tag = "2")]
pub storage_utilization_percent: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub config: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(int32, tag = "5")]
pub node_count: i32,
#[prost(int32, tag = "9")]
pub processing_units: i32,
#[prost(message, optional, tag = "17")]
pub autoscaling_config: ::core::option::Option<AutoscalingConfig>,
#[prost(enumeration = "instance::State", tag = "6")]
pub state: i32,
#[prost(map = "string, string", tag = "7")]
pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, repeated, tag = "8")]
pub endpoint_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "11")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "12")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Instance`.
pub mod instance {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Ready = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Ready => "READY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"READY" => Some(Self::Ready),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceConfigsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceConfigsResponse {
#[prost(message, repeated, tag = "1")]
pub instance_configs: ::prost::alloc::vec::Vec<InstanceConfig>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceConfigRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceConfigRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub instance_config_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub instance_config: ::core::option::Option<InstanceConfig>,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceConfigRequest {
#[prost(message, optional, tag = "1")]
pub instance_config: ::core::option::Option<InstanceConfig>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceConfigRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceConfigOperationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceConfigOperationsResponse {
#[prost(message, repeated, tag = "1")]
pub operations: ::prost::alloc::vec::Vec<super::super::super::super::longrunning::Operation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub instance_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub instance: ::core::option::Option<Instance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub instance_deadline: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesResponse {
#[prost(message, repeated, tag = "1")]
pub instances: ::prost::alloc::vec::Vec<Instance>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceRequest {
#[prost(message, optional, tag = "1")]
pub instance: ::core::option::Option<Instance>,
#[prost(message, optional, tag = "2")]
pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceMetadata {
#[prost(message, optional, tag = "1")]
pub instance: ::core::option::Option<Instance>,
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub cancel_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "FulfillmentPeriod", tag = "5")]
pub expected_fulfillment_period: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceMetadata {
#[prost(message, optional, tag = "1")]
pub instance: ::core::option::Option<Instance>,
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub cancel_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "FulfillmentPeriod", tag = "5")]
pub expected_fulfillment_period: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceConfigMetadata {
#[prost(message, optional, tag = "1")]
pub instance_config: ::core::option::Option<InstanceConfig>,
#[prost(message, optional, tag = "2")]
pub progress: ::core::option::Option<OperationProgress>,
#[prost(message, optional, tag = "3")]
pub cancel_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceConfigMetadata {
#[prost(message, optional, tag = "1")]
pub instance_config: ::core::option::Option<InstanceConfig>,
#[prost(message, optional, tag = "2")]
pub progress: ::core::option::Option<OperationProgress>,
#[prost(message, optional, tag = "3")]
pub cancel_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancePartition {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub config: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "instance_partition::State", tag = "7")]
pub state: i32,
#[prost(message, optional, tag = "8")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, repeated, tag = "10")]
pub referencing_databases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "11")]
pub referencing_backups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "12")]
pub etag: ::prost::alloc::string::String,
#[prost(oneof = "instance_partition::ComputeCapacity", tags = "5, 6")]
pub compute_capacity: ::core::option::Option<instance_partition::ComputeCapacity>,
}
/// Nested message and enum types in `InstancePartition`.
pub mod instance_partition {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Ready = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Ready => "READY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"READY" => Some(Self::Ready),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum ComputeCapacity {
#[prost(int32, tag = "5")]
NodeCount(i32),
#[prost(int32, tag = "6")]
ProcessingUnits(i32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstancePartitionMetadata {
#[prost(message, optional, tag = "1")]
pub instance_partition: ::core::option::Option<InstancePartition>,
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub cancel_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstancePartitionRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub instance_partition_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub instance_partition: ::core::option::Option<InstancePartition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstancePartitionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstancePartitionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstancePartitionRequest {
#[prost(message, optional, tag = "1")]
pub instance_partition: ::core::option::Option<InstancePartition>,
#[prost(message, optional, tag = "2")]
pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstancePartitionMetadata {
#[prost(message, optional, tag = "1")]
pub instance_partition: ::core::option::Option<InstancePartition>,
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub cancel_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancePartitionsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub instance_partition_deadline: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancePartitionsResponse {
#[prost(message, repeated, tag = "1")]
pub instance_partitions: ::prost::alloc::vec::Vec<InstancePartition>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancePartitionOperationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub instance_partition_deadline: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancePartitionOperationsResponse {
#[prost(message, repeated, tag = "1")]
pub operations: ::prost::alloc::vec::Vec<super::super::super::super::longrunning::Operation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable_instance_partitions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod instance_admin_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Cloud Spanner Instance Admin API
///
/// The Cloud Spanner Instance Admin API can be used to create, delete,
/// modify and list instances. Instances are dedicated Cloud Spanner serving
/// and storage resources to be used by Cloud Spanner databases.
///
/// Each instance has a "configuration", which dictates where the
/// serving resources for the Cloud Spanner instance are located (e.g.,
/// US-central, Europe). Configurations are created by Google based on
/// resource availability.
///
/// Cloud Spanner billing is based on the instances that exist and their
/// sizes. After an instance exists, there are no additional
/// per-database or per-operation charges for use of the instance
/// (though there may be additional network bandwidth charges).
/// Instances offer isolation: problems with databases in one instance
/// will not affect other instances. However, within an instance
/// databases can affect each other. For example, if one database in an
/// instance receives a lot of requests and consumes most of the
/// instance resources, fewer resources are available for other
/// databases in that instance, and their performance may suffer.
#[derive(Debug, Clone)]
pub struct InstanceAdminClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> InstanceAdminClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> InstanceAdminClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
InstanceAdminClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Lists the supported instance configurations for a given project.
pub async fn list_instance_configs(&mut self, request: impl tonic::IntoRequest<super::ListInstanceConfigsRequest>) -> std::result::Result<tonic::Response<super::ListInstanceConfigsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/ListInstanceConfigs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "ListInstanceConfigs"));
self.inner.unary(req, path, codec).await
}
/// Gets information about a particular instance configuration.
pub async fn get_instance_config(&mut self, request: impl tonic::IntoRequest<super::GetInstanceConfigRequest>) -> std::result::Result<tonic::Response<super::InstanceConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/GetInstanceConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "GetInstanceConfig"));
self.inner.unary(req, path, codec).await
}
/// Creates an instance config and begins preparing it to be used. The
/// returned [long-running operation][google.longrunning.Operation]
/// can be used to track the progress of preparing the new
/// instance config. The instance config name is assigned by the caller. If the
/// named instance config already exists, `CreateInstanceConfig` returns
/// `ALREADY_EXISTS`.
///
/// Immediately after the request returns:
///
///   * The instance config is readable via the API, with all requested
///     attributes. The instance config's
///     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
///     field is set to true. Its state is `CREATING`.
///
/// While the operation is pending:
///
///   * Cancelling the operation renders the instance config immediately
///     unreadable via the API.
///   * Except for deleting the creating resource, all other attempts to modify
///     the instance config are rejected.
///
/// Upon completion of the returned operation:
///
///   * Instances can be created using the instance configuration.
///   * The instance config's
///   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
///   field becomes false. Its state becomes `READY`.
///
/// The returned [long-running operation][google.longrunning.Operation] will
/// have a name of the format
/// `<instance_config_name>/operations/<operation_id>` and can be used to track
/// creation of the instance config. The
/// [metadata][google.longrunning.Operation.metadata] field type is
/// [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
/// The [response][google.longrunning.Operation.response] field type is
/// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
/// successful.
///
/// Authorization requires `spanner.instanceConfigs.create` permission on
/// the resource
/// [parent][google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent].
pub async fn create_instance_config(&mut self, request: impl tonic::IntoRequest<super::CreateInstanceConfigRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/CreateInstanceConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "CreateInstanceConfig"));
self.inner.unary(req, path, codec).await
}
/// Updates an instance config. The returned
/// [long-running operation][google.longrunning.Operation] can be used to track
/// the progress of updating the instance. If the named instance config does
/// not exist, returns `NOT_FOUND`.
///
/// Only user managed configurations can be updated.
///
/// Immediately after the request returns:
///
///   * The instance config's
///     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
///     field is set to true.
///
/// While the operation is pending:
///
///   * Cancelling the operation sets its metadata's
///     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time].
///     The operation is guaranteed to succeed at undoing all changes, after
///     which point it terminates with a `CANCELLED` status.
///   * All other attempts to modify the instance config are rejected.
///   * Reading the instance config via the API continues to give the
///     pre-request values.
///
/// Upon completion of the returned operation:
///
///   * Creating instances using the instance configuration uses the new
///     values.
///   * The instance config's new values are readable via the API.
///   * The instance config's
///   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
///   field becomes false.
///
/// The returned [long-running operation][google.longrunning.Operation] will
/// have a name of the format
/// `<instance_config_name>/operations/<operation_id>` and can be used to track
/// the instance config modification.  The
/// [metadata][google.longrunning.Operation.metadata] field type is
/// [UpdateInstanceConfigMetadata][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata].
/// The [response][google.longrunning.Operation.response] field type is
/// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
/// successful.
///
/// Authorization requires `spanner.instanceConfigs.update` permission on
/// the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
pub async fn update_instance_config(&mut self, request: impl tonic::IntoRequest<super::UpdateInstanceConfigRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/UpdateInstanceConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "UpdateInstanceConfig"));
self.inner.unary(req, path, codec).await
}
/// Deletes the instance config. Deletion is only allowed when no
/// instances are using the configuration. If any instances are using
/// the config, returns `FAILED_PRECONDITION`.
///
/// Only user managed configurations can be deleted.
///
/// Authorization requires `spanner.instanceConfigs.delete` permission on
/// the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
pub async fn delete_instance_config(&mut self, request: impl tonic::IntoRequest<super::DeleteInstanceConfigRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/DeleteInstanceConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "DeleteInstanceConfig"));
self.inner.unary(req, path, codec).await
}
/// Lists the user-managed instance config [long-running
/// operations][google.longrunning.Operation] in the given project. An instance
/// config operation has a name of the form
/// `projects/<project>/instanceConfigs/<instance_config>/operations/<operation>`.
/// The long-running operation
/// [metadata][google.longrunning.Operation.metadata] field type
/// `metadata.type_url` describes the type of the metadata. Operations returned
/// include those that have completed/failed/canceled within the last 7 days,
/// and pending operations. Operations returned are ordered by
/// `operation.metadata.value.start_time` in descending order starting
/// from the most recently started operation.
pub async fn list_instance_config_operations(&mut self, request: impl tonic::IntoRequest<super::ListInstanceConfigOperationsRequest>) -> std::result::Result<tonic::Response<super::ListInstanceConfigOperationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/ListInstanceConfigOperations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "ListInstanceConfigOperations"));
self.inner.unary(req, path, codec).await
}
/// Lists all instances in the given project.
pub async fn list_instances(&mut self, request: impl tonic::IntoRequest<super::ListInstancesRequest>) -> std::result::Result<tonic::Response<super::ListInstancesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/ListInstances");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "ListInstances"));
self.inner.unary(req, path, codec).await
}
/// Lists all instance partitions for the given instance.
pub async fn list_instance_partitions(&mut self, request: impl tonic::IntoRequest<super::ListInstancePartitionsRequest>) -> std::result::Result<tonic::Response<super::ListInstancePartitionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/ListInstancePartitions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "ListInstancePartitions"));
self.inner.unary(req, path, codec).await
}
/// Gets information about a particular instance.
pub async fn get_instance(&mut self, request: impl tonic::IntoRequest<super::GetInstanceRequest>) -> std::result::Result<tonic::Response<super::Instance>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/GetInstance");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "GetInstance"));
self.inner.unary(req, path, codec).await
}
/// Creates an instance and begins preparing it to begin serving. The
/// returned [long-running operation][google.longrunning.Operation]
/// can be used to track the progress of preparing the new
/// instance. The instance name is assigned by the caller. If the
/// named instance already exists, `CreateInstance` returns
/// `ALREADY_EXISTS`.
///
/// Immediately upon completion of this request:
///
///   * The instance is readable via the API, with all requested attributes
///     but no allocated resources. Its state is `CREATING`.
///
/// Until completion of the returned operation:
///
///   * Cancelling the operation renders the instance immediately unreadable
///     via the API.
///   * The instance can be deleted.
///   * All other attempts to modify the instance are rejected.
///
/// Upon completion of the returned operation:
///
///   * Billing for all successfully-allocated resources begins (some types
///     may have lower than the requested levels).
///   * Databases can be created in the instance.
///   * The instance's allocated resource levels are readable via the API.
///   * The instance's state becomes `READY`.
///
/// The returned [long-running operation][google.longrunning.Operation] will
/// have a name of the format `<instance_name>/operations/<operation_id>` and
/// can be used to track creation of the instance.  The
/// [metadata][google.longrunning.Operation.metadata] field type is
/// [CreateInstanceMetadata][google.spanner.admin.instance.v1.CreateInstanceMetadata].
/// The [response][google.longrunning.Operation.response] field type is
/// [Instance][google.spanner.admin.instance.v1.Instance], if successful.
pub async fn create_instance(&mut self, request: impl tonic::IntoRequest<super::CreateInstanceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/CreateInstance");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "CreateInstance"));
self.inner.unary(req, path, codec).await
}
/// Updates an instance, and begins allocating or releasing resources
/// as requested. The returned [long-running
/// operation][google.longrunning.Operation] can be used to track the
/// progress of updating the instance. If the named instance does not
/// exist, returns `NOT_FOUND`.
///
/// Immediately upon completion of this request:
///
///   * For resource types for which a decrease in the instance's allocation
///     has been requested, billing is based on the newly-requested level.
///
/// Until completion of the returned operation:
///
///   * Cancelling the operation sets its metadata's
///     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time],
///     and begins restoring resources to their pre-request values. The
///     operation is guaranteed to succeed at undoing all resource changes,
///     after which point it terminates with a `CANCELLED` status.
///   * All other attempts to modify the instance are rejected.
///   * Reading the instance via the API continues to give the pre-request
///     resource levels.
///
/// Upon completion of the returned operation:
///
///   * Billing begins for all successfully-allocated resources (some types
///     may have lower than the requested levels).
///   * All newly-reserved resources are available for serving the instance's
///     tables.
///   * The instance's new resource levels are readable via the API.
///
/// The returned [long-running operation][google.longrunning.Operation] will
/// have a name of the format `<instance_name>/operations/<operation_id>` and
/// can be used to track the instance modification.  The
/// [metadata][google.longrunning.Operation.metadata] field type is
/// [UpdateInstanceMetadata][google.spanner.admin.instance.v1.UpdateInstanceMetadata].
/// The [response][google.longrunning.Operation.response] field type is
/// [Instance][google.spanner.admin.instance.v1.Instance], if successful.
///
/// Authorization requires `spanner.instances.update` permission on
/// the resource [name][google.spanner.admin.instance.v1.Instance.name].
pub async fn update_instance(&mut self, request: impl tonic::IntoRequest<super::UpdateInstanceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/UpdateInstance");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "UpdateInstance"));
self.inner.unary(req, path, codec).await
}
/// Deletes an instance.
///
/// Immediately upon completion of the request:
///
///   * Billing ceases for all of the instance's reserved resources.
///
/// Soon afterward:
///
///   * The instance and *all of its databases* immediately and
///     irrevocably disappear from the API. All data in the databases
///     is permanently deleted.
pub async fn delete_instance(&mut self, request: impl tonic::IntoRequest<super::DeleteInstanceRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/DeleteInstance");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "DeleteInstance"));
self.inner.unary(req, path, codec).await
}
/// Sets the access control policy on an instance resource. Replaces any
/// existing policy.
///
/// Authorization requires `spanner.instances.setIamPolicy` on
/// [resource][google.iam.v1.SetIamPolicyRequest.resource].
pub async fn set_iam_policy(&mut self, request: impl tonic::IntoRequest<super::super::super::super::super::iam::v1::SetIamPolicyRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::iam::v1::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/SetIamPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "SetIamPolicy"));
self.inner.unary(req, path, codec).await
}
/// Gets the access control policy for an instance resource. Returns an empty
/// policy if an instance exists but does not have a policy set.
///
/// Authorization requires `spanner.instances.getIamPolicy` on
/// [resource][google.iam.v1.GetIamPolicyRequest.resource].
pub async fn get_iam_policy(&mut self, request: impl tonic::IntoRequest<super::super::super::super::super::iam::v1::GetIamPolicyRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::iam::v1::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/GetIamPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "GetIamPolicy"));
self.inner.unary(req, path, codec).await
}
/// Returns permissions that the caller has on the specified instance resource.
///
/// Attempting this RPC on a non-existent Cloud Spanner instance resource will
/// result in a NOT_FOUND error if the user has `spanner.instances.list`
/// permission on the containing Google Cloud Project. Otherwise returns an
/// empty set of permissions.
pub async fn test_iam_permissions(&mut self, request: impl tonic::IntoRequest<super::super::super::super::super::iam::v1::TestIamPermissionsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::iam::v1::TestIamPermissionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/TestIamPermissions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "TestIamPermissions"));
self.inner.unary(req, path, codec).await
}
/// Gets information about a particular instance partition.
pub async fn get_instance_partition(&mut self, request: impl tonic::IntoRequest<super::GetInstancePartitionRequest>) -> std::result::Result<tonic::Response<super::InstancePartition>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/GetInstancePartition");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "GetInstancePartition"));
self.inner.unary(req, path, codec).await
}
/// Creates an instance partition and begins preparing it to be used. The
/// returned [long-running operation][google.longrunning.Operation]
/// can be used to track the progress of preparing the new instance partition.
/// The instance partition name is assigned by the caller. If the named
/// instance partition already exists, `CreateInstancePartition` returns
/// `ALREADY_EXISTS`.
///
/// Immediately upon completion of this request:
///
///   * The instance partition is readable via the API, with all requested
///     attributes but no allocated resources. Its state is `CREATING`.
///
/// Until completion of the returned operation:
///
///   * Cancelling the operation renders the instance partition immediately
///     unreadable via the API.
///   * The instance partition can be deleted.
///   * All other attempts to modify the instance partition are rejected.
///
/// Upon completion of the returned operation:
///
///   * Billing for all successfully-allocated resources begins (some types
///     may have lower than the requested levels).
///   * Databases can start using this instance partition.
///   * The instance partition's allocated resource levels are readable via the
///     API.
///   * The instance partition's state becomes `READY`.
///
/// The returned [long-running operation][google.longrunning.Operation] will
/// have a name of the format
/// `<instance_partition_name>/operations/<operation_id>` and can be used to
/// track creation of the instance partition.  The
/// [metadata][google.longrunning.Operation.metadata] field type is
/// [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
/// The [response][google.longrunning.Operation.response] field type is
/// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
/// successful.
pub async fn create_instance_partition(&mut self, request: impl tonic::IntoRequest<super::CreateInstancePartitionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/CreateInstancePartition");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "CreateInstancePartition"));
self.inner.unary(req, path, codec).await
}
/// Deletes an existing instance partition. Requires that the
/// instance partition is not used by any database or backup and is not the
/// default instance partition of an instance.
///
/// Authorization requires `spanner.instancePartitions.delete` permission on
/// the resource
/// [name][google.spanner.admin.instance.v1.InstancePartition.name].
pub async fn delete_instance_partition(&mut self, request: impl tonic::IntoRequest<super::DeleteInstancePartitionRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/DeleteInstancePartition");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "DeleteInstancePartition"));
self.inner.unary(req, path, codec).await
}
/// Updates an instance partition, and begins allocating or releasing resources
/// as requested. The returned [long-running
/// operation][google.longrunning.Operation] can be used to track the
/// progress of updating the instance partition. If the named instance
/// partition does not exist, returns `NOT_FOUND`.
///
/// Immediately upon completion of this request:
///
///   * For resource types for which a decrease in the instance partition's
///   allocation has been requested, billing is based on the newly-requested
///   level.
///
/// Until completion of the returned operation:
///
///   * Cancelling the operation sets its metadata's
///     [cancel_time][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata.cancel_time],
///     and begins restoring resources to their pre-request values. The
///     operation is guaranteed to succeed at undoing all resource changes,
///     after which point it terminates with a `CANCELLED` status.
///   * All other attempts to modify the instance partition are rejected.
///   * Reading the instance partition via the API continues to give the
///     pre-request resource levels.
///
/// Upon completion of the returned operation:
///
///   * Billing begins for all successfully-allocated resources (some types
///     may have lower than the requested levels).
///   * All newly-reserved resources are available for serving the instance
///     partition's tables.
///   * The instance partition's new resource levels are readable via the API.
///
/// The returned [long-running operation][google.longrunning.Operation] will
/// have a name of the format
/// `<instance_partition_name>/operations/<operation_id>` and can be used to
/// track the instance partition modification. The
/// [metadata][google.longrunning.Operation.metadata] field type is
/// [UpdateInstancePartitionMetadata][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata].
/// The [response][google.longrunning.Operation.response] field type is
/// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
/// successful.
///
/// Authorization requires `spanner.instancePartitions.update` permission on
/// the resource
/// [name][google.spanner.admin.instance.v1.InstancePartition.name].
pub async fn update_instance_partition(&mut self, request: impl tonic::IntoRequest<super::UpdateInstancePartitionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/UpdateInstancePartition");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "UpdateInstancePartition"));
self.inner.unary(req, path, codec).await
}
/// Lists instance partition [long-running
/// operations][google.longrunning.Operation] in the given instance.
/// An instance partition operation has a name of the form
/// `projects/<project>/instances/<instance>/instancePartitions/<instance_partition>/operations/<operation>`.
/// The long-running operation
/// [metadata][google.longrunning.Operation.metadata] field type
/// `metadata.type_url` describes the type of the metadata. Operations returned
/// include those that have completed/failed/canceled within the last 7 days,
/// and pending operations. Operations returned are ordered by
/// `operation.metadata.value.start_time` in descending order starting from the
/// most recently started operation.
///
/// Authorization requires `spanner.instancePartitionOperations.list`
/// permission on the resource
/// [parent][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.parent].
pub async fn list_instance_partition_operations(&mut self, request: impl tonic::IntoRequest<super::ListInstancePartitionOperationsRequest>) -> std::result::Result<tonic::Response<super::ListInstancePartitionOperationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.admin.instance.v1.InstanceAdmin/ListInstancePartitionOperations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.admin.instance.v1.InstanceAdmin", "ListInstancePartitionOperations"));
self.inner.unary(req, path, codec).await
}
}
}
