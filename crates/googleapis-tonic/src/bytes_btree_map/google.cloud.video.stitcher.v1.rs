// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(enumeration = "event::EventType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub offset: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EventType {
        Unspecified = 0,
        CreativeView = 1,
        Start = 2,
        BreakStart = 3,
        BreakEnd = 4,
        Impression = 5,
        FirstQuartile = 6,
        Midpoint = 7,
        ThirdQuartile = 8,
        Complete = 9,
        Progress = 10,
        Mute = 11,
        Unmute = 12,
        Pause = 13,
        Click = 14,
        ClickThrough = 15,
        Rewind = 16,
        Resume = 17,
        Error = 18,
        Expand = 21,
        Collapse = 22,
        Close = 24,
        CloseLinear = 25,
        Skip = 26,
        AcceptInvitation = 27,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EventType::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                EventType::CreativeView => "CREATIVE_VIEW",
                EventType::Start => "START",
                EventType::BreakStart => "BREAK_START",
                EventType::BreakEnd => "BREAK_END",
                EventType::Impression => "IMPRESSION",
                EventType::FirstQuartile => "FIRST_QUARTILE",
                EventType::Midpoint => "MIDPOINT",
                EventType::ThirdQuartile => "THIRD_QUARTILE",
                EventType::Complete => "COMPLETE",
                EventType::Progress => "PROGRESS",
                EventType::Mute => "MUTE",
                EventType::Unmute => "UNMUTE",
                EventType::Pause => "PAUSE",
                EventType::Click => "CLICK",
                EventType::ClickThrough => "CLICK_THROUGH",
                EventType::Rewind => "REWIND",
                EventType::Resume => "RESUME",
                EventType::Error => "ERROR",
                EventType::Expand => "EXPAND",
                EventType::Collapse => "COLLAPSE",
                EventType::Close => "CLOSE",
                EventType::CloseLinear => "CLOSE_LINEAR",
                EventType::Skip => "SKIP",
                EventType::AcceptInvitation => "ACCEPT_INVITATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATIVE_VIEW" => Some(Self::CreativeView),
                "START" => Some(Self::Start),
                "BREAK_START" => Some(Self::BreakStart),
                "BREAK_END" => Some(Self::BreakEnd),
                "IMPRESSION" => Some(Self::Impression),
                "FIRST_QUARTILE" => Some(Self::FirstQuartile),
                "MIDPOINT" => Some(Self::Midpoint),
                "THIRD_QUARTILE" => Some(Self::ThirdQuartile),
                "COMPLETE" => Some(Self::Complete),
                "PROGRESS" => Some(Self::Progress),
                "MUTE" => Some(Self::Mute),
                "UNMUTE" => Some(Self::Unmute),
                "PAUSE" => Some(Self::Pause),
                "CLICK" => Some(Self::Click),
                "CLICK_THROUGH" => Some(Self::ClickThrough),
                "REWIND" => Some(Self::Rewind),
                "RESUME" => Some(Self::Resume),
                "ERROR" => Some(Self::Error),
                "EXPAND" => Some(Self::Expand),
                "COLLAPSE" => Some(Self::Collapse),
                "CLOSE" => Some(Self::Close),
                "CLOSE_LINEAR" => Some(Self::CloseLinear),
                "SKIP" => Some(Self::Skip),
                "ACCEPT_INVITATION" => Some(Self::AcceptInvitation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgressEvent {
    #[prost(message, optional, tag = "1")]
    pub time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, repeated, tag = "2")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Slate {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub gam_slate: ::core::option::Option<slate::GamSlate>,
}
/// Nested message and enum types in `Slate`.
pub mod slate {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GamSlate {
        #[prost(string, tag = "1")]
        pub network_code: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub gam_slate_id: i64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchOptions {
    #[prost(btree_map = "string, string", tag = "1")]
    pub headers: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VodConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ad_tag_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub gam_vod_config: ::core::option::Option<GamVodConfig>,
    #[prost(enumeration = "vod_config::State", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "8")]
    pub source_fetch_options: ::core::option::Option<FetchOptions>,
}
/// Nested message and enum types in `VodConfig`.
pub mod vod_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GamVodConfig {
    #[prost(string, tag = "1")]
    pub network_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveAdTagDetail {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub ad_requests: ::prost::alloc::vec::Vec<AdRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VodAdTagDetail {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub ad_requests: ::prost::alloc::vec::Vec<AdRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdRequest {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
    #[prost(message, optional, tag = "3")]
    pub response_metadata: ::core::option::Option<ResponseMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestMetadata {
    #[prost(message, optional, tag = "1")]
    pub headers: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseMetadata {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub headers: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "3")]
    pub status_code: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub size_bytes: i32,
    #[prost(message, optional, tag = "5")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "6")]
    pub body: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CdnKey {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(oneof = "cdn_key::CdnKeyConfig", tags = "5, 6, 8")]
    pub cdn_key_config: ::core::option::Option<cdn_key::CdnKeyConfig>,
}
/// Nested message and enum types in `CdnKey`.
pub mod cdn_key {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CdnKeyConfig {
        #[prost(message, tag = "5")]
        GoogleCdnKey(super::GoogleCdnKey),
        #[prost(message, tag = "6")]
        AkamaiCdnKey(super::AkamaiCdnKey),
        #[prost(message, tag = "8")]
        MediaCdnKey(super::MediaCdnKey),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleCdnKey {
    #[prost(bytes = "bytes", tag = "1")]
    pub private_key: ::prost::bytes::Bytes,
    #[prost(string, tag = "2")]
    pub key_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkamaiCdnKey {
    #[prost(bytes = "bytes", tag = "1")]
    pub token_key: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaCdnKey {
    #[prost(bytes = "bytes", tag = "1")]
    pub private_key: ::prost::bytes::Bytes,
    #[prost(string, tag = "2")]
    pub key_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub token_config: ::core::option::Option<media_cdn_key::TokenConfig>,
}
/// Nested message and enum types in `MediaCdnKey`.
pub mod media_cdn_key {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TokenConfig {
        #[prost(string, tag = "1")]
        pub query_parameter: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ad_tag_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub gam_live_config: ::core::option::Option<GamLiveConfig>,
    #[prost(enumeration = "live_config::State", tag = "5")]
    pub state: i32,
    #[prost(enumeration = "AdTracking", tag = "6")]
    pub ad_tracking: i32,
    #[prost(string, tag = "7")]
    pub default_slate: ::prost::alloc::string::String,
    #[prost(enumeration = "live_config::StitchingPolicy", tag = "8")]
    pub stitching_policy: i32,
    #[prost(message, optional, tag = "10")]
    pub prefetch_config: ::core::option::Option<PrefetchConfig>,
    #[prost(message, optional, tag = "16")]
    pub source_fetch_options: ::core::option::Option<FetchOptions>,
}
/// Nested message and enum types in `LiveConfig`.
pub mod live_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Ready = 2,
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum StitchingPolicy {
        Unspecified = 0,
        CutCurrent = 1,
        CompleteAd = 2,
    }
    impl StitchingPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StitchingPolicy::Unspecified => "STITCHING_POLICY_UNSPECIFIED",
                StitchingPolicy::CutCurrent => "CUT_CURRENT",
                StitchingPolicy::CompleteAd => "COMPLETE_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STITCHING_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "CUT_CURRENT" => Some(Self::CutCurrent),
                "COMPLETE_AD" => Some(Self::CompleteAd),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrefetchConfig {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(message, optional, tag = "2")]
    pub initial_ad_request_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GamLiveConfig {
    #[prost(string, tag = "1")]
    pub network_code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub asset_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub custom_asset_key: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdTracking {
    Unspecified = 0,
    Client = 1,
    Server = 2,
}
impl AdTracking {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AdTracking::Unspecified => "AD_TRACKING_UNSPECIFIED",
            AdTracking::Client => "CLIENT",
            AdTracking::Server => "SERVER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AD_TRACKING_UNSPECIFIED" => Some(Self::Unspecified),
            "CLIENT" => Some(Self::Client),
            "SERVER" => Some(Self::Server),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompanionAds {
    #[prost(enumeration = "companion_ads::DisplayRequirement", tag = "1")]
    pub display_requirement: i32,
    #[prost(message, repeated, tag = "2")]
    pub companions: ::prost::alloc::vec::Vec<Companion>,
}
/// Nested message and enum types in `CompanionAds`.
pub mod companion_ads {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DisplayRequirement {
        Unspecified = 0,
        All = 1,
        Any = 2,
        None = 3,
    }
    impl DisplayRequirement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DisplayRequirement::Unspecified => "DISPLAY_REQUIREMENT_UNSPECIFIED",
                DisplayRequirement::All => "ALL",
                DisplayRequirement::Any => "ANY",
                DisplayRequirement::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISPLAY_REQUIREMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "ALL" => Some(Self::All),
                "ANY" => Some(Self::Any),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Companion {
    #[prost(string, tag = "1")]
    pub api_framework: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub height_px: i32,
    #[prost(int32, tag = "3")]
    pub width_px: i32,
    #[prost(int32, tag = "4")]
    pub asset_height_px: i32,
    #[prost(int32, tag = "5")]
    pub expanded_height_px: i32,
    #[prost(int32, tag = "6")]
    pub asset_width_px: i32,
    #[prost(int32, tag = "7")]
    pub expanded_width_px: i32,
    #[prost(string, tag = "8")]
    pub ad_slot_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    #[prost(oneof = "companion::AdResource", tags = "10, 11, 12")]
    pub ad_resource: ::core::option::Option<companion::AdResource>,
}
/// Nested message and enum types in `Companion`.
pub mod companion {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AdResource {
        #[prost(message, tag = "10")]
        IframeAdResource(super::IframeAdResource),
        #[prost(message, tag = "11")]
        StaticAdResource(super::StaticAdResource),
        #[prost(message, tag = "12")]
        HtmlAdResource(super::HtmlAdResource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HtmlAdResource {
    #[prost(string, tag = "1")]
    pub html_source: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IframeAdResource {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticAdResource {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub creative_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VodSession {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub interstitials: ::core::option::Option<Interstitials>,
    #[prost(string, tag = "4")]
    pub play_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub source_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub ad_tag_uri: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "7")]
    pub ad_tag_macro_map: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "9")]
    pub manifest_options: ::core::option::Option<ManifestOptions>,
    #[prost(string, tag = "10")]
    pub asset_id: ::prost::alloc::string::String,
    #[prost(enumeration = "AdTracking", tag = "11")]
    pub ad_tracking: i32,
    #[prost(message, optional, tag = "13")]
    pub gam_settings: ::core::option::Option<vod_session::GamSettings>,
    #[prost(string, tag = "14")]
    pub vod_config: ::prost::alloc::string::String,
}
/// Nested message and enum types in `VodSession`.
pub mod vod_session {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GamSettings {
        #[prost(string, tag = "1")]
        pub network_code: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub stream_id: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interstitials {
    #[prost(message, repeated, tag = "1")]
    pub ad_breaks: ::prost::alloc::vec::Vec<VodSessionAdBreak>,
    #[prost(message, optional, tag = "2")]
    pub session_content: ::core::option::Option<VodSessionContent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VodSessionAd {
    #[prost(message, optional, tag = "1")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub companion_ads: ::core::option::Option<CompanionAds>,
    #[prost(message, repeated, tag = "3")]
    pub activity_events: ::prost::alloc::vec::Vec<Event>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VodSessionContent {
    #[prost(message, optional, tag = "1")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VodSessionAdBreak {
    #[prost(message, repeated, tag = "1")]
    pub progress_events: ::prost::alloc::vec::Vec<ProgressEvent>,
    #[prost(message, repeated, tag = "2")]
    pub ads: ::prost::alloc::vec::Vec<VodSessionAd>,
    #[prost(message, optional, tag = "3")]
    pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveSession {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub play_uri: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "6")]
    pub ad_tag_macros: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "10")]
    pub manifest_options: ::core::option::Option<ManifestOptions>,
    #[prost(message, optional, tag = "15")]
    pub gam_settings: ::core::option::Option<live_session::GamSettings>,
    #[prost(string, tag = "16")]
    pub live_config: ::prost::alloc::string::String,
    #[prost(enumeration = "AdTracking", tag = "17")]
    pub ad_tracking: i32,
}
/// Nested message and enum types in `LiveSession`.
pub mod live_session {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GamSettings {
        #[prost(string, tag = "1")]
        pub stream_id: ::prost::alloc::string::String,
        #[prost(btree_map = "string, string", tag = "4")]
        pub targeting_parameters: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManifestOptions {
    #[prost(message, repeated, tag = "1")]
    pub include_renditions: ::prost::alloc::vec::Vec<RenditionFilter>,
    #[prost(enumeration = "manifest_options::OrderPolicy", tag = "2")]
    pub bitrate_order: i32,
}
/// Nested message and enum types in `ManifestOptions`.
pub mod manifest_options {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum OrderPolicy {
        Unspecified = 0,
        Ascending = 1,
        Descending = 2,
    }
    impl OrderPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OrderPolicy::Unspecified => "ORDER_POLICY_UNSPECIFIED",
                OrderPolicy::Ascending => "ASCENDING",
                OrderPolicy::Descending => "DESCENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ORDER_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "ASCENDING" => Some(Self::Ascending),
                "DESCENDING" => Some(Self::Descending),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenditionFilter {
    #[prost(int32, tag = "1")]
    pub bitrate_bps: i32,
    #[prost(string, tag = "2")]
    pub codecs: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VodStitchDetail {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub ad_stitch_details: ::prost::alloc::vec::Vec<AdStitchDetail>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdStitchDetail {
    #[prost(string, tag = "1")]
    pub ad_break_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ad_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub ad_time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "4")]
    pub skip_reason: ::prost::alloc::string::String,
    #[prost(btree_map = "string, message", tag = "5")]
    pub media:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCdnKeyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub cdn_key: ::core::option::Option<CdnKey>,
    #[prost(string, tag = "3")]
    pub cdn_key_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCdnKeysRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCdnKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub cdn_keys: ::prost::alloc::vec::Vec<CdnKey>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCdnKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCdnKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCdnKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub cdn_key: ::core::option::Option<CdnKey>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVodSessionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub vod_session: ::core::option::Option<VodSession>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVodSessionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVodStitchDetailsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVodStitchDetailsResponse {
    #[prost(message, repeated, tag = "1")]
    pub vod_stitch_details: ::prost::alloc::vec::Vec<VodStitchDetail>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVodStitchDetailRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVodAdTagDetailsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVodAdTagDetailsResponse {
    #[prost(message, repeated, tag = "1")]
    pub vod_ad_tag_details: ::prost::alloc::vec::Vec<VodAdTagDetail>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVodAdTagDetailRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLiveAdTagDetailsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLiveAdTagDetailsResponse {
    #[prost(message, repeated, tag = "1")]
    pub live_ad_tag_details: ::prost::alloc::vec::Vec<LiveAdTagDetail>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLiveAdTagDetailRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSlateRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub slate_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub slate: ::core::option::Option<Slate>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSlateRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSlatesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSlatesResponse {
    #[prost(message, repeated, tag = "1")]
    pub slates: ::prost::alloc::vec::Vec<Slate>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSlateRequest {
    #[prost(message, optional, tag = "1")]
    pub slate: ::core::option::Option<Slate>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSlateRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLiveSessionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub live_session: ::core::option::Option<LiveSession>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLiveSessionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLiveConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub live_config_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub live_config: ::core::option::Option<LiveConfig>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLiveConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLiveConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub live_configs: ::prost::alloc::vec::Vec<LiveConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLiveConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLiveConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateLiveConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub live_config: ::core::option::Option<LiveConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVodConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vod_config_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub vod_config: ::core::option::Option<VodConfig>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVodConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVodConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub vod_configs: ::prost::alloc::vec::Vec<VodConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVodConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVodConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVodConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub vod_config: ::core::option::Option<VodConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod video_stitcher_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Video-On-Demand content stitching API allows you to insert ads
    /// into (VoD) video on demand files. You will be able to render custom
    /// scrubber bars with highlighted ads, enforce ad policies, allow
    /// seamless playback and tracking on native players and monetize
    /// content with any standard VMAP compliant ad server.
    #[derive(Debug, Clone)]
    pub struct VideoStitcherServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VideoStitcherServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VideoStitcherServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            VideoStitcherServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new CDN key.
        pub async fn create_cdn_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCdnKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/CreateCdnKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "CreateCdnKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all CDN keys in the specified project and location.
        pub async fn list_cdn_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCdnKeysRequest>,
        ) -> std::result::Result<tonic::Response<super::ListCdnKeysResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/ListCdnKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "ListCdnKeys",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified CDN key.
        pub async fn get_cdn_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCdnKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::CdnKey>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetCdnKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetCdnKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified CDN key.
        pub async fn delete_cdn_key(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCdnKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/DeleteCdnKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "DeleteCdnKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified CDN key. Only update fields specified
        /// in the call method body.
        pub async fn update_cdn_key(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCdnKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/UpdateCdnKey",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "UpdateCdnKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a client side playback VOD session and returns the full
        /// tracking and playback metadata of the session.
        pub async fn create_vod_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVodSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::VodSession>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/CreateVodSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "CreateVodSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the full tracking, playback metadata, and relevant ad-ops
        /// logs for the specified VOD session.
        pub async fn get_vod_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVodSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::VodSession>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetVodSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetVodSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of detailed stitching information of the specified VOD
        /// session.
        pub async fn list_vod_stitch_details(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVodStitchDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListVodStitchDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/ListVodStitchDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "ListVodStitchDetails",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified stitching information for the specified VOD session.
        pub async fn get_vod_stitch_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVodStitchDetailRequest>,
        ) -> std::result::Result<tonic::Response<super::VodStitchDetail>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetVodStitchDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetVodStitchDetail",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Return the list of ad tag details for the specified VOD session.
        pub async fn list_vod_ad_tag_details(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVodAdTagDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListVodAdTagDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/ListVodAdTagDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "ListVodAdTagDetails",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified ad tag detail for the specified VOD session.
        pub async fn get_vod_ad_tag_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVodAdTagDetailRequest>,
        ) -> std::result::Result<tonic::Response<super::VodAdTagDetail>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetVodAdTagDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetVodAdTagDetail",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Return the list of ad tag details for the specified live session.
        pub async fn list_live_ad_tag_details(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLiveAdTagDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListLiveAdTagDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/ListLiveAdTagDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "ListLiveAdTagDetails",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified ad tag detail for the specified live session.
        pub async fn get_live_ad_tag_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLiveAdTagDetailRequest>,
        ) -> std::result::Result<tonic::Response<super::LiveAdTagDetail>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetLiveAdTagDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetLiveAdTagDetail",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a slate.
        pub async fn create_slate(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSlateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/CreateSlate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "CreateSlate",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all slates in the specified project and location.
        pub async fn list_slates(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSlatesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListSlatesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/ListSlates",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "ListSlates",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified slate.
        pub async fn get_slate(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSlateRequest>,
        ) -> std::result::Result<tonic::Response<super::Slate>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetSlate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetSlate",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified slate.
        pub async fn update_slate(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSlateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/UpdateSlate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "UpdateSlate",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified slate.
        pub async fn delete_slate(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSlateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/DeleteSlate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "DeleteSlate",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new live session.
        pub async fn create_live_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateLiveSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::LiveSession>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/CreateLiveSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "CreateLiveSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the details for the specified live session.
        pub async fn get_live_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLiveSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::LiveSession>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetLiveSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetLiveSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Registers the live config with the provided unique ID in
        /// the specified region.
        pub async fn create_live_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateLiveConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/CreateLiveConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "CreateLiveConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all live configs managed by the Video Stitcher that
        /// belong to the specified project and region.
        pub async fn list_live_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLiveConfigsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListLiveConfigsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/ListLiveConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "ListLiveConfigs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified live config managed by the Video
        /// Stitcher service.
        pub async fn get_live_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLiveConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::LiveConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetLiveConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetLiveConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified live config.
        pub async fn delete_live_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteLiveConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/DeleteLiveConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "DeleteLiveConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified LiveConfig. Only update fields specified
        /// in the call method body.
        pub async fn update_live_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateLiveConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/UpdateLiveConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "UpdateLiveConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Registers the VOD config with the provided unique ID in
        /// the specified region.
        pub async fn create_vod_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVodConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/CreateVodConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "CreateVodConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all VOD configs managed by the Video Stitcher API that
        /// belong to the specified project and region.
        pub async fn list_vod_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVodConfigsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListVodConfigsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/ListVodConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "ListVodConfigs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified VOD config managed by the Video
        /// Stitcher API service.
        pub async fn get_vod_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVodConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::VodConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/GetVodConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "GetVodConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified VOD config.
        pub async fn delete_vod_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVodConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/DeleteVodConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "DeleteVodConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified VOD config. Only update fields specified
        /// in the call method body.
        pub async fn update_vod_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVodConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.stitcher.v1.VideoStitcherService/UpdateVodConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.video.stitcher.v1.VideoStitcherService",
                "UpdateVodConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
