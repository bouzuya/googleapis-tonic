// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCustomerLifecycleGoalsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<CustomerLifecycleGoalOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerLifecycleGoalOperation {
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_lifecycle_goal_operation::Operation", tags = "1, 3")]
pub operation: ::core::option::Option<customer_lifecycle_goal_operation::Operation>,
}
/// Nested message and enum types in `CustomerLifecycleGoalOperation`.
pub mod customer_lifecycle_goal_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerLifecycleGoal),
#[prost(message, tag = "3")]
Update(super::super::resources::CustomerLifecycleGoal),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCustomerLifecycleGoalsResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<ConfigureCustomerLifecycleGoalsResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCustomerLifecycleGoalsResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod customer_lifecycle_goal_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to configure customer lifecycle goals.
#[derive(Debug, Clone)]
pub struct CustomerLifecycleGoalServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerLifecycleGoalServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerLifecycleGoalServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerLifecycleGoalServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Process the given customer lifecycle configurations.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CustomerLifecycleGoalConfigError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn configure_customer_lifecycle_goals(&mut self, request: impl tonic::IntoRequest<super::ConfigureCustomerLifecycleGoalsRequest>) -> std::result::Result<tonic::Response<super::ConfigureCustomerLifecycleGoalsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerLifecycleGoalService/ConfigureCustomerLifecycleGoals");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerLifecycleGoalService", "ConfigureCustomerLifecycleGoals"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomConversionGoalsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomConversionGoalOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "4")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomConversionGoalOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "custom_conversion_goal_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<custom_conversion_goal_operation::Operation>,
}
/// Nested message and enum types in `CustomConversionGoalOperation`.
pub mod custom_conversion_goal_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomConversionGoal),
#[prost(message, tag = "2")]
Update(super::super::resources::CustomConversionGoal),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomConversionGoalsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCustomConversionGoalResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomConversionGoalResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub custom_conversion_goal: ::core::option::Option<super::resources::CustomConversionGoal>,
}
/// Generated client implementations.
pub mod custom_conversion_goal_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage custom conversion goal.
#[derive(Debug, Clone)]
pub struct CustomConversionGoalServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomConversionGoalServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomConversionGoalServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomConversionGoalServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes custom conversion goals. Operation statuses
/// are returned.
pub async fn mutate_custom_conversion_goals(&mut self, request: impl tonic::IntoRequest<super::MutateCustomConversionGoalsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomConversionGoalsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomConversionGoalService/MutateCustomConversionGoals");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomConversionGoalService", "MutateCustomConversionGoals"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerLabelOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerLabelOperation {
#[prost(oneof = "customer_label_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customer_label_operation::Operation>,
}
/// Nested message and enum types in `CustomerLabelOperation`.
pub mod customer_label_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerLabel),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerLabelResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod customer_label_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage labels on customers.
#[derive(Debug, Clone)]
pub struct CustomerLabelServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerLabelServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerLabelServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerLabelServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates and removes customer-label relationships.
/// Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [HeaderError]()
///   [InternalError]()
///   [LabelError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_customer_labels(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerLabelsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerLabelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerLabelService/MutateCustomerLabels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerLabelService", "MutateCustomerLabels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestBrandsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, optional, tag = "2")]
pub brand_prefix: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub selected_brands: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestBrandsResponse {
#[prost(message, repeated, tag = "1")]
pub brands: ::prost::alloc::vec::Vec<BrandSuggestion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrandSuggestion {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "super::enums::brand_state_enum::BrandState", tag = "4")]
pub state: i32,
}
/// Generated client implementations.
pub mod brand_suggestion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service will suggest brands based on a prefix.
#[derive(Debug, Clone)]
pub struct BrandSuggestionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> BrandSuggestionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> BrandSuggestionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
BrandSuggestionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Rpc to return a list of matching brands based on a prefix for this
/// customer.
pub async fn suggest_brands(&mut self, request: impl tonic::IntoRequest<super::SuggestBrandsRequest>) -> std::result::Result<tonic::Response<super::SuggestBrandsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BrandSuggestionService/SuggestBrands");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BrandSuggestionService", "SuggestBrands"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingSeasonalityAdjustmentsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<BiddingSeasonalityAdjustmentOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddingSeasonalityAdjustmentOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "bidding_seasonality_adjustment_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<bidding_seasonality_adjustment_operation::Operation>,
}
/// Nested message and enum types in `BiddingSeasonalityAdjustmentOperation`.
pub mod bidding_seasonality_adjustment_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::BiddingSeasonalityAdjustment),
#[prost(message, tag = "2")]
Update(super::super::resources::BiddingSeasonalityAdjustment),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingSeasonalityAdjustmentsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateBiddingSeasonalityAdjustmentsResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingSeasonalityAdjustmentsResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub bidding_seasonality_adjustment: ::core::option::Option<super::resources::BiddingSeasonalityAdjustment>,
}
/// Generated client implementations.
pub mod bidding_seasonality_adjustment_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage bidding seasonality adjustments.
#[derive(Debug, Clone)]
pub struct BiddingSeasonalityAdjustmentServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> BiddingSeasonalityAdjustmentServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> BiddingSeasonalityAdjustmentServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
BiddingSeasonalityAdjustmentServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes seasonality adjustments.
/// Operation statuses are returned.
pub async fn mutate_bidding_seasonality_adjustments(&mut self, request: impl tonic::IntoRequest<super::MutateBiddingSeasonalityAdjustmentsRequest>) -> std::result::Result<tonic::Response<super::MutateBiddingSeasonalityAdjustmentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BiddingSeasonalityAdjustmentService/MutateBiddingSeasonalityAdjustments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BiddingSeasonalityAdjustmentService", "MutateBiddingSeasonalityAdjustments"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadClickConversionsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub conversions: ::prost::alloc::vec::Vec<ClickConversion>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(bool, tag = "5")]
pub debug_enabled: bool,
#[prost(int32, optional, tag = "6")]
pub job_id: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadClickConversionsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<ClickConversionResult>,
#[prost(int64, tag = "3")]
pub job_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadCallConversionsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub conversions: ::prost::alloc::vec::Vec<CallConversion>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadCallConversionsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<CallConversionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickConversion {
#[prost(string, optional, tag = "9")]
pub gclid: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, tag = "18")]
pub gbraid: ::prost::alloc::string::String,
#[prost(string, tag = "19")]
pub wbraid: ::prost::alloc::string::String,
#[prost(string, optional, tag = "10")]
pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "11")]
pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(double, optional, tag = "12")]
pub conversion_value: ::core::option::Option<f64>,
#[prost(string, optional, tag = "13")]
pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "14")]
pub order_id: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub external_attribution_data: ::core::option::Option<ExternalAttributionData>,
#[prost(message, repeated, tag = "15")]
pub custom_variables: ::prost::alloc::vec::Vec<CustomVariable>,
#[prost(message, optional, tag = "16")]
pub cart_data: ::core::option::Option<CartData>,
#[prost(message, repeated, tag = "17")]
pub user_identifiers: ::prost::alloc::vec::Vec<super::common::UserIdentifier>,
#[prost(enumeration = "super::enums::conversion_environment_enum::ConversionEnvironment", tag = "20")]
pub conversion_environment: i32,
#[prost(message, optional, tag = "23")]
pub consent: ::core::option::Option<super::common::Consent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallConversion {
#[prost(string, optional, tag = "7")]
pub caller_id: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "8")]
pub call_start_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "9")]
pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "10")]
pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(double, optional, tag = "11")]
pub conversion_value: ::core::option::Option<f64>,
#[prost(string, optional, tag = "12")]
pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "13")]
pub custom_variables: ::prost::alloc::vec::Vec<CustomVariable>,
#[prost(message, optional, tag = "14")]
pub consent: ::core::option::Option<super::common::Consent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalAttributionData {
#[prost(double, optional, tag = "3")]
pub external_attribution_credit: ::core::option::Option<f64>,
#[prost(string, optional, tag = "4")]
pub external_attribution_model: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickConversionResult {
#[prost(string, optional, tag = "4")]
pub gclid: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, tag = "8")]
pub gbraid: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub wbraid: ::prost::alloc::string::String,
#[prost(string, optional, tag = "5")]
pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "6")]
pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "7")]
pub user_identifiers: ::prost::alloc::vec::Vec<super::common::UserIdentifier>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallConversionResult {
#[prost(string, optional, tag = "5")]
pub caller_id: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "6")]
pub call_start_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "7")]
pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "8")]
pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomVariable {
#[prost(string, tag = "1")]
pub conversion_custom_variable: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CartData {
#[prost(int64, tag = "6")]
pub merchant_id: i64,
#[prost(string, tag = "2")]
pub feed_country_code: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub feed_language_code: ::prost::alloc::string::String,
#[prost(double, tag = "4")]
pub local_transaction_cost: f64,
#[prost(message, repeated, tag = "5")]
pub items: ::prost::alloc::vec::Vec<cart_data::Item>,
}
/// Nested message and enum types in `CartData`.
pub mod cart_data {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Item {
#[prost(string, tag = "1")]
pub product_id: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub quantity: i32,
#[prost(double, tag = "3")]
pub unit_price: f64,
}
}
/// Generated client implementations.
pub mod conversion_upload_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to upload conversions.
#[derive(Debug, Clone)]
pub struct ConversionUploadServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversionUploadServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversionUploadServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversionUploadServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Processes the given click conversions.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ConversionUploadError]()
///   [HeaderError]()
///   [InternalError]()
///   [PartialFailureError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn upload_click_conversions(&mut self, request: impl tonic::IntoRequest<super::UploadClickConversionsRequest>) -> std::result::Result<tonic::Response<super::UploadClickConversionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionUploadService/UploadClickConversions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionUploadService", "UploadClickConversions"));
self.inner.unary(req, path, codec).await
}
/// Processes the given call conversions.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [PartialFailureError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn upload_call_conversions(&mut self, request: impl tonic::IntoRequest<super::UploadCallConversionsRequest>) -> std::result::Result<tonic::Response<super::UploadCallConversionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionUploadService/UploadCallConversions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionUploadService", "UploadCallConversions"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<CustomerClientLinkOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerClientLinkOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_client_link_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customer_client_link_operation::Operation>,
}
/// Nested message and enum types in `CustomerClientLinkOperation`.
pub mod customer_client_link_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerClientLink),
#[prost(message, tag = "2")]
Update(super::super::resources::CustomerClientLink),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<MutateCustomerClientLinkResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod customer_client_link_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer client links.
#[derive(Debug, Clone)]
pub struct CustomerClientLinkServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerClientLinkServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerClientLinkServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerClientLinkServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or updates a customer client link. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [ManagerLinkError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_customer_client_link(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerClientLinkRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerClientLinkResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerClientLinkService/MutateCustomerClientLink");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerClientLinkService", "MutateCustomerClientLink"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<SharedSetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedSetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "shared_set_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<shared_set_operation::Operation>,
}
/// Nested message and enum types in `SharedSetOperation`.
pub mod shared_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::SharedSet),
#[prost(message, tag = "2")]
Update(super::super::resources::SharedSet),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateSharedSetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub shared_set: ::core::option::Option<super::resources::SharedSet>,
}
/// Generated client implementations.
pub mod shared_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage shared sets.
#[derive(Debug, Clone)]
pub struct SharedSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SharedSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SharedSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SharedSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes shared sets. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SharedSetError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_shared_sets(&mut self, request: impl tonic::IntoRequest<super::MutateSharedSetsRequest>) -> std::result::Result<tonic::Response<super::MutateSharedSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.SharedSetService/MutateSharedSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.SharedSetService", "MutateSharedSets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub operation: ::core::option::Option<CustomerOperation>,
#[prost(bool, tag = "5")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "6")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerClientRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer_client: ::core::option::Option<super::resources::Customer>,
#[prost(string, optional, tag = "5")]
pub email_address: ::core::option::Option<::prost::alloc::string::String>,
#[prost(enumeration = "super::enums::access_role_enum::AccessRole", tag = "4")]
pub access_role: i32,
#[prost(bool, tag = "6")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerOperation {
#[prost(message, optional, tag = "1")]
pub update: ::core::option::Option<super::resources::Customer>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerClientResponse {
#[prost(string, tag = "2")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub invitation_link: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerResponse {
#[prost(message, optional, tag = "2")]
pub result: ::core::option::Option<MutateCustomerResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer: ::core::option::Option<super::resources::Customer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListAccessibleCustomersRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessibleCustomersResponse {
#[prost(string, repeated, tag = "1")]
pub resource_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod customer_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customers.
#[derive(Debug, Clone)]
pub struct CustomerServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Updates a customer. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
///   [UrlFieldError]()
pub async fn mutate_customer(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerService/MutateCustomer");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerService", "MutateCustomer"));
self.inner.unary(req, path, codec).await
}
/// Returns resource names of customers directly accessible by the
/// user authenticating the call.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_accessible_customers(&mut self, request: impl tonic::IntoRequest<super::ListAccessibleCustomersRequest>) -> std::result::Result<tonic::Response<super::ListAccessibleCustomersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerService/ListAccessibleCustomers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerService", "ListAccessibleCustomers"));
self.inner.unary(req, path, codec).await
}
/// Creates a new client under manager. The new client customer is returned.
///
/// List of thrown errors:
///   [AccessInvitationError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CurrencyCodeError]()
///   [HeaderError]()
///   [InternalError]()
///   [ManagerLinkError]()
///   [QuotaError]()
///   [RequestError]()
///   [StringLengthError]()
///   [TimeZoneError]()
pub async fn create_customer_client(&mut self, request: impl tonic::IntoRequest<super::CreateCustomerClientRequest>) -> std::result::Result<tonic::Response<super::CreateCustomerClientResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerService/CreateCustomerClient");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerService", "CreateCustomerClient"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ConversionActionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionActionOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "conversion_action_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<conversion_action_operation::Operation>,
}
/// Nested message and enum types in `ConversionActionOperation`.
pub mod conversion_action_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::ConversionAction),
#[prost(message, tag = "2")]
Update(super::super::resources::ConversionAction),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateConversionActionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversion_action: ::core::option::Option<super::resources::ConversionAction>,
}
/// Generated client implementations.
pub mod conversion_action_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage conversion actions.
#[derive(Debug, Clone)]
pub struct ConversionActionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversionActionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversionActionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversionActionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes conversion actions. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ConversionActionError]()
///   [CurrencyCodeError]()
///   [DatabaseError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [StringLengthError]()
pub async fn mutate_conversion_actions(&mut self, request: impl tonic::IntoRequest<super::MutateConversionActionsRequest>) -> std::result::Result<tonic::Response<super::MutateConversionActionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionActionService/MutateConversionActions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionActionService", "MutateConversionActions"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriteriaRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignCriterionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignCriterionOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_criterion_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_criterion_operation::Operation>,
}
/// Nested message and enum types in `CampaignCriterionOperation`.
pub mod campaign_criterion_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignCriterion),
#[prost(message, tag = "2")]
Update(super::super::resources::CampaignCriterion),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriteriaResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignCriterionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriterionResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_criterion: ::core::option::Option<super::resources::CampaignCriterion>,
}
/// Generated client implementations.
pub mod campaign_criterion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign criteria.
#[derive(Debug, Clone)]
pub struct CampaignCriterionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignCriterionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignCriterionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignCriterionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes criteria. Operation statuses are returned.
///
/// List of thrown errors:
///   [AdxError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CampaignCriterionError]()
///   [CollectionSizeError]()
///   [ContextError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [FunctionError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RegionCodeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_campaign_criteria(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignCriteriaRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignCriteriaResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignCriterionService/MutateCampaignCriteria");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignCriterionService", "MutateCampaignCriteria"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupAdLabelOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAdLabelOperation {
#[prost(oneof = "ad_group_ad_label_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<ad_group_ad_label_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAdLabelOperation`.
pub mod ad_group_ad_label_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupAdLabel),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupAdLabelResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod ad_group_ad_label_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage labels on ad group ads.
#[derive(Debug, Clone)]
pub struct AdGroupAdLabelServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupAdLabelServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupAdLabelServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupAdLabelServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates and removes ad group ad labels.
/// Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [HeaderError]()
///   [InternalError]()
///   [LabelError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_ad_group_ad_labels(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupAdLabelsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupAdLabelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupAdLabelService/MutateAdGroupAdLabels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupAdLabelService", "MutateAdGroupAdLabels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateInsightsFinderReportRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub baseline_audience: ::core::option::Option<BasicInsightsAudience>,
#[prost(message, optional, tag = "3")]
pub specific_audience: ::core::option::Option<BasicInsightsAudience>,
#[prost(string, tag = "4")]
pub customer_insights_group: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateInsightsFinderReportResponse {
#[prost(string, tag = "1")]
pub saved_report_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAudienceCompositionInsightsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub audience: ::core::option::Option<InsightsAudience>,
#[prost(message, optional, tag = "6")]
pub baseline_audience: ::core::option::Option<InsightsAudience>,
#[prost(string, tag = "3")]
pub data_month: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension", repeated, packed = "false", tag = "4")]
pub dimensions: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "5")]
pub customer_insights_group: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAudienceCompositionInsightsResponse {
#[prost(message, repeated, tag = "1")]
pub sections: ::prost::alloc::vec::Vec<AudienceCompositionSection>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateSuggestedTargetingInsightsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub audience: ::core::option::Option<InsightsAudience>,
#[prost(message, optional, tag = "3")]
pub baseline_audience: ::core::option::Option<InsightsAudience>,
#[prost(string, tag = "4")]
pub data_month: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub customer_insights_group: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateSuggestedTargetingInsightsResponse {
#[prost(message, repeated, tag = "1")]
pub suggestions: ::prost::alloc::vec::Vec<TargetingSuggestionMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetingSuggestionMetrics {
#[prost(message, repeated, tag = "1")]
pub locations: ::prost::alloc::vec::Vec<AudienceInsightsAttributeMetadata>,
#[prost(message, repeated, tag = "2")]
pub age_ranges: ::prost::alloc::vec::Vec<super::common::AgeRangeInfo>,
#[prost(message, optional, tag = "3")]
pub gender: ::core::option::Option<super::common::GenderInfo>,
#[prost(message, repeated, tag = "4")]
pub user_interests: ::prost::alloc::vec::Vec<AudienceInsightsAttributeMetadata>,
#[prost(double, tag = "5")]
pub coverage: f64,
#[prost(double, tag = "6")]
pub index: f64,
#[prost(int64, tag = "7")]
pub potential_youtube_reach: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAudienceInsightsAttributesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension", repeated, packed = "false", tag = "2")]
pub dimensions: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "3")]
pub query_text: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub customer_insights_group: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "5")]
pub location_country_filters: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAudienceInsightsAttributesResponse {
#[prost(message, repeated, tag = "1")]
pub attributes: ::prost::alloc::vec::Vec<AudienceInsightsAttributeMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListInsightsEligibleDatesRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInsightsEligibleDatesResponse {
#[prost(string, repeated, tag = "1")]
pub data_months: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "2")]
pub last_thirty_days: ::core::option::Option<super::common::DateRange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsAttribute {
#[prost(oneof = "audience_insights_attribute::Attribute", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
pub attribute: ::core::option::Option<audience_insights_attribute::Attribute>,
}
/// Nested message and enum types in `AudienceInsightsAttribute`.
pub mod audience_insights_attribute {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Attribute {
#[prost(message, tag = "1")]
AgeRange(super::super::common::AgeRangeInfo),
#[prost(message, tag = "2")]
Gender(super::super::common::GenderInfo),
#[prost(message, tag = "3")]
Location(super::super::common::LocationInfo),
#[prost(message, tag = "4")]
UserInterest(super::super::common::UserInterestInfo),
#[prost(message, tag = "5")]
Entity(super::AudienceInsightsEntity),
#[prost(message, tag = "6")]
Category(super::AudienceInsightsCategory),
#[prost(message, tag = "7")]
DynamicLineup(super::AudienceInsightsDynamicLineup),
#[prost(message, tag = "8")]
ParentalStatus(super::super::common::ParentalStatusInfo),
#[prost(message, tag = "9")]
IncomeRange(super::super::common::IncomeRangeInfo),
#[prost(message, tag = "10")]
YoutubeChannel(super::super::common::YouTubeChannelInfo),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsTopic {
#[prost(oneof = "audience_insights_topic::Topic", tags = "1, 2")]
pub topic: ::core::option::Option<audience_insights_topic::Topic>,
}
/// Nested message and enum types in `AudienceInsightsTopic`.
pub mod audience_insights_topic {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Topic {
#[prost(message, tag = "1")]
Entity(super::AudienceInsightsEntity),
#[prost(message, tag = "2")]
Category(super::AudienceInsightsCategory),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsEntity {
#[prost(string, tag = "1")]
pub knowledge_graph_machine_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsCategory {
#[prost(string, tag = "1")]
pub category_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsDynamicLineup {
#[prost(string, tag = "1")]
pub dynamic_lineup_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BasicInsightsAudience {
#[prost(message, repeated, tag = "1")]
pub country_location: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
#[prost(message, repeated, tag = "2")]
pub sub_country_locations: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
#[prost(message, optional, tag = "3")]
pub gender: ::core::option::Option<super::common::GenderInfo>,
#[prost(message, repeated, tag = "4")]
pub age_ranges: ::prost::alloc::vec::Vec<super::common::AgeRangeInfo>,
#[prost(message, repeated, tag = "5")]
pub user_interests: ::prost::alloc::vec::Vec<super::common::UserInterestInfo>,
#[prost(message, repeated, tag = "6")]
pub topics: ::prost::alloc::vec::Vec<AudienceInsightsTopic>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsAttributeMetadata {
#[prost(enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension", tag = "1")]
pub dimension: i32,
#[prost(message, optional, tag = "2")]
pub attribute: ::core::option::Option<AudienceInsightsAttribute>,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub display_info: ::prost::alloc::string::String,
#[prost(oneof = "audience_insights_attribute_metadata::DimensionMetadata", tags = "6, 7, 8")]
pub dimension_metadata: ::core::option::Option<audience_insights_attribute_metadata::DimensionMetadata>,
}
/// Nested message and enum types in `AudienceInsightsAttributeMetadata`.
pub mod audience_insights_attribute_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DimensionMetadata {
#[prost(message, tag = "6")]
YoutubeChannelMetadata(super::YouTubeChannelAttributeMetadata),
#[prost(message, tag = "7")]
DynamicAttributeMetadata(super::DynamicLineupAttributeMetadata),
#[prost(message, tag = "8")]
LocationAttributeMetadata(super::LocationAttributeMetadata),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct YouTubeChannelAttributeMetadata {
#[prost(int64, tag = "1")]
pub subscriber_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicLineupAttributeMetadata {
#[prost(message, optional, tag = "1")]
pub inventory_country: ::core::option::Option<super::common::LocationInfo>,
#[prost(int64, optional, tag = "2")]
pub median_monthly_inventory: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "3")]
pub channel_count_lower_bound: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "4")]
pub channel_count_upper_bound: ::core::option::Option<i64>,
#[prost(message, repeated, tag = "5")]
pub sample_channels: ::prost::alloc::vec::Vec<dynamic_lineup_attribute_metadata::SampleChannel>,
}
/// Nested message and enum types in `DynamicLineupAttributeMetadata`.
pub mod dynamic_lineup_attribute_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleChannel {
#[prost(message, optional, tag = "1")]
pub youtube_channel: ::core::option::Option<super::super::common::YouTubeChannelInfo>,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub youtube_channel_metadata: ::core::option::Option<super::YouTubeChannelAttributeMetadata>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationAttributeMetadata {
#[prost(message, optional, tag = "1")]
pub country_location: ::core::option::Option<super::common::LocationInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsightsAudience {
#[prost(message, repeated, tag = "1")]
pub country_locations: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
#[prost(message, repeated, tag = "2")]
pub sub_country_locations: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
#[prost(message, optional, tag = "3")]
pub gender: ::core::option::Option<super::common::GenderInfo>,
#[prost(message, repeated, tag = "4")]
pub age_ranges: ::prost::alloc::vec::Vec<super::common::AgeRangeInfo>,
#[prost(message, optional, tag = "5")]
pub parental_status: ::core::option::Option<super::common::ParentalStatusInfo>,
#[prost(message, repeated, tag = "6")]
pub income_ranges: ::prost::alloc::vec::Vec<super::common::IncomeRangeInfo>,
#[prost(message, repeated, tag = "7")]
pub dynamic_lineups: ::prost::alloc::vec::Vec<AudienceInsightsDynamicLineup>,
#[prost(message, repeated, tag = "8")]
pub topic_audience_combinations: ::prost::alloc::vec::Vec<InsightsAudienceAttributeGroup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsightsAudienceAttributeGroup {
#[prost(message, repeated, tag = "1")]
pub attributes: ::prost::alloc::vec::Vec<AudienceInsightsAttribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceCompositionSection {
#[prost(enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension", tag = "1")]
pub dimension: i32,
#[prost(message, repeated, tag = "3")]
pub top_attributes: ::prost::alloc::vec::Vec<AudienceCompositionAttribute>,
#[prost(message, repeated, tag = "4")]
pub clustered_attributes: ::prost::alloc::vec::Vec<AudienceCompositionAttributeCluster>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceCompositionAttributeCluster {
#[prost(string, tag = "1")]
pub cluster_display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub cluster_metrics: ::core::option::Option<AudienceCompositionMetrics>,
#[prost(message, repeated, tag = "4")]
pub attributes: ::prost::alloc::vec::Vec<AudienceCompositionAttribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceCompositionMetrics {
#[prost(double, tag = "1")]
pub baseline_audience_share: f64,
#[prost(double, tag = "2")]
pub audience_share: f64,
#[prost(double, tag = "3")]
pub index: f64,
#[prost(double, tag = "4")]
pub score: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceCompositionAttribute {
#[prost(message, optional, tag = "1")]
pub attribute_metadata: ::core::option::Option<AudienceInsightsAttributeMetadata>,
#[prost(message, optional, tag = "2")]
pub metrics: ::core::option::Option<AudienceCompositionMetrics>,
}
/// Generated client implementations.
pub mod audience_insights_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Audience Insights Service helps users find information about groups of
/// people and how they can be reached with Google Ads. Accessible to
/// allowlisted customers only.
#[derive(Debug, Clone)]
pub struct AudienceInsightsServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AudienceInsightsServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AudienceInsightsServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AudienceInsightsServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a saved report that can be viewed in the Insights Finder tool.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
pub async fn generate_insights_finder_report(&mut self, request: impl tonic::IntoRequest<super::GenerateInsightsFinderReportRequest>) -> std::result::Result<tonic::Response<super::GenerateInsightsFinderReportResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AudienceInsightsService/GenerateInsightsFinderReport");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AudienceInsightsService", "GenerateInsightsFinderReport"));
self.inner.unary(req, path, codec).await
}
/// Searches for audience attributes that can be used to generate insights.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
pub async fn list_audience_insights_attributes(&mut self, request: impl tonic::IntoRequest<super::ListAudienceInsightsAttributesRequest>) -> std::result::Result<tonic::Response<super::ListAudienceInsightsAttributesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AudienceInsightsService/ListAudienceInsightsAttributes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AudienceInsightsService", "ListAudienceInsightsAttributes"));
self.inner.unary(req, path, codec).await
}
/// Lists date ranges for which audience insights data can be requested.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
pub async fn list_insights_eligible_dates(&mut self, request: impl tonic::IntoRequest<super::ListInsightsEligibleDatesRequest>) -> std::result::Result<tonic::Response<super::ListInsightsEligibleDatesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AudienceInsightsService/ListInsightsEligibleDates");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AudienceInsightsService", "ListInsightsEligibleDates"));
self.inner.unary(req, path, codec).await
}
/// Returns a collection of attributes that are represented in an audience of
/// interest, with metrics that compare each attribute's share of the audience
/// with its share of a baseline audience.
///
/// List of thrown errors:
///   [AudienceInsightsError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
pub async fn generate_audience_composition_insights(&mut self, request: impl tonic::IntoRequest<super::GenerateAudienceCompositionInsightsRequest>) -> std::result::Result<tonic::Response<super::GenerateAudienceCompositionInsightsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AudienceInsightsService/GenerateAudienceCompositionInsights");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AudienceInsightsService", "GenerateAudienceCompositionInsights"));
self.inner.unary(req, path, codec).await
}
/// Returns a collection of targeting insights (e.g. targetable audiences) that
/// are relevant to the requested audience.
///
/// List of thrown errors:
///   [AudienceInsightsError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
pub async fn generate_suggested_targeting_insights(&mut self, request: impl tonic::IntoRequest<super::GenerateSuggestedTargetingInsightsRequest>) -> std::result::Result<tonic::Response<super::GenerateSuggestedTargetingInsightsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AudienceInsightsService/GenerateSuggestedTargetingInsights");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AudienceInsightsService", "GenerateSuggestedTargetingInsights"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ExperimentOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExperimentOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "experiment_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<experiment_operation::Operation>,
}
/// Nested message and enum types in `ExperimentOperation`.
pub mod experiment_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::Experiment),
#[prost(message, tag = "2")]
Update(super::super::resources::Experiment),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateExperimentResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndExperimentRequest {
#[prost(string, tag = "1")]
pub experiment: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExperimentAsyncErrorsRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExperimentAsyncErrorsResponse {
#[prost(message, repeated, tag = "1")]
pub errors: ::prost::alloc::vec::Vec<super::super::super::super::rpc::Status>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraduateExperimentRequest {
#[prost(string, tag = "1")]
pub experiment: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub campaign_budget_mappings: ::prost::alloc::vec::Vec<CampaignBudgetMapping>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBudgetMapping {
#[prost(string, tag = "1")]
pub experiment_campaign: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub campaign_budget: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleExperimentRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleExperimentMetadata {
#[prost(string, tag = "1")]
pub experiment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteExperimentRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteExperimentMetadata {
#[prost(string, tag = "1")]
pub experiment: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod experiment_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage experiments.
#[derive(Debug, Clone)]
pub struct ExperimentServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ExperimentServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ExperimentServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ExperimentServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes experiments. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ExperimentError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_experiments(&mut self, request: impl tonic::IntoRequest<super::MutateExperimentsRequest>) -> std::result::Result<tonic::Response<super::MutateExperimentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExperimentService/MutateExperiments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExperimentService", "MutateExperiments"));
self.inner.unary(req, path, codec).await
}
/// Immediately ends an experiment, changing the experiment's scheduled
/// end date and without waiting for end of day. End date is updated to be the
/// time of the request.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ExperimentError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn end_experiment(&mut self, request: impl tonic::IntoRequest<super::EndExperimentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExperimentService/EndExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExperimentService", "EndExperiment"));
self.inner.unary(req, path, codec).await
}
/// Returns all errors that occurred during the last Experiment update (either
/// scheduling or promotion).
/// Supports standard list paging.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_experiment_async_errors(&mut self, request: impl tonic::IntoRequest<super::ListExperimentAsyncErrorsRequest>) -> std::result::Result<tonic::Response<super::ListExperimentAsyncErrorsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExperimentService/ListExperimentAsyncErrors");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExperimentService", "ListExperimentAsyncErrors"));
self.inner.unary(req, path, codec).await
}
/// Graduates an experiment to a full campaign.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ExperimentError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn graduate_experiment(&mut self, request: impl tonic::IntoRequest<super::GraduateExperimentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExperimentService/GraduateExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExperimentService", "GraduateExperiment"));
self.inner.unary(req, path, codec).await
}
/// Schedule an experiment. The in design campaign
/// will be converted into a real campaign (called the experiment campaign)
/// that will begin serving ads if successfully created.
///
/// The experiment is scheduled immediately with status INITIALIZING.
/// This method returns a long running operation that tracks the forking of the
/// in design campaign. If the forking fails, a list of errors can be retrieved
/// using the ListExperimentAsyncErrors method. The operation's
/// metadata will be a string containing the resource name of the created
/// experiment.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ExperimentError]()
///   [DatabaseError]()
///   [DateError]()
///   [DateRangeError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
pub async fn schedule_experiment(&mut self, request: impl tonic::IntoRequest<super::ScheduleExperimentRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExperimentService/ScheduleExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExperimentService", "ScheduleExperiment"));
self.inner.unary(req, path, codec).await
}
/// Promotes the trial campaign thus applying changes in the trial campaign
/// to the base campaign.
/// This method returns a long running operation that tracks the promotion of
/// the experiment campaign. If it fails, a list of errors can be retrieved
/// using the ListExperimentAsyncErrors method. The operation's
/// metadata will be a string containing the resource name of the created
/// experiment.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ExperimentError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn promote_experiment(&mut self, request: impl tonic::IntoRequest<super::PromoteExperimentRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExperimentService/PromoteExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExperimentService", "PromoteExperiment"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerFeedOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerFeedOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_feed_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<customer_feed_operation::Operation>,
}
/// Nested message and enum types in `CustomerFeedOperation`.
pub mod customer_feed_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerFeed),
#[prost(message, tag = "2")]
Update(super::super::resources::CustomerFeed),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerFeedResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer_feed: ::core::option::Option<super::resources::CustomerFeed>,
}
/// Generated client implementations.
pub mod customer_feed_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer feeds.
#[derive(Debug, Clone)]
pub struct CustomerFeedServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerFeedServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerFeedServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerFeedServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes customer feeds. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [CustomerFeedError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [FunctionError]()
///   [FunctionParsingError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NotEmptyError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_customer_feeds(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerFeedsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerFeedsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerFeedService/MutateCustomerFeeds");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerFeedService", "MutateCustomerFeeds"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupFeedOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupFeedOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "ad_group_feed_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<ad_group_feed_operation::Operation>,
}
/// Nested message and enum types in `AdGroupFeedOperation`.
pub mod ad_group_feed_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupFeed),
#[prost(message, tag = "2")]
Update(super::super::resources::AdGroupFeed),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupFeedResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_feed: ::core::option::Option<super::resources::AdGroupFeed>,
}
/// Generated client implementations.
pub mod ad_group_feed_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group feeds.
#[derive(Debug, Clone)]
pub struct AdGroupFeedServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupFeedServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupFeedServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupFeedServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes ad group feeds. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AdGroupFeedError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [FunctionError]()
///   [FunctionParsingError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_ad_group_feeds(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupFeedsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupFeedsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupFeedService/MutateAdGroupFeeds");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupFeedService", "MutateAdGroupFeeds"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetAssetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AssetSetAssetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetSetAssetOperation {
#[prost(oneof = "asset_set_asset_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<asset_set_asset_operation::Operation>,
}
/// Nested message and enum types in `AssetSetAssetOperation`.
pub mod asset_set_asset_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AssetSetAsset),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetAssetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAssetSetAssetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetAssetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub asset_set_asset: ::core::option::Option<super::resources::AssetSetAsset>,
}
/// Generated client implementations.
pub mod asset_set_asset_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage asset set asset.
#[derive(Debug, Clone)]
pub struct AssetSetAssetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AssetSetAssetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AssetSetAssetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AssetSetAssetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes asset set assets. Operation statuses are
/// returned.
pub async fn mutate_asset_set_assets(&mut self, request: impl tonic::IntoRequest<super::MutateAssetSetAssetsRequest>) -> std::result::Result<tonic::Response<super::MutateAssetSetAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AssetSetAssetService/MutateAssetSetAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AssetSetAssetService", "MutateAssetSetAssets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTravelAssetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub language_option: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub place_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTravelAssetsResponse {
#[prost(message, repeated, tag = "1")]
pub hotel_asset_suggestions: ::prost::alloc::vec::Vec<HotelAssetSuggestion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotelAssetSuggestion {
#[prost(string, tag = "1")]
pub place_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub final_url: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub hotel_name: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::call_to_action_type_enum::CallToActionType", tag = "4")]
pub call_to_action: i32,
#[prost(message, repeated, tag = "5")]
pub text_assets: ::prost::alloc::vec::Vec<HotelTextAsset>,
#[prost(message, repeated, tag = "6")]
pub image_assets: ::prost::alloc::vec::Vec<HotelImageAsset>,
#[prost(enumeration = "super::enums::hotel_asset_suggestion_status_enum::HotelAssetSuggestionStatus", tag = "7")]
pub status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotelTextAsset {
#[prost(string, tag = "1")]
pub text: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::asset_field_type_enum::AssetFieldType", tag = "2")]
pub asset_field_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotelImageAsset {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::asset_field_type_enum::AssetFieldType", tag = "2")]
pub asset_field_type: i32,
}
/// Generated client implementations.
pub mod travel_asset_suggestion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to retrieve Travel asset suggestions.
#[derive(Debug, Clone)]
pub struct TravelAssetSuggestionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> TravelAssetSuggestionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> TravelAssetSuggestionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
TravelAssetSuggestionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns Travel Asset suggestions. Asset
/// suggestions are returned on a best-effort basis. There are no guarantees
/// that all possible asset types will be returned for any given hotel
/// property.
pub async fn suggest_travel_assets(&mut self, request: impl tonic::IntoRequest<super::SuggestTravelAssetsRequest>) -> std::result::Result<tonic::Response<super::SuggestTravelAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.TravelAssetSuggestionService/SuggestTravelAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.TravelAssetSuggestionService", "SuggestTravelAssets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadUserDataRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub operations: ::prost::alloc::vec::Vec<UserDataOperation>,
#[prost(oneof = "upload_user_data_request::Metadata", tags = "2")]
pub metadata: ::core::option::Option<upload_user_data_request::Metadata>,
}
/// Nested message and enum types in `UploadUserDataRequest`.
pub mod upload_user_data_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Metadata {
#[prost(message, tag = "2")]
CustomerMatchUserListMetadata(super::super::common::CustomerMatchUserListMetadata),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserDataOperation {
#[prost(oneof = "user_data_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<user_data_operation::Operation>,
}
/// Nested message and enum types in `UserDataOperation`.
pub mod user_data_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::common::UserData),
#[prost(message, tag = "2")]
Remove(super::super::common::UserData),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadUserDataResponse {
#[prost(string, optional, tag = "3")]
pub upload_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(int32, optional, tag = "4")]
pub received_operations_count: ::core::option::Option<i32>,
}
/// Generated client implementations.
pub mod user_data_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage user data uploads.
/// Any uploads made to a Customer Match list through this service will be
/// eligible for matching as per the customer matching process. See
/// https://support.google.com/google-ads/answer/7474263. However, the uploads
/// made through this service will not be visible under the 'Segment members'
/// section for the Customer Match List in the Google Ads UI.
#[derive(Debug, Clone)]
pub struct UserDataServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> UserDataServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> UserDataServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
UserDataServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Uploads the given user data.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [OfflineUserDataJobError]()
///   [QuotaError]()
///   [RequestError]()
///   [UserDataError]()
pub async fn upload_user_data(&mut self, request: impl tonic::IntoRequest<super::UploadUserDataRequest>) -> std::result::Result<tonic::Response<super::UploadUserDataResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.UserDataService/UploadUserData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.UserDataService", "UploadUserData"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerSkAdNetworkConversionValueSchemaOperation {
#[prost(message, optional, tag = "1")]
pub update: ::core::option::Option<super::resources::CustomerSkAdNetworkConversionValueSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerSkAdNetworkConversionValueSchemaRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<CustomerSkAdNetworkConversionValueSchemaOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
#[prost(bool, tag = "4")]
pub enable_warnings: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerSkAdNetworkConversionValueSchemaResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub app_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerSkAdNetworkConversionValueSchemaResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<MutateCustomerSkAdNetworkConversionValueSchemaResult>,
#[prost(message, optional, tag = "2")]
pub warning: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// Generated client implementations.
pub mod customer_sk_ad_network_conversion_value_schema_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage CustomerSkAdNetworkConversionValueSchema.
#[derive(Debug, Clone)]
pub struct CustomerSkAdNetworkConversionValueSchemaServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerSkAdNetworkConversionValueSchemaServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerSkAdNetworkConversionValueSchemaServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerSkAdNetworkConversionValueSchemaServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or updates the CustomerSkAdNetworkConversionValueSchema.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [InternalError]()
///   [MutateError]()
pub async fn mutate_customer_sk_ad_network_conversion_value_schema(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerSkAdNetworkConversionValueSchemaRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerSkAdNetworkConversionValueSchemaResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerSkAdNetworkConversionValueSchemaService/MutateCustomerSkAdNetworkConversionValueSchema");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerSkAdNetworkConversionValueSchemaService", "MutateCustomerSkAdNetworkConversionValueSchema"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdOperation>,
#[prost(bool, tag = "4")]
pub partial_failure: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdOperation {
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "3")]
pub policy_validation_parameter: ::core::option::Option<super::common::PolicyValidationParameter>,
#[prost(oneof = "ad_operation::Operation", tags = "1")]
pub operation: ::core::option::Option<ad_operation::Operation>,
}
/// Nested message and enum types in `AdOperation`.
pub mod ad_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Update(super::super::resources::Ad),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad: ::core::option::Option<super::resources::Ad>,
}
/// Generated client implementations.
pub mod ad_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ads.
#[derive(Debug, Clone)]
pub struct AdServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Updates ads. Operation statuses are returned. Updating ads is not supported
/// for TextAd, ExpandedDynamicSearchAd, GmailAd and ImageAd.
///
/// List of thrown errors:
///   [AdCustomizerError]()
///   [AdError]()
///   [AdSharingError]()
///   [AdxError]()
///   [AssetError]()
///   [AssetLinkError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FeedAttributeReferenceError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [FunctionError]()
///   [FunctionParsingError]()
///   [HeaderError]()
///   [IdError]()
///   [ImageError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MediaBundleError]()
///   [MediaFileError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [PolicyFindingError]()
///   [PolicyViolationError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_ads(&mut self, request: impl tonic::IntoRequest<super::MutateAdsRequest>) -> std::result::Result<tonic::Response<super::MutateAdsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdService/MutateAds");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdService", "MutateAds"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "ad_group_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<ad_group_operation::Operation>,
}
/// Nested message and enum types in `AdGroupOperation`.
pub mod ad_group_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroup),
#[prost(message, tag = "2")]
Update(super::super::resources::AdGroup),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group: ::core::option::Option<super::resources::AdGroup>,
}
/// Generated client implementations.
pub mod ad_group_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad groups.
#[derive(Debug, Clone)]
pub struct AdGroupServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes ad groups. Operation statuses are returned.
///
/// List of thrown errors:
///   [AdGroupError]()
///   [AdxError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BiddingError]()
///   [BiddingStrategyError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MultiplierError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SettingError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_ad_groups(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupService/MutateAdGroups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupService", "MutateAdGroups"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ExtensionFeedItemOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtensionFeedItemOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "extension_feed_item_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<extension_feed_item_operation::Operation>,
}
/// Nested message and enum types in `ExtensionFeedItemOperation`.
pub mod extension_feed_item_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::ExtensionFeedItem),
#[prost(message, tag = "2")]
Update(super::super::resources::ExtensionFeedItem),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateExtensionFeedItemResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub extension_feed_item: ::core::option::Option<super::resources::ExtensionFeedItem>,
}
/// Generated client implementations.
pub mod extension_feed_item_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage extension feed items.
#[derive(Debug, Clone)]
pub struct ExtensionFeedItemServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ExtensionFeedItemServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ExtensionFeedItemServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ExtensionFeedItemServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes extension feed items. Operation
/// statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [CountryCodeError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [ExtensionFeedItemError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [ImageError]()
///   [InternalError]()
///   [LanguageCodeError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [OperationAccessDeniedError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_extension_feed_items(&mut self, request: impl tonic::IntoRequest<super::MutateExtensionFeedItemsRequest>) -> std::result::Result<tonic::Response<super::MutateExtensionFeedItemsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExtensionFeedItemService/MutateExtensionFeedItems");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExtensionFeedItemService", "MutateExtensionFeedItems"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionGoalCampaignConfigsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ConversionGoalCampaignConfigOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "4")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionGoalCampaignConfigOperation {
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "conversion_goal_campaign_config_operation::Operation", tags = "1")]
pub operation: ::core::option::Option<conversion_goal_campaign_config_operation::Operation>,
}
/// Nested message and enum types in `ConversionGoalCampaignConfigOperation`.
pub mod conversion_goal_campaign_config_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Update(super::super::resources::ConversionGoalCampaignConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionGoalCampaignConfigsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateConversionGoalCampaignConfigResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionGoalCampaignConfigResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversion_goal_campaign_config: ::core::option::Option<super::resources::ConversionGoalCampaignConfig>,
}
/// Generated client implementations.
pub mod conversion_goal_campaign_config_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage conversion goal campaign config.
#[derive(Debug, Clone)]
pub struct ConversionGoalCampaignConfigServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversionGoalCampaignConfigServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversionGoalCampaignConfigServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversionGoalCampaignConfigServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes conversion goal campaign config. Operation
/// statuses are returned.
pub async fn mutate_conversion_goal_campaign_configs(&mut self, request: impl tonic::IntoRequest<super::MutateConversionGoalCampaignConfigsRequest>) -> std::result::Result<tonic::Response<super::MutateConversionGoalCampaignConfigsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionGoalCampaignConfigService/MutateConversionGoalCampaignConfigs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionGoalCampaignConfigService", "MutateConversionGoalCampaignConfigs"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerConversionGoalsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerConversionGoalOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerConversionGoalOperation {
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_conversion_goal_operation::Operation", tags = "1")]
pub operation: ::core::option::Option<customer_conversion_goal_operation::Operation>,
}
/// Nested message and enum types in `CustomerConversionGoalOperation`.
pub mod customer_conversion_goal_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Update(super::super::resources::CustomerConversionGoal),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerConversionGoalsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerConversionGoalResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerConversionGoalResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod customer_conversion_goal_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer conversion goal.
#[derive(Debug, Clone)]
pub struct CustomerConversionGoalServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerConversionGoalServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerConversionGoalServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerConversionGoalServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes customer conversion goals. Operation statuses
/// are returned.
pub async fn mutate_customer_conversion_goals(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerConversionGoalsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerConversionGoalsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerConversionGoalService/MutateCustomerConversionGoals");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerConversionGoalService", "MutateCustomerConversionGoals"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentArmsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ExperimentArmOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExperimentArmOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "experiment_arm_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<experiment_arm_operation::Operation>,
}
/// Nested message and enum types in `ExperimentArmOperation`.
pub mod experiment_arm_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::ExperimentArm),
#[prost(message, tag = "2")]
Update(super::super::resources::ExperimentArm),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentArmsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateExperimentArmResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentArmResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub experiment_arm: ::core::option::Option<super::resources::ExperimentArm>,
}
/// Generated client implementations.
pub mod experiment_arm_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage experiment arms.
#[derive(Debug, Clone)]
pub struct ExperimentArmServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ExperimentArmServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ExperimentArmServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ExperimentArmServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes experiment arms. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ExperimentArmError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_experiment_arms(&mut self, request: impl tonic::IntoRequest<super::MutateExperimentArmsRequest>) -> std::result::Result<tonic::Response<super::MutateExperimentArmsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ExperimentArmService/MutateExperimentArms");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ExperimentArmService", "MutateExperimentArms"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriteriaRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<SharedCriterionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedCriterionOperation {
#[prost(oneof = "shared_criterion_operation::Operation", tags = "1, 3")]
pub operation: ::core::option::Option<shared_criterion_operation::Operation>,
}
/// Nested message and enum types in `SharedCriterionOperation`.
pub mod shared_criterion_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::SharedCriterion),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriteriaResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateSharedCriterionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriterionResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub shared_criterion: ::core::option::Option<super::resources::SharedCriterion>,
}
/// Generated client implementations.
pub mod shared_criterion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage shared criteria.
#[derive(Debug, Clone)]
pub struct SharedCriterionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SharedCriterionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SharedCriterionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SharedCriterionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or removes shared criteria. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_shared_criteria(&mut self, request: impl tonic::IntoRequest<super::MutateSharedCriteriaRequest>) -> std::result::Result<tonic::Response<super::MutateSharedCriteriaResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.SharedCriterionService/MutateSharedCriteria");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.SharedCriterionService", "MutateSharedCriteria"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupSignalsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AssetGroupSignalOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupSignalOperation {
#[prost(message, repeated, tag = "3")]
pub exempt_policy_violation_keys: ::prost::alloc::vec::Vec<super::common::PolicyViolationKey>,
#[prost(oneof = "asset_group_signal_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<asset_group_signal_operation::Operation>,
}
/// Nested message and enum types in `AssetGroupSignalOperation`.
pub mod asset_group_signal_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AssetGroupSignal),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupSignalsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAssetGroupSignalResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupSignalResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub asset_group_signal: ::core::option::Option<super::resources::AssetGroupSignal>,
}
/// Generated client implementations.
pub mod asset_group_signal_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage asset group signal.
#[derive(Debug, Clone)]
pub struct AssetGroupSignalServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AssetGroupSignalServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AssetGroupSignalServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AssetGroupSignalServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or removes asset group signals. Operation statuses are
/// returned.
pub async fn mutate_asset_group_signals(&mut self, request: impl tonic::IntoRequest<super::MutateAssetGroupSignalsRequest>) -> std::result::Result<tonic::Response<super::MutateAssetGroupSignalsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AssetGroupSignalService/MutateAssetGroupSignals");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AssetGroupSignalService", "MutateAssetGroupSignals"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignSharedSetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignSharedSetOperation {
#[prost(oneof = "campaign_shared_set_operation::Operation", tags = "1, 3")]
pub operation: ::core::option::Option<campaign_shared_set_operation::Operation>,
}
/// Nested message and enum types in `CampaignSharedSetOperation`.
pub mod campaign_shared_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignSharedSet),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignSharedSetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_shared_set: ::core::option::Option<super::resources::CampaignSharedSet>,
}
/// Generated client implementations.
pub mod campaign_shared_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign shared sets.
#[derive(Debug, Clone)]
pub struct CampaignSharedSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignSharedSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignSharedSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignSharedSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or removes campaign shared sets. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CampaignSharedSetError]()
///   [ContextError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_campaign_shared_sets(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignSharedSetsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignSharedSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignSharedSetService/MutateCampaignSharedSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignSharedSetService", "MutateCampaignSharedSets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemeConstantsRequest {
#[prost(string, tag = "1")]
pub query_text: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub country_code: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemeConstantsResponse {
#[prost(message, repeated, tag = "1")]
pub keyword_theme_constants: ::prost::alloc::vec::Vec<super::resources::KeywordThemeConstant>,
}
/// Generated client implementations.
pub mod keyword_theme_constant_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to fetch Smart Campaign keyword themes.
#[derive(Debug, Clone)]
pub struct KeywordThemeConstantServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> KeywordThemeConstantServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> KeywordThemeConstantServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
KeywordThemeConstantServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns KeywordThemeConstant suggestions by keyword themes.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn suggest_keyword_theme_constants(&mut self, request: impl tonic::IntoRequest<super::SuggestKeywordThemeConstantsRequest>) -> std::result::Result<tonic::Response<super::SuggestKeywordThemeConstantsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordThemeConstantService/SuggestKeywordThemeConstants");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordThemeConstantService", "SuggestKeywordThemeConstants"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<FeedMappingOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedMappingOperation {
#[prost(oneof = "feed_mapping_operation::Operation", tags = "1, 3")]
pub operation: ::core::option::Option<feed_mapping_operation::Operation>,
}
/// Nested message and enum types in `FeedMappingOperation`.
pub mod feed_mapping_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::FeedMapping),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateFeedMappingResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feed_mapping: ::core::option::Option<super::resources::FeedMapping>,
}
/// Generated client implementations.
pub mod feed_mapping_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage feed mappings.
#[derive(Debug, Clone)]
pub struct FeedMappingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeedMappingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeedMappingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeedMappingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or removes feed mappings. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FeedMappingError]()
///   [FieldError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NotEmptyError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_feed_mappings(&mut self, request: impl tonic::IntoRequest<super::MutateFeedMappingsRequest>) -> std::result::Result<tonic::Response<super::MutateFeedMappingsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.FeedMappingService/MutateFeedMappings");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.FeedMappingService", "MutateFeedMappings"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignGroupsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignGroupOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignGroupOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_group_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_group_operation::Operation>,
}
/// Nested message and enum types in `CampaignGroupOperation`.
pub mod campaign_group_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignGroup),
#[prost(message, tag = "2")]
Update(super::super::resources::CampaignGroup),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignGroupsResponse {
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignGroupResult>,
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignGroupResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_group: ::core::option::Option<super::resources::CampaignGroup>,
}
/// Generated client implementations.
pub mod campaign_group_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign groups.
#[derive(Debug, Clone)]
pub struct CampaignGroupServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignGroupServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignGroupServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignGroupServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaign groups. Operation statuses are
/// returned.
pub async fn mutate_campaign_groups(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignGroupsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignGroupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignGroupService/MutateCampaignGroups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignGroupService", "MutateCampaignGroups"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignAssetSetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignAssetSetOperation {
#[prost(oneof = "campaign_asset_set_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<campaign_asset_set_operation::Operation>,
}
/// Nested message and enum types in `CampaignAssetSetOperation`.
pub mod campaign_asset_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignAssetSet),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetSetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignAssetSetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_asset_set: ::core::option::Option<super::resources::CampaignAssetSet>,
}
/// Generated client implementations.
pub mod campaign_asset_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign asset set
#[derive(Debug, Clone)]
pub struct CampaignAssetSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignAssetSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignAssetSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignAssetSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes campaign asset sets. Operation statuses are
/// returned.
pub async fn mutate_campaign_asset_sets(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignAssetSetsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignAssetSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignAssetSetService/MutateCampaignAssetSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignAssetSetService", "MutateCampaignAssetSets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerManagerLinkOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveManagerLinkRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub previous_customer_manager_link: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub new_manager: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerManagerLinkOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_manager_link_operation::Operation", tags = "2")]
pub operation: ::core::option::Option<customer_manager_link_operation::Operation>,
}
/// Nested message and enum types in `CustomerManagerLinkOperation`.
pub mod customer_manager_link_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "2")]
Update(super::super::resources::CustomerManagerLink),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerManagerLinkResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveManagerLinkResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod customer_manager_link_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer-manager links.
#[derive(Debug, Clone)]
pub struct CustomerManagerLinkServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerManagerLinkServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerManagerLinkServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerManagerLinkServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Updates customer manager links. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [ManagerLinkError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_customer_manager_link(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerManagerLinkRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerManagerLinkResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerManagerLinkService/MutateCustomerManagerLink");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerManagerLinkService", "MutateCustomerManagerLink"));
self.inner.unary(req, path, codec).await
}
/// Moves a client customer to a new manager customer.
/// This simplifies the complex request that requires two operations to move
/// a client customer to a new manager, for example:
/// 1. Update operation with Status INACTIVE (previous manager) and,
/// 2. Update operation with Status ACTIVE (new manager).
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn move_manager_link(&mut self, request: impl tonic::IntoRequest<super::MoveManagerLinkRequest>) -> std::result::Result<tonic::Response<super::MoveManagerLinkResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerManagerLinkService/MoveManagerLink");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerManagerLinkService", "MoveManagerLink"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessInvitationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<CustomerUserAccessInvitationOperation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerUserAccessInvitationOperation {
#[prost(oneof = "customer_user_access_invitation_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customer_user_access_invitation_operation::Operation>,
}
/// Nested message and enum types in `CustomerUserAccessInvitationOperation`.
pub mod customer_user_access_invitation_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerUserAccessInvitation),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessInvitationResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<MutateCustomerUserAccessInvitationResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessInvitationResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod customer_user_access_invitation_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service manages the access invitation extended to users for a given
/// customer.
#[derive(Debug, Clone)]
pub struct CustomerUserAccessInvitationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerUserAccessInvitationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerUserAccessInvitationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerUserAccessInvitationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or removes an access invitation.
///
/// List of thrown errors:
///   [AccessInvitationError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_customer_user_access_invitation(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerUserAccessInvitationRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerUserAccessInvitationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerUserAccessInvitationService/MutateCustomerUserAccessInvitation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerUserAccessInvitationService", "MutateCustomerUserAccessInvitation"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ConversionValueRuleSetOperation>,
#[prost(bool, tag = "5")]
pub partial_failure: bool,
#[prost(bool, tag = "3")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "4")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleSetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "conversion_value_rule_set_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<conversion_value_rule_set_operation::Operation>,
}
/// Nested message and enum types in `ConversionValueRuleSetOperation`.
pub mod conversion_value_rule_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::ConversionValueRuleSet),
#[prost(message, tag = "2")]
Update(super::super::resources::ConversionValueRuleSet),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleSetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateConversionValueRuleSetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversion_value_rule_set: ::core::option::Option<super::resources::ConversionValueRuleSet>,
}
/// Generated client implementations.
pub mod conversion_value_rule_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage conversion value rule sets.
#[derive(Debug, Clone)]
pub struct ConversionValueRuleSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversionValueRuleSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversionValueRuleSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversionValueRuleSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes conversion value rule sets. Operation statuses
/// are returned.
pub async fn mutate_conversion_value_rule_sets(&mut self, request: impl tonic::IntoRequest<super::MutateConversionValueRuleSetsRequest>) -> std::result::Result<tonic::Response<super::MutateConversionValueRuleSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionValueRuleSetService/MutateConversionValueRuleSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionValueRuleSetService", "MutateConversionValueRuleSets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignLabelOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignLabelOperation {
#[prost(oneof = "campaign_label_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<campaign_label_operation::Operation>,
}
/// Nested message and enum types in `CampaignLabelOperation`.
pub mod campaign_label_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignLabel),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignLabelResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod campaign_label_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage labels on campaigns.
#[derive(Debug, Clone)]
pub struct CampaignLabelServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignLabelServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignLabelServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignLabelServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates and removes campaign-label relationships.
/// Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [LabelError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_campaign_labels(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignLabelsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignLabelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignLabelService/MutateCampaignLabels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignLabelService", "MutateCampaignLabels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionCustomizersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupCriterionCustomizerOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionCustomizerOperation {
#[prost(oneof = "ad_group_criterion_customizer_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<ad_group_criterion_customizer_operation::Operation>,
}
/// Nested message and enum types in `AdGroupCriterionCustomizerOperation`.
pub mod ad_group_criterion_customizer_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupCriterionCustomizer),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionCustomizersResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupCriterionCustomizerResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionCustomizerResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_criterion_customizer: ::core::option::Option<super::resources::AdGroupCriterionCustomizer>,
}
/// Generated client implementations.
pub mod ad_group_criterion_customizer_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group criterion customizer
#[derive(Debug, Clone)]
pub struct AdGroupCriterionCustomizerServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupCriterionCustomizerServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupCriterionCustomizerServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupCriterionCustomizerServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes ad group criterion customizers. Operation
/// statuses are returned.
pub async fn mutate_ad_group_criterion_customizers(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupCriterionCustomizersRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupCriterionCustomizersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupCriterionCustomizerService/MutateAdGroupCriterionCustomizers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupCriterionCustomizerService", "MutateAdGroupCriterionCustomizers"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeasRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, optional, tag = "14")]
pub language: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "15")]
pub geo_target_constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "10")]
pub include_adult_keywords: bool,
#[prost(string, tag = "12")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "13")]
pub page_size: i32,
#[prost(enumeration = "super::enums::keyword_plan_network_enum::KeywordPlanNetwork", tag = "9")]
pub keyword_plan_network: i32,
#[prost(enumeration = "super::enums::keyword_plan_keyword_annotation_enum::KeywordPlanKeywordAnnotation", repeated, tag = "17")]
pub keyword_annotation: ::prost::alloc::vec::Vec<i32>,
#[prost(message, optional, tag = "16")]
pub aggregate_metrics: ::core::option::Option<super::common::KeywordPlanAggregateMetrics>,
#[prost(message, optional, tag = "18")]
pub historical_metrics_options: ::core::option::Option<super::common::HistoricalMetricsOptions>,
#[prost(oneof = "generate_keyword_ideas_request::Seed", tags = "2, 3, 5, 11")]
pub seed: ::core::option::Option<generate_keyword_ideas_request::Seed>,
}
/// Nested message and enum types in `GenerateKeywordIdeasRequest`.
pub mod generate_keyword_ideas_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Seed {
#[prost(message, tag = "2")]
KeywordAndUrlSeed(super::KeywordAndUrlSeed),
#[prost(message, tag = "3")]
KeywordSeed(super::KeywordSeed),
#[prost(message, tag = "5")]
UrlSeed(super::UrlSeed),
#[prost(message, tag = "11")]
SiteSeed(super::SiteSeed),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordAndUrlSeed {
#[prost(string, optional, tag = "3")]
pub url: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordSeed {
#[prost(string, repeated, tag = "2")]
pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SiteSeed {
#[prost(string, optional, tag = "2")]
pub site: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlSeed {
#[prost(string, optional, tag = "2")]
pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeaResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<GenerateKeywordIdeaResult>,
#[prost(message, optional, tag = "4")]
pub aggregate_metric_results: ::core::option::Option<super::common::KeywordPlanAggregateMetricResults>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub total_size: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeaResult {
#[prost(string, optional, tag = "5")]
pub text: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub keyword_idea_metrics: ::core::option::Option<super::common::KeywordPlanHistoricalMetrics>,
#[prost(message, optional, tag = "6")]
pub keyword_annotations: ::core::option::Option<super::common::KeywordAnnotations>,
#[prost(string, repeated, tag = "7")]
pub close_variants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordHistoricalMetricsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, optional, tag = "4")]
pub language: ::core::option::Option<::prost::alloc::string::String>,
#[prost(bool, tag = "5")]
pub include_adult_keywords: bool,
#[prost(string, repeated, tag = "6")]
pub geo_target_constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "super::enums::keyword_plan_network_enum::KeywordPlanNetwork", tag = "7")]
pub keyword_plan_network: i32,
#[prost(message, optional, tag = "8")]
pub aggregate_metrics: ::core::option::Option<super::common::KeywordPlanAggregateMetrics>,
#[prost(message, optional, tag = "3")]
pub historical_metrics_options: ::core::option::Option<super::common::HistoricalMetricsOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordHistoricalMetricsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<GenerateKeywordHistoricalMetricsResult>,
#[prost(message, optional, tag = "2")]
pub aggregate_metric_results: ::core::option::Option<super::common::KeywordPlanAggregateMetricResults>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordHistoricalMetricsResult {
#[prost(string, optional, tag = "1")]
pub text: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub close_variants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "2")]
pub keyword_metrics: ::core::option::Option<super::common::KeywordPlanHistoricalMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAdGroupThemesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub ad_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAdGroupThemesResponse {
#[prost(message, repeated, tag = "1")]
pub ad_group_keyword_suggestions: ::prost::alloc::vec::Vec<AdGroupKeywordSuggestion>,
#[prost(message, repeated, tag = "2")]
pub unusable_ad_groups: ::prost::alloc::vec::Vec<UnusableAdGroup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupKeywordSuggestion {
#[prost(string, tag = "1")]
pub keyword_text: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub suggested_keyword_text: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::keyword_match_type_enum::KeywordMatchType", tag = "3")]
pub suggested_match_type: i32,
#[prost(string, tag = "4")]
pub suggested_ad_group: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub suggested_campaign: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnusableAdGroup {
#[prost(string, tag = "1")]
pub ad_group: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub campaign: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordForecastMetricsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, optional, tag = "2")]
pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub forecast_period: ::core::option::Option<super::common::DateRange>,
#[prost(message, optional, tag = "4")]
pub campaign: ::core::option::Option<CampaignToForecast>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignToForecast {
#[prost(string, repeated, tag = "1")]
pub language_constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "2")]
pub geo_modifiers: ::prost::alloc::vec::Vec<CriterionBidModifier>,
#[prost(enumeration = "super::enums::keyword_plan_network_enum::KeywordPlanNetwork", tag = "3")]
pub keyword_plan_network: i32,
#[prost(message, repeated, tag = "4")]
pub negative_keywords: ::prost::alloc::vec::Vec<super::common::KeywordInfo>,
#[prost(message, optional, tag = "5")]
pub bidding_strategy: ::core::option::Option<campaign_to_forecast::CampaignBiddingStrategy>,
#[prost(double, optional, tag = "6")]
pub conversion_rate: ::core::option::Option<f64>,
#[prost(message, repeated, tag = "7")]
pub ad_groups: ::prost::alloc::vec::Vec<ForecastAdGroup>,
}
/// Nested message and enum types in `CampaignToForecast`.
pub mod campaign_to_forecast {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignBiddingStrategy {
#[prost(oneof = "campaign_bidding_strategy::BiddingStrategy", tags = "1, 2, 3")]
pub bidding_strategy: ::core::option::Option<campaign_bidding_strategy::BiddingStrategy>,
}
/// Nested message and enum types in `CampaignBiddingStrategy`.
pub mod campaign_bidding_strategy {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum BiddingStrategy {
#[prost(message, tag = "1")]
ManualCpcBiddingStrategy(super::super::ManualCpcBiddingStrategy),
#[prost(message, tag = "2")]
MaximizeClicksBiddingStrategy(super::super::MaximizeClicksBiddingStrategy),
#[prost(message, tag = "3")]
MaximizeConversionsBiddingStrategy(super::super::MaximizeConversionsBiddingStrategy),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastAdGroup {
#[prost(int64, optional, tag = "1")]
pub max_cpc_bid_micros: ::core::option::Option<i64>,
#[prost(message, repeated, tag = "2")]
pub biddable_keywords: ::prost::alloc::vec::Vec<BiddableKeyword>,
#[prost(message, repeated, tag = "3")]
pub negative_keywords: ::prost::alloc::vec::Vec<super::common::KeywordInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddableKeyword {
#[prost(message, optional, tag = "1")]
pub keyword: ::core::option::Option<super::common::KeywordInfo>,
#[prost(int64, optional, tag = "2")]
pub max_cpc_bid_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CriterionBidModifier {
#[prost(string, tag = "1")]
pub geo_target_constant: ::prost::alloc::string::String,
#[prost(double, optional, tag = "2")]
pub bid_modifier: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManualCpcBiddingStrategy {
#[prost(int64, optional, tag = "1")]
pub daily_budget_micros: ::core::option::Option<i64>,
#[prost(int64, tag = "2")]
pub max_cpc_bid_micros: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaximizeClicksBiddingStrategy {
#[prost(int64, tag = "1")]
pub daily_target_spend_micros: i64,
#[prost(int64, optional, tag = "2")]
pub max_cpc_bid_ceiling_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaximizeConversionsBiddingStrategy {
#[prost(int64, tag = "1")]
pub daily_target_spend_micros: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenerateKeywordForecastMetricsResponse {
#[prost(message, optional, tag = "1")]
pub campaign_forecast_metrics: ::core::option::Option<KeywordForecastMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordForecastMetrics {
#[prost(double, optional, tag = "1")]
pub impressions: ::core::option::Option<f64>,
#[prost(double, optional, tag = "2")]
pub click_through_rate: ::core::option::Option<f64>,
#[prost(int64, optional, tag = "3")]
pub average_cpc_micros: ::core::option::Option<i64>,
#[prost(double, optional, tag = "4")]
pub clicks: ::core::option::Option<f64>,
#[prost(int64, optional, tag = "5")]
pub cost_micros: ::core::option::Option<i64>,
#[prost(double, optional, tag = "6")]
pub conversions: ::core::option::Option<f64>,
#[prost(double, optional, tag = "7")]
pub conversion_rate: ::core::option::Option<f64>,
#[prost(int64, optional, tag = "8")]
pub average_cpa_micros: ::core::option::Option<i64>,
}
/// Generated client implementations.
pub mod keyword_plan_idea_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to generate keyword ideas.
#[derive(Debug, Clone)]
pub struct KeywordPlanIdeaServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> KeywordPlanIdeaServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> KeywordPlanIdeaServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
KeywordPlanIdeaServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns a list of keyword ideas.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [HeaderError]()
///   [InternalError]()
///   [KeywordPlanIdeaError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn generate_keyword_ideas(&mut self, request: impl tonic::IntoRequest<super::GenerateKeywordIdeasRequest>) -> std::result::Result<tonic::Response<super::GenerateKeywordIdeaResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanIdeaService/GenerateKeywordIdeas");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanIdeaService", "GenerateKeywordIdeas"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of keyword historical metrics.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn generate_keyword_historical_metrics(&mut self, request: impl tonic::IntoRequest<super::GenerateKeywordHistoricalMetricsRequest>) -> std::result::Result<tonic::Response<super::GenerateKeywordHistoricalMetricsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanIdeaService/GenerateKeywordHistoricalMetrics");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanIdeaService", "GenerateKeywordHistoricalMetrics"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of suggested AdGroups and suggested modifications
/// (text, match type) for the given keywords.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn generate_ad_group_themes(&mut self, request: impl tonic::IntoRequest<super::GenerateAdGroupThemesRequest>) -> std::result::Result<tonic::Response<super::GenerateAdGroupThemesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanIdeaService/GenerateAdGroupThemes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanIdeaService", "GenerateAdGroupThemes"));
self.inner.unary(req, path, codec).await
}
/// Returns metrics (such as impressions, clicks, total cost) of a keyword
/// forecast for the given campaign.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn generate_keyword_forecast_metrics(&mut self, request: impl tonic::IntoRequest<super::GenerateKeywordForecastMetricsRequest>) -> std::result::Result<tonic::Response<super::GenerateKeywordForecastMetricsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanIdeaService/GenerateKeywordForecastMetrics");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanIdeaService", "GenerateKeywordForecastMetrics"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetLinksRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<FeedItemSetLinkOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemSetLinkOperation {
#[prost(oneof = "feed_item_set_link_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<feed_item_set_link_operation::Operation>,
}
/// Nested message and enum types in `FeedItemSetLinkOperation`.
pub mod feed_item_set_link_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::FeedItemSetLink),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetLinksResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateFeedItemSetLinkResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetLinkResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod feed_item_set_link_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage feed item set links.
#[derive(Debug, Clone)]
pub struct FeedItemSetLinkServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeedItemSetLinkServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeedItemSetLinkServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeedItemSetLinkServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes feed item set links.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_feed_item_set_links(&mut self, request: impl tonic::IntoRequest<super::MutateFeedItemSetLinksRequest>) -> std::result::Result<tonic::Response<super::MutateFeedItemSetLinksResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.FeedItemSetLinkService/MutateFeedItemSetLinks");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.FeedItemSetLinkService", "MutateFeedItemSetLinks"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInvoicesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub billing_setup: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub issue_year: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::month_of_year_enum::MonthOfYear", tag = "4")]
pub issue_month: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInvoicesResponse {
#[prost(message, repeated, tag = "1")]
pub invoices: ::prost::alloc::vec::Vec<super::resources::Invoice>,
}
/// Generated client implementations.
pub mod invoice_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service to fetch invoices issued for a billing setup during a given month.
#[derive(Debug, Clone)]
pub struct InvoiceServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> InvoiceServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> InvoiceServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
InvoiceServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns all invoices associated with a billing setup, for a given month.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [InvoiceError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_invoices(&mut self, request: impl tonic::IntoRequest<super::ListInvoicesRequest>) -> std::result::Result<tonic::Response<super::ListInvoicesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.InvoiceService/ListInvoices");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.InvoiceService", "ListInvoices"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AssetOperation>,
#[prost(bool, tag = "5")]
pub partial_failure: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "3")]
pub response_content_type: i32,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetOperation {
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "asset_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<asset_operation::Operation>,
}
/// Nested message and enum types in `AssetOperation`.
pub mod asset_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::Asset),
#[prost(message, tag = "2")]
Update(super::super::resources::Asset),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAssetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub asset: ::core::option::Option<super::resources::Asset>,
}
/// Generated client implementations.
pub mod asset_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage assets. Asset types can be created with AssetService are
/// YoutubeVideoAsset, MediaBundleAsset and ImageAsset. TextAsset should be
/// created with Ad inline.
#[derive(Debug, Clone)]
pub struct AssetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AssetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AssetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AssetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates assets. Operation statuses are returned.
///
/// List of thrown errors:
///   [AssetError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [CurrencyCodeError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MediaUploadError]()
///   [MutateError]()
///   [NotAllowlistedError]()
///   [NotEmptyError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
///   [YoutubeVideoRegistrationError]()
pub async fn mutate_assets(&mut self, request: impl tonic::IntoRequest<super::MutateAssetsRequest>) -> std::result::Result<tonic::Response<super::MutateAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AssetService/MutateAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AssetService", "MutateAssets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCustomizersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupCustomizerOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCustomizerOperation {
#[prost(oneof = "ad_group_customizer_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<ad_group_customizer_operation::Operation>,
}
/// Nested message and enum types in `AdGroupCustomizerOperation`.
pub mod ad_group_customizer_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupCustomizer),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCustomizersResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupCustomizerResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCustomizerResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_customizer: ::core::option::Option<super::resources::AdGroupCustomizer>,
}
/// Generated client implementations.
pub mod ad_group_customizer_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group customizer
#[derive(Debug, Clone)]
pub struct AdGroupCustomizerServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupCustomizerServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupCustomizerServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupCustomizerServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes ad group customizers. Operation statuses are
/// returned.
pub async fn mutate_ad_group_customizers(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupCustomizersRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupCustomizersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupCustomizerService/MutateAdGroupCustomizers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupCustomizerService", "MutateAdGroupCustomizers"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AssetGroupOperation>,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "asset_group_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<asset_group_operation::Operation>,
}
/// Nested message and enum types in `AssetGroupOperation`.
pub mod asset_group_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AssetGroup),
#[prost(message, tag = "2")]
Update(super::super::resources::AssetGroup),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAssetGroupResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod asset_group_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage asset group
#[derive(Debug, Clone)]
pub struct AssetGroupServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AssetGroupServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AssetGroupServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AssetGroupServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes asset groups. Operation statuses are
/// returned.
pub async fn mutate_asset_groups(&mut self, request: impl tonic::IntoRequest<super::MutateAssetGroupsRequest>) -> std::result::Result<tonic::Response<super::MutateAssetGroupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AssetGroupService/MutateAssetGroups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AssetGroupService", "MutateAssetGroups"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOfflineUserDataJobRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub job: ::core::option::Option<super::resources::OfflineUserDataJob>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
#[prost(bool, tag = "5")]
pub enable_match_rate_range_preview: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOfflineUserDataJobResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunOfflineUserDataJobRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddOfflineUserDataJobOperationsRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(bool, optional, tag = "4")]
pub enable_partial_failure: ::core::option::Option<bool>,
#[prost(bool, optional, tag = "6")]
pub enable_warnings: ::core::option::Option<bool>,
#[prost(message, repeated, tag = "3")]
pub operations: ::prost::alloc::vec::Vec<OfflineUserDataJobOperation>,
#[prost(bool, tag = "5")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobOperation {
#[prost(oneof = "offline_user_data_job_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<offline_user_data_job_operation::Operation>,
}
/// Nested message and enum types in `OfflineUserDataJobOperation`.
pub mod offline_user_data_job_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::common::UserData),
#[prost(message, tag = "2")]
Remove(super::super::common::UserData),
#[prost(bool, tag = "3")]
RemoveAll(bool),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddOfflineUserDataJobOperationsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, optional, tag = "2")]
pub warning: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// Generated client implementations.
pub mod offline_user_data_job_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage offline user data jobs.
#[derive(Debug, Clone)]
pub struct OfflineUserDataJobServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> OfflineUserDataJobServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> OfflineUserDataJobServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
OfflineUserDataJobServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates an offline user data job.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [NotAllowlistedError]()
///   [OfflineUserDataJobError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn create_offline_user_data_job(&mut self, request: impl tonic::IntoRequest<super::CreateOfflineUserDataJobRequest>) -> std::result::Result<tonic::Response<super::CreateOfflineUserDataJobResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.OfflineUserDataJobService/CreateOfflineUserDataJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.OfflineUserDataJobService", "CreateOfflineUserDataJob"));
self.inner.unary(req, path, codec).await
}
/// Adds operations to the offline user data job.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [OfflineUserDataJobError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn add_offline_user_data_job_operations(&mut self, request: impl tonic::IntoRequest<super::AddOfflineUserDataJobOperationsRequest>) -> std::result::Result<tonic::Response<super::AddOfflineUserDataJobOperationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.OfflineUserDataJobService/AddOfflineUserDataJobOperations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.OfflineUserDataJobService", "AddOfflineUserDataJobOperations"));
self.inner.unary(req, path, codec).await
}
/// Runs the offline user data job.
///
/// When finished, the long running operation will contain the processing
/// result or failure information, if any.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [HeaderError]()
///   [InternalError]()
///   [OfflineUserDataJobError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn run_offline_user_data_job(&mut self, request: impl tonic::IntoRequest<super::RunOfflineUserDataJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.OfflineUserDataJobService/RunOfflineUserDataJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.OfflineUserDataJobService", "RunOfflineUserDataJob"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupAdOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAdOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "5")]
pub policy_validation_parameter: ::core::option::Option<super::common::PolicyValidationParameter>,
#[prost(oneof = "ad_group_ad_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<ad_group_ad_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAdOperation`.
pub mod ad_group_ad_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupAd),
#[prost(message, tag = "2")]
Update(super::super::resources::AdGroupAd),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupAdResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_ad: ::core::option::Option<super::resources::AdGroupAd>,
}
/// Generated client implementations.
pub mod ad_group_ad_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ads in an ad group.
#[derive(Debug, Clone)]
pub struct AdGroupAdServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupAdServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupAdServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupAdServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes ads. Operation statuses are returned.
///
/// List of thrown errors:
///   [AdCustomizerError]()
///   [AdError]()
///   [AdGroupAdError]()
///   [AdSharingError]()
///   [AdxError]()
///   [AssetError]()
///   [AssetLinkError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [ContextError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FeedAttributeReferenceError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [FunctionError]()
///   [FunctionParsingError]()
///   [HeaderError]()
///   [IdError]()
///   [ImageError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MediaBundleError]()
///   [MediaFileError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [PolicyFindingError]()
///   [PolicyValidationParameterError]()
///   [PolicyViolationError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_ad_group_ads(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupAdsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupAdsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupAdService/MutateAdGroupAds");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupAdService", "MutateAdGroupAds"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupAssetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAssetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "ad_group_asset_operation::Operation", tags = "1, 3, 2")]
pub operation: ::core::option::Option<ad_group_asset_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAssetOperation`.
pub mod ad_group_asset_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupAsset),
#[prost(message, tag = "3")]
Update(super::super::resources::AdGroupAsset),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupAssetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_asset: ::core::option::Option<super::resources::AdGroupAsset>,
}
/// Generated client implementations.
pub mod ad_group_asset_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group assets.
#[derive(Debug, Clone)]
pub struct AdGroupAssetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupAssetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupAssetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupAssetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes ad group assets. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AssetLinkError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ContextError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [NotAllowlistedError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_ad_group_assets(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupAssetsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupAssetService/MutateAdGroupAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupAssetService", "MutateAdGroupAssets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifiersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupBidModifierOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupBidModifierOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "ad_group_bid_modifier_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<ad_group_bid_modifier_operation::Operation>,
}
/// Nested message and enum types in `AdGroupBidModifierOperation`.
pub mod ad_group_bid_modifier_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupBidModifier),
#[prost(message, tag = "2")]
Update(super::super::resources::AdGroupBidModifier),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifiersResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupBidModifierResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifierResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_bid_modifier: ::core::option::Option<super::resources::AdGroupBidModifier>,
}
/// Generated client implementations.
pub mod ad_group_bid_modifier_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group bid modifiers.
#[derive(Debug, Clone)]
pub struct AdGroupBidModifierServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupBidModifierServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupBidModifierServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupBidModifierServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes ad group bid modifiers.
/// Operation statuses are returned.
///
/// List of thrown errors:
///   [AdGroupBidModifierError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ContextError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_ad_group_bid_modifiers(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupBidModifiersRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupBidModifiersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupBidModifierService/MutateAdGroupBidModifiers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupBidModifierService", "MutateAdGroupBidModifiers"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupCriterionLabelOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionLabelOperation {
#[prost(oneof = "ad_group_criterion_label_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<ad_group_criterion_label_operation::Operation>,
}
/// Nested message and enum types in `AdGroupCriterionLabelOperation`.
pub mod ad_group_criterion_label_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupCriterionLabel),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupCriterionLabelResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod ad_group_criterion_label_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage labels on ad group criteria.
#[derive(Debug, Clone)]
pub struct AdGroupCriterionLabelServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupCriterionLabelServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupCriterionLabelServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupCriterionLabelServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates and removes ad group criterion labels.
/// Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_ad_group_criterion_labels(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupCriterionLabelsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupCriterionLabelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupCriterionLabelService/MutateAdGroupCriterionLabels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupCriterionLabelService", "MutateAdGroupCriterionLabels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriteriaRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupCriterionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, repeated, tag = "5")]
pub exempt_policy_violation_keys: ::prost::alloc::vec::Vec<super::common::PolicyViolationKey>,
#[prost(oneof = "ad_group_criterion_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<ad_group_criterion_operation::Operation>,
}
/// Nested message and enum types in `AdGroupCriterionOperation`.
pub mod ad_group_criterion_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupCriterion),
#[prost(message, tag = "2")]
Update(super::super::resources::AdGroupCriterion),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriteriaResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupCriterionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_criterion: ::core::option::Option<super::resources::AdGroupCriterion>,
}
/// Generated client implementations.
pub mod ad_group_criterion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group criteria.
#[derive(Debug, Clone)]
pub struct AdGroupCriterionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupCriterionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupCriterionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupCriterionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes criteria. Operation statuses are returned.
///
/// List of thrown errors:
///   [AdGroupCriterionError]()
///   [AdxError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BiddingError]()
///   [BiddingStrategyError]()
///   [CollectionSizeError]()
///   [ContextError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MultiplierError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [PolicyViolationError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_ad_group_criteria(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupCriteriaRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupCriteriaResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupCriterionService/MutateAdGroupCriteria");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupCriterionService", "MutateAdGroupCriteria"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupExtensionSettingOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupExtensionSettingOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
#[prost(oneof = "ad_group_extension_setting_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<ad_group_extension_setting_operation::Operation>,
}
/// Nested message and enum types in `AdGroupExtensionSettingOperation`.
pub mod ad_group_extension_setting_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupExtensionSetting),
#[prost(message, tag = "2")]
Update(super::super::resources::AdGroupExtensionSetting),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupExtensionSettingResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_extension_setting: ::core::option::Option<super::resources::AdGroupExtensionSetting>,
}
/// Generated client implementations.
pub mod ad_group_extension_setting_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group extension settings.
#[derive(Debug, Clone)]
pub struct AdGroupExtensionSettingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupExtensionSettingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupExtensionSettingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupExtensionSettingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes ad group extension settings. Operation
/// statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [ExtensionSettingError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_ad_group_extension_settings(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupExtensionSettingsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupExtensionSettingsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupExtensionSettingService/MutateAdGroupExtensionSettings");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupExtensionSettingService", "MutateAdGroupExtensionSettings"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupLabelOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupLabelOperation {
#[prost(oneof = "ad_group_label_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<ad_group_label_operation::Operation>,
}
/// Nested message and enum types in `AdGroupLabelOperation`.
pub mod ad_group_label_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupLabel),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupLabelResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod ad_group_label_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage labels on ad groups.
#[derive(Debug, Clone)]
pub struct AdGroupLabelServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupLabelServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupLabelServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupLabelServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates and removes ad group labels.
/// Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [LabelError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_ad_group_labels(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupLabelsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupLabelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupLabelService/MutateAdGroupLabels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupLabelService", "MutateAdGroupLabels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParametersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdParameterOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdParameterOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "ad_parameter_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<ad_parameter_operation::Operation>,
}
/// Nested message and enum types in `AdParameterOperation`.
pub mod ad_parameter_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdParameter),
#[prost(message, tag = "2")]
Update(super::super::resources::AdParameter),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParametersResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateAdParameterResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParameterResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_parameter: ::core::option::Option<super::resources::AdParameter>,
}
/// Generated client implementations.
pub mod ad_parameter_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad parameters.
#[derive(Debug, Clone)]
pub struct AdParameterServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdParameterServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdParameterServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdParameterServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes ad parameters. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AdParameterError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ContextError]()
///   [DatabaseError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_ad_parameters(&mut self, request: impl tonic::IntoRequest<super::MutateAdParametersRequest>) -> std::result::Result<tonic::Response<super::MutateAdParametersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdParameterService/MutateAdParameters");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdParameterService", "MutateAdParameters"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupAssetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AssetGroupAssetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupAssetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "asset_group_asset_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<asset_group_asset_operation::Operation>,
}
/// Nested message and enum types in `AssetGroupAssetOperation`.
pub mod asset_group_asset_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AssetGroupAsset),
#[prost(message, tag = "2")]
Update(super::super::resources::AssetGroupAsset),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupAssetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAssetGroupAssetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupAssetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod asset_group_asset_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage asset group asset.
#[derive(Debug, Clone)]
pub struct AssetGroupAssetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AssetGroupAssetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AssetGroupAssetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AssetGroupAssetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes asset group assets. Operation statuses are
/// returned.
pub async fn mutate_asset_group_assets(&mut self, request: impl tonic::IntoRequest<super::MutateAssetGroupAssetsRequest>) -> std::result::Result<tonic::Response<super::MutateAssetGroupAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AssetGroupAssetService/MutateAssetGroupAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AssetGroupAssetService", "MutateAssetGroupAssets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupListingGroupFiltersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AssetGroupListingGroupFilterOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "4")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupListingGroupFilterOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "asset_group_listing_group_filter_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<asset_group_listing_group_filter_operation::Operation>,
}
/// Nested message and enum types in `AssetGroupListingGroupFilterOperation`.
pub mod asset_group_listing_group_filter_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AssetGroupListingGroupFilter),
#[prost(message, tag = "2")]
Update(super::super::resources::AssetGroupListingGroupFilter),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupListingGroupFiltersResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAssetGroupListingGroupFilterResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupListingGroupFilterResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub asset_group_listing_group_filter: ::core::option::Option<super::resources::AssetGroupListingGroupFilter>,
}
/// Generated client implementations.
pub mod asset_group_listing_group_filter_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage asset group listing group filter.
#[derive(Debug, Clone)]
pub struct AssetGroupListingGroupFilterServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AssetGroupListingGroupFilterServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AssetGroupListingGroupFilterServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AssetGroupListingGroupFilterServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes asset group listing group filters. Operation
/// statuses are returned.
pub async fn mutate_asset_group_listing_group_filters(&mut self, request: impl tonic::IntoRequest<super::MutateAssetGroupListingGroupFiltersRequest>) -> std::result::Result<tonic::Response<super::MutateAssetGroupListingGroupFiltersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AssetGroupListingGroupFilterService/MutateAssetGroupListingGroupFilters");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AssetGroupListingGroupFilterService", "MutateAssetGroupListingGroupFilters"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AssetSetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetSetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "asset_set_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<asset_set_operation::Operation>,
}
/// Nested message and enum types in `AssetSetOperation`.
pub mod asset_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AssetSet),
#[prost(message, tag = "2")]
Update(super::super::resources::AssetSet),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAssetSetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub asset_set: ::core::option::Option<super::resources::AssetSet>,
}
/// Generated client implementations.
pub mod asset_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage asset set
#[derive(Debug, Clone)]
pub struct AssetSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AssetSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AssetSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AssetSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes asset sets. Operation statuses are
/// returned.
pub async fn mutate_asset_sets(&mut self, request: impl tonic::IntoRequest<super::MutateAssetSetsRequest>) -> std::result::Result<tonic::Response<super::MutateAssetSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AssetSetService/MutateAssetSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AssetSetService", "MutateAssetSets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAudiencesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AudienceOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAudiencesResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAudienceResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "audience_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<audience_operation::Operation>,
}
/// Nested message and enum types in `AudienceOperation`.
pub mod audience_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::Audience),
#[prost(message, tag = "2")]
Update(super::super::resources::Audience),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAudienceResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub audience: ::core::option::Option<super::resources::Audience>,
}
/// Generated client implementations.
pub mod audience_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage audiences.
#[derive(Debug, Clone)]
pub struct AudienceServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AudienceServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AudienceServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AudienceServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates audiences. Operation statuses are returned.
///
/// List of thrown errors:
///   [AudienceError]()
pub async fn mutate_audiences(&mut self, request: impl tonic::IntoRequest<super::MutateAudiencesRequest>) -> std::result::Result<tonic::Response<super::MutateAudiencesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AudienceService/MutateAudiences");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AudienceService", "MutateAudiences"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingDataExclusionsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<BiddingDataExclusionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddingDataExclusionOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "bidding_data_exclusion_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<bidding_data_exclusion_operation::Operation>,
}
/// Nested message and enum types in `BiddingDataExclusionOperation`.
pub mod bidding_data_exclusion_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::BiddingDataExclusion),
#[prost(message, tag = "2")]
Update(super::super::resources::BiddingDataExclusion),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingDataExclusionsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateBiddingDataExclusionsResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingDataExclusionsResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub bidding_data_exclusion: ::core::option::Option<super::resources::BiddingDataExclusion>,
}
/// Generated client implementations.
pub mod bidding_data_exclusion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage bidding data exclusions.
#[derive(Debug, Clone)]
pub struct BiddingDataExclusionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> BiddingDataExclusionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> BiddingDataExclusionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
BiddingDataExclusionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes data exclusions.
/// Operation statuses are returned.
pub async fn mutate_bidding_data_exclusions(&mut self, request: impl tonic::IntoRequest<super::MutateBiddingDataExclusionsRequest>) -> std::result::Result<tonic::Response<super::MutateBiddingDataExclusionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BiddingDataExclusionService/MutateBiddingDataExclusions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BiddingDataExclusionService", "MutateBiddingDataExclusions"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategiesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<BiddingStrategyOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddingStrategyOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "bidding_strategy_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<bidding_strategy_operation::Operation>,
}
/// Nested message and enum types in `BiddingStrategyOperation`.
pub mod bidding_strategy_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::BiddingStrategy),
#[prost(message, tag = "2")]
Update(super::super::resources::BiddingStrategy),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategiesResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateBiddingStrategyResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategyResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub bidding_strategy: ::core::option::Option<super::resources::BiddingStrategy>,
}
/// Generated client implementations.
pub mod bidding_strategy_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage bidding strategies.
#[derive(Debug, Clone)]
pub struct BiddingStrategyServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> BiddingStrategyServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> BiddingStrategyServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
BiddingStrategyServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes bidding strategies. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AdxError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BiddingError]()
///   [BiddingStrategyError]()
///   [ContextError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_bidding_strategies(&mut self, request: impl tonic::IntoRequest<super::MutateBiddingStrategiesRequest>) -> std::result::Result<tonic::Response<super::MutateBiddingStrategiesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BiddingStrategyService/MutateBiddingStrategies");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BiddingStrategyService", "MutateBiddingStrategies"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignAssetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignAssetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_asset_operation::Operation", tags = "1, 3, 2")]
pub operation: ::core::option::Option<campaign_asset_operation::Operation>,
}
/// Nested message and enum types in `CampaignAssetOperation`.
pub mod campaign_asset_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignAsset),
#[prost(message, tag = "3")]
Update(super::super::resources::CampaignAsset),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignAssetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_asset: ::core::option::Option<super::resources::CampaignAsset>,
}
/// Generated client implementations.
pub mod campaign_asset_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign assets.
#[derive(Debug, Clone)]
pub struct CampaignAssetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignAssetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignAssetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignAssetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaign assets. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AssetLinkError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ContextError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [NotAllowlistedError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_campaign_assets(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignAssetsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignAssetService/MutateCampaignAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignAssetService", "MutateCampaignAssets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifiersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignBidModifierOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBidModifierOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_bid_modifier_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_bid_modifier_operation::Operation>,
}
/// Nested message and enum types in `CampaignBidModifierOperation`.
pub mod campaign_bid_modifier_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignBidModifier),
#[prost(message, tag = "2")]
Update(super::super::resources::CampaignBidModifier),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifiersResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignBidModifierResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifierResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_bid_modifier: ::core::option::Option<super::resources::CampaignBidModifier>,
}
/// Generated client implementations.
pub mod campaign_bid_modifier_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign bid modifiers.
#[derive(Debug, Clone)]
pub struct CampaignBidModifierServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignBidModifierServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignBidModifierServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignBidModifierServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaign bid modifiers.
/// Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ContextError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_campaign_bid_modifiers(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignBidModifiersRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignBidModifiersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignBidModifierService/MutateCampaignBidModifiers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignBidModifierService", "MutateCampaignBidModifiers"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignBudgetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBudgetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_budget_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_budget_operation::Operation>,
}
/// Nested message and enum types in `CampaignBudgetOperation`.
pub mod campaign_budget_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignBudget),
#[prost(message, tag = "2")]
Update(super::super::resources::CampaignBudget),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignBudgetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_budget: ::core::option::Option<super::resources::CampaignBudget>,
}
/// Generated client implementations.
pub mod campaign_budget_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign budgets.
#[derive(Debug, Clone)]
pub struct CampaignBudgetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignBudgetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignBudgetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignBudgetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaign budgets. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CampaignBudgetError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [OperationAccessDeniedError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [StringLengthError]()
pub async fn mutate_campaign_budgets(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignBudgetsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignBudgetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignBudgetService/MutateCampaignBudgets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignBudgetService", "MutateCampaignBudgets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignConversionGoalsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignConversionGoalOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignConversionGoalOperation {
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_conversion_goal_operation::Operation", tags = "1")]
pub operation: ::core::option::Option<campaign_conversion_goal_operation::Operation>,
}
/// Nested message and enum types in `CampaignConversionGoalOperation`.
pub mod campaign_conversion_goal_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Update(super::super::resources::CampaignConversionGoal),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignConversionGoalsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignConversionGoalResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignConversionGoalResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod campaign_conversion_goal_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign conversion goal.
#[derive(Debug, Clone)]
pub struct CampaignConversionGoalServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignConversionGoalServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignConversionGoalServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignConversionGoalServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes campaign conversion goals. Operation statuses
/// are returned.
pub async fn mutate_campaign_conversion_goals(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignConversionGoalsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignConversionGoalsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignConversionGoalService/MutateCampaignConversionGoals");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignConversionGoalService", "MutateCampaignConversionGoals"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCustomizersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignCustomizerOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignCustomizerOperation {
#[prost(oneof = "campaign_customizer_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<campaign_customizer_operation::Operation>,
}
/// Nested message and enum types in `CampaignCustomizerOperation`.
pub mod campaign_customizer_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignCustomizer),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCustomizersResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignCustomizerResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCustomizerResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_customizer: ::core::option::Option<super::resources::CampaignCustomizer>,
}
/// Generated client implementations.
pub mod campaign_customizer_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign customizer
#[derive(Debug, Clone)]
pub struct CampaignCustomizerServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignCustomizerServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignCustomizerServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignCustomizerServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes campaign customizers. Operation statuses are
/// returned.
pub async fn mutate_campaign_customizers(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignCustomizersRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignCustomizersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignCustomizerService/MutateCampaignCustomizers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignCustomizerService", "MutateCampaignCustomizers"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignDraftOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteCampaignDraftRequest {
#[prost(string, tag = "1")]
pub campaign_draft: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignDraftOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_draft_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_draft_operation::Operation>,
}
/// Nested message and enum types in `CampaignDraftOperation`.
pub mod campaign_draft_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignDraft),
#[prost(message, tag = "2")]
Update(super::super::resources::CampaignDraft),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignDraftResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_draft: ::core::option::Option<super::resources::CampaignDraft>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignDraftAsyncErrorsRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignDraftAsyncErrorsResponse {
#[prost(message, repeated, tag = "1")]
pub errors: ::prost::alloc::vec::Vec<super::super::super::super::rpc::Status>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod campaign_draft_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign drafts.
#[derive(Debug, Clone)]
pub struct CampaignDraftServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignDraftServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignDraftServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignDraftServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaign drafts. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CampaignDraftError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_campaign_drafts(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignDraftsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignDraftsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignDraftService/MutateCampaignDrafts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignDraftService", "MutateCampaignDrafts"));
self.inner.unary(req, path, codec).await
}
/// Promotes the changes in a draft back to the base campaign.
///
/// This method returns a Long Running Operation (LRO) indicating if the
/// Promote is done. Use [Operations.GetOperation] to poll the LRO until it
/// is done. Only a done status is returned in the response. See the status
/// in the Campaign Draft resource to determine if the promotion was
/// successful. If the LRO failed, use
/// [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v17.services.CampaignDraftService.ListCampaignDraftAsyncErrors]
/// to view the list of error reasons.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CampaignDraftError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn promote_campaign_draft(&mut self, request: impl tonic::IntoRequest<super::PromoteCampaignDraftRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignDraftService/PromoteCampaignDraft");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignDraftService", "PromoteCampaignDraft"));
self.inner.unary(req, path, codec).await
}
/// Returns all errors that occurred during CampaignDraft promote. Throws an
/// error if called before campaign draft is promoted.
/// Supports standard list paging.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_campaign_draft_async_errors(&mut self, request: impl tonic::IntoRequest<super::ListCampaignDraftAsyncErrorsRequest>) -> std::result::Result<tonic::Response<super::ListCampaignDraftAsyncErrorsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignDraftService/ListCampaignDraftAsyncErrors");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignDraftService", "ListCampaignDraftAsyncErrors"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignExtensionSettingOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignExtensionSettingOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_extension_setting_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_extension_setting_operation::Operation>,
}
/// Nested message and enum types in `CampaignExtensionSettingOperation`.
pub mod campaign_extension_setting_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignExtensionSetting),
#[prost(message, tag = "2")]
Update(super::super::resources::CampaignExtensionSetting),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignExtensionSettingResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_extension_setting: ::core::option::Option<super::resources::CampaignExtensionSetting>,
}
/// Generated client implementations.
pub mod campaign_extension_setting_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign extension settings.
#[derive(Debug, Clone)]
pub struct CampaignExtensionSettingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignExtensionSettingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignExtensionSettingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignExtensionSettingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaign extension settings. Operation
/// statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [ExtensionSettingError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_campaign_extension_settings(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignExtensionSettingsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignExtensionSettingsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignExtensionSettingService/MutateCampaignExtensionSettings");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignExtensionSettingService", "MutateCampaignExtensionSettings"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignFeedOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignFeedOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_feed_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_feed_operation::Operation>,
}
/// Nested message and enum types in `CampaignFeedOperation`.
pub mod campaign_feed_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignFeed),
#[prost(message, tag = "2")]
Update(super::super::resources::CampaignFeed),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignFeedResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign_feed: ::core::option::Option<super::resources::CampaignFeed>,
}
/// Generated client implementations.
pub mod campaign_feed_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaign feeds.
#[derive(Debug, Clone)]
pub struct CampaignFeedServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignFeedServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignFeedServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignFeedServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaign feeds. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CampaignFeedError]()
///   [CollectionSizeError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [FunctionError]()
///   [FunctionParsingError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_campaign_feeds(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignFeedsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignFeedsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignFeedService/MutateCampaignFeeds");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignFeedService", "MutateCampaignFeeds"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CampaignOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<campaign_operation::Operation>,
}
/// Nested message and enum types in `CampaignOperation`.
pub mod campaign_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::Campaign),
#[prost(message, tag = "2")]
Update(super::super::resources::Campaign),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCampaignResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub campaign: ::core::option::Option<super::resources::Campaign>,
}
/// Generated client implementations.
pub mod campaign_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage campaigns.
#[derive(Debug, Clone)]
pub struct CampaignServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes campaigns. Operation statuses are returned.
///
/// List of thrown errors:
///   [AdxError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BiddingError]()
///   [BiddingStrategyError]()
///   [CampaignBudgetError]()
///   [CampaignError]()
///   [ContextError]()
///   [DatabaseError]()
///   [DateError]()
///   [DateRangeError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotAllowlistedError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RegionCodeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SettingError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_campaigns(&mut self, request: impl tonic::IntoRequest<super::MutateCampaignsRequest>) -> std::result::Result<tonic::Response<super::MutateCampaignsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignService/MutateCampaigns");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignService", "MutateCampaigns"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionCustomVariablesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ConversionCustomVariableOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableOperation {
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "conversion_custom_variable_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<conversion_custom_variable_operation::Operation>,
}
/// Nested message and enum types in `ConversionCustomVariableOperation`.
pub mod conversion_custom_variable_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::ConversionCustomVariable),
#[prost(message, tag = "2")]
Update(super::super::resources::ConversionCustomVariable),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionCustomVariablesResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateConversionCustomVariableResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionCustomVariableResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversion_custom_variable: ::core::option::Option<super::resources::ConversionCustomVariable>,
}
/// Generated client implementations.
pub mod conversion_custom_variable_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage conversion custom variables.
#[derive(Debug, Clone)]
pub struct ConversionCustomVariableServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversionCustomVariableServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversionCustomVariableServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversionCustomVariableServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or updates conversion custom variables. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ConversionCustomVariableError]()
///   [DatabaseError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_conversion_custom_variables(&mut self, request: impl tonic::IntoRequest<super::MutateConversionCustomVariablesRequest>) -> std::result::Result<tonic::Response<super::MutateConversionCustomVariablesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionCustomVariableService/MutateConversionCustomVariables");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionCustomVariableService", "MutateConversionCustomVariables"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRulesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ConversionValueRuleOperation>,
#[prost(bool, tag = "5")]
pub partial_failure: bool,
#[prost(bool, tag = "3")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "4")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "conversion_value_rule_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<conversion_value_rule_operation::Operation>,
}
/// Nested message and enum types in `ConversionValueRuleOperation`.
pub mod conversion_value_rule_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::ConversionValueRule),
#[prost(message, tag = "2")]
Update(super::super::resources::ConversionValueRule),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRulesResponse {
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateConversionValueRuleResult>,
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversion_value_rule: ::core::option::Option<super::resources::ConversionValueRule>,
}
/// Generated client implementations.
pub mod conversion_value_rule_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage conversion value rules.
#[derive(Debug, Clone)]
pub struct ConversionValueRuleServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversionValueRuleServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversionValueRuleServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversionValueRuleServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes conversion value rules. Operation statuses are
/// returned.
pub async fn mutate_conversion_value_rules(&mut self, request: impl tonic::IntoRequest<super::MutateConversionValueRulesRequest>) -> std::result::Result<tonic::Response<super::MutateConversionValueRulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionValueRuleService/MutateConversionValueRules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionValueRuleService", "MutateConversionValueRules"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerAssetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerAssetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_asset_operation::Operation", tags = "1, 3, 2")]
pub operation: ::core::option::Option<customer_asset_operation::Operation>,
}
/// Nested message and enum types in `CustomerAssetOperation`.
pub mod customer_asset_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerAsset),
#[prost(message, tag = "3")]
Update(super::super::resources::CustomerAsset),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerAssetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer_asset: ::core::option::Option<super::resources::CustomerAsset>,
}
/// Generated client implementations.
pub mod customer_asset_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer assets.
#[derive(Debug, Clone)]
pub struct CustomerAssetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerAssetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerAssetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerAssetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes customer assets. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AssetLinkError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_customer_assets(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerAssetsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerAssetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerAssetService/MutateCustomerAssets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerAssetService", "MutateCustomerAssets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerCustomizersRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerCustomizerOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerCustomizerOperation {
#[prost(oneof = "customer_customizer_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customer_customizer_operation::Operation>,
}
/// Nested message and enum types in `CustomerCustomizerOperation`.
pub mod customer_customizer_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerCustomizer),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerCustomizersResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerCustomizerResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerCustomizerResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer_customizer: ::core::option::Option<super::resources::CustomerCustomizer>,
}
/// Generated client implementations.
pub mod customer_customizer_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer customizer
#[derive(Debug, Clone)]
pub struct CustomerCustomizerServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerCustomizerServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerCustomizerServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerCustomizerServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes customer customizers. Operation statuses are
/// returned.
pub async fn mutate_customer_customizers(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerCustomizersRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerCustomizersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerCustomizerService/MutateCustomerCustomizers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerCustomizerService", "MutateCustomerCustomizers"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerExtensionSettingOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerExtensionSettingOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_extension_setting_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<customer_extension_setting_operation::Operation>,
}
/// Nested message and enum types in `CustomerExtensionSettingOperation`.
pub mod customer_extension_setting_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerExtensionSetting),
#[prost(message, tag = "2")]
Update(super::super::resources::CustomerExtensionSetting),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerExtensionSettingResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer_extension_setting: ::core::option::Option<super::resources::CustomerExtensionSetting>,
}
/// Generated client implementations.
pub mod customer_extension_setting_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer extension settings.
#[derive(Debug, Clone)]
pub struct CustomerExtensionSettingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerExtensionSettingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerExtensionSettingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerExtensionSettingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes customer extension settings. Operation
/// statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [ExtensionSettingError]()
///   [FieldError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_customer_extension_settings(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerExtensionSettingsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerExtensionSettingsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerExtensionSettingService/MutateCustomerExtensionSettings");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerExtensionSettingService", "MutateCustomerExtensionSettings"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerNegativeCriterionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerNegativeCriterionOperation {
#[prost(oneof = "customer_negative_criterion_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customer_negative_criterion_operation::Operation>,
}
/// Nested message and enum types in `CustomerNegativeCriterionOperation`.
pub mod customer_negative_criterion_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerNegativeCriterion),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerNegativeCriteriaResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer_negative_criterion: ::core::option::Option<super::resources::CustomerNegativeCriterion>,
}
/// Generated client implementations.
pub mod customer_negative_criterion_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer negative criteria.
#[derive(Debug, Clone)]
pub struct CustomerNegativeCriterionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerNegativeCriterionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerNegativeCriterionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerNegativeCriterionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or removes criteria. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_customer_negative_criteria(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerNegativeCriteriaRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerNegativeCriteriaResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerNegativeCriterionService/MutateCustomerNegativeCriteria");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerNegativeCriterionService", "MutateCustomerNegativeCriteria"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomizerAttributesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomizerAttributeOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customizer_attribute_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customizer_attribute_operation::Operation>,
}
/// Nested message and enum types in `CustomizerAttributeOperation`.
pub mod customizer_attribute_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomizerAttribute),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomizerAttributesResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCustomizerAttributeResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomizerAttributeResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customizer_attribute: ::core::option::Option<super::resources::CustomizerAttribute>,
}
/// Generated client implementations.
pub mod customizer_attribute_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customizer attribute
#[derive(Debug, Clone)]
pub struct CustomizerAttributeServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomizerAttributeServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomizerAttributeServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomizerAttributeServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes customizer attributes. Operation statuses are
/// returned.
pub async fn mutate_customizer_attributes(&mut self, request: impl tonic::IntoRequest<super::MutateCustomizerAttributesRequest>) -> std::result::Result<tonic::Response<super::MutateCustomizerAttributesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomizerAttributeService/MutateCustomizerAttributes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomizerAttributeService", "MutateCustomizerAttributes"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<FeedItemOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "feed_item_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<feed_item_operation::Operation>,
}
/// Nested message and enum types in `FeedItemOperation`.
pub mod feed_item_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::FeedItem),
#[prost(message, tag = "2")]
Update(super::super::resources::FeedItem),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateFeedItemResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feed_item: ::core::option::Option<super::resources::FeedItem>,
}
/// Generated client implementations.
pub mod feed_item_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage feed items.
#[derive(Debug, Clone)]
pub struct FeedItemServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeedItemServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeedItemServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeedItemServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes feed items. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FeedItemError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MutateError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
pub async fn mutate_feed_items(&mut self, request: impl tonic::IntoRequest<super::MutateFeedItemsRequest>) -> std::result::Result<tonic::Response<super::MutateFeedItemsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.FeedItemService/MutateFeedItems");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.FeedItemService", "MutateFeedItems"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<FeedItemSetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemSetOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "feed_item_set_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<feed_item_set_operation::Operation>,
}
/// Nested message and enum types in `FeedItemSetOperation`.
pub mod feed_item_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::FeedItemSet),
#[prost(message, tag = "2")]
Update(super::super::resources::FeedItemSet),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateFeedItemSetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod feed_item_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage feed Item Set
#[derive(Debug, Clone)]
pub struct FeedItemSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeedItemSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeedItemSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeedItemSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates or removes feed item sets. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_feed_item_sets(&mut self, request: impl tonic::IntoRequest<super::MutateFeedItemSetsRequest>) -> std::result::Result<tonic::Response<super::MutateFeedItemSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.FeedItemSetService/MutateFeedItemSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.FeedItemSetService", "MutateFeedItemSets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<FeedItemTargetOperation>,
#[prost(bool, tag = "4")]
pub partial_failure: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemTargetOperation {
#[prost(oneof = "feed_item_target_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<feed_item_target_operation::Operation>,
}
/// Nested message and enum types in `FeedItemTargetOperation`.
pub mod feed_item_target_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::FeedItemTarget),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateFeedItemTargetResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feed_item_target: ::core::option::Option<super::resources::FeedItemTarget>,
}
/// Generated client implementations.
pub mod feed_item_target_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage feed item targets.
#[derive(Debug, Clone)]
pub struct FeedItemTargetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeedItemTargetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeedItemTargetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeedItemTargetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or removes feed item targets. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CriterionError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FeedItemTargetError]()
///   [FieldError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [MutateError]()
///   [NotEmptyError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_feed_item_targets(&mut self, request: impl tonic::IntoRequest<super::MutateFeedItemTargetsRequest>) -> std::result::Result<tonic::Response<super::MutateFeedItemTargetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.FeedItemTargetService/MutateFeedItemTargets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.FeedItemTargetService", "MutateFeedItemTargets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<FeedOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "feed_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<feed_operation::Operation>,
}
/// Nested message and enum types in `FeedOperation`.
pub mod feed_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::Feed),
#[prost(message, tag = "2")]
Update(super::super::resources::Feed),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateFeedResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feed: ::core::option::Option<super::resources::Feed>,
}
/// Generated client implementations.
pub mod feed_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage feeds.
#[derive(Debug, Clone)]
pub struct FeedServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeedServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeedServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeedServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes feeds. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FeedError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [ListOperationError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_feeds(&mut self, request: impl tonic::IntoRequest<super::MutateFeedsRequest>) -> std::result::Result<tonic::Response<super::MutateFeedsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.FeedService/MutateFeeds");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.FeedService", "MutateFeeds"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupKeywordsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<KeywordPlanAdGroupKeywordOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupKeywordOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "keyword_plan_ad_group_keyword_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<keyword_plan_ad_group_keyword_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanAdGroupKeywordOperation`.
pub mod keyword_plan_ad_group_keyword_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::KeywordPlanAdGroupKeyword),
#[prost(message, tag = "2")]
Update(super::super::resources::KeywordPlanAdGroupKeyword),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupKeywordsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanAdGroupKeywordResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupKeywordResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod keyword_plan_ad_group_keyword_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage Keyword Plan ad group keywords. KeywordPlanAdGroup is
/// required to add ad group keywords. Positive and negative keywords are
/// supported. A maximum of 10,000 positive keywords are allowed per keyword
/// plan. A maximum of 1,000 negative keywords are allower per keyword plan. This
/// includes campaign negative keywords and ad group negative keywords.
#[derive(Debug, Clone)]
pub struct KeywordPlanAdGroupKeywordServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> KeywordPlanAdGroupKeywordServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> KeywordPlanAdGroupKeywordServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
KeywordPlanAdGroupKeywordServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes Keyword Plan ad group keywords. Operation
/// statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [KeywordPlanAdGroupKeywordError]()
///   [KeywordPlanError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
pub async fn mutate_keyword_plan_ad_group_keywords(&mut self, request: impl tonic::IntoRequest<super::MutateKeywordPlanAdGroupKeywordsRequest>) -> std::result::Result<tonic::Response<super::MutateKeywordPlanAdGroupKeywordsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanAdGroupKeywordService/MutateKeywordPlanAdGroupKeywords");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanAdGroupKeywordService", "MutateKeywordPlanAdGroupKeywords"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<KeywordPlanAdGroupOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "keyword_plan_ad_group_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<keyword_plan_ad_group_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanAdGroupOperation`.
pub mod keyword_plan_ad_group_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::KeywordPlanAdGroup),
#[prost(message, tag = "2")]
Update(super::super::resources::KeywordPlanAdGroup),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanAdGroupResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod keyword_plan_ad_group_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage Keyword Plan ad groups.
#[derive(Debug, Clone)]
pub struct KeywordPlanAdGroupServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> KeywordPlanAdGroupServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> KeywordPlanAdGroupServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
KeywordPlanAdGroupServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes Keyword Plan ad groups. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [KeywordPlanAdGroupError]()
///   [KeywordPlanError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [QuotaError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
pub async fn mutate_keyword_plan_ad_groups(&mut self, request: impl tonic::IntoRequest<super::MutateKeywordPlanAdGroupsRequest>) -> std::result::Result<tonic::Response<super::MutateKeywordPlanAdGroupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanAdGroupService/MutateKeywordPlanAdGroups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanAdGroupService", "MutateKeywordPlanAdGroups"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignKeywordsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<KeywordPlanCampaignKeywordOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignKeywordOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "keyword_plan_campaign_keyword_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<keyword_plan_campaign_keyword_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanCampaignKeywordOperation`.
pub mod keyword_plan_campaign_keyword_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::KeywordPlanCampaignKeyword),
#[prost(message, tag = "2")]
Update(super::super::resources::KeywordPlanCampaignKeyword),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignKeywordsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanCampaignKeywordResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignKeywordResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod keyword_plan_campaign_keyword_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage Keyword Plan campaign keywords. KeywordPlanCampaign is
/// required to add the campaign keywords. Only negative keywords are supported.
/// A maximum of 1000 negative keywords are allowed per plan. This includes both
/// campaign negative keywords and ad group negative keywords.
#[derive(Debug, Clone)]
pub struct KeywordPlanCampaignKeywordServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> KeywordPlanCampaignKeywordServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> KeywordPlanCampaignKeywordServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
KeywordPlanCampaignKeywordServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes Keyword Plan campaign keywords. Operation
/// statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [KeywordPlanAdGroupKeywordError]()
///   [KeywordPlanCampaignKeywordError]()
///   [QuotaError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
pub async fn mutate_keyword_plan_campaign_keywords(&mut self, request: impl tonic::IntoRequest<super::MutateKeywordPlanCampaignKeywordsRequest>) -> std::result::Result<tonic::Response<super::MutateKeywordPlanCampaignKeywordsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanCampaignKeywordService/MutateKeywordPlanCampaignKeywords");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanCampaignKeywordService", "MutateKeywordPlanCampaignKeywords"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<KeywordPlanCampaignOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "keyword_plan_campaign_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<keyword_plan_campaign_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanCampaignOperation`.
pub mod keyword_plan_campaign_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::KeywordPlanCampaign),
#[prost(message, tag = "2")]
Update(super::super::resources::KeywordPlanCampaign),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanCampaignResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod keyword_plan_campaign_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage Keyword Plan campaigns.
#[derive(Debug, Clone)]
pub struct KeywordPlanCampaignServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> KeywordPlanCampaignServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> KeywordPlanCampaignServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
KeywordPlanCampaignServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes Keyword Plan campaigns. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [KeywordPlanCampaignError]()
///   [KeywordPlanError]()
///   [ListOperationError]()
///   [MutateError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
pub async fn mutate_keyword_plan_campaigns(&mut self, request: impl tonic::IntoRequest<super::MutateKeywordPlanCampaignsRequest>) -> std::result::Result<tonic::Response<super::MutateKeywordPlanCampaignsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanCampaignService/MutateKeywordPlanCampaigns");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanCampaignService", "MutateKeywordPlanCampaigns"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<KeywordPlanOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "keyword_plan_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<keyword_plan_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanOperation`.
pub mod keyword_plan_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::KeywordPlan),
#[prost(message, tag = "2")]
Update(super::super::resources::KeywordPlan),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateKeywordPlansResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod keyword_plan_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage keyword plans.
#[derive(Debug, Clone)]
pub struct KeywordPlanServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> KeywordPlanServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> KeywordPlanServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
KeywordPlanServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes keyword plans. Operation statuses are
/// returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [KeywordPlanError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [QuotaError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [StringLengthError]()
pub async fn mutate_keyword_plans(&mut self, request: impl tonic::IntoRequest<super::MutateKeywordPlansRequest>) -> std::result::Result<tonic::Response<super::MutateKeywordPlansResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.KeywordPlanService/MutateKeywordPlans");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.KeywordPlanService", "MutateKeywordPlans"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<LabelOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "label_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<label_operation::Operation>,
}
/// Nested message and enum types in `LabelOperation`.
pub mod label_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::Label),
#[prost(message, tag = "2")]
Update(super::super::resources::Label),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateLabelResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub label: ::core::option::Option<super::resources::Label>,
}
/// Generated client implementations.
pub mod label_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage labels.
#[derive(Debug, Clone)]
pub struct LabelServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> LabelServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> LabelServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
LabelServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes labels. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [DateError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [IdError]()
///   [InternalError]()
///   [LabelError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotEmptyError]()
///   [NullError]()
///   [OperatorError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
pub async fn mutate_labels(&mut self, request: impl tonic::IntoRequest<super::MutateLabelsRequest>) -> std::result::Result<tonic::Response<super::MutateLabelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.LabelService/MutateLabels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.LabelService", "MutateLabels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRecommendationSubscriptionRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<RecommendationSubscriptionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendationSubscriptionOperation {
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "recommendation_subscription_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<recommendation_subscription_operation::Operation>,
}
/// Nested message and enum types in `RecommendationSubscriptionOperation`.
pub mod recommendation_subscription_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::RecommendationSubscription),
#[prost(message, tag = "2")]
Update(super::super::resources::RecommendationSubscription),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRecommendationSubscriptionResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateRecommendationSubscriptionResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRecommendationSubscriptionResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub recommendation_subscription: ::core::option::Option<super::resources::RecommendationSubscription>,
}
/// Generated client implementations.
pub mod recommendation_subscription_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage recommendation subscriptions.
#[derive(Debug, Clone)]
pub struct RecommendationSubscriptionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> RecommendationSubscriptionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> RecommendationSubscriptionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
RecommendationSubscriptionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Mutates given subscription with corresponding apply parameters.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RecommendationError]()
///   [RequestError]()
///   [UrlFieldError]()
pub async fn mutate_recommendation_subscription(&mut self, request: impl tonic::IntoRequest<super::MutateRecommendationSubscriptionRequest>) -> std::result::Result<tonic::Response<super::MutateRecommendationSubscriptionResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.RecommendationSubscriptionService/MutateRecommendationSubscription");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.RecommendationSubscriptionService", "MutateRecommendationSubscription"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<RemarketingActionOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemarketingActionOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "remarketing_action_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<remarketing_action_operation::Operation>,
}
/// Nested message and enum types in `RemarketingActionOperation`.
pub mod remarketing_action_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::RemarketingAction),
#[prost(message, tag = "2")]
Update(super::super::resources::RemarketingAction),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateRemarketingActionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod remarketing_action_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage remarketing actions.
#[derive(Debug, Clone)]
pub struct RemarketingActionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> RemarketingActionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> RemarketingActionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
RemarketingActionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or updates remarketing actions. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ConversionActionError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_remarketing_actions(&mut self, request: impl tonic::IntoRequest<super::MutateRemarketingActionsRequest>) -> std::result::Result<tonic::Response<super::MutateRemarketingActionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.RemarketingActionService/MutateRemarketingActions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.RemarketingActionService", "MutateRemarketingActions"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSmartCampaignStatusRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignNotEligibleDetails {
#[prost(enumeration = "super::enums::smart_campaign_not_eligible_reason_enum::SmartCampaignNotEligibleReason", optional, tag = "1")]
pub not_eligible_reason: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignEligibleDetails {
#[prost(string, optional, tag = "1")]
pub last_impression_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "2")]
pub end_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignPausedDetails {
#[prost(string, optional, tag = "1")]
pub paused_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignRemovedDetails {
#[prost(string, optional, tag = "1")]
pub removed_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignEndedDetails {
#[prost(string, optional, tag = "1")]
pub end_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSmartCampaignStatusResponse {
#[prost(enumeration = "super::enums::smart_campaign_status_enum::SmartCampaignStatus", tag = "1")]
pub smart_campaign_status: i32,
#[prost(oneof = "get_smart_campaign_status_response::SmartCampaignStatusDetails", tags = "2, 3, 4, 5, 6")]
pub smart_campaign_status_details: ::core::option::Option<get_smart_campaign_status_response::SmartCampaignStatusDetails>,
}
/// Nested message and enum types in `GetSmartCampaignStatusResponse`.
pub mod get_smart_campaign_status_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum SmartCampaignStatusDetails {
#[prost(message, tag = "2")]
NotEligibleDetails(super::SmartCampaignNotEligibleDetails),
#[prost(message, tag = "3")]
EligibleDetails(super::SmartCampaignEligibleDetails),
#[prost(message, tag = "4")]
PausedDetails(super::SmartCampaignPausedDetails),
#[prost(message, tag = "5")]
RemovedDetails(super::SmartCampaignRemovedDetails),
#[prost(message, tag = "6")]
EndedDetails(super::SmartCampaignEndedDetails),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSmartCampaignSettingsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<SmartCampaignSettingOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignSettingOperation {
#[prost(message, optional, tag = "1")]
pub update: ::core::option::Option<super::resources::SmartCampaignSetting>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSmartCampaignSettingsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateSmartCampaignSettingResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSmartCampaignSettingResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub smart_campaign_setting: ::core::option::Option<super::resources::SmartCampaignSetting>,
}
/// Generated client implementations.
pub mod smart_campaign_setting_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage Smart campaign settings.
#[derive(Debug, Clone)]
pub struct SmartCampaignSettingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SmartCampaignSettingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SmartCampaignSettingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SmartCampaignSettingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns the status of the requested Smart campaign.
pub async fn get_smart_campaign_status(&mut self, request: impl tonic::IntoRequest<super::GetSmartCampaignStatusRequest>) -> std::result::Result<tonic::Response<super::GetSmartCampaignStatusResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.SmartCampaignSettingService/GetSmartCampaignStatus");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.SmartCampaignSettingService", "GetSmartCampaignStatus"));
self.inner.unary(req, path, codec).await
}
/// Updates Smart campaign settings for campaigns.
pub async fn mutate_smart_campaign_settings(&mut self, request: impl tonic::IntoRequest<super::MutateSmartCampaignSettingsRequest>) -> std::result::Result<tonic::Response<super::MutateSmartCampaignSettingsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.SmartCampaignSettingService/MutateSmartCampaignSettings");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.SmartCampaignSettingService", "MutateSmartCampaignSettings"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<UserListOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserListOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "user_list_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<user_list_operation::Operation>,
}
/// Nested message and enum types in `UserListOperation`.
pub mod user_list_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::UserList),
#[prost(message, tag = "2")]
Update(super::super::resources::UserList),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateUserListResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod user_list_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage user lists.
#[derive(Debug, Clone)]
pub struct UserListServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> UserListServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> UserListServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
UserListServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or updates user lists. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CollectionSizeError]()
///   [DatabaseError]()
///   [DistinctError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NotAllowlistedError]()
///   [NotEmptyError]()
///   [OperationAccessDeniedError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UserListError]()
pub async fn mutate_user_lists(&mut self, request: impl tonic::IntoRequest<super::MutateUserListsRequest>) -> std::result::Result<tonic::Response<super::MutateUserListsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.UserListService/MutateUserLists");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.UserListService", "MutateUserLists"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "4")]
pub page_size: i32,
#[prost(bool, tag = "5")]
pub validate_only: bool,
#[prost(bool, tag = "7")]
pub return_total_results_count: bool,
#[prost(enumeration = "super::enums::summary_row_setting_enum::SummaryRowSetting", tag = "8")]
pub summary_row_setting: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<GoogleAdsRow>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub total_results_count: i64,
#[prost(message, optional, tag = "5")]
pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "6")]
pub summary_row: ::core::option::Option<GoogleAdsRow>,
#[prost(int64, tag = "8")]
pub query_resource_consumption: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsStreamRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::summary_row_setting_enum::SummaryRowSetting", tag = "3")]
pub summary_row_setting: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsStreamResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<GoogleAdsRow>,
#[prost(message, optional, tag = "2")]
pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "3")]
pub summary_row: ::core::option::Option<GoogleAdsRow>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
#[prost(int64, tag = "6")]
pub query_resource_consumption: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsRow {
#[prost(message, optional, tag = "42")]
pub account_budget: ::core::option::Option<super::resources::AccountBudget>,
#[prost(message, optional, tag = "43")]
pub account_budget_proposal: ::core::option::Option<super::resources::AccountBudgetProposal>,
#[prost(message, optional, tag = "143")]
pub account_link: ::core::option::Option<super::resources::AccountLink>,
#[prost(message, optional, tag = "227")]
pub ad: ::core::option::Option<super::resources::Ad>,
#[prost(message, optional, tag = "3")]
pub ad_group: ::core::option::Option<super::resources::AdGroup>,
#[prost(message, optional, tag = "16")]
pub ad_group_ad: ::core::option::Option<super::resources::AdGroupAd>,
#[prost(message, optional, tag = "193")]
pub ad_group_ad_asset_combination_view: ::core::option::Option<super::resources::AdGroupAdAssetCombinationView>,
#[prost(message, optional, tag = "131")]
pub ad_group_ad_asset_view: ::core::option::Option<super::resources::AdGroupAdAssetView>,
#[prost(message, optional, tag = "120")]
pub ad_group_ad_label: ::core::option::Option<super::resources::AdGroupAdLabel>,
#[prost(message, optional, tag = "154")]
pub ad_group_asset: ::core::option::Option<super::resources::AdGroupAsset>,
#[prost(message, optional, tag = "196")]
pub ad_group_asset_set: ::core::option::Option<super::resources::AdGroupAssetSet>,
#[prost(message, optional, tag = "57")]
pub ad_group_audience_view: ::core::option::Option<super::resources::AdGroupAudienceView>,
#[prost(message, optional, tag = "24")]
pub ad_group_bid_modifier: ::core::option::Option<super::resources::AdGroupBidModifier>,
#[prost(message, optional, tag = "17")]
pub ad_group_criterion: ::core::option::Option<super::resources::AdGroupCriterion>,
#[prost(message, optional, tag = "187")]
pub ad_group_criterion_customizer: ::core::option::Option<super::resources::AdGroupCriterionCustomizer>,
#[prost(message, optional, tag = "121")]
pub ad_group_criterion_label: ::core::option::Option<super::resources::AdGroupCriterionLabel>,
#[prost(message, optional, tag = "110")]
pub ad_group_criterion_simulation: ::core::option::Option<super::resources::AdGroupCriterionSimulation>,
#[prost(message, optional, tag = "185")]
pub ad_group_customizer: ::core::option::Option<super::resources::AdGroupCustomizer>,
#[prost(message, optional, tag = "112")]
pub ad_group_extension_setting: ::core::option::Option<super::resources::AdGroupExtensionSetting>,
#[prost(message, optional, tag = "67")]
pub ad_group_feed: ::core::option::Option<super::resources::AdGroupFeed>,
#[prost(message, optional, tag = "115")]
pub ad_group_label: ::core::option::Option<super::resources::AdGroupLabel>,
#[prost(message, optional, tag = "107")]
pub ad_group_simulation: ::core::option::Option<super::resources::AdGroupSimulation>,
#[prost(message, optional, tag = "130")]
pub ad_parameter: ::core::option::Option<super::resources::AdParameter>,
#[prost(message, optional, tag = "48")]
pub age_range_view: ::core::option::Option<super::resources::AgeRangeView>,
#[prost(message, optional, tag = "89")]
pub ad_schedule_view: ::core::option::Option<super::resources::AdScheduleView>,
#[prost(message, optional, tag = "91")]
pub domain_category: ::core::option::Option<super::resources::DomainCategory>,
#[prost(message, optional, tag = "105")]
pub asset: ::core::option::Option<super::resources::Asset>,
#[prost(message, optional, tag = "168")]
pub asset_field_type_view: ::core::option::Option<super::resources::AssetFieldTypeView>,
#[prost(message, optional, tag = "222")]
pub channel_aggregate_asset_view: ::core::option::Option<super::resources::ChannelAggregateAssetView>,
#[prost(message, optional, tag = "224")]
pub campaign_aggregate_asset_view: ::core::option::Option<super::resources::CampaignAggregateAssetView>,
#[prost(message, optional, tag = "173")]
pub asset_group_asset: ::core::option::Option<super::resources::AssetGroupAsset>,
#[prost(message, optional, tag = "191")]
pub asset_group_signal: ::core::option::Option<super::resources::AssetGroupSignal>,
#[prost(message, optional, tag = "182")]
pub asset_group_listing_group_filter: ::core::option::Option<super::resources::AssetGroupListingGroupFilter>,
#[prost(message, optional, tag = "189")]
pub asset_group_product_group_view: ::core::option::Option<super::resources::AssetGroupProductGroupView>,
#[prost(message, optional, tag = "199")]
pub asset_group_top_combination_view: ::core::option::Option<super::resources::AssetGroupTopCombinationView>,
#[prost(message, optional, tag = "172")]
pub asset_group: ::core::option::Option<super::resources::AssetGroup>,
#[prost(message, optional, tag = "180")]
pub asset_set_asset: ::core::option::Option<super::resources::AssetSetAsset>,
#[prost(message, optional, tag = "179")]
pub asset_set: ::core::option::Option<super::resources::AssetSet>,
#[prost(message, optional, tag = "197")]
pub asset_set_type_view: ::core::option::Option<super::resources::AssetSetTypeView>,
#[prost(message, optional, tag = "139")]
pub batch_job: ::core::option::Option<super::resources::BatchJob>,
#[prost(message, optional, tag = "159")]
pub bidding_data_exclusion: ::core::option::Option<super::resources::BiddingDataExclusion>,
#[prost(message, optional, tag = "160")]
pub bidding_seasonality_adjustment: ::core::option::Option<super::resources::BiddingSeasonalityAdjustment>,
#[prost(message, optional, tag = "18")]
pub bidding_strategy: ::core::option::Option<super::resources::BiddingStrategy>,
#[prost(message, optional, tag = "158")]
pub bidding_strategy_simulation: ::core::option::Option<super::resources::BiddingStrategySimulation>,
#[prost(message, optional, tag = "41")]
pub billing_setup: ::core::option::Option<super::resources::BillingSetup>,
#[prost(message, optional, tag = "152")]
pub call_view: ::core::option::Option<super::resources::CallView>,
#[prost(message, optional, tag = "19")]
pub campaign_budget: ::core::option::Option<super::resources::CampaignBudget>,
#[prost(message, optional, tag = "2")]
pub campaign: ::core::option::Option<super::resources::Campaign>,
#[prost(message, optional, tag = "142")]
pub campaign_asset: ::core::option::Option<super::resources::CampaignAsset>,
#[prost(message, optional, tag = "181")]
pub campaign_asset_set: ::core::option::Option<super::resources::CampaignAssetSet>,
#[prost(message, optional, tag = "69")]
pub campaign_audience_view: ::core::option::Option<super::resources::CampaignAudienceView>,
#[prost(message, optional, tag = "26")]
pub campaign_bid_modifier: ::core::option::Option<super::resources::CampaignBidModifier>,
#[prost(message, optional, tag = "175")]
pub campaign_conversion_goal: ::core::option::Option<super::resources::CampaignConversionGoal>,
#[prost(message, optional, tag = "20")]
pub campaign_criterion: ::core::option::Option<super::resources::CampaignCriterion>,
#[prost(message, optional, tag = "186")]
pub campaign_customizer: ::core::option::Option<super::resources::CampaignCustomizer>,
#[prost(message, optional, tag = "49")]
pub campaign_draft: ::core::option::Option<super::resources::CampaignDraft>,
#[prost(message, optional, tag = "113")]
pub campaign_extension_setting: ::core::option::Option<super::resources::CampaignExtensionSetting>,
#[prost(message, optional, tag = "63")]
pub campaign_feed: ::core::option::Option<super::resources::CampaignFeed>,
#[prost(message, optional, tag = "25")]
pub campaign_group: ::core::option::Option<super::resources::CampaignGroup>,
#[prost(message, optional, tag = "108")]
pub campaign_label: ::core::option::Option<super::resources::CampaignLabel>,
#[prost(message, optional, tag = "213")]
pub campaign_lifecycle_goal: ::core::option::Option<super::resources::CampaignLifecycleGoal>,
#[prost(message, optional, tag = "204")]
pub campaign_search_term_insight: ::core::option::Option<super::resources::CampaignSearchTermInsight>,
#[prost(message, optional, tag = "30")]
pub campaign_shared_set: ::core::option::Option<super::resources::CampaignSharedSet>,
#[prost(message, optional, tag = "157")]
pub campaign_simulation: ::core::option::Option<super::resources::CampaignSimulation>,
#[prost(message, optional, tag = "66")]
pub carrier_constant: ::core::option::Option<super::resources::CarrierConstant>,
#[prost(message, optional, tag = "145")]
pub change_event: ::core::option::Option<super::resources::ChangeEvent>,
#[prost(message, optional, tag = "37")]
pub change_status: ::core::option::Option<super::resources::ChangeStatus>,
#[prost(message, optional, tag = "148")]
pub combined_audience: ::core::option::Option<super::resources::CombinedAudience>,
#[prost(message, optional, tag = "190")]
pub audience: ::core::option::Option<super::resources::Audience>,
#[prost(message, optional, tag = "103")]
pub conversion_action: ::core::option::Option<super::resources::ConversionAction>,
#[prost(message, optional, tag = "153")]
pub conversion_custom_variable: ::core::option::Option<super::resources::ConversionCustomVariable>,
#[prost(message, optional, tag = "177")]
pub conversion_goal_campaign_config: ::core::option::Option<super::resources::ConversionGoalCampaignConfig>,
#[prost(message, optional, tag = "164")]
pub conversion_value_rule: ::core::option::Option<super::resources::ConversionValueRule>,
#[prost(message, optional, tag = "165")]
pub conversion_value_rule_set: ::core::option::Option<super::resources::ConversionValueRuleSet>,
#[prost(message, optional, tag = "122")]
pub click_view: ::core::option::Option<super::resources::ClickView>,
#[prost(message, optional, tag = "134")]
pub currency_constant: ::core::option::Option<super::resources::CurrencyConstant>,
#[prost(message, optional, tag = "147")]
pub custom_audience: ::core::option::Option<super::resources::CustomAudience>,
#[prost(message, optional, tag = "176")]
pub custom_conversion_goal: ::core::option::Option<super::resources::CustomConversionGoal>,
#[prost(message, optional, tag = "104")]
pub custom_interest: ::core::option::Option<super::resources::CustomInterest>,
#[prost(message, optional, tag = "1")]
pub customer: ::core::option::Option<super::resources::Customer>,
#[prost(message, optional, tag = "155")]
pub customer_asset: ::core::option::Option<super::resources::CustomerAsset>,
#[prost(message, optional, tag = "195")]
pub customer_asset_set: ::core::option::Option<super::resources::CustomerAssetSet>,
#[prost(message, optional, tag = "169")]
pub accessible_bidding_strategy: ::core::option::Option<super::resources::AccessibleBiddingStrategy>,
#[prost(message, optional, tag = "184")]
pub customer_customizer: ::core::option::Option<super::resources::CustomerCustomizer>,
#[prost(message, optional, tag = "61")]
pub customer_manager_link: ::core::option::Option<super::resources::CustomerManagerLink>,
#[prost(message, optional, tag = "62")]
pub customer_client_link: ::core::option::Option<super::resources::CustomerClientLink>,
#[prost(message, optional, tag = "70")]
pub customer_client: ::core::option::Option<super::resources::CustomerClient>,
#[prost(message, optional, tag = "174")]
pub customer_conversion_goal: ::core::option::Option<super::resources::CustomerConversionGoal>,
#[prost(message, optional, tag = "114")]
pub customer_extension_setting: ::core::option::Option<super::resources::CustomerExtensionSetting>,
#[prost(message, optional, tag = "64")]
pub customer_feed: ::core::option::Option<super::resources::CustomerFeed>,
#[prost(message, optional, tag = "124")]
pub customer_label: ::core::option::Option<super::resources::CustomerLabel>,
#[prost(message, optional, tag = "212")]
pub customer_lifecycle_goal: ::core::option::Option<super::resources::CustomerLifecycleGoal>,
#[prost(message, optional, tag = "88")]
pub customer_negative_criterion: ::core::option::Option<super::resources::CustomerNegativeCriterion>,
#[prost(message, optional, tag = "205")]
pub customer_search_term_insight: ::core::option::Option<super::resources::CustomerSearchTermInsight>,
#[prost(message, optional, tag = "146")]
pub customer_user_access: ::core::option::Option<super::resources::CustomerUserAccess>,
#[prost(message, optional, tag = "150")]
pub customer_user_access_invitation: ::core::option::Option<super::resources::CustomerUserAccessInvitation>,
#[prost(message, optional, tag = "178")]
pub customizer_attribute: ::core::option::Option<super::resources::CustomizerAttribute>,
#[prost(message, optional, tag = "118")]
pub detail_placement_view: ::core::option::Option<super::resources::DetailPlacementView>,
#[prost(message, optional, tag = "166")]
pub detailed_demographic: ::core::option::Option<super::resources::DetailedDemographic>,
#[prost(message, optional, tag = "47")]
pub display_keyword_view: ::core::option::Option<super::resources::DisplayKeywordView>,
#[prost(message, optional, tag = "132")]
pub distance_view: ::core::option::Option<super::resources::DistanceView>,
#[prost(message, optional, tag = "106")]
pub dynamic_search_ads_search_term_view: ::core::option::Option<super::resources::DynamicSearchAdsSearchTermView>,
#[prost(message, optional, tag = "128")]
pub expanded_landing_page_view: ::core::option::Option<super::resources::ExpandedLandingPageView>,
#[prost(message, optional, tag = "85")]
pub extension_feed_item: ::core::option::Option<super::resources::ExtensionFeedItem>,
#[prost(message, optional, tag = "46")]
pub feed: ::core::option::Option<super::resources::Feed>,
#[prost(message, optional, tag = "50")]
pub feed_item: ::core::option::Option<super::resources::FeedItem>,
#[prost(message, optional, tag = "149")]
pub feed_item_set: ::core::option::Option<super::resources::FeedItemSet>,
#[prost(message, optional, tag = "151")]
pub feed_item_set_link: ::core::option::Option<super::resources::FeedItemSetLink>,
#[prost(message, optional, tag = "116")]
pub feed_item_target: ::core::option::Option<super::resources::FeedItemTarget>,
#[prost(message, optional, tag = "58")]
pub feed_mapping: ::core::option::Option<super::resources::FeedMapping>,
#[prost(message, optional, tag = "97")]
pub feed_placeholder_view: ::core::option::Option<super::resources::FeedPlaceholderView>,
#[prost(message, optional, tag = "40")]
pub gender_view: ::core::option::Option<super::resources::GenderView>,
#[prost(message, optional, tag = "23")]
pub geo_target_constant: ::core::option::Option<super::resources::GeoTargetConstant>,
#[prost(message, optional, tag = "125")]
pub geographic_view: ::core::option::Option<super::resources::GeographicView>,
#[prost(message, optional, tag = "119")]
pub group_placement_view: ::core::option::Option<super::resources::GroupPlacementView>,
#[prost(message, optional, tag = "51")]
pub hotel_group_view: ::core::option::Option<super::resources::HotelGroupView>,
#[prost(message, optional, tag = "71")]
pub hotel_performance_view: ::core::option::Option<super::resources::HotelPerformanceView>,
#[prost(message, optional, tag = "188")]
pub hotel_reconciliation: ::core::option::Option<super::resources::HotelReconciliation>,
#[prost(message, optional, tag = "138")]
pub income_range_view: ::core::option::Option<super::resources::IncomeRangeView>,
#[prost(message, optional, tag = "21")]
pub keyword_view: ::core::option::Option<super::resources::KeywordView>,
#[prost(message, optional, tag = "32")]
pub keyword_plan: ::core::option::Option<super::resources::KeywordPlan>,
#[prost(message, optional, tag = "33")]
pub keyword_plan_campaign: ::core::option::Option<super::resources::KeywordPlanCampaign>,
#[prost(message, optional, tag = "140")]
pub keyword_plan_campaign_keyword: ::core::option::Option<super::resources::KeywordPlanCampaignKeyword>,
#[prost(message, optional, tag = "35")]
pub keyword_plan_ad_group: ::core::option::Option<super::resources::KeywordPlanAdGroup>,
#[prost(message, optional, tag = "141")]
pub keyword_plan_ad_group_keyword: ::core::option::Option<super::resources::KeywordPlanAdGroupKeyword>,
#[prost(message, optional, tag = "163")]
pub keyword_theme_constant: ::core::option::Option<super::resources::KeywordThemeConstant>,
#[prost(message, optional, tag = "52")]
pub label: ::core::option::Option<super::resources::Label>,
#[prost(message, optional, tag = "126")]
pub landing_page_view: ::core::option::Option<super::resources::LandingPageView>,
#[prost(message, optional, tag = "55")]
pub language_constant: ::core::option::Option<super::resources::LanguageConstant>,
#[prost(message, optional, tag = "123")]
pub location_view: ::core::option::Option<super::resources::LocationView>,
#[prost(message, optional, tag = "53")]
pub managed_placement_view: ::core::option::Option<super::resources::ManagedPlacementView>,
#[prost(message, optional, tag = "90")]
pub media_file: ::core::option::Option<super::resources::MediaFile>,
#[prost(message, optional, tag = "223")]
pub local_services_employee: ::core::option::Option<super::resources::LocalServicesEmployee>,
#[prost(message, optional, tag = "211")]
pub local_services_verification_artifact: ::core::option::Option<super::resources::LocalServicesVerificationArtifact>,
#[prost(message, optional, tag = "87")]
pub mobile_app_category_constant: ::core::option::Option<super::resources::MobileAppCategoryConstant>,
#[prost(message, optional, tag = "98")]
pub mobile_device_constant: ::core::option::Option<super::resources::MobileDeviceConstant>,
#[prost(message, optional, tag = "216")]
pub offline_conversion_upload_client_summary: ::core::option::Option<super::resources::OfflineConversionUploadClientSummary>,
#[prost(message, optional, tag = "137")]
pub offline_user_data_job: ::core::option::Option<super::resources::OfflineUserDataJob>,
#[prost(message, optional, tag = "86")]
pub operating_system_version_constant: ::core::option::Option<super::resources::OperatingSystemVersionConstant>,
#[prost(message, optional, tag = "129")]
pub paid_organic_search_term_view: ::core::option::Option<super::resources::PaidOrganicSearchTermView>,
#[prost(message, optional, tag = "202")]
pub qualifying_question: ::core::option::Option<super::resources::QualifyingQuestion>,
#[prost(message, optional, tag = "45")]
pub parental_status_view: ::core::option::Option<super::resources::ParentalStatusView>,
#[prost(message, optional, tag = "198")]
pub per_store_view: ::core::option::Option<super::resources::PerStoreView>,
#[prost(message, optional, tag = "208")]
pub product_category_constant: ::core::option::Option<super::resources::ProductCategoryConstant>,
#[prost(message, optional, tag = "54")]
pub product_group_view: ::core::option::Option<super::resources::ProductGroupView>,
#[prost(message, optional, tag = "194")]
pub product_link: ::core::option::Option<super::resources::ProductLink>,
#[prost(message, optional, tag = "209")]
pub product_link_invitation: ::core::option::Option<super::resources::ProductLinkInvitation>,
#[prost(message, optional, tag = "22")]
pub recommendation: ::core::option::Option<super::resources::Recommendation>,
#[prost(message, optional, tag = "220")]
pub recommendation_subscription: ::core::option::Option<super::resources::RecommendationSubscription>,
#[prost(message, optional, tag = "68")]
pub search_term_view: ::core::option::Option<super::resources::SearchTermView>,
#[prost(message, optional, tag = "29")]
pub shared_criterion: ::core::option::Option<super::resources::SharedCriterion>,
#[prost(message, optional, tag = "27")]
pub shared_set: ::core::option::Option<super::resources::SharedSet>,
#[prost(message, optional, tag = "167")]
pub smart_campaign_setting: ::core::option::Option<super::resources::SmartCampaignSetting>,
#[prost(message, optional, tag = "117")]
pub shopping_performance_view: ::core::option::Option<super::resources::ShoppingPerformanceView>,
#[prost(message, optional, tag = "226")]
pub shopping_product: ::core::option::Option<super::resources::ShoppingProduct>,
#[prost(message, optional, tag = "170")]
pub smart_campaign_search_term_view: ::core::option::Option<super::resources::SmartCampaignSearchTermView>,
#[prost(message, optional, tag = "144")]
pub third_party_app_analytics_link: ::core::option::Option<super::resources::ThirdPartyAppAnalyticsLink>,
#[prost(message, optional, tag = "44")]
pub topic_view: ::core::option::Option<super::resources::TopicView>,
#[prost(message, optional, tag = "201")]
pub travel_activity_group_view: ::core::option::Option<super::resources::TravelActivityGroupView>,
#[prost(message, optional, tag = "200")]
pub travel_activity_performance_view: ::core::option::Option<super::resources::TravelActivityPerformanceView>,
#[prost(message, optional, tag = "133")]
pub experiment: ::core::option::Option<super::resources::Experiment>,
#[prost(message, optional, tag = "183")]
pub experiment_arm: ::core::option::Option<super::resources::ExperimentArm>,
#[prost(message, optional, tag = "59")]
pub user_interest: ::core::option::Option<super::resources::UserInterest>,
#[prost(message, optional, tag = "161")]
pub life_event: ::core::option::Option<super::resources::LifeEvent>,
#[prost(message, optional, tag = "38")]
pub user_list: ::core::option::Option<super::resources::UserList>,
#[prost(message, optional, tag = "225")]
pub user_list_customer_type: ::core::option::Option<super::resources::UserListCustomerType>,
#[prost(message, optional, tag = "135")]
pub user_location_view: ::core::option::Option<super::resources::UserLocationView>,
#[prost(message, optional, tag = "60")]
pub remarketing_action: ::core::option::Option<super::resources::RemarketingAction>,
#[prost(message, optional, tag = "31")]
pub topic_constant: ::core::option::Option<super::resources::TopicConstant>,
#[prost(message, optional, tag = "39")]
pub video: ::core::option::Option<super::resources::Video>,
#[prost(message, optional, tag = "162")]
pub webpage_view: ::core::option::Option<super::resources::WebpageView>,
#[prost(message, optional, tag = "192")]
pub lead_form_submission_data: ::core::option::Option<super::resources::LeadFormSubmissionData>,
#[prost(message, optional, tag = "210")]
pub local_services_lead: ::core::option::Option<super::resources::LocalServicesLead>,
#[prost(message, optional, tag = "214")]
pub local_services_lead_conversation: ::core::option::Option<super::resources::LocalServicesLeadConversation>,
#[prost(message, optional, tag = "217")]
pub android_privacy_shared_key_google_ad_group: ::core::option::Option<super::resources::AndroidPrivacySharedKeyGoogleAdGroup>,
#[prost(message, optional, tag = "218")]
pub android_privacy_shared_key_google_campaign: ::core::option::Option<super::resources::AndroidPrivacySharedKeyGoogleCampaign>,
#[prost(message, optional, tag = "219")]
pub android_privacy_shared_key_google_network_type: ::core::option::Option<super::resources::AndroidPrivacySharedKeyGoogleNetworkType>,
#[prost(message, optional, tag = "4")]
pub metrics: ::core::option::Option<super::common::Metrics>,
#[prost(message, optional, tag = "102")]
pub segments: ::core::option::Option<super::common::Segments>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateGoogleAdsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub mutate_operations: ::prost::alloc::vec::Vec<MutateOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateGoogleAdsResponse {
#[prost(message, optional, tag = "3")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "1")]
pub mutate_operation_responses: ::prost::alloc::vec::Vec<MutateOperationResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateOperation {
#[prost(oneof = "mutate_operation::Operation", tags = "17, 1, 56, 2, 77, 18, 3, 75, 19, 20, 21, 5, 49, 22, 23, 65, 78, 80, 62, 71, 72, 81, 58, 59, 6, 52, 73, 7, 8, 67, 13, 76, 24, 26, 27, 9, 28, 10, 11, 12, 55, 69, 63, 64, 68, 57, 66, 79, 30, 31, 32, 34, 35, 70, 82, 83, 36, 37, 53, 54, 38, 39, 40, 44, 50, 51, 45, 48, 41, 86, 43, 14, 15, 61, 16")]
pub operation: ::core::option::Option<mutate_operation::Operation>,
}
/// Nested message and enum types in `MutateOperation`.
pub mod mutate_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "17")]
AdGroupAdLabelOperation(super::AdGroupAdLabelOperation),
#[prost(message, tag = "1")]
AdGroupAdOperation(super::AdGroupAdOperation),
#[prost(message, tag = "56")]
AdGroupAssetOperation(super::AdGroupAssetOperation),
#[prost(message, tag = "2")]
AdGroupBidModifierOperation(super::AdGroupBidModifierOperation),
#[prost(message, tag = "77")]
AdGroupCriterionCustomizerOperation(super::AdGroupCriterionCustomizerOperation),
#[prost(message, tag = "18")]
AdGroupCriterionLabelOperation(super::AdGroupCriterionLabelOperation),
#[prost(message, tag = "3")]
AdGroupCriterionOperation(super::AdGroupCriterionOperation),
#[prost(message, tag = "75")]
AdGroupCustomizerOperation(super::AdGroupCustomizerOperation),
#[prost(message, tag = "19")]
AdGroupExtensionSettingOperation(super::AdGroupExtensionSettingOperation),
#[prost(message, tag = "20")]
AdGroupFeedOperation(super::AdGroupFeedOperation),
#[prost(message, tag = "21")]
AdGroupLabelOperation(super::AdGroupLabelOperation),
#[prost(message, tag = "5")]
AdGroupOperation(super::AdGroupOperation),
#[prost(message, tag = "49")]
AdOperation(super::AdOperation),
#[prost(message, tag = "22")]
AdParameterOperation(super::AdParameterOperation),
#[prost(message, tag = "23")]
AssetOperation(super::AssetOperation),
#[prost(message, tag = "65")]
AssetGroupAssetOperation(super::AssetGroupAssetOperation),
#[prost(message, tag = "78")]
AssetGroupListingGroupFilterOperation(super::AssetGroupListingGroupFilterOperation),
#[prost(message, tag = "80")]
AssetGroupSignalOperation(super::AssetGroupSignalOperation),
#[prost(message, tag = "62")]
AssetGroupOperation(super::AssetGroupOperation),
#[prost(message, tag = "71")]
AssetSetAssetOperation(super::AssetSetAssetOperation),
#[prost(message, tag = "72")]
AssetSetOperation(super::AssetSetOperation),
#[prost(message, tag = "81")]
AudienceOperation(super::AudienceOperation),
#[prost(message, tag = "58")]
BiddingDataExclusionOperation(super::BiddingDataExclusionOperation),
#[prost(message, tag = "59")]
BiddingSeasonalityAdjustmentOperation(super::BiddingSeasonalityAdjustmentOperation),
#[prost(message, tag = "6")]
BiddingStrategyOperation(super::BiddingStrategyOperation),
#[prost(message, tag = "52")]
CampaignAssetOperation(super::CampaignAssetOperation),
#[prost(message, tag = "73")]
CampaignAssetSetOperation(super::CampaignAssetSetOperation),
#[prost(message, tag = "7")]
CampaignBidModifierOperation(super::CampaignBidModifierOperation),
#[prost(message, tag = "8")]
CampaignBudgetOperation(super::CampaignBudgetOperation),
#[prost(message, tag = "67")]
CampaignConversionGoalOperation(super::CampaignConversionGoalOperation),
#[prost(message, tag = "13")]
CampaignCriterionOperation(super::CampaignCriterionOperation),
#[prost(message, tag = "76")]
CampaignCustomizerOperation(super::CampaignCustomizerOperation),
#[prost(message, tag = "24")]
CampaignDraftOperation(super::CampaignDraftOperation),
#[prost(message, tag = "26")]
CampaignExtensionSettingOperation(super::CampaignExtensionSettingOperation),
#[prost(message, tag = "27")]
CampaignFeedOperation(super::CampaignFeedOperation),
#[prost(message, tag = "9")]
CampaignGroupOperation(super::CampaignGroupOperation),
#[prost(message, tag = "28")]
CampaignLabelOperation(super::CampaignLabelOperation),
#[prost(message, tag = "10")]
CampaignOperation(super::CampaignOperation),
#[prost(message, tag = "11")]
CampaignSharedSetOperation(super::CampaignSharedSetOperation),
#[prost(message, tag = "12")]
ConversionActionOperation(super::ConversionActionOperation),
#[prost(message, tag = "55")]
ConversionCustomVariableOperation(super::ConversionCustomVariableOperation),
#[prost(message, tag = "69")]
ConversionGoalCampaignConfigOperation(super::ConversionGoalCampaignConfigOperation),
#[prost(message, tag = "63")]
ConversionValueRuleOperation(super::ConversionValueRuleOperation),
#[prost(message, tag = "64")]
ConversionValueRuleSetOperation(super::ConversionValueRuleSetOperation),
#[prost(message, tag = "68")]
CustomConversionGoalOperation(super::CustomConversionGoalOperation),
#[prost(message, tag = "57")]
CustomerAssetOperation(super::CustomerAssetOperation),
#[prost(message, tag = "66")]
CustomerConversionGoalOperation(super::CustomerConversionGoalOperation),
#[prost(message, tag = "79")]
CustomerCustomizerOperation(super::CustomerCustomizerOperation),
#[prost(message, tag = "30")]
CustomerExtensionSettingOperation(super::CustomerExtensionSettingOperation),
#[prost(message, tag = "31")]
CustomerFeedOperation(super::CustomerFeedOperation),
#[prost(message, tag = "32")]
CustomerLabelOperation(super::CustomerLabelOperation),
#[prost(message, tag = "34")]
CustomerNegativeCriterionOperation(super::CustomerNegativeCriterionOperation),
#[prost(message, tag = "35")]
CustomerOperation(super::CustomerOperation),
#[prost(message, tag = "70")]
CustomizerAttributeOperation(super::CustomizerAttributeOperation),
#[prost(message, tag = "82")]
ExperimentOperation(super::ExperimentOperation),
#[prost(message, tag = "83")]
ExperimentArmOperation(super::ExperimentArmOperation),
#[prost(message, tag = "36")]
ExtensionFeedItemOperation(super::ExtensionFeedItemOperation),
#[prost(message, tag = "37")]
FeedItemOperation(super::FeedItemOperation),
#[prost(message, tag = "53")]
FeedItemSetOperation(super::FeedItemSetOperation),
#[prost(message, tag = "54")]
FeedItemSetLinkOperation(super::FeedItemSetLinkOperation),
#[prost(message, tag = "38")]
FeedItemTargetOperation(super::FeedItemTargetOperation),
#[prost(message, tag = "39")]
FeedMappingOperation(super::FeedMappingOperation),
#[prost(message, tag = "40")]
FeedOperation(super::FeedOperation),
#[prost(message, tag = "44")]
KeywordPlanAdGroupOperation(super::KeywordPlanAdGroupOperation),
#[prost(message, tag = "50")]
KeywordPlanAdGroupKeywordOperation(super::KeywordPlanAdGroupKeywordOperation),
#[prost(message, tag = "51")]
KeywordPlanCampaignKeywordOperation(super::KeywordPlanCampaignKeywordOperation),
#[prost(message, tag = "45")]
KeywordPlanCampaignOperation(super::KeywordPlanCampaignOperation),
#[prost(message, tag = "48")]
KeywordPlanOperation(super::KeywordPlanOperation),
#[prost(message, tag = "41")]
LabelOperation(super::LabelOperation),
#[prost(message, tag = "86")]
RecommendationSubscriptionOperation(super::RecommendationSubscriptionOperation),
#[prost(message, tag = "43")]
RemarketingActionOperation(super::RemarketingActionOperation),
#[prost(message, tag = "14")]
SharedCriterionOperation(super::SharedCriterionOperation),
#[prost(message, tag = "15")]
SharedSetOperation(super::SharedSetOperation),
#[prost(message, tag = "61")]
SmartCampaignSettingOperation(super::SmartCampaignSettingOperation),
#[prost(message, tag = "16")]
UserListOperation(super::UserListOperation),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateOperationResponse {
#[prost(oneof = "mutate_operation_response::Response", tags = "17, 1, 56, 2, 77, 18, 3, 75, 19, 20, 21, 5, 22, 49, 23, 65, 78, 79, 62, 71, 72, 80, 58, 59, 6, 52, 73, 7, 8, 67, 13, 76, 24, 26, 27, 9, 28, 10, 11, 12, 55, 69, 63, 64, 68, 57, 66, 74, 30, 31, 32, 34, 35, 70, 81, 82, 36, 37, 53, 54, 38, 39, 40, 44, 45, 50, 51, 48, 41, 85, 43, 14, 15, 61, 16")]
pub response: ::core::option::Option<mutate_operation_response::Response>,
}
/// Nested message and enum types in `MutateOperationResponse`.
pub mod mutate_operation_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Response {
#[prost(message, tag = "17")]
AdGroupAdLabelResult(super::MutateAdGroupAdLabelResult),
#[prost(message, tag = "1")]
AdGroupAdResult(super::MutateAdGroupAdResult),
#[prost(message, tag = "56")]
AdGroupAssetResult(super::MutateAdGroupAssetResult),
#[prost(message, tag = "2")]
AdGroupBidModifierResult(super::MutateAdGroupBidModifierResult),
#[prost(message, tag = "77")]
AdGroupCriterionCustomizerResult(super::MutateAdGroupCriterionCustomizerResult),
#[prost(message, tag = "18")]
AdGroupCriterionLabelResult(super::MutateAdGroupCriterionLabelResult),
#[prost(message, tag = "3")]
AdGroupCriterionResult(super::MutateAdGroupCriterionResult),
#[prost(message, tag = "75")]
AdGroupCustomizerResult(super::MutateAdGroupCustomizerResult),
#[prost(message, tag = "19")]
AdGroupExtensionSettingResult(super::MutateAdGroupExtensionSettingResult),
#[prost(message, tag = "20")]
AdGroupFeedResult(super::MutateAdGroupFeedResult),
#[prost(message, tag = "21")]
AdGroupLabelResult(super::MutateAdGroupLabelResult),
#[prost(message, tag = "5")]
AdGroupResult(super::MutateAdGroupResult),
#[prost(message, tag = "22")]
AdParameterResult(super::MutateAdParameterResult),
#[prost(message, tag = "49")]
AdResult(super::MutateAdResult),
#[prost(message, tag = "23")]
AssetResult(super::MutateAssetResult),
#[prost(message, tag = "65")]
AssetGroupAssetResult(super::MutateAssetGroupAssetResult),
#[prost(message, tag = "78")]
AssetGroupListingGroupFilterResult(super::MutateAssetGroupListingGroupFilterResult),
#[prost(message, tag = "79")]
AssetGroupSignalResult(super::MutateAssetGroupSignalResult),
#[prost(message, tag = "62")]
AssetGroupResult(super::MutateAssetGroupResult),
#[prost(message, tag = "71")]
AssetSetAssetResult(super::MutateAssetSetAssetResult),
#[prost(message, tag = "72")]
AssetSetResult(super::MutateAssetSetResult),
#[prost(message, tag = "80")]
AudienceResult(super::MutateAudienceResult),
#[prost(message, tag = "58")]
BiddingDataExclusionResult(super::MutateBiddingDataExclusionsResult),
#[prost(message, tag = "59")]
BiddingSeasonalityAdjustmentResult(super::MutateBiddingSeasonalityAdjustmentsResult),
#[prost(message, tag = "6")]
BiddingStrategyResult(super::MutateBiddingStrategyResult),
#[prost(message, tag = "52")]
CampaignAssetResult(super::MutateCampaignAssetResult),
#[prost(message, tag = "73")]
CampaignAssetSetResult(super::MutateCampaignAssetSetResult),
#[prost(message, tag = "7")]
CampaignBidModifierResult(super::MutateCampaignBidModifierResult),
#[prost(message, tag = "8")]
CampaignBudgetResult(super::MutateCampaignBudgetResult),
#[prost(message, tag = "67")]
CampaignConversionGoalResult(super::MutateCampaignConversionGoalResult),
#[prost(message, tag = "13")]
CampaignCriterionResult(super::MutateCampaignCriterionResult),
#[prost(message, tag = "76")]
CampaignCustomizerResult(super::MutateCampaignCustomizerResult),
#[prost(message, tag = "24")]
CampaignDraftResult(super::MutateCampaignDraftResult),
#[prost(message, tag = "26")]
CampaignExtensionSettingResult(super::MutateCampaignExtensionSettingResult),
#[prost(message, tag = "27")]
CampaignFeedResult(super::MutateCampaignFeedResult),
#[prost(message, tag = "9")]
CampaignGroupResult(super::MutateCampaignGroupResult),
#[prost(message, tag = "28")]
CampaignLabelResult(super::MutateCampaignLabelResult),
#[prost(message, tag = "10")]
CampaignResult(super::MutateCampaignResult),
#[prost(message, tag = "11")]
CampaignSharedSetResult(super::MutateCampaignSharedSetResult),
#[prost(message, tag = "12")]
ConversionActionResult(super::MutateConversionActionResult),
#[prost(message, tag = "55")]
ConversionCustomVariableResult(super::MutateConversionCustomVariableResult),
#[prost(message, tag = "69")]
ConversionGoalCampaignConfigResult(super::MutateConversionGoalCampaignConfigResult),
#[prost(message, tag = "63")]
ConversionValueRuleResult(super::MutateConversionValueRuleResult),
#[prost(message, tag = "64")]
ConversionValueRuleSetResult(super::MutateConversionValueRuleSetResult),
#[prost(message, tag = "68")]
CustomConversionGoalResult(super::MutateCustomConversionGoalResult),
#[prost(message, tag = "57")]
CustomerAssetResult(super::MutateCustomerAssetResult),
#[prost(message, tag = "66")]
CustomerConversionGoalResult(super::MutateCustomerConversionGoalResult),
#[prost(message, tag = "74")]
CustomerCustomizerResult(super::MutateCustomerCustomizerResult),
#[prost(message, tag = "30")]
CustomerExtensionSettingResult(super::MutateCustomerExtensionSettingResult),
#[prost(message, tag = "31")]
CustomerFeedResult(super::MutateCustomerFeedResult),
#[prost(message, tag = "32")]
CustomerLabelResult(super::MutateCustomerLabelResult),
#[prost(message, tag = "34")]
CustomerNegativeCriterionResult(super::MutateCustomerNegativeCriteriaResult),
#[prost(message, tag = "35")]
CustomerResult(super::MutateCustomerResult),
#[prost(message, tag = "70")]
CustomizerAttributeResult(super::MutateCustomizerAttributeResult),
#[prost(message, tag = "81")]
ExperimentResult(super::MutateExperimentResult),
#[prost(message, tag = "82")]
ExperimentArmResult(super::MutateExperimentArmResult),
#[prost(message, tag = "36")]
ExtensionFeedItemResult(super::MutateExtensionFeedItemResult),
#[prost(message, tag = "37")]
FeedItemResult(super::MutateFeedItemResult),
#[prost(message, tag = "53")]
FeedItemSetResult(super::MutateFeedItemSetResult),
#[prost(message, tag = "54")]
FeedItemSetLinkResult(super::MutateFeedItemSetLinkResult),
#[prost(message, tag = "38")]
FeedItemTargetResult(super::MutateFeedItemTargetResult),
#[prost(message, tag = "39")]
FeedMappingResult(super::MutateFeedMappingResult),
#[prost(message, tag = "40")]
FeedResult(super::MutateFeedResult),
#[prost(message, tag = "44")]
KeywordPlanAdGroupResult(super::MutateKeywordPlanAdGroupResult),
#[prost(message, tag = "45")]
KeywordPlanCampaignResult(super::MutateKeywordPlanCampaignResult),
#[prost(message, tag = "50")]
KeywordPlanAdGroupKeywordResult(super::MutateKeywordPlanAdGroupKeywordResult),
#[prost(message, tag = "51")]
KeywordPlanCampaignKeywordResult(super::MutateKeywordPlanCampaignKeywordResult),
#[prost(message, tag = "48")]
KeywordPlanResult(super::MutateKeywordPlansResult),
#[prost(message, tag = "41")]
LabelResult(super::MutateLabelResult),
#[prost(message, tag = "85")]
RecommendationSubscriptionResult(super::MutateRecommendationSubscriptionResult),
#[prost(message, tag = "43")]
RemarketingActionResult(super::MutateRemarketingActionResult),
#[prost(message, tag = "14")]
SharedCriterionResult(super::MutateSharedCriterionResult),
#[prost(message, tag = "15")]
SharedSetResult(super::MutateSharedSetResult),
#[prost(message, tag = "61")]
SmartCampaignSettingResult(super::MutateSmartCampaignSettingResult),
#[prost(message, tag = "16")]
UserListResult(super::MutateUserListResult),
}
}
/// Generated client implementations.
pub mod google_ads_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to fetch data and metrics across resources.
#[derive(Debug, Clone)]
pub struct GoogleAdsServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> GoogleAdsServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> GoogleAdsServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
GoogleAdsServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns all rows that match the search query.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ChangeEventError]()
///   [ChangeStatusError]()
///   [ClickViewError]()
///   [HeaderError]()
///   [InternalError]()
///   [QueryError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn search(&mut self, request: impl tonic::IntoRequest<super::SearchGoogleAdsRequest>) -> std::result::Result<tonic::Response<super::SearchGoogleAdsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.GoogleAdsService/Search");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.GoogleAdsService", "Search"));
self.inner.unary(req, path, codec).await
}
/// Returns all rows that match the search stream query.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [ChangeEventError]()
///   [ChangeStatusError]()
///   [ClickViewError]()
///   [HeaderError]()
///   [InternalError]()
///   [QueryError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn search_stream(&mut self, request: impl tonic::IntoRequest<super::SearchGoogleAdsStreamRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::SearchGoogleAdsStreamResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.GoogleAdsService/SearchStream");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.GoogleAdsService", "SearchStream"));
self.inner.server_streaming(req, path, codec).await
}
/// Creates, updates, or removes resources. This method supports atomic
/// transactions with multiple types of resources. For example, you can
/// atomically create a campaign and a campaign budget, or perform up to
/// thousands of mutates atomically.
///
/// This method is essentially a wrapper around a series of mutate methods. The
/// only features it offers over calling those methods directly are:
///
/// - Atomic transactions
/// - Temp resource names (described below)
/// - Somewhat reduced latency over making a series of mutate calls
///
/// Note: Only resources that support atomic transactions are included, so this
/// method can't replace all calls to individual services.
///
/// ## Atomic Transaction Benefits
///
/// Atomicity makes error handling much easier. If you're making a series of
/// changes and one fails, it can leave your account in an inconsistent state.
/// With atomicity, you either reach the chosen state directly, or the request
/// fails and you can retry.
///
/// ## Temp Resource Names
///
/// Temp resource names are a special type of resource name used to create a
/// resource and reference that resource in the same request. For example, if a
/// campaign budget is created with `resource_name` equal to
/// `customers/123/campaignBudgets/-1`, that resource name can be reused in
/// the `Campaign.budget` field in the same request. That way, the two
/// resources are created and linked atomically.
///
/// To create a temp resource name, put a negative number in the part of the
/// name that the server would normally allocate.
///
/// Note:
///
/// - Resources must be created with a temp name before the name can be reused.
///   For example, the previous CampaignBudget+Campaign example would fail if
///   the mutate order was reversed.
/// - Temp names are not remembered across requests.
/// - There's no limit to the number of temp names in a request.
/// - Each temp name must use a unique negative number, even if the resource
///   types differ.
///
/// ## Latency
///
/// It's important to group mutates by resource type or the request may time
/// out and fail. Latency is roughly equal to a series of calls to individual
/// mutate methods, where each change in resource type is a new call. For
/// example, mutating 10 campaigns then 10 ad groups is like 2 calls, while
/// mutating 1 campaign, 1 ad group, 1 campaign, 1 ad group is like 4 calls.
///
/// List of thrown errors:
///   [AdCustomizerError]()
///   [AdError]()
///   [AdGroupAdError]()
///   [AdGroupCriterionError]()
///   [AdGroupError]()
///   [AssetError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BiddingError]()
///   [CampaignBudgetError]()
///   [CampaignCriterionError]()
///   [CampaignError]()
///   [CampaignExperimentError]()
///   [CampaignSharedSetError]()
///   [CollectionSizeError]()
///   [ContextError]()
///   [ConversionActionError]()
///   [CriterionError]()
///   [CustomerFeedError]()
///   [DatabaseError]()
///   [DateError]()
///   [DateRangeError]()
///   [DistinctError]()
///   [ExtensionFeedItemError]()
///   [ExtensionSettingError]()
///   [FeedAttributeReferenceError]()
///   [FeedError]()
///   [FeedItemError]()
///   [FeedItemSetError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [FunctionParsingError]()
///   [HeaderError]()
///   [ImageError]()
///   [InternalError]()
///   [KeywordPlanAdGroupKeywordError]()
///   [KeywordPlanCampaignError]()
///   [KeywordPlanError]()
///   [LabelError]()
///   [ListOperationError]()
///   [MediaUploadError]()
///   [MutateError]()
///   [NewResourceCreationError]()
///   [NullError]()
///   [OperationAccessDeniedError]()
///   [PolicyFindingError]()
///   [PolicyViolationError]()
///   [QuotaError]()
///   [RangeError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
///   [SettingError]()
///   [SharedSetError]()
///   [SizeLimitError]()
///   [StringFormatError]()
///   [StringLengthError]()
///   [UrlFieldError]()
///   [UserListError]()
///   [YoutubeVideoRegistrationError]()
pub async fn mutate(&mut self, request: impl tonic::IntoRequest<super::MutateGoogleAdsRequest>) -> std::result::Result<tonic::Response<super::MutateGoogleAdsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.GoogleAdsService/Mutate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.GoogleAdsService", "Mutate"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBatchJobRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<BatchJobOperation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchJobOperation {
#[prost(oneof = "batch_job_operation::Operation", tags = "1, 4")]
pub operation: ::core::option::Option<batch_job_operation::Operation>,
}
/// Nested message and enum types in `BatchJobOperation`.
pub mod batch_job_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::BatchJob),
#[prost(string, tag = "4")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBatchJobResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<MutateBatchJobResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBatchJobResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunBatchJobRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddBatchJobOperationsRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub sequence_token: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub mutate_operations: ::prost::alloc::vec::Vec<MutateOperation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddBatchJobOperationsResponse {
#[prost(int64, tag = "1")]
pub total_operations: i64,
#[prost(string, tag = "2")]
pub next_sequence_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchJobResultsRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "4")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchJobResultsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<BatchJobResult>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchJobResult {
#[prost(int64, tag = "1")]
pub operation_index: i64,
#[prost(message, optional, tag = "2")]
pub mutate_operation_response: ::core::option::Option<MutateOperationResponse>,
#[prost(message, optional, tag = "3")]
pub status: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// Generated client implementations.
pub mod batch_job_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage batch jobs.
#[derive(Debug, Clone)]
pub struct BatchJobServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> BatchJobServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> BatchJobServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
BatchJobServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Mutates a batch job.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
pub async fn mutate_batch_job(&mut self, request: impl tonic::IntoRequest<super::MutateBatchJobRequest>) -> std::result::Result<tonic::Response<super::MutateBatchJobResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BatchJobService/MutateBatchJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BatchJobService", "MutateBatchJob"));
self.inner.unary(req, path, codec).await
}
/// Returns the results of the batch job. The job must be done.
/// Supports standard list paging.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BatchJobError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_batch_job_results(&mut self, request: impl tonic::IntoRequest<super::ListBatchJobResultsRequest>) -> std::result::Result<tonic::Response<super::ListBatchJobResultsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BatchJobService/ListBatchJobResults");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BatchJobService", "ListBatchJobResults"));
self.inner.unary(req, path, codec).await
}
/// Runs the batch job.
///
/// The Operation.metadata field type is BatchJobMetadata. When finished, the
/// long running operation will not contain errors or a response. Instead, use
/// ListBatchJobResults to get the results of the job.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BatchJobError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn run_batch_job(&mut self, request: impl tonic::IntoRequest<super::RunBatchJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BatchJobService/RunBatchJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BatchJobService", "RunBatchJob"));
self.inner.unary(req, path, codec).await
}
/// Add operations to the batch job.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BatchJobError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
///   [ResourceCountLimitExceededError]()
pub async fn add_batch_job_operations(&mut self, request: impl tonic::IntoRequest<super::AddBatchJobOperationsRequest>) -> std::result::Result<tonic::Response<super::AddBatchJobOperationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BatchJobService/AddBatchJobOperations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BatchJobService", "AddBatchJobOperations"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListCustomerTypesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<UserListCustomerTypeOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserListCustomerTypeOperation {
#[prost(oneof = "user_list_customer_type_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<user_list_customer_type_operation::Operation>,
}
/// Nested message and enum types in `UserListCustomerTypeOperation`.
pub mod user_list_customer_type_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::UserListCustomerType),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListCustomerTypesResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateUserListCustomerTypeResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListCustomerTypeResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod user_list_customer_type_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage user list customer types.
#[derive(Debug, Clone)]
pub struct UserListCustomerTypeServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> UserListCustomerTypeServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> UserListCustomerTypeServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
UserListCustomerTypeServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Attach or remove user list customer types. Operation statuses
/// are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [UserListCustomerTypeError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_user_list_customer_types(&mut self, request: impl tonic::IntoRequest<super::MutateUserListCustomerTypesRequest>) -> std::result::Result<tonic::Response<super::MutateUserListCustomerTypesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.UserListCustomerTypeService/MutateUserListCustomerTypes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.UserListCustomerTypeService", "MutateUserListCustomerTypes"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub product_link: ::core::option::Option<super::resources::ProductLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub resource_name: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod product_link_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service allows management of links between  a Google
/// Ads customer and another product.
#[derive(Debug, Clone)]
pub struct ProductLinkServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ProductLinkServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ProductLinkServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ProductLinkServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a product link.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn create_product_link(&mut self, request: impl tonic::IntoRequest<super::CreateProductLinkRequest>) -> std::result::Result<tonic::Response<super::CreateProductLinkResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ProductLinkService/CreateProductLink");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ProductLinkService", "CreateProductLink"));
self.inner.unary(req, path, codec).await
}
/// Removes a product link.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn remove_product_link(&mut self, request: impl tonic::IntoRequest<super::RemoveProductLinkRequest>) -> std::result::Result<tonic::Response<super::RemoveProductLinkResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ProductLinkService/RemoveProductLink");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ProductLinkService", "RemoveProductLink"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomInterestOperation>,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomInterestOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "custom_interest_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<custom_interest_operation::Operation>,
}
/// Nested message and enum types in `CustomInterestOperation`.
pub mod custom_interest_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomInterest),
#[prost(message, tag = "2")]
Update(super::super::resources::CustomInterest),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestsResponse {
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<MutateCustomInterestResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod custom_interest_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage custom interests.
#[derive(Debug, Clone)]
pub struct CustomInterestServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomInterestServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomInterestServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomInterestServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or updates custom interests. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CriterionError]()
///   [CustomInterestError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [PolicyViolationError]()
///   [QuotaError]()
///   [RequestError]()
///   [StringLengthError]()
pub async fn mutate_custom_interests(&mut self, request: impl tonic::IntoRequest<super::MutateCustomInterestsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomInterestsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomInterestService/MutateCustomInterests");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomInterestService", "MutateCustomInterests"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkInvitationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub product_link_invitation: ::core::option::Option<super::resources::ProductLinkInvitation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkInvitationResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductLinkInvitationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::product_link_invitation_status_enum::ProductLinkInvitationStatus", tag = "2")]
pub product_link_invitation_status: i32,
#[prost(string, tag = "3")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductLinkInvitationResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkInvitationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkInvitationResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod product_link_invitation_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service allows management of product link invitations from Google Ads
/// accounts to other accounts.
#[derive(Debug, Clone)]
pub struct ProductLinkInvitationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ProductLinkInvitationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ProductLinkInvitationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ProductLinkInvitationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a product link invitation.
pub async fn create_product_link_invitation(&mut self, request: impl tonic::IntoRequest<super::CreateProductLinkInvitationRequest>) -> std::result::Result<tonic::Response<super::CreateProductLinkInvitationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ProductLinkInvitationService/CreateProductLinkInvitation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ProductLinkInvitationService", "CreateProductLinkInvitation"));
self.inner.unary(req, path, codec).await
}
/// Update a product link invitation.
pub async fn update_product_link_invitation(&mut self, request: impl tonic::IntoRequest<super::UpdateProductLinkInvitationRequest>) -> std::result::Result<tonic::Response<super::UpdateProductLinkInvitationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ProductLinkInvitationService/UpdateProductLinkInvitation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ProductLinkInvitationService", "UpdateProductLinkInvitation"));
self.inner.unary(req, path, codec).await
}
/// Remove a product link invitation.
pub async fn remove_product_link_invitation(&mut self, request: impl tonic::IntoRequest<super::RemoveProductLinkInvitationRequest>) -> std::result::Result<tonic::Response<super::RemoveProductLinkInvitationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ProductLinkInvitationService/RemoveProductLinkInvitation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ProductLinkInvitationService", "RemoveProductLinkInvitation"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomerAssetSetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerAssetSetOperation {
#[prost(oneof = "customer_asset_set_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customer_asset_set_operation::Operation>,
}
/// Nested message and enum types in `CustomerAssetSetOperation`.
pub mod customer_asset_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomerAssetSet),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetSetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCustomerAssetSetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub customer_asset_set: ::core::option::Option<super::resources::CustomerAssetSet>,
}
/// Generated client implementations.
pub mod customer_asset_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage customer asset set
#[derive(Debug, Clone)]
pub struct CustomerAssetSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerAssetSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerAssetSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerAssetSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, or removes customer asset sets. Operation statuses are
/// returned.
pub async fn mutate_customer_asset_sets(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerAssetSetsRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerAssetSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerAssetSetService/MutateCustomerAssetSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerAssetSetService", "MutateCustomerAssetSets"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<BillingSetupOperation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingSetupOperation {
#[prost(oneof = "billing_setup_operation::Operation", tags = "2, 1")]
pub operation: ::core::option::Option<billing_setup_operation::Operation>,
}
/// Nested message and enum types in `BillingSetupOperation`.
pub mod billing_setup_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "2")]
Create(super::super::resources::BillingSetup),
#[prost(string, tag = "1")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<MutateBillingSetupResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod billing_setup_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for designating the business entity responsible for accrued costs.
///
/// A billing setup is associated with a payments account.  Billing-related
/// activity for all billing setups associated with a particular payments account
/// will appear on a single invoice generated monthly.
///
/// Mutates:
/// The REMOVE operation cancels a pending billing setup.
/// The CREATE operation creates a new billing setup.
#[derive(Debug, Clone)]
pub struct BillingSetupServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> BillingSetupServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> BillingSetupServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
BillingSetupServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a billing setup, or cancels an existing billing setup.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [BillingSetupError]()
///   [DateError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_billing_setup(&mut self, request: impl tonic::IntoRequest<super::MutateBillingSetupRequest>) -> std::result::Result<tonic::Response<super::MutateBillingSetupResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.BillingSetupService/MutateBillingSetup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.BillingSetupService", "MutateBillingSetup"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountLinkRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub account_link: ::core::option::Option<super::resources::AccountLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountLinkResponse {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountLinkRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<AccountLinkOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountLinkOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "account_link_operation::Operation", tags = "2, 3")]
pub operation: ::core::option::Option<account_link_operation::Operation>,
}
/// Nested message and enum types in `AccountLinkOperation`.
pub mod account_link_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "2")]
Update(super::super::resources::AccountLink),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountLinkResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<MutateAccountLinkResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountLinkResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod account_link_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service allows management of links between Google Ads accounts and other
/// accounts.
#[derive(Debug, Clone)]
pub struct AccountLinkServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AccountLinkServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AccountLinkServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AccountLinkServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates an account link.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
///   [ThirdPartyAppAnalyticsLinkError]()
pub async fn create_account_link(&mut self, request: impl tonic::IntoRequest<super::CreateAccountLinkRequest>) -> std::result::Result<tonic::Response<super::CreateAccountLinkResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AccountLinkService/CreateAccountLink");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AccountLinkService", "CreateAccountLink"));
self.inner.unary(req, path, codec).await
}
/// Creates or removes an account link.
/// From V5, create is not supported through
/// AccountLinkService.MutateAccountLink. Use
/// AccountLinkService.CreateAccountLink instead.
///
/// List of thrown errors:
///   [AccountLinkError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_account_link(&mut self, request: impl tonic::IntoRequest<super::MutateAccountLinkRequest>) -> std::result::Result<tonic::Response<super::MutateAccountLinkResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AccountLinkService/MutateAccountLink");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AccountLinkService", "MutateAccountLink"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListPlannableLocationsRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlannableLocationsResponse {
#[prost(message, repeated, tag = "1")]
pub plannable_locations: ::prost::alloc::vec::Vec<PlannableLocation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannableLocation {
#[prost(string, optional, tag = "4")]
pub id: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "5")]
pub name: ::core::option::Option<::prost::alloc::string::String>,
#[prost(int64, optional, tag = "6")]
pub parent_country_id: ::core::option::Option<i64>,
#[prost(string, optional, tag = "7")]
pub country_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "8")]
pub location_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlannableProductsRequest {
#[prost(string, tag = "2")]
pub plannable_location_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlannableProductsResponse {
#[prost(message, repeated, tag = "1")]
pub product_metadata: ::prost::alloc::vec::Vec<ProductMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductMetadata {
#[prost(string, optional, tag = "4")]
pub plannable_product_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, tag = "3")]
pub plannable_product_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub plannable_targeting: ::core::option::Option<PlannableTargeting>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannableTargeting {
#[prost(enumeration = "super::enums::reach_plan_age_range_enum::ReachPlanAgeRange", repeated, tag = "1")]
pub age_ranges: ::prost::alloc::vec::Vec<i32>,
#[prost(message, repeated, tag = "2")]
pub genders: ::prost::alloc::vec::Vec<super::common::GenderInfo>,
#[prost(message, repeated, tag = "3")]
pub devices: ::prost::alloc::vec::Vec<super::common::DeviceInfo>,
#[prost(enumeration = "super::enums::reach_plan_network_enum::ReachPlanNetwork", repeated, tag = "4")]
pub networks: ::prost::alloc::vec::Vec<i32>,
#[prost(message, repeated, tag = "5")]
pub youtube_select_lineups: ::prost::alloc::vec::Vec<YouTubeSelectLineUp>,
#[prost(message, optional, tag = "6")]
pub surface_targeting: ::core::option::Option<SurfaceTargetingCombinations>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateReachForecastRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(string, optional, tag = "9")]
pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub campaign_duration: ::core::option::Option<CampaignDuration>,
#[prost(int32, optional, tag = "10")]
pub cookie_frequency_cap: ::core::option::Option<i32>,
#[prost(message, optional, tag = "8")]
pub cookie_frequency_cap_setting: ::core::option::Option<FrequencyCap>,
#[prost(int32, optional, tag = "11")]
pub min_effective_frequency: ::core::option::Option<i32>,
#[prost(message, optional, tag = "12")]
pub effective_frequency_limit: ::core::option::Option<EffectiveFrequencyLimit>,
#[prost(message, optional, tag = "6")]
pub targeting: ::core::option::Option<Targeting>,
#[prost(message, repeated, tag = "7")]
pub planned_products: ::prost::alloc::vec::Vec<PlannedProduct>,
#[prost(message, optional, tag = "13")]
pub forecast_metric_options: ::core::option::Option<ForecastMetricOptions>,
#[prost(string, optional, tag = "14")]
pub customer_reach_group: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffectiveFrequencyLimit {
#[prost(int32, tag = "1")]
pub effective_frequency_breakdown_limit: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCap {
#[prost(int32, tag = "3")]
pub impressions: i32,
#[prost(enumeration = "super::enums::frequency_cap_time_unit_enum::FrequencyCapTimeUnit", tag = "2")]
pub time_unit: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Targeting {
#[prost(string, optional, tag = "6")]
pub plannable_location_id: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "8")]
pub plannable_location_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "super::enums::reach_plan_age_range_enum::ReachPlanAgeRange", tag = "2")]
pub age_range: i32,
#[prost(message, repeated, tag = "3")]
pub genders: ::prost::alloc::vec::Vec<super::common::GenderInfo>,
#[prost(message, repeated, tag = "4")]
pub devices: ::prost::alloc::vec::Vec<super::common::DeviceInfo>,
#[prost(enumeration = "super::enums::reach_plan_network_enum::ReachPlanNetwork", tag = "5")]
pub network: i32,
#[prost(message, optional, tag = "7")]
pub audience_targeting: ::core::option::Option<AudienceTargeting>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignDuration {
#[prost(int32, optional, tag = "2")]
pub duration_in_days: ::core::option::Option<i32>,
#[prost(message, optional, tag = "3")]
pub date_range: ::core::option::Option<super::common::DateRange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannedProduct {
#[prost(string, optional, tag = "3")]
pub plannable_product_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(int64, optional, tag = "4")]
pub budget_micros: ::core::option::Option<i64>,
#[prost(message, optional, tag = "5")]
pub advanced_product_targeting: ::core::option::Option<AdvancedProductTargeting>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateReachForecastResponse {
#[prost(message, optional, tag = "1")]
pub on_target_audience_metrics: ::core::option::Option<OnTargetAudienceMetrics>,
#[prost(message, optional, tag = "2")]
pub reach_curve: ::core::option::Option<ReachCurve>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReachCurve {
#[prost(message, repeated, tag = "1")]
pub reach_forecasts: ::prost::alloc::vec::Vec<ReachForecast>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReachForecast {
#[prost(int64, tag = "5")]
pub cost_micros: i64,
#[prost(message, optional, tag = "2")]
pub forecast: ::core::option::Option<Forecast>,
#[prost(message, repeated, tag = "4")]
pub planned_product_reach_forecasts: ::prost::alloc::vec::Vec<PlannedProductReachForecast>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Forecast {
#[prost(int64, optional, tag = "5")]
pub on_target_reach: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "6")]
pub total_reach: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "7")]
pub on_target_impressions: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "8")]
pub total_impressions: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "9")]
pub viewable_impressions: ::core::option::Option<i64>,
#[prost(message, repeated, tag = "10")]
pub effective_frequency_breakdowns: ::prost::alloc::vec::Vec<EffectiveFrequencyBreakdown>,
#[prost(int64, optional, tag = "11")]
pub on_target_coview_reach: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "12")]
pub total_coview_reach: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "13")]
pub on_target_coview_impressions: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "14")]
pub total_coview_impressions: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "15")]
pub views: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannedProductReachForecast {
#[prost(string, tag = "1")]
pub plannable_product_code: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub cost_micros: i64,
#[prost(message, optional, tag = "3")]
pub planned_product_forecast: ::core::option::Option<PlannedProductForecast>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlannedProductForecast {
#[prost(int64, tag = "1")]
pub on_target_reach: i64,
#[prost(int64, tag = "2")]
pub total_reach: i64,
#[prost(int64, tag = "3")]
pub on_target_impressions: i64,
#[prost(int64, tag = "4")]
pub total_impressions: i64,
#[prost(int64, optional, tag = "5")]
pub viewable_impressions: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "6")]
pub on_target_coview_reach: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "7")]
pub total_coview_reach: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "8")]
pub on_target_coview_impressions: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "9")]
pub total_coview_impressions: ::core::option::Option<i64>,
#[prost(double, optional, tag = "10")]
pub average_frequency: ::core::option::Option<f64>,
#[prost(int64, optional, tag = "11")]
pub views: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OnTargetAudienceMetrics {
#[prost(int64, optional, tag = "3")]
pub youtube_audience_size: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "4")]
pub census_audience_size: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffectiveFrequencyBreakdown {
#[prost(int32, tag = "1")]
pub effective_frequency: i32,
#[prost(int64, tag = "2")]
pub on_target_reach: i64,
#[prost(int64, tag = "3")]
pub total_reach: i64,
#[prost(int64, optional, tag = "4")]
pub effective_coview_reach: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "5")]
pub on_target_effective_coview_reach: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForecastMetricOptions {
#[prost(bool, tag = "1")]
pub include_coview: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceTargeting {
#[prost(message, repeated, tag = "1")]
pub user_interest: ::prost::alloc::vec::Vec<super::common::UserInterestInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdvancedProductTargeting {
#[prost(message, optional, tag = "2")]
pub surface_targeting_settings: ::core::option::Option<SurfaceTargeting>,
#[prost(message, optional, tag = "3")]
pub target_frequency_settings: ::core::option::Option<TargetFrequencySettings>,
#[prost(oneof = "advanced_product_targeting::AdvancedTargeting", tags = "1")]
pub advanced_targeting: ::core::option::Option<advanced_product_targeting::AdvancedTargeting>,
}
/// Nested message and enum types in `AdvancedProductTargeting`.
pub mod advanced_product_targeting {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum AdvancedTargeting {
#[prost(message, tag = "1")]
YoutubeSelectSettings(super::YouTubeSelectSettings),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct YouTubeSelectSettings {
#[prost(int64, tag = "1")]
pub lineup_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YouTubeSelectLineUp {
#[prost(int64, tag = "1")]
pub lineup_id: i64,
#[prost(string, tag = "2")]
pub lineup_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SurfaceTargetingCombinations {
#[prost(message, optional, tag = "1")]
pub default_targeting: ::core::option::Option<SurfaceTargeting>,
#[prost(message, repeated, tag = "2")]
pub available_targeting_combinations: ::prost::alloc::vec::Vec<SurfaceTargeting>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SurfaceTargeting {
#[prost(enumeration = "super::enums::reach_plan_surface_enum::ReachPlanSurface", repeated, tag = "1")]
pub surfaces: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetFrequencySettings {
#[prost(enumeration = "super::enums::target_frequency_time_unit_enum::TargetFrequencyTimeUnit", tag = "1")]
pub time_unit: i32,
#[prost(int32, tag = "2")]
pub target_frequency: i32,
}
/// Generated client implementations.
pub mod reach_plan_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Reach Plan Service gives users information about audience size that can
/// be reached through advertisement on YouTube. In particular,
/// GenerateReachForecast provides estimated number of people of specified
/// demographics that can be reached by an ad in a given market by a campaign of
/// certain duration with a defined budget.
#[derive(Debug, Clone)]
pub struct ReachPlanServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ReachPlanServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ReachPlanServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ReachPlanServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns the list of plannable locations (for example, countries).
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_plannable_locations(&mut self, request: impl tonic::IntoRequest<super::ListPlannableLocationsRequest>) -> std::result::Result<tonic::Response<super::ListPlannableLocationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ReachPlanService/ListPlannableLocations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ReachPlanService", "ListPlannableLocations"));
self.inner.unary(req, path, codec).await
}
/// Returns the list of per-location plannable YouTube ad formats with allowed
/// targeting.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_plannable_products(&mut self, request: impl tonic::IntoRequest<super::ListPlannableProductsRequest>) -> std::result::Result<tonic::Response<super::ListPlannableProductsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ReachPlanService/ListPlannableProducts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ReachPlanService", "ListPlannableProducts"));
self.inner.unary(req, path, codec).await
}
/// Generates a reach forecast for a given targeting / product mix.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RangeError]()
///   [ReachPlanError]()
///   [RequestError]()
pub async fn generate_reach_forecast(&mut self, request: impl tonic::IntoRequest<super::GenerateReachForecastRequest>) -> std::result::Result<tonic::Response<super::GenerateReachForecastResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ReachPlanService/GenerateReachForecast");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ReachPlanService", "GenerateReachForecast"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendLeadConversationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub conversations: ::prost::alloc::vec::Vec<Conversation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendLeadConversationResponse {
#[prost(message, repeated, tag = "1")]
pub responses: ::prost::alloc::vec::Vec<ConversationOrError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
#[prost(string, tag = "1")]
pub local_services_lead: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub text: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationOrError {
#[prost(oneof = "conversation_or_error::AppendLeadConversationResponse", tags = "1, 2")]
pub append_lead_conversation_response: ::core::option::Option<conversation_or_error::AppendLeadConversationResponse>,
}
/// Nested message and enum types in `ConversationOrError`.
pub mod conversation_or_error {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum AppendLeadConversationResponse {
#[prost(string, tag = "1")]
LocalServicesLeadConversation(::prost::alloc::string::String),
#[prost(message, tag = "2")]
PartialFailureError(super::super::super::super::super::rpc::Status),
}
}
/// Generated client implementations.
pub mod local_services_lead_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service allows management of LocalServicesLead resources.
#[derive(Debug, Clone)]
pub struct LocalServicesLeadServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> LocalServicesLeadServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> LocalServicesLeadServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
LocalServicesLeadServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// RPC to append Local Services Lead Conversation resources to Local Services
/// Lead resources.
pub async fn append_lead_conversation(&mut self, request: impl tonic::IntoRequest<super::AppendLeadConversationRequest>) -> std::result::Result<tonic::Response<super::AppendLeadConversationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.LocalServicesLeadService/AppendLeadConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.LocalServicesLeadService", "AppendLeadConversation"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCampaignLifecycleGoalsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<CampaignLifecycleGoalOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignLifecycleGoalOperation {
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "campaign_lifecycle_goal_operation::Operation", tags = "1, 3")]
pub operation: ::core::option::Option<campaign_lifecycle_goal_operation::Operation>,
}
/// Nested message and enum types in `CampaignLifecycleGoalOperation`.
pub mod campaign_lifecycle_goal_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CampaignLifecycleGoal),
#[prost(message, tag = "3")]
Update(super::super::resources::CampaignLifecycleGoal),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCampaignLifecycleGoalsResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<ConfigureCampaignLifecycleGoalsResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCampaignLifecycleGoalsResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod campaign_lifecycle_goal_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to configure campaign lifecycle goals.
#[derive(Debug, Clone)]
pub struct CampaignLifecycleGoalServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CampaignLifecycleGoalServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CampaignLifecycleGoalServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CampaignLifecycleGoalServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Process the given campaign lifecycle configurations.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CampaignLifecycleGoalConfigError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn configure_campaign_lifecycle_goals(&mut self, request: impl tonic::IntoRequest<super::ConfigureCampaignLifecycleGoalsRequest>) -> std::result::Result<tonic::Response<super::ConfigureCampaignLifecycleGoalsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CampaignLifecycleGoalService/ConfigureCampaignLifecycleGoals");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CampaignLifecycleGoalService", "ConfigureCampaignLifecycleGoals"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPaymentsAccountsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPaymentsAccountsResponse {
#[prost(message, repeated, tag = "1")]
pub payments_accounts: ::prost::alloc::vec::Vec<super::resources::PaymentsAccount>,
}
/// Generated client implementations.
pub mod payments_account_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to provide payments accounts that can be used to set up consolidated
/// billing.
#[derive(Debug, Clone)]
pub struct PaymentsAccountServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> PaymentsAccountServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> PaymentsAccountServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
PaymentsAccountServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns all payments accounts associated with all managers
/// between the login customer ID and specified serving customer in the
/// hierarchy, inclusive.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [PaymentsAccountError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn list_payments_accounts(&mut self, request: impl tonic::IntoRequest<super::ListPaymentsAccountsRequest>) -> std::result::Result<tonic::Response<super::ListPaymentsAccountsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.PaymentsAccountService/ListPaymentsAccounts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.PaymentsAccountService", "ListPaymentsAccounts"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<ApplyRecommendationOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationOperation {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(oneof = "apply_recommendation_operation::ApplyParameters", tags = "2, 3, 4, 5, 10, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25")]
pub apply_parameters: ::core::option::Option<apply_recommendation_operation::ApplyParameters>,
}
/// Nested message and enum types in `ApplyRecommendationOperation`.
pub mod apply_recommendation_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignBudgetParameters {
#[prost(int64, optional, tag = "2")]
pub new_budget_amount_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForecastingSetTargetRoasParameters {
#[prost(double, optional, tag = "1")]
pub target_roas: ::core::option::Option<f64>,
#[prost(int64, optional, tag = "2")]
pub campaign_budget_amount_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextAdParameters {
#[prost(message, optional, tag = "1")]
pub ad: ::core::option::Option<super::super::resources::Ad>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordParameters {
#[prost(string, optional, tag = "4")]
pub ad_group: ::core::option::Option<::prost::alloc::string::String>,
#[prost(enumeration = "super::super::enums::keyword_match_type_enum::KeywordMatchType", tag = "2")]
pub match_type: i32,
#[prost(int64, optional, tag = "5")]
pub cpc_bid_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetCpaOptInParameters {
#[prost(int64, optional, tag = "3")]
pub target_cpa_micros: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "4")]
pub new_campaign_budget_amount_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetRoasOptInParameters {
#[prost(double, optional, tag = "1")]
pub target_roas: ::core::option::Option<f64>,
#[prost(int64, optional, tag = "2")]
pub new_campaign_budget_amount_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalloutExtensionParameters {
#[prost(message, repeated, tag = "1")]
pub callout_extensions: ::prost::alloc::vec::Vec<super::super::common::CalloutFeedItem>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallExtensionParameters {
#[prost(message, repeated, tag = "1")]
pub call_extensions: ::prost::alloc::vec::Vec<super::super::common::CallFeedItem>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SitelinkExtensionParameters {
#[prost(message, repeated, tag = "1")]
pub sitelink_extensions: ::prost::alloc::vec::Vec<super::super::common::SitelinkFeedItem>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalloutAssetParameters {
#[prost(message, optional, tag = "1")]
pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallAssetParameters {
#[prost(message, optional, tag = "1")]
pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SitelinkAssetParameters {
#[prost(message, optional, tag = "1")]
pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RaiseTargetCpaParameters {
#[prost(double, tag = "1")]
pub target_cpa_multiplier: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LowerTargetRoasParameters {
#[prost(double, tag = "1")]
pub target_roas_multiplier: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdAssetApplyParameters {
#[prost(message, repeated, tag = "1")]
pub new_assets: ::prost::alloc::vec::Vec<super::super::resources::Asset>,
#[prost(string, repeated, tag = "2")]
pub existing_assets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "ad_asset_apply_parameters::ApplyScope", tag = "3")]
pub scope: i32,
}
/// Nested message and enum types in `AdAssetApplyParameters`.
pub mod ad_asset_apply_parameters {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApplyScope {
Unspecified = 0,
Unknown = 1,
Customer = 2,
Campaign = 3,
}
impl ApplyScope {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ApplyScope::Unspecified => "UNSPECIFIED",
ApplyScope::Unknown => "UNKNOWN",
ApplyScope::Customer => "CUSTOMER",
ApplyScope::Campaign => "CAMPAIGN",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"UNSPECIFIED" => Some(Self::Unspecified),
"UNKNOWN" => Some(Self::Unknown),
"CUSTOMER" => Some(Self::Customer),
"CAMPAIGN" => Some(Self::Campaign),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MoveUnusedBudgetParameters {
#[prost(int64, optional, tag = "2")]
pub budget_micros_to_move: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponsiveSearchAdAssetParameters {
#[prost(message, optional, tag = "1")]
pub updated_ad: ::core::option::Option<super::super::resources::Ad>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponsiveSearchAdImproveAdStrengthParameters {
#[prost(message, optional, tag = "1")]
pub updated_ad: ::core::option::Option<super::super::resources::Ad>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponsiveSearchAdParameters {
#[prost(message, optional, tag = "1")]
pub ad: ::core::option::Option<super::super::resources::Ad>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RaiseTargetCpaBidTooLowParameters {
#[prost(double, tag = "1")]
pub target_multiplier: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseBroadMatchKeywordParameters {
#[prost(int64, optional, tag = "1")]
pub new_budget_amount_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForecastingSetTargetCpaParameters {
#[prost(int64, optional, tag = "1")]
pub target_cpa_micros: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "2")]
pub campaign_budget_amount_micros: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeadFormAssetParameters {
#[prost(message, optional, tag = "1")]
pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
#[prost(bool, optional, tag = "2")]
pub set_submit_lead_form_asset_campaign_goal: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ApplyParameters {
#[prost(message, tag = "2")]
CampaignBudget(CampaignBudgetParameters),
#[prost(message, tag = "3")]
TextAd(TextAdParameters),
#[prost(message, tag = "4")]
Keyword(KeywordParameters),
#[prost(message, tag = "5")]
TargetCpaOptIn(TargetCpaOptInParameters),
#[prost(message, tag = "10")]
TargetRoasOptIn(TargetRoasOptInParameters),
#[prost(message, tag = "6")]
CalloutExtension(CalloutExtensionParameters),
#[prost(message, tag = "7")]
CallExtension(CallExtensionParameters),
#[prost(message, tag = "8")]
SitelinkExtension(SitelinkExtensionParameters),
#[prost(message, tag = "9")]
MoveUnusedBudget(MoveUnusedBudgetParameters),
#[prost(message, tag = "11")]
ResponsiveSearchAd(ResponsiveSearchAdParameters),
#[prost(message, tag = "12")]
UseBroadMatchKeyword(UseBroadMatchKeywordParameters),
#[prost(message, tag = "13")]
ResponsiveSearchAdAsset(ResponsiveSearchAdAssetParameters),
#[prost(message, tag = "14")]
ResponsiveSearchAdImproveAdStrength(ResponsiveSearchAdImproveAdStrengthParameters),
#[prost(message, tag = "15")]
RaiseTargetCpaBidTooLow(RaiseTargetCpaBidTooLowParameters),
#[prost(message, tag = "16")]
ForecastingSetTargetRoas(ForecastingSetTargetRoasParameters),
#[prost(message, tag = "17")]
CalloutAsset(CalloutAssetParameters),
#[prost(message, tag = "18")]
CallAsset(CallAssetParameters),
#[prost(message, tag = "19")]
SitelinkAsset(SitelinkAssetParameters),
#[prost(message, tag = "20")]
RaiseTargetCpa(RaiseTargetCpaParameters),
#[prost(message, tag = "21")]
LowerTargetRoas(LowerTargetRoasParameters),
#[prost(message, tag = "22")]
ForecastingSetTargetCpa(ForecastingSetTargetCpaParameters),
#[prost(message, tag = "23")]
SetTargetCpa(ForecastingSetTargetCpaParameters),
#[prost(message, tag = "24")]
SetTargetRoas(ForecastingSetTargetRoasParameters),
#[prost(message, tag = "25")]
LeadFormAsset(LeadFormAssetParameters),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<ApplyRecommendationResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub operations: ::prost::alloc::vec::Vec<dismiss_recommendation_request::DismissRecommendationOperation>,
#[prost(bool, tag = "2")]
pub partial_failure: bool,
}
/// Nested message and enum types in `DismissRecommendationRequest`.
pub mod dismiss_recommendation_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationOperation {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<dismiss_recommendation_response::DismissRecommendationResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// Nested message and enum types in `DismissRecommendationResponse`.
pub mod dismiss_recommendation_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateRecommendationsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::recommendation_type_enum::RecommendationType", repeated, packed = "false", tag = "2")]
pub recommendation_types: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "super::enums::advertising_channel_type_enum::AdvertisingChannelType", tag = "3")]
pub advertising_channel_type: i32,
#[prost(int32, optional, tag = "4")]
pub campaign_sitelink_count: ::core::option::Option<i32>,
#[prost(enumeration = "super::enums::conversion_tracking_status_enum::ConversionTrackingStatus", optional, tag = "5")]
pub conversion_tracking_status: ::core::option::Option<i32>,
#[prost(message, optional, tag = "6")]
pub bidding_info: ::core::option::Option<generate_recommendations_request::BiddingInfo>,
#[prost(message, repeated, tag = "7")]
pub ad_group_info: ::prost::alloc::vec::Vec<generate_recommendations_request::AdGroupInfo>,
#[prost(message, optional, tag = "8")]
pub seed_info: ::core::option::Option<generate_recommendations_request::SeedInfo>,
}
/// Nested message and enum types in `GenerateRecommendationsRequest`.
pub mod generate_recommendations_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingInfo {
#[prost(enumeration = "super::super::enums::bidding_strategy_type_enum::BiddingStrategyType", optional, tag = "1")]
pub bidding_strategy_type: ::core::option::Option<i32>,
#[prost(oneof = "bidding_info::BiddingStrategyTargetInfo", tags = "2, 3")]
pub bidding_strategy_target_info: ::core::option::Option<bidding_info::BiddingStrategyTargetInfo>,
}
/// Nested message and enum types in `BiddingInfo`.
pub mod bidding_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum BiddingStrategyTargetInfo {
#[prost(int64, tag = "2")]
TargetCpaMicros(i64),
#[prost(double, tag = "3")]
TargetRoas(f64),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupInfo {
#[prost(enumeration = "super::super::enums::ad_group_type_enum::AdGroupType", optional, tag = "1")]
pub ad_group_type: ::core::option::Option<i32>,
#[prost(message, repeated, tag = "2")]
pub keywords: ::prost::alloc::vec::Vec<super::super::common::KeywordInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeedInfo {
#[prost(string, optional, tag = "2")]
pub url_seed: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub keyword_seeds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateRecommendationsResponse {
#[prost(message, repeated, tag = "1")]
pub recommendations: ::prost::alloc::vec::Vec<super::resources::Recommendation>,
}
/// Generated client implementations.
pub mod recommendation_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage recommendations.
#[derive(Debug, Clone)]
pub struct RecommendationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> RecommendationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> RecommendationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
RecommendationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Applies given recommendations with corresponding apply parameters.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [FieldError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RecommendationError]()
///   [RequestError]()
///   [UrlFieldError]()
pub async fn apply_recommendation(&mut self, request: impl tonic::IntoRequest<super::ApplyRecommendationRequest>) -> std::result::Result<tonic::Response<super::ApplyRecommendationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.RecommendationService/ApplyRecommendation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.RecommendationService", "ApplyRecommendation"));
self.inner.unary(req, path, codec).await
}
/// Dismisses given recommendations.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RecommendationError]()
///   [RequestError]()
pub async fn dismiss_recommendation(&mut self, request: impl tonic::IntoRequest<super::DismissRecommendationRequest>) -> std::result::Result<tonic::Response<super::DismissRecommendationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.RecommendationService/DismissRecommendation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.RecommendationService", "DismissRecommendation"));
self.inner.unary(req, path, codec).await
}
/// Generates Recommendations based off the requested recommendation_types.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RecommendationError]()
///   [RequestError]()
pub async fn generate_recommendations(&mut self, request: impl tonic::IntoRequest<super::GenerateRecommendationsRequest>) -> std::result::Result<tonic::Response<super::GenerateRecommendationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.RecommendationService/GenerateRecommendations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.RecommendationService", "GenerateRecommendations"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartIdentityVerificationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(enumeration = "super::enums::identity_verification_program_enum::IdentityVerificationProgram", tag = "2")]
pub verification_program: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityVerificationRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityVerificationResponse {
#[prost(message, repeated, tag = "1")]
pub identity_verification: ::prost::alloc::vec::Vec<IdentityVerification>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityVerification {
#[prost(enumeration = "super::enums::identity_verification_program_enum::IdentityVerificationProgram", tag = "1")]
pub verification_program: i32,
#[prost(message, optional, tag = "2")]
pub identity_verification_requirement: ::core::option::Option<IdentityVerificationRequirement>,
#[prost(message, optional, tag = "3")]
pub verification_progress: ::core::option::Option<IdentityVerificationProgress>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityVerificationProgress {
#[prost(enumeration = "super::enums::identity_verification_program_status_enum::IdentityVerificationProgramStatus", tag = "1")]
pub program_status: i32,
#[prost(string, tag = "2")]
pub invitation_link_expiration_time: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub action_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityVerificationRequirement {
#[prost(string, tag = "1")]
pub verification_start_deadline_time: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub verification_completion_deadline_time: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod identity_verification_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for managing Identity Verification Service.
#[derive(Debug, Clone)]
pub struct IdentityVerificationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> IdentityVerificationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> IdentityVerificationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
IdentityVerificationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Starts Identity Verification for a given verification program type.
///  Statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn start_identity_verification(&mut self, request: impl tonic::IntoRequest<super::StartIdentityVerificationRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.IdentityVerificationService/StartIdentityVerification");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.IdentityVerificationService", "StartIdentityVerification"));
self.inner.unary(req, path, codec).await
}
/// Returns Identity Verification information.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn get_identity_verification(&mut self, request: impl tonic::IntoRequest<super::GetIdentityVerificationRequest>) -> std::result::Result<tonic::Response<super::GetIdentityVerificationResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.IdentityVerificationService/GetIdentityVerification");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.IdentityVerificationService", "GetIdentityVerification"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignBudgetOptionsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(oneof = "suggest_smart_campaign_budget_options_request::SuggestionData", tags = "2, 3")]
pub suggestion_data: ::core::option::Option<suggest_smart_campaign_budget_options_request::SuggestionData>,
}
/// Nested message and enum types in `SuggestSmartCampaignBudgetOptionsRequest`.
pub mod suggest_smart_campaign_budget_options_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum SuggestionData {
#[prost(string, tag = "2")]
Campaign(::prost::alloc::string::String),
#[prost(message, tag = "3")]
SuggestionInfo(super::SmartCampaignSuggestionInfo),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignSuggestionInfo {
#[prost(string, tag = "1")]
pub final_url: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub language_code: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "6")]
pub ad_schedules: ::prost::alloc::vec::Vec<super::common::AdScheduleInfo>,
#[prost(message, repeated, tag = "7")]
pub keyword_themes: ::prost::alloc::vec::Vec<super::common::KeywordThemeInfo>,
#[prost(oneof = "smart_campaign_suggestion_info::BusinessSetting", tags = "8, 9")]
pub business_setting: ::core::option::Option<smart_campaign_suggestion_info::BusinessSetting>,
#[prost(oneof = "smart_campaign_suggestion_info::GeoTarget", tags = "4, 5")]
pub geo_target: ::core::option::Option<smart_campaign_suggestion_info::GeoTarget>,
}
/// Nested message and enum types in `SmartCampaignSuggestionInfo`.
pub mod smart_campaign_suggestion_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationList {
#[prost(message, repeated, tag = "1")]
pub locations: ::prost::alloc::vec::Vec<super::super::common::LocationInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BusinessContext {
#[prost(string, tag = "1")]
pub business_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum BusinessSetting {
#[prost(message, tag = "8")]
BusinessContext(BusinessContext),
#[prost(string, tag = "9")]
BusinessProfileLocation(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum GeoTarget {
#[prost(message, tag = "4")]
LocationList(LocationList),
#[prost(message, tag = "5")]
Proximity(super::super::common::ProximityInfo),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignBudgetOptionsResponse {
#[prost(message, optional, tag = "1")]
pub low: ::core::option::Option<suggest_smart_campaign_budget_options_response::BudgetOption>,
#[prost(message, optional, tag = "2")]
pub recommended: ::core::option::Option<suggest_smart_campaign_budget_options_response::BudgetOption>,
#[prost(message, optional, tag = "3")]
pub high: ::core::option::Option<suggest_smart_campaign_budget_options_response::BudgetOption>,
}
/// Nested message and enum types in `SuggestSmartCampaignBudgetOptionsResponse`.
pub mod suggest_smart_campaign_budget_options_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Metrics {
#[prost(int64, tag = "1")]
pub min_daily_clicks: i64,
#[prost(int64, tag = "2")]
pub max_daily_clicks: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetOption {
#[prost(int64, tag = "1")]
pub daily_amount_micros: i64,
#[prost(message, optional, tag = "2")]
pub metrics: ::core::option::Option<Metrics>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignAdRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub suggestion_info: ::core::option::Option<SmartCampaignSuggestionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignAdResponse {
#[prost(message, optional, tag = "1")]
pub ad_info: ::core::option::Option<super::common::SmartCampaignAdInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub suggestion_info: ::core::option::Option<SmartCampaignSuggestionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemesResponse {
#[prost(message, repeated, tag = "2")]
pub keyword_themes: ::prost::alloc::vec::Vec<suggest_keyword_themes_response::KeywordTheme>,
}
/// Nested message and enum types in `SuggestKeywordThemesResponse`.
pub mod suggest_keyword_themes_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordTheme {
#[prost(oneof = "keyword_theme::KeywordTheme", tags = "1, 2")]
pub keyword_theme: ::core::option::Option<keyword_theme::KeywordTheme>,
}
/// Nested message and enum types in `KeywordTheme`.
pub mod keyword_theme {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum KeywordTheme {
#[prost(message, tag = "1")]
KeywordThemeConstant(super::super::super::resources::KeywordThemeConstant),
#[prost(string, tag = "2")]
FreeFormKeywordTheme(::prost::alloc::string::String),
}
}
}
/// Generated client implementations.
pub mod smart_campaign_suggest_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to get suggestions for Smart Campaigns.
#[derive(Debug, Clone)]
pub struct SmartCampaignSuggestServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SmartCampaignSuggestServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SmartCampaignSuggestServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SmartCampaignSuggestServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns BudgetOption suggestions.
pub async fn suggest_smart_campaign_budget_options(&mut self, request: impl tonic::IntoRequest<super::SuggestSmartCampaignBudgetOptionsRequest>) -> std::result::Result<tonic::Response<super::SuggestSmartCampaignBudgetOptionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.SmartCampaignSuggestService/SuggestSmartCampaignBudgetOptions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.SmartCampaignSuggestService", "SuggestSmartCampaignBudgetOptions"));
self.inner.unary(req, path, codec).await
}
/// Suggests a Smart campaign ad compatible with the Ad family of resources,
/// based on data points such as targeting and the business to advertise.
pub async fn suggest_smart_campaign_ad(&mut self, request: impl tonic::IntoRequest<super::SuggestSmartCampaignAdRequest>) -> std::result::Result<tonic::Response<super::SuggestSmartCampaignAdResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.SmartCampaignSuggestService/SuggestSmartCampaignAd");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.SmartCampaignSuggestService", "SuggestSmartCampaignAd"));
self.inner.unary(req, path, codec).await
}
/// Suggests keyword themes to advertise on.
pub async fn suggest_keyword_themes(&mut self, request: impl tonic::IntoRequest<super::SuggestKeywordThemesRequest>) -> std::result::Result<tonic::Response<super::SuggestKeywordThemesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.SmartCampaignSuggestService/SuggestKeywordThemes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.SmartCampaignSuggestService", "SuggestKeywordThemes"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestGeoTargetConstantsRequest {
#[prost(string, optional, tag = "6")]
pub locale: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "7")]
pub country_code: ::core::option::Option<::prost::alloc::string::String>,
#[prost(oneof = "suggest_geo_target_constants_request::Query", tags = "1, 2")]
pub query: ::core::option::Option<suggest_geo_target_constants_request::Query>,
}
/// Nested message and enum types in `SuggestGeoTargetConstantsRequest`.
pub mod suggest_geo_target_constants_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationNames {
#[prost(string, repeated, tag = "2")]
pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoTargets {
#[prost(string, repeated, tag = "2")]
pub geo_target_constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Query {
#[prost(message, tag = "1")]
LocationNames(LocationNames),
#[prost(message, tag = "2")]
GeoTargets(GeoTargets),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestGeoTargetConstantsResponse {
#[prost(message, repeated, tag = "1")]
pub geo_target_constant_suggestions: ::prost::alloc::vec::Vec<GeoTargetConstantSuggestion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantSuggestion {
#[prost(string, optional, tag = "6")]
pub locale: ::core::option::Option<::prost::alloc::string::String>,
#[prost(int64, optional, tag = "7")]
pub reach: ::core::option::Option<i64>,
#[prost(string, optional, tag = "8")]
pub search_term: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, optional, tag = "4")]
pub geo_target_constant: ::core::option::Option<super::resources::GeoTargetConstant>,
#[prost(message, repeated, tag = "5")]
pub geo_target_constant_parents: ::prost::alloc::vec::Vec<super::resources::GeoTargetConstant>,
}
/// Generated client implementations.
pub mod geo_target_constant_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to fetch geo target constants.
#[derive(Debug, Clone)]
pub struct GeoTargetConstantServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> GeoTargetConstantServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> GeoTargetConstantServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
GeoTargetConstantServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns GeoTargetConstant suggestions by location name or by resource name.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [GeoTargetConstantSuggestionError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn suggest_geo_target_constants(&mut self, request: impl tonic::IntoRequest<super::SuggestGeoTargetConstantsRequest>) -> std::result::Result<tonic::Response<super::SuggestGeoTargetConstantsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.GeoTargetConstantService/SuggestGeoTargetConstants");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.GeoTargetConstantService", "SuggestGeoTargetConstants"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<CustomerUserAccessOperation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerUserAccessOperation {
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "customer_user_access_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<customer_user_access_operation::Operation>,
}
/// Nested message and enum types in `CustomerUserAccessOperation`.
pub mod customer_user_access_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Update(super::super::resources::CustomerUserAccess),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<MutateCustomerUserAccessResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod customer_user_access_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service manages the permissions of a user on a given customer.
#[derive(Debug, Clone)]
pub struct CustomerUserAccessServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomerUserAccessServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomerUserAccessServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomerUserAccessServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Updates, removes permission of a user on a given customer. Operation
/// statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CustomerUserAccessError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_customer_user_access(&mut self, request: impl tonic::IntoRequest<super::MutateCustomerUserAccessRequest>) -> std::result::Result<tonic::Response<super::MutateCustomerUserAccessResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomerUserAccessService/MutateCustomerUserAccess");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomerUserAccessService", "MutateCustomerUserAccess"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomAudiencesRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<CustomAudienceOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAudienceOperation {
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "custom_audience_operation::Operation", tags = "1, 2, 3")]
pub operation: ::core::option::Option<custom_audience_operation::Operation>,
}
/// Nested message and enum types in `CustomAudienceOperation`.
pub mod custom_audience_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::CustomAudience),
#[prost(message, tag = "2")]
Update(super::super::resources::CustomAudience),
#[prost(string, tag = "3")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomAudiencesResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateCustomAudienceResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomAudienceResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod custom_audience_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage custom audiences.
#[derive(Debug, Clone)]
pub struct CustomAudienceServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CustomAudienceServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CustomAudienceServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CustomAudienceServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates or updates custom audiences. Operation statuses are returned.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [CustomAudienceError]()
///   [CustomInterestError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [OperationAccessDeniedError]()
///   [PolicyViolationError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn mutate_custom_audiences(&mut self, request: impl tonic::IntoRequest<super::MutateCustomAudiencesRequest>) -> std::result::Result<tonic::Response<super::MutateCustomAudiencesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.CustomAudienceService/MutateCustomAudiences");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.CustomAudienceService", "MutateCustomAudiences"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegenerateShareableLinkIdRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegenerateShareableLinkIdResponse {}
/// Generated client implementations.
pub mod third_party_app_analytics_link_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This service allows management of links between Google Ads and third party
/// app analytics.
#[derive(Debug, Clone)]
pub struct ThirdPartyAppAnalyticsLinkServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ThirdPartyAppAnalyticsLinkServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ThirdPartyAppAnalyticsLinkServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ThirdPartyAppAnalyticsLinkServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Regenerate ThirdPartyAppAnalyticsLink.shareable_link_id that should be
/// provided to the third party when setting up app analytics.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn regenerate_shareable_link_id(&mut self, request: impl tonic::IntoRequest<super::RegenerateShareableLinkIdRequest>) -> std::result::Result<tonic::Response<super::RegenerateShareableLinkIdResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ThirdPartyAppAnalyticsLinkService/RegenerateShareableLinkId");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ThirdPartyAppAnalyticsLinkService", "RegenerateShareableLinkId"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGoogleAdsFieldRequest {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsFieldsRequest {
#[prost(string, tag = "1")]
pub query: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsFieldsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<super::resources::GoogleAdsField>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub total_results_count: i64,
}
/// Generated client implementations.
pub mod google_ads_field_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to fetch Google Ads API fields.
#[derive(Debug, Clone)]
pub struct GoogleAdsFieldServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> GoogleAdsFieldServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> GoogleAdsFieldServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
GoogleAdsFieldServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns just the requested field.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn get_google_ads_field(&mut self, request: impl tonic::IntoRequest<super::GetGoogleAdsFieldRequest>) -> std::result::Result<tonic::Response<super::super::resources::GoogleAdsField>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.GoogleAdsFieldService/GetGoogleAdsField");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.GoogleAdsFieldService", "GetGoogleAdsField"));
self.inner.unary(req, path, codec).await
}
/// Returns all fields that match the search query.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [QueryError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn search_google_ads_fields(&mut self, request: impl tonic::IntoRequest<super::SearchGoogleAdsFieldsRequest>) -> std::result::Result<tonic::Response<super::SearchGoogleAdsFieldsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.GoogleAdsFieldService/SearchGoogleAdsFields");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.GoogleAdsFieldService", "SearchGoogleAdsFields"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub operation: ::core::option::Option<AccountBudgetProposalOperation>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalOperation {
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(oneof = "account_budget_proposal_operation::Operation", tags = "2, 1")]
pub operation: ::core::option::Option<account_budget_proposal_operation::Operation>,
}
/// Nested message and enum types in `AccountBudgetProposalOperation`.
pub mod account_budget_proposal_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "2")]
Create(super::super::resources::AccountBudgetProposal),
#[prost(string, tag = "1")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalResponse {
#[prost(message, optional, tag = "2")]
pub result: ::core::option::Option<MutateAccountBudgetProposalResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod account_budget_proposal_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for managing account-level budgets through proposals.
///
/// A proposal is a request to create a new budget or make changes to an
/// existing one.
///
/// Mutates:
/// The CREATE operation creates a new proposal.
/// UPDATE operations aren't supported.
/// The REMOVE operation cancels a pending proposal.
#[derive(Debug, Clone)]
pub struct AccountBudgetProposalServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AccountBudgetProposalServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AccountBudgetProposalServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AccountBudgetProposalServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, updates, or removes account budget proposals.  Operation statuses
/// are returned.
///
/// List of thrown errors:
///   [AccountBudgetProposalError]()
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [DatabaseError]()
///   [DateError]()
///   [FieldError]()
///   [FieldMaskError]()
///   [HeaderError]()
///   [InternalError]()
///   [MutateError]()
///   [QuotaError]()
///   [RequestError]()
///   [StringLengthError]()
pub async fn mutate_account_budget_proposal(&mut self, request: impl tonic::IntoRequest<super::MutateAccountBudgetProposalRequest>) -> std::result::Result<tonic::Response<super::MutateAccountBudgetProposalResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AccountBudgetProposalService/MutateAccountBudgetProposal");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AccountBudgetProposalService", "MutateAccountBudgetProposal"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversionAdjustmentsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub conversion_adjustments: ::prost::alloc::vec::Vec<ConversionAdjustment>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(int32, optional, tag = "5")]
pub job_id: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversionAdjustmentsResponse {
#[prost(message, optional, tag = "1")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "2")]
pub results: ::prost::alloc::vec::Vec<ConversionAdjustmentResult>,
#[prost(int64, tag = "3")]
pub job_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionAdjustment {
#[prost(message, optional, tag = "12")]
pub gclid_date_time_pair: ::core::option::Option<GclidDateTimePair>,
#[prost(string, optional, tag = "13")]
pub order_id: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "8")]
pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "9")]
pub adjustment_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(enumeration = "super::enums::conversion_adjustment_type_enum::ConversionAdjustmentType", tag = "5")]
pub adjustment_type: i32,
#[prost(message, optional, tag = "6")]
pub restatement_value: ::core::option::Option<RestatementValue>,
#[prost(message, repeated, tag = "10")]
pub user_identifiers: ::prost::alloc::vec::Vec<super::common::UserIdentifier>,
#[prost(string, optional, tag = "11")]
pub user_agent: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestatementValue {
#[prost(double, optional, tag = "3")]
pub adjusted_value: ::core::option::Option<f64>,
#[prost(string, optional, tag = "4")]
pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GclidDateTimePair {
#[prost(string, optional, tag = "3")]
pub gclid: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "4")]
pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionAdjustmentResult {
#[prost(message, optional, tag = "9")]
pub gclid_date_time_pair: ::core::option::Option<GclidDateTimePair>,
#[prost(string, tag = "10")]
pub order_id: ::prost::alloc::string::String,
#[prost(string, optional, tag = "7")]
pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "8")]
pub adjustment_date_time: ::core::option::Option<::prost::alloc::string::String>,
#[prost(enumeration = "super::enums::conversion_adjustment_type_enum::ConversionAdjustmentType", tag = "5")]
pub adjustment_type: i32,
}
/// Generated client implementations.
pub mod conversion_adjustment_upload_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to upload conversion adjustments.
#[derive(Debug, Clone)]
pub struct ConversionAdjustmentUploadServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ConversionAdjustmentUploadServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ConversionAdjustmentUploadServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ConversionAdjustmentUploadServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Processes the given conversion adjustments.
///
/// List of thrown errors:
///   [AuthenticationError]()
///   [AuthorizationError]()
///   [HeaderError]()
///   [InternalError]()
///   [PartialFailureError]()
///   [QuotaError]()
///   [RequestError]()
pub async fn upload_conversion_adjustments(&mut self, request: impl tonic::IntoRequest<super::UploadConversionAdjustmentsRequest>) -> std::result::Result<tonic::Response<super::UploadConversionAdjustmentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.ConversionAdjustmentUploadService/UploadConversionAdjustments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.ConversionAdjustmentUploadService", "UploadConversionAdjustments"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetSetsRequest {
#[prost(string, tag = "1")]
pub customer_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub operations: ::prost::alloc::vec::Vec<AdGroupAssetSetOperation>,
#[prost(bool, tag = "3")]
pub partial_failure: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
#[prost(enumeration = "super::enums::response_content_type_enum::ResponseContentType", tag = "5")]
pub response_content_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAssetSetOperation {
#[prost(oneof = "ad_group_asset_set_operation::Operation", tags = "1, 2")]
pub operation: ::core::option::Option<ad_group_asset_set_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAssetSetOperation`.
pub mod ad_group_asset_set_operation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Create(super::super::resources::AdGroupAssetSet),
#[prost(string, tag = "2")]
Remove(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetSetsResponse {
#[prost(message, repeated, tag = "1")]
pub results: ::prost::alloc::vec::Vec<MutateAdGroupAssetSetResult>,
#[prost(message, optional, tag = "2")]
pub partial_failure_error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetSetResult {
#[prost(string, tag = "1")]
pub resource_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub ad_group_asset_set: ::core::option::Option<super::resources::AdGroupAssetSet>,
}
/// Generated client implementations.
pub mod ad_group_asset_set_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service to manage ad group asset set
#[derive(Debug, Clone)]
pub struct AdGroupAssetSetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdGroupAssetSetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdGroupAssetSetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdGroupAssetSetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates, or removes ad group asset sets. Operation statuses are
/// returned.
pub async fn mutate_ad_group_asset_sets(&mut self, request: impl tonic::IntoRequest<super::MutateAdGroupAssetSetsRequest>) -> std::result::Result<tonic::Response<super::MutateAdGroupAssetSetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.googleads.v17.services.AdGroupAssetSetService/MutateAdGroupAssetSets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.googleads.v17.services.AdGroupAssetSetService", "MutateAdGroupAssetSets"));
self.inner.unary(req, path, codec).await
}
}
}
