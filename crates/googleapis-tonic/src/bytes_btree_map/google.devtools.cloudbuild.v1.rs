// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryBuildRequest {
#[prost(string, tag = "3")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunBuildTriggerRequest {
#[prost(string, tag = "4")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub trigger_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub source: ::core::option::Option<RepoSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageSource {
#[prost(string, tag = "1")]
pub bucket: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub object: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub generation: i64,
#[prost(enumeration = "storage_source::SourceFetcher", tag = "5")]
pub source_fetcher: i32,
}
/// Nested message and enum types in `StorageSource`.
pub mod storage_source {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SourceFetcher {
Unspecified = 0,
Gsutil = 1,
GcsFetcher = 2,
}
impl SourceFetcher {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SourceFetcher::Unspecified => "SOURCE_FETCHER_UNSPECIFIED",
SourceFetcher::Gsutil => "GSUTIL",
SourceFetcher::GcsFetcher => "GCS_FETCHER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SOURCE_FETCHER_UNSPECIFIED" => Some(Self::Unspecified),
"GSUTIL" => Some(Self::Gsutil),
"GCS_FETCHER" => Some(Self::GcsFetcher),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitSource {
#[prost(string, tag = "1")]
pub url: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub dir: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub revision: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepoSource {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub repo_name: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub dir: ::prost::alloc::string::String,
#[prost(bool, tag = "8")]
pub invert_regex: bool,
#[prost(btree_map = "string, string", tag = "9")]
pub substitutions: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(oneof = "repo_source::Revision", tags = "3, 4, 5")]
pub revision: ::core::option::Option<repo_source::Revision>,
}
/// Nested message and enum types in `RepoSource`.
pub mod repo_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Revision {
#[prost(string, tag = "3")]
BranchName(::prost::alloc::string::String),
#[prost(string, tag = "4")]
TagName(::prost::alloc::string::String),
#[prost(string, tag = "5")]
CommitSha(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageSourceManifest {
#[prost(string, tag = "1")]
pub bucket: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub object: ::prost::alloc::string::String,
#[prost(int64, tag = "3")]
pub generation: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Source {
#[prost(oneof = "source::Source", tags = "2, 3, 5, 8")]
pub source: ::core::option::Option<source::Source>,
}
/// Nested message and enum types in `Source`.
pub mod source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
StorageSource(super::StorageSource),
#[prost(message, tag = "3")]
RepoSource(super::RepoSource),
#[prost(message, tag = "5")]
GitSource(super::GitSource),
#[prost(message, tag = "8")]
StorageSourceManifest(super::StorageSourceManifest),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuiltImage {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub digest: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub push_timing: ::core::option::Option<TimeSpan>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadedPythonPackage {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub file_hashes: ::core::option::Option<FileHashes>,
#[prost(message, optional, tag = "3")]
pub push_timing: ::core::option::Option<TimeSpan>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadedMavenArtifact {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub file_hashes: ::core::option::Option<FileHashes>,
#[prost(message, optional, tag = "3")]
pub push_timing: ::core::option::Option<TimeSpan>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadedNpmPackage {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub file_hashes: ::core::option::Option<FileHashes>,
#[prost(message, optional, tag = "3")]
pub push_timing: ::core::option::Option<TimeSpan>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildStep {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub dir: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "6")]
pub wait_for: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub entrypoint: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "8")]
pub secret_env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "9")]
pub volumes: ::prost::alloc::vec::Vec<Volume>,
#[prost(message, optional, tag = "10")]
pub timing: ::core::option::Option<TimeSpan>,
#[prost(message, optional, tag = "13")]
pub pull_timing: ::core::option::Option<TimeSpan>,
#[prost(message, optional, tag = "11")]
pub timeout: ::core::option::Option<::prost_types::Duration>,
#[prost(enumeration = "build::Status", tag = "12")]
pub status: i32,
#[prost(bool, tag = "14")]
pub allow_failure: bool,
#[prost(int32, tag = "16")]
pub exit_code: i32,
#[prost(int32, repeated, tag = "18")]
pub allow_exit_codes: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "19")]
pub script: ::prost::alloc::string::String,
#[prost(bool, optional, tag = "20")]
pub automap_substitutions: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Volume {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Results {
#[prost(message, repeated, tag = "2")]
pub images: ::prost::alloc::vec::Vec<BuiltImage>,
#[prost(string, repeated, tag = "3")]
pub build_step_images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub artifact_manifest: ::prost::alloc::string::String,
#[prost(int64, tag = "5")]
pub num_artifacts: i64,
#[prost(bytes = "bytes", repeated, tag = "6")]
pub build_step_outputs: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
#[prost(message, optional, tag = "7")]
pub artifact_timing: ::core::option::Option<TimeSpan>,
#[prost(message, repeated, tag = "8")]
pub python_packages: ::prost::alloc::vec::Vec<UploadedPythonPackage>,
#[prost(message, repeated, tag = "9")]
pub maven_artifacts: ::prost::alloc::vec::Vec<UploadedMavenArtifact>,
#[prost(message, repeated, tag = "12")]
pub npm_packages: ::prost::alloc::vec::Vec<UploadedNpmPackage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactResult {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub file_hash: ::prost::alloc::vec::Vec<FileHashes>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Build {
#[prost(string, tag = "45")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "16")]
pub project_id: ::prost::alloc::string::String,
#[prost(enumeration = "build::Status", tag = "2")]
pub status: i32,
#[prost(string, tag = "24")]
pub status_detail: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub source: ::core::option::Option<Source>,
#[prost(message, repeated, tag = "11")]
pub steps: ::prost::alloc::vec::Vec<BuildStep>,
#[prost(message, optional, tag = "10")]
pub results: ::core::option::Option<Results>,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub finish_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "12")]
pub timeout: ::core::option::Option<::prost_types::Duration>,
#[prost(string, repeated, tag = "13")]
pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "40")]
pub queue_ttl: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "37")]
pub artifacts: ::core::option::Option<Artifacts>,
#[prost(string, tag = "19")]
pub logs_bucket: ::prost::alloc::string::String,
#[prost(message, optional, tag = "21")]
pub source_provenance: ::core::option::Option<SourceProvenance>,
#[prost(string, tag = "22")]
pub build_trigger_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "23")]
pub options: ::core::option::Option<BuildOptions>,
#[prost(string, tag = "25")]
pub log_url: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "29")]
pub substitutions: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, repeated, tag = "31")]
pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "32")]
pub secrets: ::prost::alloc::vec::Vec<Secret>,
#[prost(btree_map = "string, message", tag = "33")]
pub timing: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, TimeSpan>,
#[prost(message, optional, tag = "44")]
pub approval: ::core::option::Option<BuildApproval>,
#[prost(string, tag = "42")]
pub service_account: ::prost::alloc::string::String,
#[prost(message, optional, tag = "47")]
pub available_secrets: ::core::option::Option<Secrets>,
#[prost(message, repeated, tag = "49")]
pub warnings: ::prost::alloc::vec::Vec<build::Warning>,
#[prost(message, optional, tag = "51")]
pub failure_info: ::core::option::Option<build::FailureInfo>,
}
/// Nested message and enum types in `Build`.
pub mod build {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Warning {
#[prost(string, tag = "1")]
pub text: ::prost::alloc::string::String,
#[prost(enumeration = "warning::Priority", tag = "2")]
pub priority: i32,
}
/// Nested message and enum types in `Warning`.
pub mod warning {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Priority {
Unspecified = 0,
Info = 1,
Warning = 2,
Alert = 3,
}
impl Priority {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Priority::Unspecified => "PRIORITY_UNSPECIFIED",
Priority::Info => "INFO",
Priority::Warning => "WARNING",
Priority::Alert => "ALERT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PRIORITY_UNSPECIFIED" => Some(Self::Unspecified),
"INFO" => Some(Self::Info),
"WARNING" => Some(Self::Warning),
"ALERT" => Some(Self::Alert),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailureInfo {
#[prost(enumeration = "failure_info::FailureType", tag = "1")]
pub r#type: i32,
#[prost(string, tag = "2")]
pub detail: ::prost::alloc::string::String,
}
/// Nested message and enum types in `FailureInfo`.
pub mod failure_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FailureType {
Unspecified = 0,
PushFailed = 1,
PushImageNotFound = 2,
PushNotAuthorized = 3,
LoggingFailure = 4,
UserBuildStep = 5,
FetchSourceFailed = 6,
}
impl FailureType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FailureType::Unspecified => "FAILURE_TYPE_UNSPECIFIED",
FailureType::PushFailed => "PUSH_FAILED",
FailureType::PushImageNotFound => "PUSH_IMAGE_NOT_FOUND",
FailureType::PushNotAuthorized => "PUSH_NOT_AUTHORIZED",
FailureType::LoggingFailure => "LOGGING_FAILURE",
FailureType::UserBuildStep => "USER_BUILD_STEP",
FailureType::FetchSourceFailed => "FETCH_SOURCE_FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FAILURE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PUSH_FAILED" => Some(Self::PushFailed),
"PUSH_IMAGE_NOT_FOUND" => Some(Self::PushImageNotFound),
"PUSH_NOT_AUTHORIZED" => Some(Self::PushNotAuthorized),
"LOGGING_FAILURE" => Some(Self::LoggingFailure),
"USER_BUILD_STEP" => Some(Self::UserBuildStep),
"FETCH_SOURCE_FAILED" => Some(Self::FetchSourceFailed),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
Unknown = 0,
Pending = 10,
Queued = 1,
Working = 2,
Success = 3,
Failure = 4,
InternalError = 5,
Timeout = 6,
Cancelled = 7,
Expired = 9,
}
impl Status {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Status::Unknown => "STATUS_UNKNOWN",
Status::Pending => "PENDING",
Status::Queued => "QUEUED",
Status::Working => "WORKING",
Status::Success => "SUCCESS",
Status::Failure => "FAILURE",
Status::InternalError => "INTERNAL_ERROR",
Status::Timeout => "TIMEOUT",
Status::Cancelled => "CANCELLED",
Status::Expired => "EXPIRED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATUS_UNKNOWN" => Some(Self::Unknown),
"PENDING" => Some(Self::Pending),
"QUEUED" => Some(Self::Queued),
"WORKING" => Some(Self::Working),
"SUCCESS" => Some(Self::Success),
"FAILURE" => Some(Self::Failure),
"INTERNAL_ERROR" => Some(Self::InternalError),
"TIMEOUT" => Some(Self::Timeout),
"CANCELLED" => Some(Self::Cancelled),
"EXPIRED" => Some(Self::Expired),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifacts {
#[prost(string, repeated, tag = "1")]
pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "2")]
pub objects: ::core::option::Option<artifacts::ArtifactObjects>,
#[prost(message, repeated, tag = "3")]
pub maven_artifacts: ::prost::alloc::vec::Vec<artifacts::MavenArtifact>,
#[prost(message, repeated, tag = "5")]
pub python_packages: ::prost::alloc::vec::Vec<artifacts::PythonPackage>,
#[prost(message, repeated, tag = "6")]
pub npm_packages: ::prost::alloc::vec::Vec<artifacts::NpmPackage>,
}
/// Nested message and enum types in `Artifacts`.
pub mod artifacts {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactObjects {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub timing: ::core::option::Option<super::TimeSpan>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MavenArtifact {
#[prost(string, tag = "1")]
pub repository: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub path: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub artifact_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub group_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PythonPackage {
#[prost(string, tag = "1")]
pub repository: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NpmPackage {
#[prost(string, tag = "1")]
pub repository: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub package_path: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeSpan {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildOperationMetadata {
#[prost(message, optional, tag = "1")]
pub build: ::core::option::Option<Build>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceProvenance {
#[prost(message, optional, tag = "3")]
pub resolved_storage_source: ::core::option::Option<StorageSource>,
#[prost(message, optional, tag = "6")]
pub resolved_repo_source: ::core::option::Option<RepoSource>,
#[prost(message, optional, tag = "9")]
pub resolved_storage_source_manifest: ::core::option::Option<StorageSourceManifest>,
#[prost(btree_map = "string, message", tag = "4")]
pub file_hashes: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, FileHashes>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileHashes {
#[prost(message, repeated, tag = "1")]
pub file_hash: ::prost::alloc::vec::Vec<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hash {
#[prost(enumeration = "hash::HashType", tag = "1")]
pub r#type: i32,
#[prost(bytes = "bytes", tag = "2")]
pub value: ::prost::bytes::Bytes,
}
/// Nested message and enum types in `Hash`.
pub mod hash {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashType {
None = 0,
Sha256 = 1,
Md5 = 2,
Sha512 = 4,
}
impl HashType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HashType::None => "NONE",
HashType::Sha256 => "SHA256",
HashType::Md5 => "MD5",
HashType::Sha512 => "SHA512",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NONE" => Some(Self::None),
"SHA256" => Some(Self::Sha256),
"MD5" => Some(Self::Md5),
"SHA512" => Some(Self::Sha512),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secrets {
#[prost(message, repeated, tag = "1")]
pub secret_manager: ::prost::alloc::vec::Vec<SecretManagerSecret>,
#[prost(message, repeated, tag = "2")]
pub inline: ::prost::alloc::vec::Vec<InlineSecret>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineSecret {
#[prost(string, tag = "1")]
pub kms_key_name: ::prost::alloc::string::String,
#[prost(btree_map = "string, bytes", tag = "2")]
pub env_map: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::bytes::Bytes>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretManagerSecret {
#[prost(string, tag = "1")]
pub version_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub env: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
#[prost(string, tag = "1")]
pub kms_key_name: ::prost::alloc::string::String,
#[prost(btree_map = "string, bytes", tag = "3")]
pub secret_env: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::bytes::Bytes>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBuildRequest {
#[prost(string, tag = "4")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub build: ::core::option::Option<Build>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBuildRequest {
#[prost(string, tag = "4")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildsRequest {
#[prost(string, tag = "9")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildsResponse {
#[prost(message, repeated, tag = "1")]
pub builds: ::prost::alloc::vec::Vec<Build>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelBuildRequest {
#[prost(string, tag = "4")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveBuildRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub approval_result: ::core::option::Option<ApprovalResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildApproval {
#[prost(enumeration = "build_approval::State", tag = "1")]
pub state: i32,
#[prost(message, optional, tag = "2")]
pub config: ::core::option::Option<ApprovalConfig>,
#[prost(message, optional, tag = "3")]
pub result: ::core::option::Option<ApprovalResult>,
}
/// Nested message and enum types in `BuildApproval`.
pub mod build_approval {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Approved = 2,
Rejected = 3,
Cancelled = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Approved => "APPROVED",
State::Rejected => "REJECTED",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"APPROVED" => Some(Self::Approved),
"REJECTED" => Some(Self::Rejected),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApprovalConfig {
#[prost(bool, tag = "1")]
pub approval_required: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApprovalResult {
#[prost(string, tag = "2")]
pub approver_account: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub approval_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "approval_result::Decision", tag = "4")]
pub decision: i32,
#[prost(string, tag = "5")]
pub comment: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub url: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ApprovalResult`.
pub mod approval_result {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Decision {
Unspecified = 0,
Approved = 1,
Rejected = 2,
}
impl Decision {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Decision::Unspecified => "DECISION_UNSPECIFIED",
Decision::Approved => "APPROVED",
Decision::Rejected => "REJECTED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DECISION_UNSPECIFIED" => Some(Self::Unspecified),
"APPROVED" => Some(Self::Approved),
"REJECTED" => Some(Self::Rejected),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitRepoSource {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub r#ref: ::prost::alloc::string::String,
#[prost(enumeration = "git_file_source::RepoType", tag = "3")]
pub repo_type: i32,
#[prost(oneof = "git_repo_source::Source", tags = "6")]
pub source: ::core::option::Option<git_repo_source::Source>,
#[prost(oneof = "git_repo_source::EnterpriseConfig", tags = "4")]
pub enterprise_config: ::core::option::Option<git_repo_source::EnterpriseConfig>,
}
/// Nested message and enum types in `GitRepoSource`.
pub mod git_repo_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(string, tag = "6")]
Repository(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EnterpriseConfig {
#[prost(string, tag = "4")]
GithubEnterpriseConfig(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitFileSource {
#[prost(string, tag = "1")]
pub path: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(enumeration = "git_file_source::RepoType", tag = "3")]
pub repo_type: i32,
#[prost(string, tag = "4")]
pub revision: ::prost::alloc::string::String,
#[prost(oneof = "git_file_source::Source", tags = "7")]
pub source: ::core::option::Option<git_file_source::Source>,
#[prost(oneof = "git_file_source::EnterpriseConfig", tags = "5")]
pub enterprise_config: ::core::option::Option<git_file_source::EnterpriseConfig>,
}
/// Nested message and enum types in `GitFileSource`.
pub mod git_file_source {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RepoType {
Unknown = 0,
CloudSourceRepositories = 1,
Github = 2,
BitbucketServer = 3,
Gitlab = 4,
}
impl RepoType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RepoType::Unknown => "UNKNOWN",
RepoType::CloudSourceRepositories => "CLOUD_SOURCE_REPOSITORIES",
RepoType::Github => "GITHUB",
RepoType::BitbucketServer => "BITBUCKET_SERVER",
RepoType::Gitlab => "GITLAB",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"UNKNOWN" => Some(Self::Unknown),
"CLOUD_SOURCE_REPOSITORIES" => Some(Self::CloudSourceRepositories),
"GITHUB" => Some(Self::Github),
"BITBUCKET_SERVER" => Some(Self::BitbucketServer),
"GITLAB" => Some(Self::Gitlab),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(string, tag = "7")]
Repository(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EnterpriseConfig {
#[prost(string, tag = "5")]
GithubEnterpriseConfig(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildTrigger {
#[prost(string, tag = "34")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "21")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "19")]
pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub trigger_template: ::core::option::Option<RepoSource>,
#[prost(message, optional, tag = "13")]
pub github: ::core::option::Option<GitHubEventsConfig>,
#[prost(message, optional, tag = "29")]
pub pubsub_config: ::core::option::Option<PubsubConfig>,
#[prost(message, optional, tag = "31")]
pub webhook_config: ::core::option::Option<WebhookConfig>,
#[prost(message, optional, tag = "5")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(bool, tag = "9")]
pub disabled: bool,
#[prost(btree_map = "string, string", tag = "11")]
pub substitutions: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, repeated, tag = "15")]
pub ignored_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "16")]
pub included_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "30")]
pub filter: ::prost::alloc::string::String,
#[prost(message, optional, tag = "26")]
pub source_to_build: ::core::option::Option<GitRepoSource>,
#[prost(string, tag = "33")]
pub service_account: ::prost::alloc::string::String,
#[prost(message, optional, tag = "39")]
pub repository_event_config: ::core::option::Option<RepositoryEventConfig>,
#[prost(oneof = "build_trigger::BuildTemplate", tags = "18, 4, 8, 24")]
pub build_template: ::core::option::Option<build_trigger::BuildTemplate>,
}
/// Nested message and enum types in `BuildTrigger`.
pub mod build_trigger {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum BuildTemplate {
#[prost(bool, tag = "18")]
Autodetect(bool),
#[prost(message, tag = "4")]
Build(super::Build),
#[prost(string, tag = "8")]
Filename(::prost::alloc::string::String),
#[prost(message, tag = "24")]
GitFileSource(super::GitFileSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepositoryEventConfig {
#[prost(string, tag = "1")]
pub repository: ::prost::alloc::string::String,
#[prost(enumeration = "repository_event_config::RepositoryType", tag = "2")]
pub repository_type: i32,
#[prost(oneof = "repository_event_config::Filter", tags = "3, 4")]
pub filter: ::core::option::Option<repository_event_config::Filter>,
}
/// Nested message and enum types in `RepositoryEventConfig`.
pub mod repository_event_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RepositoryType {
Unspecified = 0,
Github = 1,
GithubEnterprise = 2,
GitlabEnterprise = 3,
}
impl RepositoryType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RepositoryType::Unspecified => "REPOSITORY_TYPE_UNSPECIFIED",
RepositoryType::Github => "GITHUB",
RepositoryType::GithubEnterprise => "GITHUB_ENTERPRISE",
RepositoryType::GitlabEnterprise => "GITLAB_ENTERPRISE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"REPOSITORY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"GITHUB" => Some(Self::Github),
"GITHUB_ENTERPRISE" => Some(Self::GithubEnterprise),
"GITLAB_ENTERPRISE" => Some(Self::GitlabEnterprise),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Filter {
#[prost(message, tag = "3")]
PullRequest(super::PullRequestFilter),
#[prost(message, tag = "4")]
Push(super::PushFilter),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubEventsConfig {
#[deprecated]
#[prost(int64, tag = "1")]
pub installation_id: i64,
#[prost(string, tag = "6")]
pub owner: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
#[prost(oneof = "git_hub_events_config::Event", tags = "4, 5")]
pub event: ::core::option::Option<git_hub_events_config::Event>,
}
/// Nested message and enum types in `GitHubEventsConfig`.
pub mod git_hub_events_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Event {
#[prost(message, tag = "4")]
PullRequest(super::PullRequestFilter),
#[prost(message, tag = "5")]
Push(super::PushFilter),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubConfig {
#[prost(string, tag = "1")]
pub subscription: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub topic: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub service_account_email: ::prost::alloc::string::String,
#[prost(enumeration = "pubsub_config::State", tag = "4")]
pub state: i32,
}
/// Nested message and enum types in `PubsubConfig`.
pub mod pubsub_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Ok = 1,
SubscriptionDeleted = 2,
TopicDeleted = 3,
SubscriptionMisconfigured = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Ok => "OK",
State::SubscriptionDeleted => "SUBSCRIPTION_DELETED",
State::TopicDeleted => "TOPIC_DELETED",
State::SubscriptionMisconfigured => "SUBSCRIPTION_MISCONFIGURED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"OK" => Some(Self::Ok),
"SUBSCRIPTION_DELETED" => Some(Self::SubscriptionDeleted),
"TOPIC_DELETED" => Some(Self::TopicDeleted),
"SUBSCRIPTION_MISCONFIGURED" => Some(Self::SubscriptionMisconfigured),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookConfig {
#[prost(enumeration = "webhook_config::State", tag = "4")]
pub state: i32,
#[prost(oneof = "webhook_config::AuthMethod", tags = "3")]
pub auth_method: ::core::option::Option<webhook_config::AuthMethod>,
}
/// Nested message and enum types in `WebhookConfig`.
pub mod webhook_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Ok = 1,
SecretDeleted = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Ok => "OK",
State::SecretDeleted => "SECRET_DELETED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"OK" => Some(Self::Ok),
"SECRET_DELETED" => Some(Self::SecretDeleted),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum AuthMethod {
#[prost(string, tag = "3")]
Secret(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullRequestFilter {
#[prost(enumeration = "pull_request_filter::CommentControl", tag = "5")]
pub comment_control: i32,
#[prost(bool, tag = "6")]
pub invert_regex: bool,
#[prost(oneof = "pull_request_filter::GitRef", tags = "2")]
pub git_ref: ::core::option::Option<pull_request_filter::GitRef>,
}
/// Nested message and enum types in `PullRequestFilter`.
pub mod pull_request_filter {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommentControl {
CommentsDisabled = 0,
CommentsEnabled = 1,
CommentsEnabledForExternalContributorsOnly = 2,
}
impl CommentControl {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CommentControl::CommentsDisabled => "COMMENTS_DISABLED",
CommentControl::CommentsEnabled => "COMMENTS_ENABLED",
CommentControl::CommentsEnabledForExternalContributorsOnly => "COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMMENTS_DISABLED" => Some(Self::CommentsDisabled),
"COMMENTS_ENABLED" => Some(Self::CommentsEnabled),
"COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY" => Some(Self::CommentsEnabledForExternalContributorsOnly),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum GitRef {
#[prost(string, tag = "2")]
Branch(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushFilter {
#[prost(bool, tag = "4")]
pub invert_regex: bool,
#[prost(oneof = "push_filter::GitRef", tags = "2, 3")]
pub git_ref: ::core::option::Option<push_filter::GitRef>,
}
/// Nested message and enum types in `PushFilter`.
pub mod push_filter {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum GitRef {
#[prost(string, tag = "2")]
Branch(::prost::alloc::string::String),
#[prost(string, tag = "3")]
Tag(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBuildTriggerRequest {
#[prost(string, tag = "3")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub trigger: ::core::option::Option<BuildTrigger>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBuildTriggerRequest {
#[prost(string, tag = "3")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub trigger_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildTriggersRequest {
#[prost(string, tag = "4")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildTriggersResponse {
#[prost(message, repeated, tag = "1")]
pub triggers: ::prost::alloc::vec::Vec<BuildTrigger>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBuildTriggerRequest {
#[prost(string, tag = "3")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub trigger_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBuildTriggerRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub trigger_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub trigger: ::core::option::Option<BuildTrigger>,
#[prost(message, optional, tag = "5")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildOptions {
#[prost(enumeration = "hash::HashType", repeated, tag = "1")]
pub source_provenance_hash: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "build_options::VerifyOption", tag = "2")]
pub requested_verify_option: i32,
#[prost(enumeration = "build_options::MachineType", tag = "3")]
pub machine_type: i32,
#[prost(int64, tag = "6")]
pub disk_size_gb: i64,
#[prost(enumeration = "build_options::SubstitutionOption", tag = "4")]
pub substitution_option: i32,
#[prost(bool, tag = "17")]
pub dynamic_substitutions: bool,
#[prost(bool, tag = "22")]
pub automap_substitutions: bool,
#[prost(enumeration = "build_options::LogStreamingOption", tag = "5")]
pub log_streaming_option: i32,
#[deprecated]
#[prost(string, tag = "7")]
pub worker_pool: ::prost::alloc::string::String,
#[prost(message, optional, tag = "19")]
pub pool: ::core::option::Option<build_options::PoolOption>,
#[prost(enumeration = "build_options::LoggingMode", tag = "11")]
pub logging: i32,
#[prost(string, repeated, tag = "12")]
pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "13")]
pub secret_env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "14")]
pub volumes: ::prost::alloc::vec::Vec<Volume>,
#[prost(enumeration = "build_options::DefaultLogsBucketBehavior", tag = "21")]
pub default_logs_bucket_behavior: i32,
}
/// Nested message and enum types in `BuildOptions`.
pub mod build_options {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolOption {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerifyOption {
NotVerified = 0,
Verified = 1,
}
impl VerifyOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
VerifyOption::NotVerified => "NOT_VERIFIED",
VerifyOption::Verified => "VERIFIED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NOT_VERIFIED" => Some(Self::NotVerified),
"VERIFIED" => Some(Self::Verified),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MachineType {
Unspecified = 0,
N1Highcpu8 = 1,
N1Highcpu32 = 2,
E2Highcpu8 = 5,
E2Highcpu32 = 6,
E2Medium = 7,
}
impl MachineType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MachineType::Unspecified => "UNSPECIFIED",
MachineType::N1Highcpu8 => "N1_HIGHCPU_8",
MachineType::N1Highcpu32 => "N1_HIGHCPU_32",
MachineType::E2Highcpu8 => "E2_HIGHCPU_8",
MachineType::E2Highcpu32 => "E2_HIGHCPU_32",
MachineType::E2Medium => "E2_MEDIUM",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"UNSPECIFIED" => Some(Self::Unspecified),
"N1_HIGHCPU_8" => Some(Self::N1Highcpu8),
"N1_HIGHCPU_32" => Some(Self::N1Highcpu32),
"E2_HIGHCPU_8" => Some(Self::E2Highcpu8),
"E2_HIGHCPU_32" => Some(Self::E2Highcpu32),
"E2_MEDIUM" => Some(Self::E2Medium),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubstitutionOption {
MustMatch = 0,
AllowLoose = 1,
}
impl SubstitutionOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SubstitutionOption::MustMatch => "MUST_MATCH",
SubstitutionOption::AllowLoose => "ALLOW_LOOSE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MUST_MATCH" => Some(Self::MustMatch),
"ALLOW_LOOSE" => Some(Self::AllowLoose),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogStreamingOption {
StreamDefault = 0,
StreamOn = 1,
StreamOff = 2,
}
impl LogStreamingOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LogStreamingOption::StreamDefault => "STREAM_DEFAULT",
LogStreamingOption::StreamOn => "STREAM_ON",
LogStreamingOption::StreamOff => "STREAM_OFF",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STREAM_DEFAULT" => Some(Self::StreamDefault),
"STREAM_ON" => Some(Self::StreamOn),
"STREAM_OFF" => Some(Self::StreamOff),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoggingMode {
LoggingUnspecified = 0,
Legacy = 1,
GcsOnly = 2,
StackdriverOnly = 3,
CloudLoggingOnly = 5,
None = 4,
}
impl LoggingMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LoggingMode::LoggingUnspecified => "LOGGING_UNSPECIFIED",
LoggingMode::Legacy => "LEGACY",
LoggingMode::GcsOnly => "GCS_ONLY",
LoggingMode::StackdriverOnly => "STACKDRIVER_ONLY",
LoggingMode::CloudLoggingOnly => "CLOUD_LOGGING_ONLY",
LoggingMode::None => "NONE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOGGING_UNSPECIFIED" => Some(Self::LoggingUnspecified),
"LEGACY" => Some(Self::Legacy),
"GCS_ONLY" => Some(Self::GcsOnly),
"STACKDRIVER_ONLY" => Some(Self::StackdriverOnly),
"CLOUD_LOGGING_ONLY" => Some(Self::CloudLoggingOnly),
"NONE" => Some(Self::None),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DefaultLogsBucketBehavior {
Unspecified = 0,
RegionalUserOwnedBucket = 1,
}
impl DefaultLogsBucketBehavior {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DefaultLogsBucketBehavior::Unspecified => "DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED",
DefaultLogsBucketBehavior::RegionalUserOwnedBucket => "REGIONAL_USER_OWNED_BUCKET",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
"REGIONAL_USER_OWNED_BUCKET" => Some(Self::RegionalUserOwnedBucket),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiveTriggerWebhookRequest {
#[prost(string, tag = "5")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "1")]
pub body: ::core::option::Option<super::super::super::api::HttpBody>,
#[prost(string, tag = "2")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub trigger: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub secret: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceiveTriggerWebhookResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubEnterpriseConfig {
#[prost(string, tag = "7")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub host_url: ::prost::alloc::string::String,
#[prost(int64, tag = "4")]
pub app_id: i64,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "8")]
pub webhook_key: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub peered_network: ::prost::alloc::string::String,
#[prost(message, optional, tag = "10")]
pub secrets: ::core::option::Option<GitHubEnterpriseSecrets>,
#[prost(string, tag = "11")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "12")]
pub ssl_ca: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubEnterpriseSecrets {
#[prost(string, tag = "5")]
pub private_key_version_name: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub webhook_secret_version_name: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub oauth_secret_version_name: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub oauth_client_id_version_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerPool {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub uid: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "4")]
pub annotations: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "5")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "worker_pool::State", tag = "8")]
pub state: i32,
#[prost(string, tag = "11")]
pub etag: ::prost::alloc::string::String,
#[prost(oneof = "worker_pool::Config", tags = "12")]
pub config: ::core::option::Option<worker_pool::Config>,
}
/// Nested message and enum types in `WorkerPool`.
pub mod worker_pool {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Running = 2,
Deleting = 3,
Deleted = 4,
Updating = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Running => "RUNNING",
State::Deleting => "DELETING",
State::Deleted => "DELETED",
State::Updating => "UPDATING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"RUNNING" => Some(Self::Running),
"DELETING" => Some(Self::Deleting),
"DELETED" => Some(Self::Deleted),
"UPDATING" => Some(Self::Updating),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Config {
#[prost(message, tag = "12")]
PrivatePoolV1Config(super::PrivatePoolV1Config),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePoolV1Config {
#[prost(message, optional, tag = "1")]
pub worker_config: ::core::option::Option<private_pool_v1_config::WorkerConfig>,
#[prost(message, optional, tag = "2")]
pub network_config: ::core::option::Option<private_pool_v1_config::NetworkConfig>,
}
/// Nested message and enum types in `PrivatePoolV1Config`.
pub mod private_pool_v1_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerConfig {
#[prost(string, tag = "1")]
pub machine_type: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub disk_size_gb: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
#[prost(string, tag = "1")]
pub peered_network: ::prost::alloc::string::String,
#[prost(enumeration = "network_config::EgressOption", tag = "2")]
pub egress_option: i32,
#[prost(string, tag = "3")]
pub peered_network_ip_range: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NetworkConfig`.
pub mod network_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EgressOption {
Unspecified = 0,
NoPublicEgress = 1,
PublicEgress = 2,
}
impl EgressOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EgressOption::Unspecified => "EGRESS_OPTION_UNSPECIFIED",
EgressOption::NoPublicEgress => "NO_PUBLIC_EGRESS",
EgressOption::PublicEgress => "PUBLIC_EGRESS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EGRESS_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"NO_PUBLIC_EGRESS" => Some(Self::NoPublicEgress),
"PUBLIC_EGRESS" => Some(Self::PublicEgress),
_ => None,
}
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkerPoolRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub worker_pool: ::core::option::Option<WorkerPool>,
#[prost(string, tag = "3")]
pub worker_pool_id: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerPoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkerPoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub allow_missing: bool,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerPoolRequest {
#[prost(message, optional, tag = "1")]
pub worker_pool: ::core::option::Option<WorkerPool>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkerPoolsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkerPoolsResponse {
#[prost(message, repeated, tag = "1")]
pub worker_pools: ::prost::alloc::vec::Vec<WorkerPool>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkerPoolOperationMetadata {
#[prost(string, tag = "1")]
pub worker_pool: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerPoolOperationMetadata {
#[prost(string, tag = "1")]
pub worker_pool: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkerPoolOperationMetadata {
#[prost(string, tag = "1")]
pub worker_pool: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod cloud_build_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Creates and manages builds on Google Cloud Platform.
///
/// The main concept used by this API is a `Build`, which describes the location
/// of the source to build, how to build the source, and where to store the
/// built artifacts, if any.
///
/// A user can list previously-requested builds or get builds by their ID to
/// determine the status of the build.
#[derive(Debug, Clone)]
pub struct CloudBuildClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CloudBuildClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CloudBuildClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CloudBuildClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Starts a build with the specified configuration.
///
/// This method returns a long-running `Operation`, which includes the build
/// ID. Pass the build ID to `GetBuild` to determine the build status (such as
/// `SUCCESS` or `FAILURE`).
pub async fn create_build(&mut self, request: impl tonic::IntoRequest<super::CreateBuildRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/CreateBuild");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "CreateBuild"));
self.inner.unary(req, path, codec).await
}
/// Returns information about a previously requested build.
///
/// The `Build` that is returned includes its status (such as `SUCCESS`,
/// `FAILURE`, or `WORKING`), and timing information.
pub async fn get_build(&mut self, request: impl tonic::IntoRequest<super::GetBuildRequest>) -> std::result::Result<tonic::Response<super::Build>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/GetBuild");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "GetBuild"));
self.inner.unary(req, path, codec).await
}
/// Lists previously requested builds.
///
/// Previously requested builds may still be in-progress, or may have finished
/// successfully or unsuccessfully.
pub async fn list_builds(&mut self, request: impl tonic::IntoRequest<super::ListBuildsRequest>) -> std::result::Result<tonic::Response<super::ListBuildsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/ListBuilds");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "ListBuilds"));
self.inner.unary(req, path, codec).await
}
/// Cancels a build in progress.
pub async fn cancel_build(&mut self, request: impl tonic::IntoRequest<super::CancelBuildRequest>) -> std::result::Result<tonic::Response<super::Build>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/CancelBuild");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "CancelBuild"));
self.inner.unary(req, path, codec).await
}
/// Creates a new build based on the specified build.
///
/// This method creates a new build using the original build request, which may
/// or may not result in an identical build.
///
/// For triggered builds:
///
/// * Triggered builds resolve to a precise revision; therefore a retry of a
/// triggered build will result in a build that uses the same revision.
///
/// For non-triggered builds that specify `RepoSource`:
///
/// * If the original build built from the tip of a branch, the retried build
/// will build from the tip of that branch, which may not be the same revision
/// as the original build.
/// * If the original build specified a commit sha or revision ID, the retried
/// build will use the identical source.
///
/// For builds that specify `StorageSource`:
///
/// * If the original build pulled source from Cloud Storage without
/// specifying the generation of the object, the new build will use the current
/// object, which may be different from the original build source.
/// * If the original build pulled source from Cloud Storage and specified the
/// generation of the object, the new build will attempt to use the same
/// object, which may or may not be available depending on the bucket's
/// lifecycle management settings.
pub async fn retry_build(&mut self, request: impl tonic::IntoRequest<super::RetryBuildRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/RetryBuild");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "RetryBuild"));
self.inner.unary(req, path, codec).await
}
/// Approves or rejects a pending build.
///
/// If approved, the returned LRO will be analogous to the LRO returned from
/// a CreateBuild call.
///
/// If rejected, the returned LRO will be immediately done.
pub async fn approve_build(&mut self, request: impl tonic::IntoRequest<super::ApproveBuildRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/ApproveBuild");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "ApproveBuild"));
self.inner.unary(req, path, codec).await
}
/// Creates a new `BuildTrigger`.
///
/// This API is experimental.
pub async fn create_build_trigger(&mut self, request: impl tonic::IntoRequest<super::CreateBuildTriggerRequest>) -> std::result::Result<tonic::Response<super::BuildTrigger>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/CreateBuildTrigger");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "CreateBuildTrigger"));
self.inner.unary(req, path, codec).await
}
/// Returns information about a `BuildTrigger`.
///
/// This API is experimental.
pub async fn get_build_trigger(&mut self, request: impl tonic::IntoRequest<super::GetBuildTriggerRequest>) -> std::result::Result<tonic::Response<super::BuildTrigger>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/GetBuildTrigger");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "GetBuildTrigger"));
self.inner.unary(req, path, codec).await
}
/// Lists existing `BuildTrigger`s.
///
/// This API is experimental.
pub async fn list_build_triggers(&mut self, request: impl tonic::IntoRequest<super::ListBuildTriggersRequest>) -> std::result::Result<tonic::Response<super::ListBuildTriggersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/ListBuildTriggers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "ListBuildTriggers"));
self.inner.unary(req, path, codec).await
}
/// Deletes a `BuildTrigger` by its project ID and trigger ID.
///
/// This API is experimental.
pub async fn delete_build_trigger(&mut self, request: impl tonic::IntoRequest<super::DeleteBuildTriggerRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/DeleteBuildTrigger");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "DeleteBuildTrigger"));
self.inner.unary(req, path, codec).await
}
/// Updates a `BuildTrigger` by its project ID and trigger ID.
///
/// This API is experimental.
pub async fn update_build_trigger(&mut self, request: impl tonic::IntoRequest<super::UpdateBuildTriggerRequest>) -> std::result::Result<tonic::Response<super::BuildTrigger>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/UpdateBuildTrigger");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "UpdateBuildTrigger"));
self.inner.unary(req, path, codec).await
}
/// Runs a `BuildTrigger` at a particular source revision.
///
/// To run a regional or global trigger, use the POST request
/// that includes the location endpoint in the path (ex.
/// v1/projects/{projectId}/locations/{region}/triggers/{triggerId}:run). The
/// POST request that does not include the location endpoint in the path can
/// only be used when running global triggers.
pub async fn run_build_trigger(&mut self, request: impl tonic::IntoRequest<super::RunBuildTriggerRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/RunBuildTrigger");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "RunBuildTrigger"));
self.inner.unary(req, path, codec).await
}
/// ReceiveTriggerWebhook [Experimental] is called when the API receives a
/// webhook request targeted at a specific trigger.
pub async fn receive_trigger_webhook(&mut self, request: impl tonic::IntoRequest<super::ReceiveTriggerWebhookRequest>) -> std::result::Result<tonic::Response<super::ReceiveTriggerWebhookResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/ReceiveTriggerWebhook");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "ReceiveTriggerWebhook"));
self.inner.unary(req, path, codec).await
}
/// Creates a `WorkerPool`.
pub async fn create_worker_pool(&mut self, request: impl tonic::IntoRequest<super::CreateWorkerPoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/CreateWorkerPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "CreateWorkerPool"));
self.inner.unary(req, path, codec).await
}
/// Returns details of a `WorkerPool`.
pub async fn get_worker_pool(&mut self, request: impl tonic::IntoRequest<super::GetWorkerPoolRequest>) -> std::result::Result<tonic::Response<super::WorkerPool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/GetWorkerPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "GetWorkerPool"));
self.inner.unary(req, path, codec).await
}
/// Deletes a `WorkerPool`.
pub async fn delete_worker_pool(&mut self, request: impl tonic::IntoRequest<super::DeleteWorkerPoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/DeleteWorkerPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "DeleteWorkerPool"));
self.inner.unary(req, path, codec).await
}
/// Updates a `WorkerPool`.
pub async fn update_worker_pool(&mut self, request: impl tonic::IntoRequest<super::UpdateWorkerPoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/UpdateWorkerPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "UpdateWorkerPool"));
self.inner.unary(req, path, codec).await
}
/// Lists `WorkerPool`s.
pub async fn list_worker_pools(&mut self, request: impl tonic::IntoRequest<super::ListWorkerPoolsRequest>) -> std::result::Result<tonic::Response<super::ListWorkerPoolsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.devtools.cloudbuild.v1.CloudBuild/ListWorkerPools");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.devtools.cloudbuild.v1.CloudBuild", "ListWorkerPools"));
self.inner.unary(req, path, codec).await
}
}
}
