// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MigrationStateEvent {
#[prost(enumeration = "MigrationState", tag = "1")]
pub state: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MigrationProgressEvent {
#[prost(enumeration = "MigrationStep", tag = "1")]
pub step: i32,
#[prost(oneof = "migration_progress_event::StepDetails", tags = "2, 3")]
pub step_details: ::core::option::Option<migration_progress_event::StepDetails>,
}
/// Nested message and enum types in `MigrationProgressEvent`.
pub mod migration_progress_event {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrepareStepDetails {
#[prost(enumeration = "ConcurrencyMode", tag = "1")]
pub concurrency_mode: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedirectWritesStepDetails {
#[prost(enumeration = "ConcurrencyMode", tag = "1")]
pub concurrency_mode: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConcurrencyMode {
Unspecified = 0,
Pessimistic = 1,
Optimistic = 2,
OptimisticWithEntityGroups = 3,
}
impl ConcurrencyMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ConcurrencyMode::Unspecified => "CONCURRENCY_MODE_UNSPECIFIED",
ConcurrencyMode::Pessimistic => "PESSIMISTIC",
ConcurrencyMode::Optimistic => "OPTIMISTIC",
ConcurrencyMode::OptimisticWithEntityGroups => "OPTIMISTIC_WITH_ENTITY_GROUPS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CONCURRENCY_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"PESSIMISTIC" => Some(Self::Pessimistic),
"OPTIMISTIC" => Some(Self::Optimistic),
"OPTIMISTIC_WITH_ENTITY_GROUPS" => Some(Self::OptimisticWithEntityGroups),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum StepDetails {
#[prost(message, tag = "2")]
PrepareStepDetails(PrepareStepDetails),
#[prost(message, tag = "3")]
RedirectWritesStepDetails(RedirectWritesStepDetails),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MigrationState {
Unspecified = 0,
Running = 1,
Paused = 2,
Complete = 3,
}
impl MigrationState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MigrationState::Unspecified => "MIGRATION_STATE_UNSPECIFIED",
MigrationState::Running => "RUNNING",
MigrationState::Paused => "PAUSED",
MigrationState::Complete => "COMPLETE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MIGRATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"RUNNING" => Some(Self::Running),
"PAUSED" => Some(Self::Paused),
"COMPLETE" => Some(Self::Complete),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MigrationStep {
Unspecified = 0,
Prepare = 6,
Start = 1,
ApplyWritesSynchronously = 7,
CopyAndVerify = 2,
RedirectEventuallyConsistentReads = 3,
RedirectStronglyConsistentReads = 4,
RedirectWrites = 5,
}
impl MigrationStep {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MigrationStep::Unspecified => "MIGRATION_STEP_UNSPECIFIED",
MigrationStep::Prepare => "PREPARE",
MigrationStep::Start => "START",
MigrationStep::ApplyWritesSynchronously => "APPLY_WRITES_SYNCHRONOUSLY",
MigrationStep::CopyAndVerify => "COPY_AND_VERIFY",
MigrationStep::RedirectEventuallyConsistentReads => "REDIRECT_EVENTUALLY_CONSISTENT_READS",
MigrationStep::RedirectStronglyConsistentReads => "REDIRECT_STRONGLY_CONSISTENT_READS",
MigrationStep::RedirectWrites => "REDIRECT_WRITES",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MIGRATION_STEP_UNSPECIFIED" => Some(Self::Unspecified),
"PREPARE" => Some(Self::Prepare),
"START" => Some(Self::Start),
"APPLY_WRITES_SYNCHRONOUSLY" => Some(Self::ApplyWritesSynchronously),
"COPY_AND_VERIFY" => Some(Self::CopyAndVerify),
"REDIRECT_EVENTUALLY_CONSISTENT_READS" => Some(Self::RedirectEventuallyConsistentReads),
"REDIRECT_STRONGLY_CONSISTENT_READS" => Some(Self::RedirectStronglyConsistentReads),
"REDIRECT_WRITES" => Some(Self::RedirectWrites),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub index_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub kind: ::prost::alloc::string::String,
#[prost(enumeration = "index::AncestorMode", tag = "5")]
pub ancestor: i32,
#[prost(message, repeated, tag = "6")]
pub properties: ::prost::alloc::vec::Vec<index::IndexedProperty>,
#[prost(enumeration = "index::State", tag = "7")]
pub state: i32,
}
/// Nested message and enum types in `Index`.
pub mod index {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexedProperty {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "Direction", tag = "2")]
pub direction: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AncestorMode {
Unspecified = 0,
None = 1,
AllAncestors = 2,
}
impl AncestorMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AncestorMode::Unspecified => "ANCESTOR_MODE_UNSPECIFIED",
AncestorMode::None => "NONE",
AncestorMode::AllAncestors => "ALL_ANCESTORS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ANCESTOR_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"NONE" => Some(Self::None),
"ALL_ANCESTORS" => Some(Self::AllAncestors),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
Unspecified = 0,
Ascending = 1,
Descending = 2,
}
impl Direction {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Direction::Unspecified => "DIRECTION_UNSPECIFIED",
Direction::Ascending => "ASCENDING",
Direction::Descending => "DESCENDING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
"ASCENDING" => Some(Self::Ascending),
"DESCENDING" => Some(Self::Descending),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Ready = 2,
Deleting = 3,
Error = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Ready => "READY",
State::Deleting => "DELETING",
State::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"READY" => Some(Self::Ready),
"DELETING" => Some(Self::Deleting),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonMetadata {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "OperationType", tag = "3")]
pub operation_type: i32,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(enumeration = "common_metadata::State", tag = "5")]
pub state: i32,
}
/// Nested message and enum types in `CommonMetadata`.
pub mod common_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Initializing = 1,
Processing = 2,
Cancelling = 3,
Finalizing = 4,
Successful = 5,
Failed = 6,
Cancelled = 7,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Initializing => "INITIALIZING",
State::Processing => "PROCESSING",
State::Cancelling => "CANCELLING",
State::Finalizing => "FINALIZING",
State::Successful => "SUCCESSFUL",
State::Failed => "FAILED",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"INITIALIZING" => Some(Self::Initializing),
"PROCESSING" => Some(Self::Processing),
"CANCELLING" => Some(Self::Cancelling),
"FINALIZING" => Some(Self::Finalizing),
"SUCCESSFUL" => Some(Self::Successful),
"FAILED" => Some(Self::Failed),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Progress {
#[prost(int64, tag = "1")]
pub work_completed: i64,
#[prost(int64, tag = "2")]
pub work_estimated: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportEntitiesRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "2")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub entity_filter: ::core::option::Option<EntityFilter>,
#[prost(string, tag = "4")]
pub output_url_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportEntitiesRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "2")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "3")]
pub input_url: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub entity_filter: ::core::option::Option<EntityFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportEntitiesResponse {
#[prost(string, tag = "1")]
pub output_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportEntitiesMetadata {
#[prost(message, optional, tag = "1")]
pub common: ::core::option::Option<CommonMetadata>,
#[prost(message, optional, tag = "2")]
pub progress_entities: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "3")]
pub progress_bytes: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "4")]
pub entity_filter: ::core::option::Option<EntityFilter>,
#[prost(string, tag = "5")]
pub output_url_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportEntitiesMetadata {
#[prost(message, optional, tag = "1")]
pub common: ::core::option::Option<CommonMetadata>,
#[prost(message, optional, tag = "2")]
pub progress_entities: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "3")]
pub progress_bytes: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "4")]
pub entity_filter: ::core::option::Option<EntityFilter>,
#[prost(string, tag = "5")]
pub input_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityFilter {
#[prost(string, repeated, tag = "1")]
pub kinds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "2")]
pub namespace_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub index: ::core::option::Option<Index>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIndexRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub index_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub index_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "4")]
pub page_size: i32,
#[prost(string, tag = "5")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesResponse {
#[prost(message, repeated, tag = "1")]
pub indexes: ::prost::alloc::vec::Vec<Index>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexOperationMetadata {
#[prost(message, optional, tag = "1")]
pub common: ::core::option::Option<CommonMetadata>,
#[prost(message, optional, tag = "2")]
pub progress_entities: ::core::option::Option<Progress>,
#[prost(string, tag = "3")]
pub index_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatastoreFirestoreMigrationMetadata {
#[prost(enumeration = "MigrationState", tag = "1")]
pub migration_state: i32,
#[prost(enumeration = "MigrationStep", tag = "2")]
pub migration_step: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationType {
Unspecified = 0,
ExportEntities = 1,
ImportEntities = 2,
CreateIndex = 3,
DeleteIndex = 4,
}
impl OperationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OperationType::Unspecified => "OPERATION_TYPE_UNSPECIFIED",
OperationType::ExportEntities => "EXPORT_ENTITIES",
OperationType::ImportEntities => "IMPORT_ENTITIES",
OperationType::CreateIndex => "CREATE_INDEX",
OperationType::DeleteIndex => "DELETE_INDEX",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"EXPORT_ENTITIES" => Some(Self::ExportEntities),
"IMPORT_ENTITIES" => Some(Self::ImportEntities),
"CREATE_INDEX" => Some(Self::CreateIndex),
"DELETE_INDEX" => Some(Self::DeleteIndex),
_ => None,
}
}
}
/// Generated client implementations.
pub mod datastore_admin_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Google Cloud Datastore Admin API
///
/// The Datastore Admin API provides several admin services for Cloud Datastore.
///
/// Concepts: Project, namespace, kind, and entity as defined in the Google Cloud
/// Datastore API.
///
/// Operation: An Operation represents work being performed in the background.
///
/// EntityFilter: Allows specifying a subset of entities in a project. This is
/// specified as a combination of kinds and namespaces (either or both of which
/// may be all).
///
/// Export/Import Service:
///
/// - The Export/Import service provides the ability to copy all or a subset of
/// entities to/from Google Cloud Storage.
/// - Exported data may be imported into Cloud Datastore for any Google Cloud
/// Platform project. It is not restricted to the export source project. It is
/// possible to export from one project and then import into another.
/// - Exported data can also be loaded into Google BigQuery for analysis.
/// - Exports and imports are performed asynchronously. An Operation resource is
/// created for each export/import. The state (including any errors encountered)
/// of the export/import may be queried via the Operation resource.
///
/// Index Service:
///
/// - The index service manages Cloud Datastore composite indexes.
/// - Index creation and deletion are performed asynchronously.
/// An Operation resource is created for each such asynchronous operation.
/// The state of the operation (including any errors encountered)
/// may be queried via the Operation resource.
///
/// Operation Service:
///
/// - The Operations collection provides a record of actions performed for the
/// specified project (including any operations in progress). Operations are not
/// created directly but through calls on other collections or resources.
/// - An operation that is not yet done may be cancelled. The request to cancel
/// is asynchronous and the operation may continue to run for some time after the
/// request to cancel is made.
/// - An operation that is done may be deleted so that it is no longer listed as
/// part of the Operation collection.
/// - ListOperations returns all pending operations, but not completed
/// operations.
/// - Operations are created by service DatastoreAdmin, but are accessed via
/// service google.longrunning.Operations.
#[derive(Debug, Clone)]
pub struct DatastoreAdminClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DatastoreAdminClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DatastoreAdminClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DatastoreAdminClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Exports a copy of all or a subset of entities from Google Cloud Datastore
/// to another storage system, such as Google Cloud Storage. Recent updates to
/// entities may not be reflected in the export. The export occurs in the
/// background and its progress can be monitored and managed via the
/// Operation resource that is created. The output of an export may only be
/// used once the associated operation is done. If an export operation is
/// cancelled before completion it may leave partial data behind in Google
/// Cloud Storage.
pub async fn export_entities(&mut self, request: impl tonic::IntoRequest<super::ExportEntitiesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1.DatastoreAdmin/ExportEntities");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1.DatastoreAdmin", "ExportEntities"));
self.inner.unary(req, path, codec).await
}
/// Imports entities into Google Cloud Datastore. Existing entities with the
/// same key are overwritten. The import occurs in the background and its
/// progress can be monitored and managed via the Operation resource that is
/// created. If an ImportEntities operation is cancelled, it is possible
/// that a subset of the data has already been imported to Cloud Datastore.
pub async fn import_entities(&mut self, request: impl tonic::IntoRequest<super::ImportEntitiesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1.DatastoreAdmin/ImportEntities");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1.DatastoreAdmin", "ImportEntities"));
self.inner.unary(req, path, codec).await
}
/// Creates the specified index.
/// A newly created index's initial state is `CREATING`. On completion of the
/// returned [google.longrunning.Operation][google.longrunning.Operation], the
/// state will be `READY`. If the index already exists, the call will return an
/// `ALREADY_EXISTS` status.
///
/// During index creation, the process could result in an error, in which
/// case the index will move to the `ERROR` state. The process can be recovered
/// by fixing the data that caused the error, removing the index with
/// [delete][google.datastore.admin.v1.DatastoreAdmin.DeleteIndex], then
/// re-creating the index with [create]
/// [google.datastore.admin.v1.DatastoreAdmin.CreateIndex].
///
/// Indexes with a single property cannot be created.
pub async fn create_index(&mut self, request: impl tonic::IntoRequest<super::CreateIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1.DatastoreAdmin/CreateIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1.DatastoreAdmin", "CreateIndex"));
self.inner.unary(req, path, codec).await
}
/// Deletes an existing index.
/// An index can only be deleted if it is in a `READY` or `ERROR` state. On
/// successful execution of the request, the index will be in a `DELETING`
/// [state][google.datastore.admin.v1.Index.State]. And on completion of the
/// returned [google.longrunning.Operation][google.longrunning.Operation], the
/// index will be removed.
///
/// During index deletion, the process could result in an error, in which
/// case the index will move to the `ERROR` state. The process can be recovered
/// by fixing the data that caused the error, followed by calling
/// [delete][google.datastore.admin.v1.DatastoreAdmin.DeleteIndex] again.
pub async fn delete_index(&mut self, request: impl tonic::IntoRequest<super::DeleteIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1.DatastoreAdmin/DeleteIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1.DatastoreAdmin", "DeleteIndex"));
self.inner.unary(req, path, codec).await
}
/// Gets an index.
pub async fn get_index(&mut self, request: impl tonic::IntoRequest<super::GetIndexRequest>) -> std::result::Result<tonic::Response<super::Index>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1.DatastoreAdmin/GetIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1.DatastoreAdmin", "GetIndex"));
self.inner.unary(req, path, codec).await
}
/// Lists the indexes that match the specified filters.  Datastore uses an
/// eventually consistent query to fetch the list of indexes and may
/// occasionally return stale results.
pub async fn list_indexes(&mut self, request: impl tonic::IntoRequest<super::ListIndexesRequest>) -> std::result::Result<tonic::Response<super::ListIndexesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.datastore.admin.v1.DatastoreAdmin/ListIndexes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.datastore.admin.v1.DatastoreAdmin", "ListIndexes"));
self.inner.unary(req, path, codec).await
}
}
}
