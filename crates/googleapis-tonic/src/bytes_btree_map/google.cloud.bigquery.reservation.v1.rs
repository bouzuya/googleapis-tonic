// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub slot_capacity: i64,
#[prost(bool, tag = "4")]
pub ignore_idle_slots: bool,
#[prost(message, optional, tag = "7")]
pub autoscale: ::core::option::Option<reservation::Autoscale>,
#[prost(int64, tag = "16")]
pub concurrency: i64,
#[prost(message, optional, tag = "8")]
pub creation_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(bool, tag = "14")]
pub multi_region_auxiliary: bool,
#[prost(enumeration = "Edition", tag = "17")]
pub edition: i32,
}
/// Nested message and enum types in `Reservation`.
pub mod reservation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Autoscale {
#[prost(int64, tag = "1")]
pub current_slots: i64,
#[prost(int64, tag = "2")]
pub max_slots: i64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapacityCommitment {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub slot_count: i64,
#[prost(enumeration = "capacity_commitment::CommitmentPlan", tag = "3")]
pub plan: i32,
#[prost(enumeration = "capacity_commitment::State", tag = "4")]
pub state: i32,
#[prost(message, optional, tag = "9")]
pub commitment_start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub commitment_end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub failure_status: ::core::option::Option<super::super::super::super::rpc::Status>,
#[prost(enumeration = "capacity_commitment::CommitmentPlan", tag = "8")]
pub renewal_plan: i32,
#[prost(bool, tag = "10")]
pub multi_region_auxiliary: bool,
#[prost(enumeration = "Edition", tag = "12")]
pub edition: i32,
}
/// Nested message and enum types in `CapacityCommitment`.
pub mod capacity_commitment {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommitmentPlan {
Unspecified = 0,
Flex = 3,
FlexFlatRate = 7,
Trial = 5,
Monthly = 2,
MonthlyFlatRate = 8,
Annual = 4,
AnnualFlatRate = 9,
ThreeYear = 10,
None = 6,
}
impl CommitmentPlan {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CommitmentPlan::Unspecified => "COMMITMENT_PLAN_UNSPECIFIED",
CommitmentPlan::Flex => "FLEX",
CommitmentPlan::FlexFlatRate => "FLEX_FLAT_RATE",
CommitmentPlan::Trial => "TRIAL",
CommitmentPlan::Monthly => "MONTHLY",
CommitmentPlan::MonthlyFlatRate => "MONTHLY_FLAT_RATE",
CommitmentPlan::Annual => "ANNUAL",
CommitmentPlan::AnnualFlatRate => "ANNUAL_FLAT_RATE",
CommitmentPlan::ThreeYear => "THREE_YEAR",
CommitmentPlan::None => "NONE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COMMITMENT_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
"FLEX" => Some(Self::Flex),
"FLEX_FLAT_RATE" => Some(Self::FlexFlatRate),
"TRIAL" => Some(Self::Trial),
"MONTHLY" => Some(Self::Monthly),
"MONTHLY_FLAT_RATE" => Some(Self::MonthlyFlatRate),
"ANNUAL" => Some(Self::Annual),
"ANNUAL_FLAT_RATE" => Some(Self::AnnualFlatRate),
"THREE_YEAR" => Some(Self::ThreeYear),
"NONE" => Some(Self::None),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Active = 2,
Failed = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Active => "ACTIVE",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"ACTIVE" => Some(Self::Active),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReservationRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub reservation_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub reservation: ::core::option::Option<Reservation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationsResponse {
#[prost(message, repeated, tag = "1")]
pub reservations: ::prost::alloc::vec::Vec<Reservation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReservationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReservationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReservationRequest {
#[prost(message, optional, tag = "1")]
pub reservation: ::core::option::Option<Reservation>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCapacityCommitmentRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub capacity_commitment: ::core::option::Option<CapacityCommitment>,
#[prost(bool, tag = "4")]
pub enforce_single_admin_project_per_org: bool,
#[prost(string, tag = "5")]
pub capacity_commitment_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCapacityCommitmentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCapacityCommitmentsResponse {
#[prost(message, repeated, tag = "1")]
pub capacity_commitments: ::prost::alloc::vec::Vec<CapacityCommitment>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCapacityCommitmentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCapacityCommitmentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCapacityCommitmentRequest {
#[prost(message, optional, tag = "1")]
pub capacity_commitment: ::core::option::Option<CapacityCommitment>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCapacityCommitmentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub slot_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCapacityCommitmentResponse {
#[prost(message, optional, tag = "1")]
pub first: ::core::option::Option<CapacityCommitment>,
#[prost(message, optional, tag = "2")]
pub second: ::core::option::Option<CapacityCommitment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeCapacityCommitmentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub capacity_commitment_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assignment {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub assignee: ::prost::alloc::string::String,
#[prost(enumeration = "assignment::JobType", tag = "3")]
pub job_type: i32,
#[prost(enumeration = "assignment::State", tag = "6")]
pub state: i32,
}
/// Nested message and enum types in `Assignment`.
pub mod assignment {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobType {
Unspecified = 0,
Pipeline = 1,
Query = 2,
MlExternal = 3,
Background = 4,
}
impl JobType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JobType::Unspecified => "JOB_TYPE_UNSPECIFIED",
JobType::Pipeline => "PIPELINE",
JobType::Query => "QUERY",
JobType::MlExternal => "ML_EXTERNAL",
JobType::Background => "BACKGROUND",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JOB_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PIPELINE" => Some(Self::Pipeline),
"QUERY" => Some(Self::Query),
"ML_EXTERNAL" => Some(Self::MlExternal),
"BACKGROUND" => Some(Self::Background),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Active = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Active => "ACTIVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"ACTIVE" => Some(Self::Active),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssignmentRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub assignment: ::core::option::Option<Assignment>,
#[prost(string, tag = "4")]
pub assignment_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssignmentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssignmentsResponse {
#[prost(message, repeated, tag = "1")]
pub assignments: ::prost::alloc::vec::Vec<Assignment>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAssignmentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAssignmentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAllAssignmentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAssignmentsResponse {
#[prost(message, repeated, tag = "1")]
pub assignments: ::prost::alloc::vec::Vec<Assignment>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAllAssignmentsResponse {
#[prost(message, repeated, tag = "1")]
pub assignments: ::prost::alloc::vec::Vec<Assignment>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveAssignmentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub destination_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub assignment_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAssignmentRequest {
#[prost(message, optional, tag = "1")]
pub assignment: ::core::option::Option<Assignment>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableReference {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub dataset_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub table_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiReservation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "4")]
pub size: i64,
#[prost(message, repeated, tag = "5")]
pub preferred_tables: ::prost::alloc::vec::Vec<TableReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBiReservationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBiReservationRequest {
#[prost(message, optional, tag = "1")]
pub bi_reservation: ::core::option::Option<BiReservation>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Edition {
Unspecified = 0,
Standard = 1,
Enterprise = 2,
EnterprisePlus = 3,
}
impl Edition {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Edition::Unspecified => "EDITION_UNSPECIFIED",
Edition::Standard => "STANDARD",
Edition::Enterprise => "ENTERPRISE",
Edition::EnterprisePlus => "ENTERPRISE_PLUS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EDITION_UNSPECIFIED" => Some(Self::Unspecified),
"STANDARD" => Some(Self::Standard),
"ENTERPRISE" => Some(Self::Enterprise),
"ENTERPRISE_PLUS" => Some(Self::EnterprisePlus),
_ => None,
}
}
}
/// Generated client implementations.
pub mod reservation_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// This API allows users to manage their BigQuery reservations.
///
/// A reservation provides computational resource guarantees, in the form of
/// [slots](https://cloud.google.com/bigquery/docs/slots), to users. A slot is a
/// unit of computational power in BigQuery, and serves as the basic unit of
/// parallelism. In a scan of a multi-partitioned table, a single slot operates
/// on a single partition of the table. A reservation resource exists as a child
/// resource of the admin project and location, e.g.:
///   `projects/myproject/locations/US/reservations/reservationName`.
///
/// A capacity commitment is a way to purchase compute capacity for BigQuery jobs
/// (in the form of slots) with some committed period of usage. A capacity
/// commitment resource exists as a child resource of the admin project and
/// location, e.g.:
///   `projects/myproject/locations/US/capacityCommitments/id`.
#[derive(Debug, Clone)]
pub struct ReservationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ReservationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ReservationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ReservationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new reservation resource.
pub async fn create_reservation(&mut self, request: impl tonic::IntoRequest<super::CreateReservationRequest>) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/CreateReservation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "CreateReservation"));
self.inner.unary(req, path, codec).await
}
/// Lists all the reservations for the project in the specified location.
pub async fn list_reservations(&mut self, request: impl tonic::IntoRequest<super::ListReservationsRequest>) -> std::result::Result<tonic::Response<super::ListReservationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/ListReservations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "ListReservations"));
self.inner.unary(req, path, codec).await
}
/// Returns information about the reservation.
pub async fn get_reservation(&mut self, request: impl tonic::IntoRequest<super::GetReservationRequest>) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/GetReservation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "GetReservation"));
self.inner.unary(req, path, codec).await
}
/// Deletes a reservation.
/// Returns `google.rpc.Code.FAILED_PRECONDITION` when reservation has
/// assignments.
pub async fn delete_reservation(&mut self, request: impl tonic::IntoRequest<super::DeleteReservationRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/DeleteReservation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "DeleteReservation"));
self.inner.unary(req, path, codec).await
}
/// Updates an existing reservation resource.
pub async fn update_reservation(&mut self, request: impl tonic::IntoRequest<super::UpdateReservationRequest>) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/UpdateReservation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "UpdateReservation"));
self.inner.unary(req, path, codec).await
}
/// Creates a new capacity commitment resource.
pub async fn create_capacity_commitment(&mut self, request: impl tonic::IntoRequest<super::CreateCapacityCommitmentRequest>) -> std::result::Result<tonic::Response<super::CapacityCommitment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/CreateCapacityCommitment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "CreateCapacityCommitment"));
self.inner.unary(req, path, codec).await
}
/// Lists all the capacity commitments for the admin project.
pub async fn list_capacity_commitments(&mut self, request: impl tonic::IntoRequest<super::ListCapacityCommitmentsRequest>) -> std::result::Result<tonic::Response<super::ListCapacityCommitmentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/ListCapacityCommitments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "ListCapacityCommitments"));
self.inner.unary(req, path, codec).await
}
/// Returns information about the capacity commitment.
pub async fn get_capacity_commitment(&mut self, request: impl tonic::IntoRequest<super::GetCapacityCommitmentRequest>) -> std::result::Result<tonic::Response<super::CapacityCommitment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/GetCapacityCommitment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "GetCapacityCommitment"));
self.inner.unary(req, path, codec).await
}
/// Deletes a capacity commitment. Attempting to delete capacity commitment
/// before its commitment_end_time will fail with the error code
/// `google.rpc.Code.FAILED_PRECONDITION`.
pub async fn delete_capacity_commitment(&mut self, request: impl tonic::IntoRequest<super::DeleteCapacityCommitmentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/DeleteCapacityCommitment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "DeleteCapacityCommitment"));
self.inner.unary(req, path, codec).await
}
/// Updates an existing capacity commitment.
///
/// Only `plan` and `renewal_plan` fields can be updated.
///
/// Plan can only be changed to a plan of a longer commitment period.
/// Attempting to change to a plan with shorter commitment period will fail
/// with the error code `google.rpc.Code.FAILED_PRECONDITION`.
pub async fn update_capacity_commitment(&mut self, request: impl tonic::IntoRequest<super::UpdateCapacityCommitmentRequest>) -> std::result::Result<tonic::Response<super::CapacityCommitment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/UpdateCapacityCommitment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "UpdateCapacityCommitment"));
self.inner.unary(req, path, codec).await
}
/// Splits capacity commitment to two commitments of the same plan and
/// `commitment_end_time`.
///
/// A common use case is to enable downgrading commitments.
///
/// For example, in order to downgrade from 10000 slots to 8000, you might
/// split a 10000 capacity commitment into commitments of 2000 and 8000. Then,
/// you delete the first one after the commitment end time passes.
pub async fn split_capacity_commitment(&mut self, request: impl tonic::IntoRequest<super::SplitCapacityCommitmentRequest>) -> std::result::Result<tonic::Response<super::SplitCapacityCommitmentResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/SplitCapacityCommitment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "SplitCapacityCommitment"));
self.inner.unary(req, path, codec).await
}
/// Merges capacity commitments of the same plan into a single commitment.
///
/// The resulting capacity commitment has the greater commitment_end_time
/// out of the to-be-merged capacity commitments.
///
/// Attempting to merge capacity commitments of different plan will fail
/// with the error code `google.rpc.Code.FAILED_PRECONDITION`.
pub async fn merge_capacity_commitments(&mut self, request: impl tonic::IntoRequest<super::MergeCapacityCommitmentsRequest>) -> std::result::Result<tonic::Response<super::CapacityCommitment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/MergeCapacityCommitments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "MergeCapacityCommitments"));
self.inner.unary(req, path, codec).await
}
/// Creates an assignment object which allows the given project to submit jobs
/// of a certain type using slots from the specified reservation.
///
/// Currently a
/// resource (project, folder, organization) can only have one assignment per
/// each (job_type, location) combination, and that reservation will be used
/// for all jobs of the matching type.
///
/// Different assignments can be created on different levels of the
/// projects, folders or organization hierarchy.  During query execution,
/// the assignment is looked up at the project, folder and organization levels
/// in that order. The first assignment found is applied to the query.
///
/// When creating assignments, it does not matter if other assignments exist at
/// higher levels.
///
/// Example:
///
/// * The organization `organizationA` contains two projects, `project1`
///   and `project2`.
/// * Assignments for all three entities (`organizationA`, `project1`, and
///   `project2`) could all be created and mapped to the same or different
///   reservations.
///
/// "None" assignments represent an absence of the assignment. Projects
/// assigned to None use on-demand pricing. To create a "None" assignment, use
/// "none" as a reservation_id in the parent. Example parent:
/// `projects/myproject/locations/US/reservations/none`.
///
/// Returns `google.rpc.Code.PERMISSION_DENIED` if user does not have
/// 'bigquery.admin' permissions on the project using the reservation
/// and the project that owns this reservation.
///
/// Returns `google.rpc.Code.INVALID_ARGUMENT` when location of the assignment
/// does not match location of the reservation.
pub async fn create_assignment(&mut self, request: impl tonic::IntoRequest<super::CreateAssignmentRequest>) -> std::result::Result<tonic::Response<super::Assignment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/CreateAssignment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "CreateAssignment"));
self.inner.unary(req, path, codec).await
}
/// Lists assignments.
///
/// Only explicitly created assignments will be returned.
///
/// Example:
///
/// * Organization `organizationA` contains two projects, `project1` and
///   `project2`.
/// * Reservation `res1` exists and was created previously.
/// * CreateAssignment was used previously to define the following
///   associations between entities and reservations: `<organizationA, res1>`
///   and `<project1, res1>`
///
/// In this example, ListAssignments will just return the above two assignments
/// for reservation `res1`, and no expansion/merge will happen.
///
/// The wildcard "-" can be used for
/// reservations in the request. In that case all assignments belongs to the
/// specified project and location will be listed.
///
/// **Note** "-" cannot be used for projects nor locations.
pub async fn list_assignments(&mut self, request: impl tonic::IntoRequest<super::ListAssignmentsRequest>) -> std::result::Result<tonic::Response<super::ListAssignmentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/ListAssignments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "ListAssignments"));
self.inner.unary(req, path, codec).await
}
/// Deletes a assignment. No expansion will happen.
///
/// Example:
///
/// * Organization `organizationA` contains two projects, `project1` and
///   `project2`.
/// * Reservation `res1` exists and was created previously.
/// * CreateAssignment was used previously to define the following
///   associations between entities and reservations: `<organizationA, res1>`
///   and `<project1, res1>`
///
/// In this example, deletion of the `<organizationA, res1>` assignment won't
/// affect the other assignment `<project1, res1>`. After said deletion,
/// queries from `project1` will still use `res1` while queries from
/// `project2` will switch to use on-demand mode.
pub async fn delete_assignment(&mut self, request: impl tonic::IntoRequest<super::DeleteAssignmentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/DeleteAssignment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "DeleteAssignment"));
self.inner.unary(req, path, codec).await
}
/// Deprecated: Looks up assignments for a specified resource for a particular
/// region. If the request is about a project:
///
/// 1. Assignments created on the project will be returned if they exist.
/// 2. Otherwise assignments created on the closest ancestor will be
///    returned.
/// 3. Assignments for different JobTypes will all be returned.
///
/// The same logic applies if the request is about a folder.
///
/// If the request is about an organization, then assignments created on the
/// organization will be returned (organization doesn't have ancestors).
///
/// Comparing to ListAssignments, there are some behavior
/// differences:
///
/// 1. permission on the assignee will be verified in this API.
/// 2. Hierarchy lookup (project->folder->organization) happens in this API.
/// 3. Parent here is `projects/*/locations/*`, instead of
///    `projects/*/locations/*reservations/*`.
///
/// **Note** "-" cannot be used for projects
/// nor locations.
pub async fn search_assignments(&mut self, request: impl tonic::IntoRequest<super::SearchAssignmentsRequest>) -> std::result::Result<tonic::Response<super::SearchAssignmentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/SearchAssignments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "SearchAssignments"));
self.inner.unary(req, path, codec).await
}
/// Looks up assignments for a specified resource for a particular region.
/// If the request is about a project:
///
/// 1. Assignments created on the project will be returned if they exist.
/// 2. Otherwise assignments created on the closest ancestor will be
///    returned.
/// 3. Assignments for different JobTypes will all be returned.
///
/// The same logic applies if the request is about a folder.
///
/// If the request is about an organization, then assignments created on the
/// organization will be returned (organization doesn't have ancestors).
///
/// Comparing to ListAssignments, there are some behavior
/// differences:
///
/// 1. permission on the assignee will be verified in this API.
/// 2. Hierarchy lookup (project->folder->organization) happens in this API.
/// 3. Parent here is `projects/*/locations/*`, instead of
///    `projects/*/locations/*reservations/*`.
pub async fn search_all_assignments(&mut self, request: impl tonic::IntoRequest<super::SearchAllAssignmentsRequest>) -> std::result::Result<tonic::Response<super::SearchAllAssignmentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/SearchAllAssignments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "SearchAllAssignments"));
self.inner.unary(req, path, codec).await
}
/// Moves an assignment under a new reservation.
///
/// This differs from removing an existing assignment and recreating a new one
/// by providing a transactional change that ensures an assignee always has an
/// associated reservation.
pub async fn move_assignment(&mut self, request: impl tonic::IntoRequest<super::MoveAssignmentRequest>) -> std::result::Result<tonic::Response<super::Assignment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/MoveAssignment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "MoveAssignment"));
self.inner.unary(req, path, codec).await
}
/// Updates an existing assignment.
///
/// Only the `priority` field can be updated.
pub async fn update_assignment(&mut self, request: impl tonic::IntoRequest<super::UpdateAssignmentRequest>) -> std::result::Result<tonic::Response<super::Assignment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/UpdateAssignment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "UpdateAssignment"));
self.inner.unary(req, path, codec).await
}
/// Retrieves a BI reservation.
pub async fn get_bi_reservation(&mut self, request: impl tonic::IntoRequest<super::GetBiReservationRequest>) -> std::result::Result<tonic::Response<super::BiReservation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/GetBiReservation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "GetBiReservation"));
self.inner.unary(req, path, codec).await
}
/// Updates a BI reservation.
///
/// Only fields specified in the `field_mask` are updated.
///
/// A singleton BI reservation always exists with default size 0.
/// In order to reserve BI capacity it needs to be updated to an amount
/// greater than 0. In order to release BI capacity reservation size
/// must be set to 0.
pub async fn update_bi_reservation(&mut self, request: impl tonic::IntoRequest<super::UpdateBiReservationRequest>) -> std::result::Result<tonic::Response<super::BiReservation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.bigquery.reservation.v1.ReservationService/UpdateBiReservation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.bigquery.reservation.v1.ReservationService", "UpdateBiReservation"));
self.inner.unary(req, path, codec).await
}
}
}
