// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(string, optional, tag = "462920692")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "264307877")]
    pub address_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "294959552")]
    pub ip_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "517397843")]
    pub network_tier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "453565747")]
    pub prefix_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "316407070")]
    pub purpose: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "111578632")]
    pub users: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Address`.
pub mod address {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AddressType {
        UndefinedAddressType = 0,
        External = 35607499,
        Internal = 279295677,
        UnspecifiedType = 53933922,
    }
    impl AddressType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AddressType::UndefinedAddressType => "UNDEFINED_ADDRESS_TYPE",
                AddressType::External => "EXTERNAL",
                AddressType::Internal => "INTERNAL",
                AddressType::UnspecifiedType => "UNSPECIFIED_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ADDRESS_TYPE" => Some(Self::UndefinedAddressType),
                "EXTERNAL" => Some(Self::External),
                "INTERNAL" => Some(Self::Internal),
                "UNSPECIFIED_TYPE" => Some(Self::UnspecifiedType),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum IpVersion {
        UndefinedIpVersion = 0,
        Ipv4 = 2254341,
        Ipv6 = 2254343,
        UnspecifiedVersion = 21850000,
    }
    impl IpVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IpVersion::UndefinedIpVersion => "UNDEFINED_IP_VERSION",
                IpVersion::Ipv4 => "IPV4",
                IpVersion::Ipv6 => "IPV6",
                IpVersion::UnspecifiedVersion => "UNSPECIFIED_VERSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IP_VERSION" => Some(Self::UndefinedIpVersion),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                "UNSPECIFIED_VERSION" => Some(Self::UnspecifiedVersion),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum NetworkTier {
        UndefinedNetworkTier = 0,
        Premium = 399530551,
        Standard = 484642493,
    }
    impl NetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkTier::UndefinedNetworkTier => "UNDEFINED_NETWORK_TIER",
                NetworkTier::Premium => "PREMIUM",
                NetworkTier::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NETWORK_TIER" => Some(Self::UndefinedNetworkTier),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Purpose {
        UndefinedPurpose = 0,
        DnsResolver = 476114556,
        GceEndpoint = 230515243,
        NatAuto = 163666477,
        VpcPeering = 400800170,
    }
    impl Purpose {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Purpose::UndefinedPurpose => "UNDEFINED_PURPOSE",
                Purpose::DnsResolver => "DNS_RESOLVER",
                Purpose::GceEndpoint => "GCE_ENDPOINT",
                Purpose::NatAuto => "NAT_AUTO",
                Purpose::VpcPeering => "VPC_PEERING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PURPOSE" => Some(Self::UndefinedPurpose),
                "DNS_RESOLVER" => Some(Self::DnsResolver),
                "GCE_ENDPOINT" => Some(Self::GceEndpoint),
                "NAT_AUTO" => Some(Self::NatAuto),
                "VPC_PEERING" => Some(Self::VpcPeering),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        InUse = 17393485,
        Reserved = 432241448,
        Reserving = 514587225,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::InUse => "IN_USE",
                Status::Reserved => "RESERVED",
                Status::Reserving => "RESERVING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "IN_USE" => Some(Self::InUse),
                "RESERVED" => Some(Self::Reserved),
                "RESERVING" => Some(Self::Reserving),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(btree_map = "string, message", tag = "100526016")]
    pub items:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, AddressesScopedList>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Address>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressesScopedList {
    #[prost(message, repeated, tag = "337673122")]
    pub addresses: ::prost::alloc::vec::Vec<Address>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListAddressesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(string, optional, tag = "106079")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111972721")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAddressRequest {
    #[prost(string, tag = "462920692")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(message, repeated, tag = "315977579")]
    pub errors: ::prost::alloc::vec::Vec<Errors>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Errors {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "290430901")]
    pub location: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertAddressRequest {
    #[prost(message, optional, tag = "483888121")]
    pub address_resource: ::core::option::Option<Address>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAddressesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, tag = "160562920")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
    #[prost(string, optional, tag = "297240295")]
    pub client_operation_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "114938801")]
    pub end_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "96784904")]
    pub error: ::core::option::Option<Error>,
    #[prost(string, optional, tag = "202521945")]
    pub http_error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "312345196")]
    pub http_error_status_code: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "433722515")]
    pub insert_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "177650450")]
    pub operation_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "72663597")]
    pub progress: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "operation::Status", optional, tag = "181260274")]
    pub status: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "297428154")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "258165385")]
    pub target_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "62671336")]
    pub target_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3599307")]
    pub user: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "498091095")]
    pub warnings: ::prost::alloc::vec::Vec<Warnings>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Done = 2104194,
        Pending = 35394935,
        Running = 121282975,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Done => "DONE",
                Status::Pending => "PENDING",
                Status::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DONE" => Some(Self::Done),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitRegionOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Warning {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3076010")]
    pub data: ::prost::alloc::vec::Vec<Data>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Warning`.
pub mod warning {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Code {
        UndefinedCode = 0,
        CleanupFailed = 150308440,
        DeprecatedResourceUsed = 391835586,
        DeprecatedTypeUsed = 346526230,
        DiskSizeLargerThanImageSize = 369442967,
        ExperimentalTypeUsed = 451954443,
        ExternalApiWarning = 175546307,
        FieldValueOverriden = 329669423,
        InjectedKernelsDeprecated = 417377419,
        MissingTypeDependency = 344505463,
        NextHopAddressNotAssigned = 324964999,
        NextHopCannotIpForward = 383382887,
        NextHopInstanceNotFound = 464250446,
        NextHopInstanceNotOnNetwork = 243758146,
        NextHopNotRunning = 417081265,
        NotCriticalError = 105763924,
        NoResultsOnPage = 30036744,
        RequiredTosAgreement = 3745539,
        ResourceInUseByOtherResourceWarning = 496728641,
        ResourceNotDeleted = 168598460,
        SchemaValidationIgnored = 275245642,
        SingleInstancePropertyTemplate = 268305617,
        UndeclaredProperties = 390513439,
        Unreachable = 13328052,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Code::UndefinedCode => "UNDEFINED_CODE",
                Code::CleanupFailed => "CLEANUP_FAILED",
                Code::DeprecatedResourceUsed => "DEPRECATED_RESOURCE_USED",
                Code::DeprecatedTypeUsed => "DEPRECATED_TYPE_USED",
                Code::DiskSizeLargerThanImageSize => "DISK_SIZE_LARGER_THAN_IMAGE_SIZE",
                Code::ExperimentalTypeUsed => "EXPERIMENTAL_TYPE_USED",
                Code::ExternalApiWarning => "EXTERNAL_API_WARNING",
                Code::FieldValueOverriden => "FIELD_VALUE_OVERRIDEN",
                Code::InjectedKernelsDeprecated => "INJECTED_KERNELS_DEPRECATED",
                Code::MissingTypeDependency => "MISSING_TYPE_DEPENDENCY",
                Code::NextHopAddressNotAssigned => "NEXT_HOP_ADDRESS_NOT_ASSIGNED",
                Code::NextHopCannotIpForward => "NEXT_HOP_CANNOT_IP_FORWARD",
                Code::NextHopInstanceNotFound => "NEXT_HOP_INSTANCE_NOT_FOUND",
                Code::NextHopInstanceNotOnNetwork => "NEXT_HOP_INSTANCE_NOT_ON_NETWORK",
                Code::NextHopNotRunning => "NEXT_HOP_NOT_RUNNING",
                Code::NotCriticalError => "NOT_CRITICAL_ERROR",
                Code::NoResultsOnPage => "NO_RESULTS_ON_PAGE",
                Code::RequiredTosAgreement => "REQUIRED_TOS_AGREEMENT",
                Code::ResourceInUseByOtherResourceWarning => {
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
                }
                Code::ResourceNotDeleted => "RESOURCE_NOT_DELETED",
                Code::SchemaValidationIgnored => "SCHEMA_VALIDATION_IGNORED",
                Code::SingleInstancePropertyTemplate => "SINGLE_INSTANCE_PROPERTY_TEMPLATE",
                Code::UndeclaredProperties => "UNDECLARED_PROPERTIES",
                Code::Unreachable => "UNREACHABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CODE" => Some(Self::UndefinedCode),
                "CLEANUP_FAILED" => Some(Self::CleanupFailed),
                "DEPRECATED_RESOURCE_USED" => Some(Self::DeprecatedResourceUsed),
                "DEPRECATED_TYPE_USED" => Some(Self::DeprecatedTypeUsed),
                "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Some(Self::DiskSizeLargerThanImageSize),
                "EXPERIMENTAL_TYPE_USED" => Some(Self::ExperimentalTypeUsed),
                "EXTERNAL_API_WARNING" => Some(Self::ExternalApiWarning),
                "FIELD_VALUE_OVERRIDEN" => Some(Self::FieldValueOverriden),
                "INJECTED_KERNELS_DEPRECATED" => Some(Self::InjectedKernelsDeprecated),
                "MISSING_TYPE_DEPENDENCY" => Some(Self::MissingTypeDependency),
                "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Some(Self::NextHopAddressNotAssigned),
                "NEXT_HOP_CANNOT_IP_FORWARD" => Some(Self::NextHopCannotIpForward),
                "NEXT_HOP_INSTANCE_NOT_FOUND" => Some(Self::NextHopInstanceNotFound),
                "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Some(Self::NextHopInstanceNotOnNetwork),
                "NEXT_HOP_NOT_RUNNING" => Some(Self::NextHopNotRunning),
                "NOT_CRITICAL_ERROR" => Some(Self::NotCriticalError),
                "NO_RESULTS_ON_PAGE" => Some(Self::NoResultsOnPage),
                "REQUIRED_TOS_AGREEMENT" => Some(Self::RequiredTosAgreement),
                "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                    Some(Self::ResourceInUseByOtherResourceWarning)
                }
                "RESOURCE_NOT_DELETED" => Some(Self::ResourceNotDeleted),
                "SCHEMA_VALIDATION_IGNORED" => Some(Self::SchemaValidationIgnored),
                "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Some(Self::SingleInstancePropertyTemplate),
                "UNDECLARED_PROPERTIES" => Some(Self::UndeclaredProperties),
                "UNREACHABLE" => Some(Self::Unreachable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Warnings {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3076010")]
    pub data: ::prost::alloc::vec::Vec<Data>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Warnings`.
pub mod warnings {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Code {
        UndefinedCode = 0,
        CleanupFailed = 150308440,
        DeprecatedResourceUsed = 391835586,
        DeprecatedTypeUsed = 346526230,
        DiskSizeLargerThanImageSize = 369442967,
        ExperimentalTypeUsed = 451954443,
        ExternalApiWarning = 175546307,
        FieldValueOverriden = 329669423,
        InjectedKernelsDeprecated = 417377419,
        MissingTypeDependency = 344505463,
        NextHopAddressNotAssigned = 324964999,
        NextHopCannotIpForward = 383382887,
        NextHopInstanceNotFound = 464250446,
        NextHopInstanceNotOnNetwork = 243758146,
        NextHopNotRunning = 417081265,
        NotCriticalError = 105763924,
        NoResultsOnPage = 30036744,
        RequiredTosAgreement = 3745539,
        ResourceInUseByOtherResourceWarning = 496728641,
        ResourceNotDeleted = 168598460,
        SchemaValidationIgnored = 275245642,
        SingleInstancePropertyTemplate = 268305617,
        UndeclaredProperties = 390513439,
        Unreachable = 13328052,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Code::UndefinedCode => "UNDEFINED_CODE",
                Code::CleanupFailed => "CLEANUP_FAILED",
                Code::DeprecatedResourceUsed => "DEPRECATED_RESOURCE_USED",
                Code::DeprecatedTypeUsed => "DEPRECATED_TYPE_USED",
                Code::DiskSizeLargerThanImageSize => "DISK_SIZE_LARGER_THAN_IMAGE_SIZE",
                Code::ExperimentalTypeUsed => "EXPERIMENTAL_TYPE_USED",
                Code::ExternalApiWarning => "EXTERNAL_API_WARNING",
                Code::FieldValueOverriden => "FIELD_VALUE_OVERRIDEN",
                Code::InjectedKernelsDeprecated => "INJECTED_KERNELS_DEPRECATED",
                Code::MissingTypeDependency => "MISSING_TYPE_DEPENDENCY",
                Code::NextHopAddressNotAssigned => "NEXT_HOP_ADDRESS_NOT_ASSIGNED",
                Code::NextHopCannotIpForward => "NEXT_HOP_CANNOT_IP_FORWARD",
                Code::NextHopInstanceNotFound => "NEXT_HOP_INSTANCE_NOT_FOUND",
                Code::NextHopInstanceNotOnNetwork => "NEXT_HOP_INSTANCE_NOT_ON_NETWORK",
                Code::NextHopNotRunning => "NEXT_HOP_NOT_RUNNING",
                Code::NotCriticalError => "NOT_CRITICAL_ERROR",
                Code::NoResultsOnPage => "NO_RESULTS_ON_PAGE",
                Code::RequiredTosAgreement => "REQUIRED_TOS_AGREEMENT",
                Code::ResourceInUseByOtherResourceWarning => {
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
                }
                Code::ResourceNotDeleted => "RESOURCE_NOT_DELETED",
                Code::SchemaValidationIgnored => "SCHEMA_VALIDATION_IGNORED",
                Code::SingleInstancePropertyTemplate => "SINGLE_INSTANCE_PROPERTY_TEMPLATE",
                Code::UndeclaredProperties => "UNDECLARED_PROPERTIES",
                Code::Unreachable => "UNREACHABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CODE" => Some(Self::UndefinedCode),
                "CLEANUP_FAILED" => Some(Self::CleanupFailed),
                "DEPRECATED_RESOURCE_USED" => Some(Self::DeprecatedResourceUsed),
                "DEPRECATED_TYPE_USED" => Some(Self::DeprecatedTypeUsed),
                "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Some(Self::DiskSizeLargerThanImageSize),
                "EXPERIMENTAL_TYPE_USED" => Some(Self::ExperimentalTypeUsed),
                "EXTERNAL_API_WARNING" => Some(Self::ExternalApiWarning),
                "FIELD_VALUE_OVERRIDEN" => Some(Self::FieldValueOverriden),
                "INJECTED_KERNELS_DEPRECATED" => Some(Self::InjectedKernelsDeprecated),
                "MISSING_TYPE_DEPENDENCY" => Some(Self::MissingTypeDependency),
                "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Some(Self::NextHopAddressNotAssigned),
                "NEXT_HOP_CANNOT_IP_FORWARD" => Some(Self::NextHopCannotIpForward),
                "NEXT_HOP_INSTANCE_NOT_FOUND" => Some(Self::NextHopInstanceNotFound),
                "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Some(Self::NextHopInstanceNotOnNetwork),
                "NEXT_HOP_NOT_RUNNING" => Some(Self::NextHopNotRunning),
                "NOT_CRITICAL_ERROR" => Some(Self::NotCriticalError),
                "NO_RESULTS_ON_PAGE" => Some(Self::NoResultsOnPage),
                "REQUIRED_TOS_AGREEMENT" => Some(Self::RequiredTosAgreement),
                "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                    Some(Self::ResourceInUseByOtherResourceWarning)
                }
                "RESOURCE_NOT_DELETED" => Some(Self::ResourceNotDeleted),
                "SCHEMA_VALIDATION_IGNORED" => Some(Self::SchemaValidationIgnored),
                "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Some(Self::SingleInstancePropertyTemplate),
                "UNDECLARED_PROPERTIES" => Some(Self::UndeclaredProperties),
                "UNREACHABLE" => Some(Self::Unreachable),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod addresses_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    ///
    /// Services
    ///
    /// The Addresses API.
    #[derive(Debug, Clone)]
    pub struct AddressesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AddressesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AddressesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AddressesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of addresses.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListAddressesRequest>,
        ) -> std::result::Result<tonic::Response<super::AddressAggregatedList>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1small.Addresses/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.compute.v1small.Addresses",
                "AggregatedList",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified address resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1small.Addresses/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.compute.v1small.Addresses",
                "Delete",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates an address resource in the specified project by using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1small.Addresses/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.compute.v1small.Addresses",
                "Insert",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of addresses contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAddressesRequest>,
        ) -> std::result::Result<tonic::Response<super::AddressList>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1small.Addresses/List",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.compute.v1small.Addresses",
                "List",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_operations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The RegionOperations API.
    #[derive(Debug, Clone)]
    pub struct RegionOperationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionOperationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionOperationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            RegionOperationsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the specified region-specific Operations resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1small.RegionOperations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.compute.v1small.RegionOperations",
                "Get",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress.
        ///
        /// This method is called on a best-effort basis. Specifically:
        /// - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds.
        /// - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
        pub async fn wait(
            &mut self,
            request: impl tonic::IntoRequest<super::WaitRegionOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1small.RegionOperations/Wait",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.compute.v1small.RegionOperations",
                "Wait",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
