// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingAccount {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub open: bool,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub master_billing_account: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectBillingInfo {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub billing_account_name: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub billing_enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBillingAccountRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBillingAccountsRequest {
#[prost(int32, tag = "1")]
pub page_size: i32,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBillingAccountsResponse {
#[prost(message, repeated, tag = "1")]
pub billing_accounts: ::prost::alloc::vec::Vec<BillingAccount>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBillingAccountRequest {
#[prost(message, optional, tag = "1")]
pub billing_account: ::core::option::Option<BillingAccount>,
#[prost(string, tag = "2")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBillingAccountRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub account: ::core::option::Option<BillingAccount>,
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProjectBillingInfoRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProjectBillingInfoResponse {
#[prost(message, repeated, tag = "1")]
pub project_billing_info: ::prost::alloc::vec::Vec<ProjectBillingInfo>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProjectBillingInfoRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProjectBillingInfoRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub project_billing_info: ::core::option::Option<ProjectBillingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveBillingAccountRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub destination_parent: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod cloud_billing_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Retrieves the Google Cloud Console billing accounts and associates them with
/// projects.
#[derive(Debug, Clone)]
pub struct CloudBillingClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CloudBillingClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CloudBillingClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CloudBillingClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets information about a billing account. The current authenticated user
/// must be a [viewer of the billing
/// account](https://cloud.google.com/billing/docs/how-to/billing-access).
pub async fn get_billing_account(&mut self, request: impl tonic::IntoRequest<super::GetBillingAccountRequest>) -> std::result::Result<tonic::Response<super::BillingAccount>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/GetBillingAccount");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "GetBillingAccount"));
self.inner.unary(req, path, codec).await
}
/// Lists the billing accounts that the current authenticated user has
/// permission to
/// [view](https://cloud.google.com/billing/docs/how-to/billing-access).
pub async fn list_billing_accounts(&mut self, request: impl tonic::IntoRequest<super::ListBillingAccountsRequest>) -> std::result::Result<tonic::Response<super::ListBillingAccountsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/ListBillingAccounts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "ListBillingAccounts"));
self.inner.unary(req, path, codec).await
}
/// Updates a billing account's fields.
/// Currently the only field that can be edited is `display_name`.
/// The current authenticated user must have the `billing.accounts.update`
/// IAM permission, which is typically given to the
/// [administrator](https://cloud.google.com/billing/docs/how-to/billing-access)
/// of the billing account.
pub async fn update_billing_account(&mut self, request: impl tonic::IntoRequest<super::UpdateBillingAccountRequest>) -> std::result::Result<tonic::Response<super::BillingAccount>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/UpdateBillingAccount");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "UpdateBillingAccount"));
self.inner.unary(req, path, codec).await
}
/// This method creates [billing
/// subaccounts](https://cloud.google.com/billing/docs/concepts#subaccounts).
///
/// Google Cloud resellers should use the
/// Channel Services APIs,
/// [accounts.customers.create](https://cloud.google.com/channel/docs/reference/rest/v1/accounts.customers/create)
/// and
/// [accounts.customers.entitlements.create](https://cloud.google.com/channel/docs/reference/rest/v1/accounts.customers.entitlements/create).
///
/// When creating a subaccount, the current authenticated user must have the
/// `billing.accounts.update` IAM permission on the parent account, which is
/// typically given to billing account
/// [administrators](https://cloud.google.com/billing/docs/how-to/billing-access).
/// This method will return an error if the parent account has not been
/// provisioned for subaccounts.
pub async fn create_billing_account(&mut self, request: impl tonic::IntoRequest<super::CreateBillingAccountRequest>) -> std::result::Result<tonic::Response<super::BillingAccount>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/CreateBillingAccount");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "CreateBillingAccount"));
self.inner.unary(req, path, codec).await
}
/// Lists the projects associated with a billing account. The current
/// authenticated user must have the `billing.resourceAssociations.list` IAM
/// permission, which is often given to billing account
/// [viewers](https://cloud.google.com/billing/docs/how-to/billing-access).
pub async fn list_project_billing_info(&mut self, request: impl tonic::IntoRequest<super::ListProjectBillingInfoRequest>) -> std::result::Result<tonic::Response<super::ListProjectBillingInfoResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/ListProjectBillingInfo");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "ListProjectBillingInfo"));
self.inner.unary(req, path, codec).await
}
/// Gets the billing information for a project. The current authenticated user
/// must have the `resourcemanager.projects.get` permission for the project,
/// which can be granted by assigning the [Project
/// Viewer](https://cloud.google.com/iam/docs/understanding-roles#predefined_roles)
/// role.
pub async fn get_project_billing_info(&mut self, request: impl tonic::IntoRequest<super::GetProjectBillingInfoRequest>) -> std::result::Result<tonic::Response<super::ProjectBillingInfo>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/GetProjectBillingInfo");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "GetProjectBillingInfo"));
self.inner.unary(req, path, codec).await
}
/// Sets or updates the billing account associated with a project. You specify
/// the new billing account by setting the `billing_account_name` in the
/// `ProjectBillingInfo` resource to the resource name of a billing account.
/// Associating a project with an open billing account enables billing on the
/// project and allows charges for resource usage. If the project already had a
/// billing account, this method changes the billing account used for resource
/// usage charges.
///
/// *Note:* Incurred charges that have not yet been reported in the transaction
/// history of the Google Cloud Console might be billed to the new billing
/// account, even if the charge occurred before the new billing account was
/// assigned to the project.
///
/// The current authenticated user must have ownership privileges for both
/// the
/// [project](https://cloud.google.com/docs/permissions-overview#h.bgs0oxofvnoo
/// ) and the [billing
/// account](https://cloud.google.com/billing/docs/how-to/billing-access).
///
/// You can disable billing on the project by setting the
/// `billing_account_name` field to empty. This action disassociates the
/// current billing account from the project. Any billable activity of your
/// in-use services will stop, and your application could stop functioning as
/// expected. Any unbilled charges to date will be billed to the previously
/// associated account. The current authenticated user must be either an owner
/// of the project or an owner of the billing account for the project.
///
/// Note that associating a project with a *closed* billing account will have
/// much the same effect as disabling billing on the project: any paid
/// resources used by the project will be shut down. Thus, unless you wish to
/// disable billing, you should always call this method with the name of an
/// *open* billing account.
pub async fn update_project_billing_info(&mut self, request: impl tonic::IntoRequest<super::UpdateProjectBillingInfoRequest>) -> std::result::Result<tonic::Response<super::ProjectBillingInfo>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/UpdateProjectBillingInfo");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "UpdateProjectBillingInfo"));
self.inner.unary(req, path, codec).await
}
/// Gets the access control policy for a billing account.
/// The caller must have the `billing.accounts.getIamPolicy` permission on the
/// account, which is often given to billing account
/// [viewers](https://cloud.google.com/billing/docs/how-to/billing-access).
pub async fn get_iam_policy(&mut self, request: impl tonic::IntoRequest<super::super::super::super::iam::v1::GetIamPolicyRequest>) -> std::result::Result<tonic::Response<super::super::super::super::iam::v1::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/GetIamPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "GetIamPolicy"));
self.inner.unary(req, path, codec).await
}
/// Sets the access control policy for a billing account. Replaces any existing
/// policy.
/// The caller must have the `billing.accounts.setIamPolicy` permission on the
/// account, which is often given to billing account
/// [administrators](https://cloud.google.com/billing/docs/how-to/billing-access).
pub async fn set_iam_policy(&mut self, request: impl tonic::IntoRequest<super::super::super::super::iam::v1::SetIamPolicyRequest>) -> std::result::Result<tonic::Response<super::super::super::super::iam::v1::Policy>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/SetIamPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "SetIamPolicy"));
self.inner.unary(req, path, codec).await
}
/// Tests the access control policy for a billing account. This method takes
/// the resource and a set of permissions as input and returns the subset of
/// the input permissions that the caller is allowed for that resource.
pub async fn test_iam_permissions(&mut self, request: impl tonic::IntoRequest<super::super::super::super::iam::v1::TestIamPermissionsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::iam::v1::TestIamPermissionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/TestIamPermissions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "TestIamPermissions"));
self.inner.unary(req, path, codec).await
}
/// Changes which parent organization a billing account belongs to.
pub async fn move_billing_account(&mut self, request: impl tonic::IntoRequest<super::MoveBillingAccountRequest>) -> std::result::Result<tonic::Response<super::BillingAccount>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudBilling/MoveBillingAccount");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudBilling", "MoveBillingAccount"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub service_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub business_entity_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sku {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub sku_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub category: ::core::option::Option<Category>,
#[prost(string, repeated, tag = "5")]
pub service_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "6")]
pub pricing_info: ::prost::alloc::vec::Vec<PricingInfo>,
#[prost(string, tag = "7")]
pub service_provider_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub geo_taxonomy: ::core::option::Option<GeoTaxonomy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Category {
#[prost(string, tag = "1")]
pub service_display_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub resource_family: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub resource_group: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub usage_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PricingInfo {
#[prost(message, optional, tag = "1")]
pub effective_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "2")]
pub summary: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub pricing_expression: ::core::option::Option<PricingExpression>,
#[prost(message, optional, tag = "4")]
pub aggregation_info: ::core::option::Option<AggregationInfo>,
#[prost(double, tag = "5")]
pub currency_conversion_rate: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PricingExpression {
#[prost(string, tag = "1")]
pub usage_unit: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub display_quantity: f64,
#[prost(message, repeated, tag = "3")]
pub tiered_rates: ::prost::alloc::vec::Vec<pricing_expression::TierRate>,
#[prost(string, tag = "4")]
pub usage_unit_description: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub base_unit: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub base_unit_description: ::prost::alloc::string::String,
#[prost(double, tag = "7")]
pub base_unit_conversion_factor: f64,
}
/// Nested message and enum types in `PricingExpression`.
pub mod pricing_expression {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TierRate {
#[prost(double, tag = "1")]
pub start_usage_amount: f64,
#[prost(message, optional, tag = "2")]
pub unit_price: ::core::option::Option<super::super::super::super::r#type::Money>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AggregationInfo {
#[prost(enumeration = "aggregation_info::AggregationLevel", tag = "1")]
pub aggregation_level: i32,
#[prost(enumeration = "aggregation_info::AggregationInterval", tag = "2")]
pub aggregation_interval: i32,
#[prost(int32, tag = "3")]
pub aggregation_count: i32,
}
/// Nested message and enum types in `AggregationInfo`.
pub mod aggregation_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregationLevel {
Unspecified = 0,
Account = 1,
Project = 2,
}
impl AggregationLevel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AggregationLevel::Unspecified => "AGGREGATION_LEVEL_UNSPECIFIED",
AggregationLevel::Account => "ACCOUNT",
AggregationLevel::Project => "PROJECT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"AGGREGATION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
"ACCOUNT" => Some(Self::Account),
"PROJECT" => Some(Self::Project),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregationInterval {
Unspecified = 0,
Daily = 1,
Monthly = 2,
}
impl AggregationInterval {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AggregationInterval::Unspecified => "AGGREGATION_INTERVAL_UNSPECIFIED",
AggregationInterval::Daily => "DAILY",
AggregationInterval::Monthly => "MONTHLY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"AGGREGATION_INTERVAL_UNSPECIFIED" => Some(Self::Unspecified),
"DAILY" => Some(Self::Daily),
"MONTHLY" => Some(Self::Monthly),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoTaxonomy {
#[prost(enumeration = "geo_taxonomy::Type", tag = "1")]
pub r#type: i32,
#[prost(string, repeated, tag = "2")]
pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `GeoTaxonomy`.
pub mod geo_taxonomy {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Global = 1,
Regional = 2,
MultiRegional = 3,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Global => "GLOBAL",
Type::Regional => "REGIONAL",
Type::MultiRegional => "MULTI_REGIONAL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"GLOBAL" => Some(Self::Global),
"REGIONAL" => Some(Self::Regional),
"MULTI_REGIONAL" => Some(Self::MultiRegional),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicesRequest {
#[prost(int32, tag = "1")]
pub page_size: i32,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicesResponse {
#[prost(message, repeated, tag = "1")]
pub services: ::prost::alloc::vec::Vec<Service>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "4")]
pub currency_code: ::prost::alloc::string::String,
#[prost(int32, tag = "5")]
pub page_size: i32,
#[prost(string, tag = "6")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusResponse {
#[prost(message, repeated, tag = "1")]
pub skus: ::prost::alloc::vec::Vec<Sku>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod cloud_catalog_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A catalog of Google Cloud Platform services and SKUs.
/// Provides pricing information and metadata on Google Cloud Platform services
/// and SKUs.
#[derive(Debug, Clone)]
pub struct CloudCatalogClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> CloudCatalogClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> CloudCatalogClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
CloudCatalogClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Lists all public cloud services.
pub async fn list_services(&mut self, request: impl tonic::IntoRequest<super::ListServicesRequest>) -> std::result::Result<tonic::Response<super::ListServicesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudCatalog/ListServices");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudCatalog", "ListServices"));
self.inner.unary(req, path, codec).await
}
/// Lists all publicly available SKUs for a given cloud service.
pub async fn list_skus(&mut self, request: impl tonic::IntoRequest<super::ListSkusRequest>) -> std::result::Result<tonic::Response<super::ListSkusResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.billing.v1.CloudCatalog/ListSkus");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.billing.v1.CloudCatalog", "ListSkus"));
self.inner.unary(req, path, codec).await
}
}
}
