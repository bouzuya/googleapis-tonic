// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestsLogEntry {
#[prost(string, tag = "1")]
pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemActivityLogEntry {
#[prost(string, tag = "1")]
pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduledBackupLogEntry {
#[prost(string, tag = "1")]
pub backup_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub service: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "scheduled_backup_log_entry::State", tag = "5")]
pub state: i32,
#[prost(int64, tag = "6")]
pub backup_size_bytes: i64,
#[prost(string, tag = "7")]
pub backup_location: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ScheduledBackupLogEntry`.
pub mod scheduled_backup_log_entry {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
InProgress = 1,
Succeeded = 2,
Failed = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::InProgress => "IN_PROGRESS",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"IN_PROGRESS" => Some(Self::InProgress),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
