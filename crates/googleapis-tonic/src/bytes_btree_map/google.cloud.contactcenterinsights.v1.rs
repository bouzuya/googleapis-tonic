// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub data_source: ::core::option::Option<ConversationDataSource>,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "17")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "14")]
pub language_code: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub agent_id: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "24")]
pub quality_metadata: ::core::option::Option<conversation::QualityMetadata>,
#[prost(message, optional, tag = "8")]
pub transcript: ::core::option::Option<conversation::Transcript>,
#[prost(enumeration = "conversation::Medium", tag = "9")]
pub medium: i32,
#[prost(message, optional, tag = "10")]
pub duration: ::core::option::Option<::prost_types::Duration>,
#[prost(int32, tag = "11")]
pub turn_count: i32,
#[prost(message, optional, tag = "12")]
pub latest_analysis: ::core::option::Option<Analysis>,
#[prost(message, optional, tag = "20")]
pub latest_summary: ::core::option::Option<ConversationSummarizationSuggestionData>,
#[prost(message, repeated, tag = "13")]
pub runtime_annotations: ::prost::alloc::vec::Vec<RuntimeAnnotation>,
#[prost(btree_map = "string, message", tag = "18")]
pub dialogflow_intents: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, DialogflowIntent>,
#[prost(string, tag = "21")]
pub obfuscated_user_id: ::prost::alloc::string::String,
#[prost(oneof = "conversation::Metadata", tags = "7")]
pub metadata: ::core::option::Option<conversation::Metadata>,
#[prost(oneof = "conversation::Expiration", tags = "15, 16")]
pub expiration: ::core::option::Option<conversation::Expiration>,
}
/// Nested message and enum types in `Conversation`.
pub mod conversation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallMetadata {
#[prost(int32, tag = "1")]
pub customer_channel: i32,
#[prost(int32, tag = "2")]
pub agent_channel: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QualityMetadata {
#[prost(int32, tag = "1")]
pub customer_satisfaction_rating: i32,
#[prost(message, optional, tag = "2")]
pub wait_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(string, tag = "3")]
pub menu_path: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub agent_info: ::prost::alloc::vec::Vec<quality_metadata::AgentInfo>,
}
/// Nested message and enum types in `QualityMetadata`.
pub mod quality_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentInfo {
#[prost(string, tag = "1")]
pub agent_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub team: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub disposition_code: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transcript {
#[prost(message, repeated, tag = "1")]
pub transcript_segments: ::prost::alloc::vec::Vec<transcript::TranscriptSegment>,
}
/// Nested message and enum types in `Transcript`.
pub mod transcript {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranscriptSegment {
#[prost(message, optional, tag = "6")]
pub message_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "1")]
pub text: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub confidence: f32,
#[prost(message, repeated, tag = "3")]
pub words: ::prost::alloc::vec::Vec<transcript_segment::WordInfo>,
#[prost(string, tag = "4")]
pub language_code: ::prost::alloc::string::String,
#[prost(int32, tag = "5")]
pub channel_tag: i32,
#[prost(message, optional, tag = "9")]
pub segment_participant: ::core::option::Option<super::super::ConversationParticipant>,
#[prost(message, optional, tag = "10")]
pub dialogflow_segment_metadata: ::core::option::Option<transcript_segment::DialogflowSegmentMetadata>,
#[prost(message, optional, tag = "11")]
pub sentiment: ::core::option::Option<super::super::SentimentData>,
}
/// Nested message and enum types in `TranscriptSegment`.
pub mod transcript_segment {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WordInfo {
#[prost(message, optional, tag = "1")]
pub start_offset: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "2")]
pub end_offset: ::core::option::Option<::prost_types::Duration>,
#[prost(string, tag = "3")]
pub word: ::prost::alloc::string::String,
#[prost(float, tag = "4")]
pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DialogflowSegmentMetadata {
#[prost(bool, tag = "1")]
pub smart_reply_allowlist_covered: bool,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Medium {
Unspecified = 0,
PhoneCall = 1,
Chat = 2,
}
impl Medium {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Medium::Unspecified => "MEDIUM_UNSPECIFIED",
Medium::PhoneCall => "PHONE_CALL",
Medium::Chat => "CHAT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MEDIUM_UNSPECIFIED" => Some(Self::Unspecified),
"PHONE_CALL" => Some(Self::PhoneCall),
"CHAT" => Some(Self::Chat),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Metadata {
#[prost(message, tag = "7")]
CallMetadata(CallMetadata),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Expiration {
#[prost(message, tag = "15")]
ExpireTime(::prost_types::Timestamp),
#[prost(message, tag = "16")]
Ttl(::prost_types::Duration),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Analysis {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub request_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub analysis_result: ::core::option::Option<AnalysisResult>,
#[prost(message, optional, tag = "8")]
pub annotator_selector: ::core::option::Option<AnnotatorSelector>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationDataSource {
#[prost(oneof = "conversation_data_source::Source", tags = "1, 3")]
pub source: ::core::option::Option<conversation_data_source::Source>,
}
/// Nested message and enum types in `ConversationDataSource`.
pub mod conversation_data_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "1")]
GcsSource(super::GcsSource),
#[prost(message, tag = "3")]
DialogflowSource(super::DialogflowSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
#[prost(string, tag = "1")]
pub audio_uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub transcript_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogflowSource {
#[prost(string, tag = "1")]
pub dialogflow_conversation: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub audio_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisResult {
#[prost(message, optional, tag = "1")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(oneof = "analysis_result::Metadata", tags = "2")]
pub metadata: ::core::option::Option<analysis_result::Metadata>,
}
/// Nested message and enum types in `AnalysisResult`.
pub mod analysis_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallAnalysisMetadata {
#[prost(message, repeated, tag = "2")]
pub annotations: ::prost::alloc::vec::Vec<super::CallAnnotation>,
#[prost(btree_map = "string, message", tag = "3")]
pub entities: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::Entity>,
#[prost(message, repeated, tag = "4")]
pub sentiments: ::prost::alloc::vec::Vec<super::ConversationLevelSentiment>,
#[prost(btree_map = "string, message", tag = "6")]
pub intents: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::Intent>,
#[prost(btree_map = "string, message", tag = "7")]
pub phrase_matchers: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::PhraseMatchData>,
#[prost(message, optional, tag = "8")]
pub issue_model_result: ::core::option::Option<super::IssueModelResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Metadata {
#[prost(message, tag = "2")]
CallAnalysisMetadata(CallAnalysisMetadata),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueModelResult {
#[prost(string, tag = "1")]
pub issue_model: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub issues: ::prost::alloc::vec::Vec<IssueAssignment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversationLevelSentiment {
#[prost(int32, tag = "1")]
pub channel_tag: i32,
#[prost(message, optional, tag = "2")]
pub sentiment_data: ::core::option::Option<SentimentData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueAssignment {
#[prost(string, tag = "1")]
pub issue: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub score: f64,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallAnnotation {
#[prost(int32, tag = "1")]
pub channel_tag: i32,
#[prost(message, optional, tag = "4")]
pub annotation_start_boundary: ::core::option::Option<AnnotationBoundary>,
#[prost(message, optional, tag = "5")]
pub annotation_end_boundary: ::core::option::Option<AnnotationBoundary>,
#[prost(oneof = "call_annotation::Data", tags = "10, 11, 12, 13, 15, 16, 17, 18")]
pub data: ::core::option::Option<call_annotation::Data>,
}
/// Nested message and enum types in `CallAnnotation`.
pub mod call_annotation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Data {
#[prost(message, tag = "10")]
InterruptionData(super::InterruptionData),
#[prost(message, tag = "11")]
SentimentData(super::SentimentData),
#[prost(message, tag = "12")]
SilenceData(super::SilenceData),
#[prost(message, tag = "13")]
HoldData(super::HoldData),
#[prost(message, tag = "15")]
EntityMentionData(super::EntityMentionData),
#[prost(message, tag = "16")]
IntentMatchData(super::IntentMatchData),
#[prost(message, tag = "17")]
PhraseMatchData(super::PhraseMatchData),
#[prost(message, tag = "18")]
IssueMatchData(super::IssueMatchData),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnnotationBoundary {
#[prost(int32, tag = "1")]
pub transcript_index: i32,
#[prost(oneof = "annotation_boundary::DetailedBoundary", tags = "3")]
pub detailed_boundary: ::core::option::Option<annotation_boundary::DetailedBoundary>,
}
/// Nested message and enum types in `AnnotationBoundary`.
pub mod annotation_boundary {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum DetailedBoundary {
#[prost(int32, tag = "3")]
WordIndex(i32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
#[prost(string, tag = "1")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "entity::Type", tag = "2")]
pub r#type: i32,
#[prost(btree_map = "string, string", tag = "3")]
pub metadata: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(float, tag = "4")]
pub salience: f32,
#[prost(message, optional, tag = "5")]
pub sentiment: ::core::option::Option<SentimentData>,
}
/// Nested message and enum types in `Entity`.
pub mod entity {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Person = 1,
Location = 2,
Organization = 3,
Event = 4,
WorkOfArt = 5,
ConsumerGood = 6,
Other = 7,
PhoneNumber = 9,
Address = 10,
Date = 11,
Number = 12,
Price = 13,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Person => "PERSON",
Type::Location => "LOCATION",
Type::Organization => "ORGANIZATION",
Type::Event => "EVENT",
Type::WorkOfArt => "WORK_OF_ART",
Type::ConsumerGood => "CONSUMER_GOOD",
Type::Other => "OTHER",
Type::PhoneNumber => "PHONE_NUMBER",
Type::Address => "ADDRESS",
Type::Date => "DATE",
Type::Number => "NUMBER",
Type::Price => "PRICE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PERSON" => Some(Self::Person),
"LOCATION" => Some(Self::Location),
"ORGANIZATION" => Some(Self::Organization),
"EVENT" => Some(Self::Event),
"WORK_OF_ART" => Some(Self::WorkOfArt),
"CONSUMER_GOOD" => Some(Self::ConsumerGood),
"OTHER" => Some(Self::Other),
"PHONE_NUMBER" => Some(Self::PhoneNumber),
"ADDRESS" => Some(Self::Address),
"DATE" => Some(Self::Date),
"NUMBER" => Some(Self::Number),
"PRICE" => Some(Self::Price),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Intent {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatchData {
#[prost(string, tag = "1")]
pub phrase_matcher: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogflowIntent {
#[prost(string, tag = "1")]
pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterruptionData {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SilenceData {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HoldData {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMentionData {
#[prost(string, tag = "1")]
pub entity_unique_id: ::prost::alloc::string::String,
#[prost(enumeration = "entity_mention_data::MentionType", tag = "2")]
pub r#type: i32,
#[prost(message, optional, tag = "3")]
pub sentiment: ::core::option::Option<SentimentData>,
}
/// Nested message and enum types in `EntityMentionData`.
pub mod entity_mention_data {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MentionType {
Unspecified = 0,
Proper = 1,
Common = 2,
}
impl MentionType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MentionType::Unspecified => "MENTION_TYPE_UNSPECIFIED",
MentionType::Proper => "PROPER",
MentionType::Common => "COMMON",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MENTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PROPER" => Some(Self::Proper),
"COMMON" => Some(Self::Common),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentMatchData {
#[prost(string, tag = "1")]
pub intent_unique_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SentimentData {
#[prost(float, tag = "1")]
pub magnitude: f32,
#[prost(float, tag = "2")]
pub score: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueMatchData {
#[prost(message, optional, tag = "1")]
pub issue_assignment: ::core::option::Option<IssueAssignment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueModel {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "8")]
pub issue_count: i64,
#[prost(enumeration = "issue_model::State", tag = "5")]
pub state: i32,
#[prost(message, optional, tag = "6")]
pub input_data_config: ::core::option::Option<issue_model::InputDataConfig>,
#[prost(message, optional, tag = "7")]
pub training_stats: ::core::option::Option<IssueModelLabelStats>,
#[prost(enumeration = "issue_model::ModelType", tag = "9")]
pub model_type: i32,
#[prost(string, tag = "10")]
pub language_code: ::prost::alloc::string::String,
}
/// Nested message and enum types in `IssueModel`.
pub mod issue_model {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputDataConfig {
#[deprecated]
#[prost(enumeration = "super::conversation::Medium", tag = "1")]
pub medium: i32,
#[prost(int64, tag = "2")]
pub training_conversations_count: i64,
#[prost(string, tag = "3")]
pub filter: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Undeployed = 1,
Deploying = 2,
Deployed = 3,
Undeploying = 4,
Deleting = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Undeployed => "UNDEPLOYED",
State::Deploying => "DEPLOYING",
State::Deployed => "DEPLOYED",
State::Undeploying => "UNDEPLOYING",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"UNDEPLOYED" => Some(Self::Undeployed),
"DEPLOYING" => Some(Self::Deploying),
"DEPLOYED" => Some(Self::Deployed),
"UNDEPLOYING" => Some(Self::Undeploying),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelType {
Unspecified = 0,
TypeV1 = 1,
TypeV2 = 2,
}
impl ModelType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ModelType::Unspecified => "MODEL_TYPE_UNSPECIFIED",
ModelType::TypeV1 => "TYPE_V1",
ModelType::TypeV2 => "TYPE_V2",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"TYPE_V1" => Some(Self::TypeV1),
"TYPE_V2" => Some(Self::TypeV2),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Issue {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, repeated, tag = "6")]
pub sample_utterances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueModelLabelStats {
#[prost(int64, tag = "1")]
pub analyzed_conversations_count: i64,
#[prost(int64, tag = "2")]
pub unclassified_conversations_count: i64,
#[prost(btree_map = "string, message", tag = "3")]
pub issue_stats: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, issue_model_label_stats::IssueStats>,
}
/// Nested message and enum types in `IssueModelLabelStats`.
pub mod issue_model_label_stats {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueStats {
#[prost(string, tag = "1")]
pub issue: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub labeled_conversations_count: i64,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatcher {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub revision_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub version_tag: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "phrase_matcher::PhraseMatcherType", tag = "6")]
pub r#type: i32,
#[prost(bool, tag = "7")]
pub active: bool,
#[prost(message, repeated, tag = "8")]
pub phrase_match_rule_groups: ::prost::alloc::vec::Vec<PhraseMatchRuleGroup>,
#[prost(message, optional, tag = "9")]
pub activation_update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "conversation_participant::Role", tag = "10")]
pub role_match: i32,
#[prost(message, optional, tag = "11")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PhraseMatcher`.
pub mod phrase_matcher {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PhraseMatcherType {
Unspecified = 0,
AllOf = 1,
AnyOf = 2,
}
impl PhraseMatcherType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PhraseMatcherType::Unspecified => "PHRASE_MATCHER_TYPE_UNSPECIFIED",
PhraseMatcherType::AllOf => "ALL_OF",
PhraseMatcherType::AnyOf => "ANY_OF",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PHRASE_MATCHER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ALL_OF" => Some(Self::AllOf),
"ANY_OF" => Some(Self::AnyOf),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatchRuleGroup {
#[prost(enumeration = "phrase_match_rule_group::PhraseMatchRuleGroupType", tag = "1")]
pub r#type: i32,
#[prost(message, repeated, tag = "2")]
pub phrase_match_rules: ::prost::alloc::vec::Vec<PhraseMatchRule>,
}
/// Nested message and enum types in `PhraseMatchRuleGroup`.
pub mod phrase_match_rule_group {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PhraseMatchRuleGroupType {
Unspecified = 0,
AllOf = 1,
AnyOf = 2,
}
impl PhraseMatchRuleGroupType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PhraseMatchRuleGroupType::Unspecified => "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED",
PhraseMatchRuleGroupType::AllOf => "ALL_OF",
PhraseMatchRuleGroupType::AnyOf => "ANY_OF",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ALL_OF" => Some(Self::AllOf),
"ANY_OF" => Some(Self::AnyOf),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatchRule {
#[prost(string, tag = "1")]
pub query: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub negated: bool,
#[prost(message, optional, tag = "3")]
pub config: ::core::option::Option<PhraseMatchRuleConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhraseMatchRuleConfig {
#[prost(oneof = "phrase_match_rule_config::Config", tags = "1")]
pub config: ::core::option::Option<phrase_match_rule_config::Config>,
}
/// Nested message and enum types in `PhraseMatchRuleConfig`.
pub mod phrase_match_rule_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Config {
#[prost(message, tag = "1")]
ExactMatchConfig(super::ExactMatchConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExactMatchConfig {
#[prost(bool, tag = "1")]
pub case_sensitive: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "4")]
pub language_code: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub conversation_ttl: ::core::option::Option<::prost_types::Duration>,
#[prost(btree_map = "string, string", tag = "6")]
pub pubsub_notification_settings: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub analysis_config: ::core::option::Option<settings::AnalysisConfig>,
#[prost(message, optional, tag = "10")]
pub redaction_config: ::core::option::Option<RedactionConfig>,
#[prost(message, optional, tag = "11")]
pub speech_config: ::core::option::Option<SpeechConfig>,
}
/// Nested message and enum types in `Settings`.
pub mod settings {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisConfig {
#[prost(double, tag = "1")]
pub runtime_integration_analysis_percentage: f64,
#[prost(double, tag = "6")]
pub upload_conversation_analysis_percentage: f64,
#[prost(message, optional, tag = "5")]
pub annotator_selector: ::core::option::Option<super::AnnotatorSelector>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedactionConfig {
#[prost(string, tag = "1")]
pub deidentify_template: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub inspect_template: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechConfig {
#[prost(string, tag = "1")]
pub speech_recognizer: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeAnnotation {
#[prost(string, tag = "1")]
pub annotation_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub start_boundary: ::core::option::Option<AnnotationBoundary>,
#[prost(message, optional, tag = "4")]
pub end_boundary: ::core::option::Option<AnnotationBoundary>,
#[prost(message, optional, tag = "5")]
pub answer_feedback: ::core::option::Option<AnswerFeedback>,
#[prost(oneof = "runtime_annotation::Data", tags = "6, 7, 8, 9, 10, 12")]
pub data: ::core::option::Option<runtime_annotation::Data>,
}
/// Nested message and enum types in `RuntimeAnnotation`.
pub mod runtime_annotation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Data {
#[prost(message, tag = "6")]
ArticleSuggestion(super::ArticleSuggestionData),
#[prost(message, tag = "7")]
FaqAnswer(super::FaqAnswerData),
#[prost(message, tag = "8")]
SmartReply(super::SmartReplyData),
#[prost(message, tag = "9")]
SmartComposeSuggestion(super::SmartComposeSuggestionData),
#[prost(message, tag = "10")]
DialogflowInteraction(super::DialogflowInteractionData),
#[prost(message, tag = "12")]
ConversationSummarizationSuggestion(super::ConversationSummarizationSuggestionData),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnswerFeedback {
#[prost(enumeration = "answer_feedback::CorrectnessLevel", tag = "1")]
pub correctness_level: i32,
#[prost(bool, tag = "2")]
pub clicked: bool,
#[prost(bool, tag = "3")]
pub displayed: bool,
}
/// Nested message and enum types in `AnswerFeedback`.
pub mod answer_feedback {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CorrectnessLevel {
Unspecified = 0,
NotCorrect = 1,
PartiallyCorrect = 2,
FullyCorrect = 3,
}
impl CorrectnessLevel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CorrectnessLevel::Unspecified => "CORRECTNESS_LEVEL_UNSPECIFIED",
CorrectnessLevel::NotCorrect => "NOT_CORRECT",
CorrectnessLevel::PartiallyCorrect => "PARTIALLY_CORRECT",
CorrectnessLevel::FullyCorrect => "FULLY_CORRECT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CORRECTNESS_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
"NOT_CORRECT" => Some(Self::NotCorrect),
"PARTIALLY_CORRECT" => Some(Self::PartiallyCorrect),
"FULLY_CORRECT" => Some(Self::FullyCorrect),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArticleSuggestionData {
#[prost(string, tag = "1")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uri: ::prost::alloc::string::String,
#[prost(float, tag = "3")]
pub confidence_score: f32,
#[prost(btree_map = "string, string", tag = "4")]
pub metadata: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub query_record: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub source: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaqAnswerData {
#[prost(string, tag = "1")]
pub answer: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub confidence_score: f32,
#[prost(string, tag = "3")]
pub question: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "4")]
pub metadata: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub query_record: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub source: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartReplyData {
#[prost(string, tag = "1")]
pub reply: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub confidence_score: f64,
#[prost(btree_map = "string, string", tag = "3")]
pub metadata: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub query_record: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartComposeSuggestionData {
#[prost(string, tag = "1")]
pub suggestion: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub confidence_score: f64,
#[prost(btree_map = "string, string", tag = "3")]
pub metadata: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub query_record: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogflowInteractionData {
#[prost(string, tag = "1")]
pub dialogflow_intent_id: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationSummarizationSuggestionData {
#[prost(string, tag = "1")]
pub text: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "5")]
pub text_sections: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(float, tag = "2")]
pub confidence: f32,
#[prost(btree_map = "string, string", tag = "3")]
pub metadata: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub answer_record: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub conversation_model: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationParticipant {
#[deprecated]
#[prost(string, tag = "1")]
pub dialogflow_participant: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub obfuscated_external_user_id: ::prost::alloc::string::String,
#[prost(enumeration = "conversation_participant::Role", tag = "2")]
pub role: i32,
#[prost(oneof = "conversation_participant::Participant", tags = "5, 6")]
pub participant: ::core::option::Option<conversation_participant::Participant>,
}
/// Nested message and enum types in `ConversationParticipant`.
pub mod conversation_participant {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Role {
Unspecified = 0,
HumanAgent = 1,
AutomatedAgent = 2,
EndUser = 3,
AnyAgent = 4,
}
impl Role {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Role::Unspecified => "ROLE_UNSPECIFIED",
Role::HumanAgent => "HUMAN_AGENT",
Role::AutomatedAgent => "AUTOMATED_AGENT",
Role::EndUser => "END_USER",
Role::AnyAgent => "ANY_AGENT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ROLE_UNSPECIFIED" => Some(Self::Unspecified),
"HUMAN_AGENT" => Some(Self::HumanAgent),
"AUTOMATED_AGENT" => Some(Self::AutomatedAgent),
"END_USER" => Some(Self::EndUser),
"ANY_AGENT" => Some(Self::AnyAgent),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Participant {
#[prost(string, tag = "5")]
DialogflowParticipantName(::prost::alloc::string::String),
#[prost(string, tag = "6")]
UserId(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct View {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotatorSelector {
#[prost(bool, tag = "1")]
pub run_interruption_annotator: bool,
#[prost(bool, tag = "2")]
pub run_silence_annotator: bool,
#[prost(bool, tag = "3")]
pub run_phrase_matcher_annotator: bool,
#[prost(string, repeated, tag = "4")]
pub phrase_matchers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "5")]
pub run_sentiment_annotator: bool,
#[prost(bool, tag = "6")]
pub run_entity_annotator: bool,
#[prost(bool, tag = "7")]
pub run_intent_annotator: bool,
#[prost(bool, tag = "8")]
pub run_issue_model_annotator: bool,
#[prost(string, repeated, tag = "10")]
pub issue_models: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bool, tag = "9")]
pub run_summarization_annotator: bool,
#[prost(message, optional, tag = "11")]
pub summarization_config: ::core::option::Option<annotator_selector::SummarizationConfig>,
}
/// Nested message and enum types in `AnnotatorSelector`.
pub mod annotator_selector {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationConfig {
#[prost(oneof = "summarization_config::ModelSource", tags = "1, 2")]
pub model_source: ::core::option::Option<summarization_config::ModelSource>,
}
/// Nested message and enum types in `SummarizationConfig`.
pub mod summarization_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SummarizationModel {
Unspecified = 0,
BaselineModel = 1,
}
impl SummarizationModel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SummarizationModel::Unspecified => "SUMMARIZATION_MODEL_UNSPECIFIED",
SummarizationModel::BaselineModel => "BASELINE_MODEL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SUMMARIZATION_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
"BASELINE_MODEL" => Some(Self::BaselineModel),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ModelSource {
#[prost(string, tag = "1")]
ConversationProfile(::prost::alloc::string::String),
#[prost(enumeration = "SummarizationModel", tag = "2")]
SummarizationModel(i32),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateStatsRequest {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateStatsResponse {
#[prost(message, optional, tag = "1")]
pub average_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(int32, tag = "2")]
pub average_turn_count: i32,
#[prost(int32, tag = "3")]
pub conversation_count: i32,
#[prost(btree_map = "string, int32", tag = "4")]
pub smart_highlighter_matches: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
#[prost(btree_map = "string, int32", tag = "5")]
pub custom_highlighter_matches: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
#[prost(btree_map = "string, int32", tag = "6")]
pub issue_matches: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
#[prost(btree_map = "string, message", tag = "8")]
pub issue_matches_stats: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, issue_model_label_stats::IssueStats>,
#[prost(message, optional, tag = "7")]
pub conversation_count_time_series: ::core::option::Option<calculate_stats_response::TimeSeries>,
}
/// Nested message and enum types in `CalculateStatsResponse`.
pub mod calculate_stats_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
#[prost(message, optional, tag = "1")]
pub interval_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(message, repeated, tag = "2")]
pub points: ::prost::alloc::vec::Vec<time_series::Interval>,
}
/// Nested message and enum types in `TimeSeries`.
pub mod time_series {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Interval {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int32, tag = "2")]
pub conversation_count: i32,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnalysisOperationMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "3")]
pub conversation: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub annotator_selector: ::core::option::Option<AnnotatorSelector>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversation: ::core::option::Option<Conversation>,
#[prost(string, tag = "3")]
pub conversation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversationRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub conversation: ::core::option::Option<Conversation>,
#[prost(string, tag = "3")]
pub conversation_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub redaction_config: ::core::option::Option<RedactionConfig>,
#[prost(message, optional, tag = "11")]
pub speech_config: ::core::option::Option<SpeechConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversationMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<UploadConversationRequest>,
#[prost(string, tag = "4")]
pub analysis_operation: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub applied_redaction_config: ::core::option::Option<RedactionConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(enumeration = "ConversationView", tag = "5")]
pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsResponse {
#[prost(message, repeated, tag = "1")]
pub conversations: ::prost::alloc::vec::Vec<Conversation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "ConversationView", tag = "2")]
pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversationRequest {
#[prost(message, optional, tag = "1")]
pub conversation: ::core::option::Option<Conversation>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConversationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestConversationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub conversation_config: ::core::option::Option<ingest_conversations_request::ConversationConfig>,
#[prost(message, optional, tag = "5")]
pub redaction_config: ::core::option::Option<RedactionConfig>,
#[prost(message, optional, tag = "6")]
pub speech_config: ::core::option::Option<SpeechConfig>,
#[prost(oneof = "ingest_conversations_request::Source", tags = "2")]
pub source: ::core::option::Option<ingest_conversations_request::Source>,
#[prost(oneof = "ingest_conversations_request::ObjectConfig", tags = "3")]
pub object_config: ::core::option::Option<ingest_conversations_request::ObjectConfig>,
}
/// Nested message and enum types in `IngestConversationsRequest`.
pub mod ingest_conversations_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
#[prost(string, tag = "1")]
pub bucket_uri: ::prost::alloc::string::String,
#[prost(enumeration = "gcs_source::BucketObjectType", tag = "2")]
pub bucket_object_type: i32,
}
/// Nested message and enum types in `GcsSource`.
pub mod gcs_source {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BucketObjectType {
Unspecified = 0,
Transcript = 1,
Audio = 2,
}
impl BucketObjectType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
BucketObjectType::Unspecified => "BUCKET_OBJECT_TYPE_UNSPECIFIED",
BucketObjectType::Transcript => "TRANSCRIPT",
BucketObjectType::Audio => "AUDIO",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"BUCKET_OBJECT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"TRANSCRIPT" => Some(Self::Transcript),
"AUDIO" => Some(Self::Audio),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TranscriptObjectConfig {
#[prost(enumeration = "super::conversation::Medium", tag = "1")]
pub medium: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationConfig {
#[prost(string, tag = "1")]
pub agent_id: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub agent_channel: i32,
#[prost(int32, tag = "3")]
pub customer_channel: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
GcsSource(GcsSource),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum ObjectConfig {
#[prost(message, tag = "3")]
TranscriptObjectConfig(TranscriptObjectConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestConversationsMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<IngestConversationsRequest>,
#[prost(message, repeated, tag = "4")]
pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "5")]
pub ingest_conversations_stats: ::core::option::Option<ingest_conversations_metadata::IngestConversationsStats>,
}
/// Nested message and enum types in `IngestConversationsMetadata`.
pub mod ingest_conversations_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IngestConversationsStats {
#[prost(int32, tag = "1")]
pub processed_object_count: i32,
#[prost(int32, tag = "2")]
pub duplicates_skipped_count: i32,
#[prost(int32, tag = "3")]
pub successful_ingest_count: i32,
#[prost(int32, tag = "4")]
pub failed_ingest_count: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IngestConversationsResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnalysisRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub analysis: ::core::option::Option<Analysis>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysesResponse {
#[prost(message, repeated, tag = "1")]
pub analyses: ::prost::alloc::vec::Vec<Analysis>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalysisRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnalysisRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkAnalyzeConversationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(float, tag = "3")]
pub analysis_percentage: f32,
#[prost(message, optional, tag = "8")]
pub annotator_selector: ::core::option::Option<AnnotatorSelector>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkAnalyzeConversationsMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<BulkAnalyzeConversationsRequest>,
#[prost(int32, tag = "4")]
pub completed_analyses_count: i32,
#[prost(int32, tag = "5")]
pub failed_analyses_count: i32,
#[prost(int32, tag = "6")]
pub total_requested_analyses_count: i32,
#[prost(message, repeated, tag = "7")]
pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkAnalyzeConversationsResponse {
#[prost(int32, tag = "1")]
pub successful_analysis_count: i32,
#[prost(int32, tag = "2")]
pub failed_analysis_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkDeleteConversationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub max_delete_count: i32,
#[prost(bool, tag = "4")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkDeleteConversationsMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<BulkDeleteConversationsRequest>,
#[prost(message, repeated, tag = "4")]
pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkDeleteConversationsResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportInsightsDataRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub kms_key: ::prost::alloc::string::String,
#[prost(enumeration = "export_insights_data_request::WriteDisposition", tag = "5")]
pub write_disposition: i32,
#[prost(oneof = "export_insights_data_request::Destination", tags = "2")]
pub destination: ::core::option::Option<export_insights_data_request::Destination>,
}
/// Nested message and enum types in `ExportInsightsDataRequest`.
pub mod export_insights_data_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryDestination {
#[prost(string, tag = "3")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub dataset: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub table: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WriteDisposition {
Unspecified = 0,
WriteTruncate = 1,
WriteAppend = 2,
}
impl WriteDisposition {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
WriteDisposition::Unspecified => "WRITE_DISPOSITION_UNSPECIFIED",
WriteDisposition::WriteTruncate => "WRITE_TRUNCATE",
WriteDisposition::WriteAppend => "WRITE_APPEND",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"WRITE_DISPOSITION_UNSPECIFIED" => Some(Self::Unspecified),
"WRITE_TRUNCATE" => Some(Self::WriteTruncate),
"WRITE_APPEND" => Some(Self::WriteAppend),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(message, tag = "2")]
BigQueryDestination(BigQueryDestination),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportInsightsDataMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<ExportInsightsDataRequest>,
#[prost(message, repeated, tag = "4")]
pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportInsightsDataResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueModelRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub issue_model: ::core::option::Option<IssueModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueModelMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<CreateIssueModelRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueModelRequest {
#[prost(message, optional, tag = "1")]
pub issue_model: ::core::option::Option<IssueModel>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssueModelsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssueModelsResponse {
#[prost(message, repeated, tag = "1")]
pub issue_models: ::prost::alloc::vec::Vec<IssueModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIssueModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueModelMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<DeleteIssueModelRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIssueModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeployIssueModelResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIssueModelMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<DeployIssueModelRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIssueModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UndeployIssueModelResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIssueModelMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub request: ::core::option::Option<UndeployIssueModelRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIssueRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssuesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssuesResponse {
#[prost(message, repeated, tag = "1")]
pub issues: ::prost::alloc::vec::Vec<Issue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueRequest {
#[prost(message, optional, tag = "1")]
pub issue: ::core::option::Option<Issue>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateIssueModelStatsRequest {
#[prost(string, tag = "1")]
pub issue_model: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateIssueModelStatsResponse {
#[prost(message, optional, tag = "4")]
pub current_stats: ::core::option::Option<IssueModelLabelStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePhraseMatcherRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub phrase_matcher: ::core::option::Option<PhraseMatcher>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPhraseMatchersRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPhraseMatchersResponse {
#[prost(message, repeated, tag = "1")]
pub phrase_matchers: ::prost::alloc::vec::Vec<PhraseMatcher>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPhraseMatcherRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePhraseMatcherRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePhraseMatcherRequest {
#[prost(message, optional, tag = "1")]
pub phrase_matcher: ::core::option::Option<PhraseMatcher>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettingsRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSettingsRequest {
#[prost(message, optional, tag = "1")]
pub settings: ::core::option::Option<Settings>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateViewRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub view: ::core::option::Option<View>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetViewRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListViewsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListViewsResponse {
#[prost(message, repeated, tag = "1")]
pub views: ::prost::alloc::vec::Vec<View>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateViewRequest {
#[prost(message, optional, tag = "1")]
pub view: ::core::option::Option<View>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteViewRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConversationView {
Unspecified = 0,
Full = 2,
Basic = 1,
}
impl ConversationView {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ConversationView::Unspecified => "CONVERSATION_VIEW_UNSPECIFIED",
ConversationView::Full => "FULL",
ConversationView::Basic => "BASIC",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CONVERSATION_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
"FULL" => Some(Self::Full),
"BASIC" => Some(Self::Basic),
_ => None,
}
}
}
/// Generated client implementations.
pub mod contact_center_insights_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// An API that lets users analyze and explore their business conversation data.
#[derive(Debug, Clone)]
pub struct ContactCenterInsightsClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ContactCenterInsightsClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ContactCenterInsightsClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ContactCenterInsightsClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a conversation.
pub async fn create_conversation(&mut self, request: impl tonic::IntoRequest<super::CreateConversationRequest>) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "CreateConversation"));
self.inner.unary(req, path, codec).await
}
/// Create a longrunning conversation upload operation. This method differs
/// from CreateConversation by allowing audio transcription and optional DLP
/// redaction.
pub async fn upload_conversation(&mut self, request: impl tonic::IntoRequest<super::UploadConversationRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UploadConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UploadConversation"));
self.inner.unary(req, path, codec).await
}
/// Updates a conversation.
pub async fn update_conversation(&mut self, request: impl tonic::IntoRequest<super::UpdateConversationRequest>) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UpdateConversation"));
self.inner.unary(req, path, codec).await
}
/// Gets a conversation.
pub async fn get_conversation(&mut self, request: impl tonic::IntoRequest<super::GetConversationRequest>) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "GetConversation"));
self.inner.unary(req, path, codec).await
}
/// Lists conversations.
pub async fn list_conversations(&mut self, request: impl tonic::IntoRequest<super::ListConversationsRequest>) -> std::result::Result<tonic::Response<super::ListConversationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListConversations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "ListConversations"));
self.inner.unary(req, path, codec).await
}
/// Deletes a conversation.
pub async fn delete_conversation(&mut self, request: impl tonic::IntoRequest<super::DeleteConversationRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteConversation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "DeleteConversation"));
self.inner.unary(req, path, codec).await
}
/// Creates an analysis. The long running operation is done when the analysis
/// has completed.
pub async fn create_analysis(&mut self, request: impl tonic::IntoRequest<super::CreateAnalysisRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateAnalysis");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "CreateAnalysis"));
self.inner.unary(req, path, codec).await
}
/// Gets an analysis.
pub async fn get_analysis(&mut self, request: impl tonic::IntoRequest<super::GetAnalysisRequest>) -> std::result::Result<tonic::Response<super::Analysis>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetAnalysis");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "GetAnalysis"));
self.inner.unary(req, path, codec).await
}
/// Lists analyses.
pub async fn list_analyses(&mut self, request: impl tonic::IntoRequest<super::ListAnalysesRequest>) -> std::result::Result<tonic::Response<super::ListAnalysesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListAnalyses");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "ListAnalyses"));
self.inner.unary(req, path, codec).await
}
/// Deletes an analysis.
pub async fn delete_analysis(&mut self, request: impl tonic::IntoRequest<super::DeleteAnalysisRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteAnalysis");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "DeleteAnalysis"));
self.inner.unary(req, path, codec).await
}
/// Analyzes multiple conversations in a single request.
pub async fn bulk_analyze_conversations(&mut self, request: impl tonic::IntoRequest<super::BulkAnalyzeConversationsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/BulkAnalyzeConversations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "BulkAnalyzeConversations"));
self.inner.unary(req, path, codec).await
}
/// Deletes multiple conversations in a single request.
pub async fn bulk_delete_conversations(&mut self, request: impl tonic::IntoRequest<super::BulkDeleteConversationsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/BulkDeleteConversations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "BulkDeleteConversations"));
self.inner.unary(req, path, codec).await
}
/// Imports conversations and processes them according to the user's
/// configuration.
pub async fn ingest_conversations(&mut self, request: impl tonic::IntoRequest<super::IngestConversationsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/IngestConversations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "IngestConversations"));
self.inner.unary(req, path, codec).await
}
/// Export insights data to a destination defined in the request body.
pub async fn export_insights_data(&mut self, request: impl tonic::IntoRequest<super::ExportInsightsDataRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ExportInsightsData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "ExportInsightsData"));
self.inner.unary(req, path, codec).await
}
/// Creates an issue model.
pub async fn create_issue_model(&mut self, request: impl tonic::IntoRequest<super::CreateIssueModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateIssueModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "CreateIssueModel"));
self.inner.unary(req, path, codec).await
}
/// Updates an issue model.
pub async fn update_issue_model(&mut self, request: impl tonic::IntoRequest<super::UpdateIssueModelRequest>) -> std::result::Result<tonic::Response<super::IssueModel>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateIssueModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UpdateIssueModel"));
self.inner.unary(req, path, codec).await
}
/// Gets an issue model.
pub async fn get_issue_model(&mut self, request: impl tonic::IntoRequest<super::GetIssueModelRequest>) -> std::result::Result<tonic::Response<super::IssueModel>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetIssueModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "GetIssueModel"));
self.inner.unary(req, path, codec).await
}
/// Lists issue models.
pub async fn list_issue_models(&mut self, request: impl tonic::IntoRequest<super::ListIssueModelsRequest>) -> std::result::Result<tonic::Response<super::ListIssueModelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListIssueModels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "ListIssueModels"));
self.inner.unary(req, path, codec).await
}
/// Deletes an issue model.
pub async fn delete_issue_model(&mut self, request: impl tonic::IntoRequest<super::DeleteIssueModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteIssueModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "DeleteIssueModel"));
self.inner.unary(req, path, codec).await
}
/// Deploys an issue model. Returns an error if a model is already deployed.
/// An issue model can only be used in analysis after it has been deployed.
pub async fn deploy_issue_model(&mut self, request: impl tonic::IntoRequest<super::DeployIssueModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeployIssueModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "DeployIssueModel"));
self.inner.unary(req, path, codec).await
}
/// Undeploys an issue model.
/// An issue model can not be used in analysis after it has been undeployed.
pub async fn undeploy_issue_model(&mut self, request: impl tonic::IntoRequest<super::UndeployIssueModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UndeployIssueModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UndeployIssueModel"));
self.inner.unary(req, path, codec).await
}
/// Gets an issue.
pub async fn get_issue(&mut self, request: impl tonic::IntoRequest<super::GetIssueRequest>) -> std::result::Result<tonic::Response<super::Issue>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetIssue");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "GetIssue"));
self.inner.unary(req, path, codec).await
}
/// Lists issues.
pub async fn list_issues(&mut self, request: impl tonic::IntoRequest<super::ListIssuesRequest>) -> std::result::Result<tonic::Response<super::ListIssuesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListIssues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "ListIssues"));
self.inner.unary(req, path, codec).await
}
/// Updates an issue.
pub async fn update_issue(&mut self, request: impl tonic::IntoRequest<super::UpdateIssueRequest>) -> std::result::Result<tonic::Response<super::Issue>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateIssue");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UpdateIssue"));
self.inner.unary(req, path, codec).await
}
/// Deletes an issue.
pub async fn delete_issue(&mut self, request: impl tonic::IntoRequest<super::DeleteIssueRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteIssue");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "DeleteIssue"));
self.inner.unary(req, path, codec).await
}
/// Gets an issue model's statistics.
pub async fn calculate_issue_model_stats(&mut self, request: impl tonic::IntoRequest<super::CalculateIssueModelStatsRequest>) -> std::result::Result<tonic::Response<super::CalculateIssueModelStatsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CalculateIssueModelStats");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "CalculateIssueModelStats"));
self.inner.unary(req, path, codec).await
}
/// Creates a phrase matcher.
pub async fn create_phrase_matcher(&mut self, request: impl tonic::IntoRequest<super::CreatePhraseMatcherRequest>) -> std::result::Result<tonic::Response<super::PhraseMatcher>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreatePhraseMatcher");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "CreatePhraseMatcher"));
self.inner.unary(req, path, codec).await
}
/// Gets a phrase matcher.
pub async fn get_phrase_matcher(&mut self, request: impl tonic::IntoRequest<super::GetPhraseMatcherRequest>) -> std::result::Result<tonic::Response<super::PhraseMatcher>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetPhraseMatcher");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "GetPhraseMatcher"));
self.inner.unary(req, path, codec).await
}
/// Lists phrase matchers.
pub async fn list_phrase_matchers(&mut self, request: impl tonic::IntoRequest<super::ListPhraseMatchersRequest>) -> std::result::Result<tonic::Response<super::ListPhraseMatchersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListPhraseMatchers");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "ListPhraseMatchers"));
self.inner.unary(req, path, codec).await
}
/// Deletes a phrase matcher.
pub async fn delete_phrase_matcher(&mut self, request: impl tonic::IntoRequest<super::DeletePhraseMatcherRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeletePhraseMatcher");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "DeletePhraseMatcher"));
self.inner.unary(req, path, codec).await
}
/// Updates a phrase matcher.
pub async fn update_phrase_matcher(&mut self, request: impl tonic::IntoRequest<super::UpdatePhraseMatcherRequest>) -> std::result::Result<tonic::Response<super::PhraseMatcher>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdatePhraseMatcher");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UpdatePhraseMatcher"));
self.inner.unary(req, path, codec).await
}
/// Gets conversation statistics.
pub async fn calculate_stats(&mut self, request: impl tonic::IntoRequest<super::CalculateStatsRequest>) -> std::result::Result<tonic::Response<super::CalculateStatsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CalculateStats");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "CalculateStats"));
self.inner.unary(req, path, codec).await
}
/// Gets project-level settings.
pub async fn get_settings(&mut self, request: impl tonic::IntoRequest<super::GetSettingsRequest>) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetSettings");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "GetSettings"));
self.inner.unary(req, path, codec).await
}
/// Updates project-level settings.
pub async fn update_settings(&mut self, request: impl tonic::IntoRequest<super::UpdateSettingsRequest>) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateSettings");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UpdateSettings"));
self.inner.unary(req, path, codec).await
}
/// Creates a view.
pub async fn create_view(&mut self, request: impl tonic::IntoRequest<super::CreateViewRequest>) -> std::result::Result<tonic::Response<super::View>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "CreateView"));
self.inner.unary(req, path, codec).await
}
/// Gets a view.
pub async fn get_view(&mut self, request: impl tonic::IntoRequest<super::GetViewRequest>) -> std::result::Result<tonic::Response<super::View>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "GetView"));
self.inner.unary(req, path, codec).await
}
/// Lists views.
pub async fn list_views(&mut self, request: impl tonic::IntoRequest<super::ListViewsRequest>) -> std::result::Result<tonic::Response<super::ListViewsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListViews");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "ListViews"));
self.inner.unary(req, path, codec).await
}
/// Updates a view.
pub async fn update_view(&mut self, request: impl tonic::IntoRequest<super::UpdateViewRequest>) -> std::result::Result<tonic::Response<super::View>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "UpdateView"));
self.inner.unary(req, path, codec).await
}
/// Deletes a view.
pub async fn delete_view(&mut self, request: impl tonic::IntoRequest<super::DeleteViewRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.contactcenterinsights.v1.ContactCenterInsights", "DeleteView"));
self.inner.unary(req, path, codec).await
}
}
}
