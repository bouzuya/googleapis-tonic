// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub network: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub endpoint_uri: ::prost::alloc::string::String,
#[prost(int32, tag = "9")]
pub port: i32,
#[prost(enumeration = "service::State", tag = "10")]
pub state: i32,
#[prost(string, tag = "11")]
pub state_message: ::prost::alloc::string::String,
#[prost(string, tag = "12")]
pub artifact_gcs_uri: ::prost::alloc::string::String,
#[prost(enumeration = "service::Tier", tag = "13")]
pub tier: i32,
#[prost(message, optional, tag = "14")]
pub metadata_integration: ::core::option::Option<MetadataIntegration>,
#[prost(message, optional, tag = "15")]
pub maintenance_window: ::core::option::Option<MaintenanceWindow>,
#[prost(string, tag = "16")]
pub uid: ::prost::alloc::string::String,
#[prost(message, optional, tag = "17")]
pub metadata_management_activity: ::core::option::Option<MetadataManagementActivity>,
#[prost(enumeration = "service::ReleaseChannel", tag = "19")]
pub release_channel: i32,
#[prost(message, optional, tag = "20")]
pub encryption_config: ::core::option::Option<EncryptionConfig>,
#[prost(message, optional, tag = "21")]
pub network_config: ::core::option::Option<NetworkConfig>,
#[prost(enumeration = "service::DatabaseType", tag = "22")]
pub database_type: i32,
#[prost(message, optional, tag = "23")]
pub telemetry_config: ::core::option::Option<TelemetryConfig>,
#[prost(message, optional, tag = "24")]
pub scaling_config: ::core::option::Option<ScalingConfig>,
#[prost(oneof = "service::MetastoreConfig", tags = "5")]
pub metastore_config: ::core::option::Option<service::MetastoreConfig>,
}
/// Nested message and enum types in `Service`.
pub mod service {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Active = 2,
Suspending = 3,
Suspended = 4,
Updating = 5,
Deleting = 6,
Error = 7,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Active => "ACTIVE",
State::Suspending => "SUSPENDING",
State::Suspended => "SUSPENDED",
State::Updating => "UPDATING",
State::Deleting => "DELETING",
State::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"ACTIVE" => Some(Self::Active),
"SUSPENDING" => Some(Self::Suspending),
"SUSPENDED" => Some(Self::Suspended),
"UPDATING" => Some(Self::Updating),
"DELETING" => Some(Self::Deleting),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Tier {
Unspecified = 0,
Developer = 1,
Enterprise = 3,
}
impl Tier {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Tier::Unspecified => "TIER_UNSPECIFIED",
Tier::Developer => "DEVELOPER",
Tier::Enterprise => "ENTERPRISE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TIER_UNSPECIFIED" => Some(Self::Unspecified),
"DEVELOPER" => Some(Self::Developer),
"ENTERPRISE" => Some(Self::Enterprise),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReleaseChannel {
Unspecified = 0,
Canary = 1,
Stable = 2,
}
impl ReleaseChannel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ReleaseChannel::Unspecified => "RELEASE_CHANNEL_UNSPECIFIED",
ReleaseChannel::Canary => "CANARY",
ReleaseChannel::Stable => "STABLE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RELEASE_CHANNEL_UNSPECIFIED" => Some(Self::Unspecified),
"CANARY" => Some(Self::Canary),
"STABLE" => Some(Self::Stable),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseType {
Unspecified = 0,
Mysql = 1,
Spanner = 2,
}
impl DatabaseType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DatabaseType::Unspecified => "DATABASE_TYPE_UNSPECIFIED",
DatabaseType::Mysql => "MYSQL",
DatabaseType::Spanner => "SPANNER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DATABASE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"MYSQL" => Some(Self::Mysql),
"SPANNER" => Some(Self::Spanner),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum MetastoreConfig {
#[prost(message, tag = "5")]
HiveMetastoreConfig(super::HiveMetastoreConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataIntegration {
#[prost(message, optional, tag = "1")]
pub data_catalog_config: ::core::option::Option<DataCatalogConfig>,
#[prost(message, optional, tag = "2")]
pub dataplex_config: ::core::option::Option<DataplexConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataCatalogConfig {
#[prost(bool, tag = "2")]
pub enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataplexConfig {
#[prost(btree_map = "string, message", tag = "1")]
pub lake_resources: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, Lake>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lake {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaintenanceWindow {
#[prost(message, optional, tag = "1")]
pub hour_of_day: ::core::option::Option<i32>,
#[prost(enumeration = "super::super::super::r#type::DayOfWeek", tag = "2")]
pub day_of_week: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HiveMetastoreConfig {
#[prost(string, tag = "1")]
pub version: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "2")]
pub config_overrides: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub kerberos_config: ::core::option::Option<KerberosConfig>,
#[prost(enumeration = "hive_metastore_config::EndpointProtocol", tag = "4")]
pub endpoint_protocol: i32,
#[prost(btree_map = "string, message", tag = "5")]
pub auxiliary_versions: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, AuxiliaryVersionConfig>,
}
/// Nested message and enum types in `HiveMetastoreConfig`.
pub mod hive_metastore_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EndpointProtocol {
Unspecified = 0,
Thrift = 1,
Grpc = 2,
}
impl EndpointProtocol {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EndpointProtocol::Unspecified => "ENDPOINT_PROTOCOL_UNSPECIFIED",
EndpointProtocol::Thrift => "THRIFT",
EndpointProtocol::Grpc => "GRPC",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENDPOINT_PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
"THRIFT" => Some(Self::Thrift),
"GRPC" => Some(Self::Grpc),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KerberosConfig {
#[prost(message, optional, tag = "1")]
pub keytab: ::core::option::Option<Secret>,
#[prost(string, tag = "2")]
pub principal: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub krb5_config_gcs_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
#[prost(oneof = "secret::Value", tags = "2")]
pub value: ::core::option::Option<secret::Value>,
}
/// Nested message and enum types in `Secret`.
pub mod secret {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(string, tag = "2")]
CloudSecret(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionConfig {
#[prost(string, tag = "1")]
pub kms_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuxiliaryVersionConfig {
#[prost(string, tag = "1")]
pub version: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "2")]
pub config_overrides: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub network_config: ::core::option::Option<NetworkConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
#[prost(message, repeated, tag = "1")]
pub consumers: ::prost::alloc::vec::Vec<network_config::Consumer>,
#[prost(bool, tag = "2")]
pub custom_routes_enabled: bool,
}
/// Nested message and enum types in `NetworkConfig`.
pub mod network_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Consumer {
#[prost(string, tag = "3")]
pub endpoint_uri: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub endpoint_location: ::prost::alloc::string::String,
#[prost(oneof = "consumer::VpcResource", tags = "1")]
pub vpc_resource: ::core::option::Option<consumer::VpcResource>,
}
/// Nested message and enum types in `Consumer`.
pub mod consumer {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum VpcResource {
#[prost(string, tag = "1")]
Subnetwork(::prost::alloc::string::String),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TelemetryConfig {
#[prost(enumeration = "telemetry_config::LogFormat", tag = "1")]
pub log_format: i32,
}
/// Nested message and enum types in `TelemetryConfig`.
pub mod telemetry_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogFormat {
Unspecified = 0,
Legacy = 1,
Json = 2,
}
impl LogFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LogFormat::Unspecified => "LOG_FORMAT_UNSPECIFIED",
LogFormat::Legacy => "LEGACY",
LogFormat::Json => "JSON",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOG_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"LEGACY" => Some(Self::Legacy),
"JSON" => Some(Self::Json),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataManagementActivity {
#[prost(message, repeated, tag = "1")]
pub metadata_exports: ::prost::alloc::vec::Vec<MetadataExport>,
#[prost(message, repeated, tag = "2")]
pub restores: ::prost::alloc::vec::Vec<Restore>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataImport {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "metadata_import::State", tag = "5")]
pub state: i32,
#[prost(oneof = "metadata_import::Metadata", tags = "6")]
pub metadata: ::core::option::Option<metadata_import::Metadata>,
}
/// Nested message and enum types in `MetadataImport`.
pub mod metadata_import {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseDump {
#[deprecated]
#[prost(enumeration = "database_dump::DatabaseType", tag = "1")]
pub database_type: i32,
#[prost(string, tag = "2")]
pub gcs_uri: ::prost::alloc::string::String,
#[deprecated]
#[prost(string, tag = "3")]
pub source_database: ::prost::alloc::string::String,
#[prost(enumeration = "super::database_dump_spec::Type", tag = "4")]
pub r#type: i32,
}
/// Nested message and enum types in `DatabaseDump`.
pub mod database_dump {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseType {
Unspecified = 0,
Mysql = 1,
}
impl DatabaseType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DatabaseType::Unspecified => "DATABASE_TYPE_UNSPECIFIED",
DatabaseType::Mysql => "MYSQL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DATABASE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"MYSQL" => Some(Self::Mysql),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Running = 1,
Succeeded = 2,
Updating = 3,
Failed = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::Updating => "UPDATING",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"UPDATING" => Some(Self::Updating),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Metadata {
#[prost(message, tag = "6")]
DatabaseDump(DatabaseDump),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataExport {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "metadata_export::State", tag = "3")]
pub state: i32,
#[prost(enumeration = "database_dump_spec::Type", tag = "5")]
pub database_dump_type: i32,
#[prost(oneof = "metadata_export::Destination", tags = "4")]
pub destination: ::core::option::Option<metadata_export::Destination>,
}
/// Nested message and enum types in `MetadataExport`.
pub mod metadata_export {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Running = 1,
Succeeded = 2,
Failed = 3,
Cancelled = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(string, tag = "4")]
DestinationGcsUri(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backup {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "backup::State", tag = "4")]
pub state: i32,
#[prost(message, optional, tag = "5")]
pub service_revision: ::core::option::Option<Service>,
#[prost(string, tag = "6")]
pub description: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "7")]
pub restoring_services: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Backup`.
pub mod backup {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Deleting = 2,
Active = 3,
Failed = 4,
Restoring = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Deleting => "DELETING",
State::Active => "ACTIVE",
State::Failed => "FAILED",
State::Restoring => "RESTORING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"DELETING" => Some(Self::Deleting),
"ACTIVE" => Some(Self::Active),
"FAILED" => Some(Self::Failed),
"RESTORING" => Some(Self::Restoring),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restore {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "restore::State", tag = "3")]
pub state: i32,
#[prost(string, tag = "4")]
pub backup: ::prost::alloc::string::String,
#[prost(enumeration = "restore::RestoreType", tag = "5")]
pub r#type: i32,
#[prost(string, tag = "6")]
pub details: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Restore`.
pub mod restore {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Running = 1,
Succeeded = 2,
Failed = 3,
Cancelled = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RestoreType {
Unspecified = 0,
Full = 1,
MetadataOnly = 2,
}
impl RestoreType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RestoreType::Unspecified => "RESTORE_TYPE_UNSPECIFIED",
RestoreType::Full => "FULL",
RestoreType::MetadataOnly => "METADATA_ONLY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RESTORE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"FULL" => Some(Self::Full),
"METADATA_ONLY" => Some(Self::MetadataOnly),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScalingConfig {
#[prost(oneof = "scaling_config::ScalingModel", tags = "1, 2")]
pub scaling_model: ::core::option::Option<scaling_config::ScalingModel>,
}
/// Nested message and enum types in `ScalingConfig`.
pub mod scaling_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstanceSize {
Unspecified = 0,
ExtraSmall = 1,
Small = 2,
Medium = 3,
Large = 4,
ExtraLarge = 5,
}
impl InstanceSize {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
InstanceSize::Unspecified => "INSTANCE_SIZE_UNSPECIFIED",
InstanceSize::ExtraSmall => "EXTRA_SMALL",
InstanceSize::Small => "SMALL",
InstanceSize::Medium => "MEDIUM",
InstanceSize::Large => "LARGE",
InstanceSize::ExtraLarge => "EXTRA_LARGE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INSTANCE_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
"EXTRA_SMALL" => Some(Self::ExtraSmall),
"SMALL" => Some(Self::Small),
"MEDIUM" => Some(Self::Medium),
"LARGE" => Some(Self::Large),
"EXTRA_LARGE" => Some(Self::ExtraLarge),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum ScalingModel {
#[prost(enumeration = "InstanceSize", tag = "1")]
InstanceSize(i32),
#[prost(float, tag = "2")]
ScalingFactor(f32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicesResponse {
#[prost(message, repeated, tag = "1")]
pub services: ::prost::alloc::vec::Vec<Service>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub service_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub service: ::core::option::Option<Service>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub service: ::core::option::Option<Service>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServiceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataImportsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataImportsResponse {
#[prost(message, repeated, tag = "1")]
pub metadata_imports: ::prost::alloc::vec::Vec<MetadataImport>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataImportRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataImportRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub metadata_import_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub metadata_import: ::core::option::Option<MetadataImport>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMetadataImportRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub metadata_import: ::core::option::Option<MetadataImport>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsResponse {
#[prost(message, repeated, tag = "1")]
pub backups: ::prost::alloc::vec::Vec<Backup>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub backup_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub backup: ::core::option::Option<Backup>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackupRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportMetadataRequest {
#[prost(string, tag = "1")]
pub service: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
#[prost(enumeration = "database_dump_spec::Type", tag = "4")]
pub database_dump_type: i32,
#[prost(oneof = "export_metadata_request::Destination", tags = "2")]
pub destination: ::core::option::Option<export_metadata_request::Destination>,
}
/// Nested message and enum types in `ExportMetadataRequest`.
pub mod export_metadata_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(string, tag = "2")]
DestinationGcsFolder(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreServiceRequest {
#[prost(string, tag = "1")]
pub service: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub backup: ::prost::alloc::string::String,
#[prost(enumeration = "restore::RestoreType", tag = "3")]
pub restore_type: i32,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "3")]
pub target: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub verb: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub status_message: ::prost::alloc::string::String,
#[prost(bool, tag = "6")]
pub requested_cancellation: bool,
#[prost(string, tag = "7")]
pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationMetadata {
#[prost(message, repeated, tag = "1")]
pub supported_hive_metastore_versions: ::prost::alloc::vec::Vec<location_metadata::HiveMetastoreVersion>,
}
/// Nested message and enum types in `LocationMetadata`.
pub mod location_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HiveMetastoreVersion {
#[prost(string, tag = "1")]
pub version: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub is_default: bool,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatabaseDumpSpec {}
/// Nested message and enum types in `DatabaseDumpSpec`.
pub mod database_dump_spec {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Mysql = 1,
Avro = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Mysql => "MYSQL",
Type::Avro => "AVRO",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"MYSQL" => Some(Self::Mysql),
"AVRO" => Some(Self::Avro),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveIamPolicyRequest {
#[prost(string, tag = "1")]
pub resource: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub asynchronous: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveIamPolicyResponse {
#[prost(bool, tag = "1")]
pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMetadataRequest {
#[prost(string, tag = "1")]
pub service: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub query: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMetadataResponse {
#[prost(string, tag = "1")]
pub result_manifest_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
#[prost(btree_map = "string, string", tag = "1")]
pub details: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveTableToDatabaseRequest {
#[prost(string, tag = "1")]
pub service: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub table_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub db_name: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub destination_db_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MoveTableToDatabaseResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterMetadataResourceLocationRequest {
#[prost(string, tag = "1")]
pub service: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub location_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AlterMetadataResourceLocationResponse {}
/// Generated client implementations.
pub mod dataproc_metastore_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Configures and manages metastore services.
/// Metastore services are fully managed, highly available, autoscaled,
/// autohealing, OSS-native deployments of technical metadata management
/// software. Each metastore service exposes a network endpoint through which
/// metadata queries are served. Metadata queries can originate from a variety
/// of sources, including Apache Hive, Apache Presto, and Apache Spark.
///
/// The Dataproc Metastore API defines the following resource model:
///
/// * The service works with a collection of Google Cloud projects, named:
/// `/projects/*`
/// * Each project has a collection of available locations, named: `/locations/*`
///   (a location must refer to a Google Cloud `region`)
/// * Each location has a collection of services, named: `/services/*`
/// * Dataproc Metastore services are resources with names of the form:
///
///   `/projects/{project_number}/locations/{location_id}/services/{service_id}`.
#[derive(Debug, Clone)]
pub struct DataprocMetastoreClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DataprocMetastoreClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DataprocMetastoreClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DataprocMetastoreClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Lists services in a project and location.
pub async fn list_services(&mut self, request: impl tonic::IntoRequest<super::ListServicesRequest>) -> std::result::Result<tonic::Response<super::ListServicesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/ListServices");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "ListServices"));
self.inner.unary(req, path, codec).await
}
/// Gets the details of a single service.
pub async fn get_service(&mut self, request: impl tonic::IntoRequest<super::GetServiceRequest>) -> std::result::Result<tonic::Response<super::Service>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/GetService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "GetService"));
self.inner.unary(req, path, codec).await
}
/// Creates a metastore service in a project and location.
pub async fn create_service(&mut self, request: impl tonic::IntoRequest<super::CreateServiceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/CreateService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "CreateService"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single service.
pub async fn update_service(&mut self, request: impl tonic::IntoRequest<super::UpdateServiceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/UpdateService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "UpdateService"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single service.
pub async fn delete_service(&mut self, request: impl tonic::IntoRequest<super::DeleteServiceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/DeleteService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "DeleteService"));
self.inner.unary(req, path, codec).await
}
/// Lists imports in a service.
pub async fn list_metadata_imports(&mut self, request: impl tonic::IntoRequest<super::ListMetadataImportsRequest>) -> std::result::Result<tonic::Response<super::ListMetadataImportsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/ListMetadataImports");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "ListMetadataImports"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single import.
pub async fn get_metadata_import(&mut self, request: impl tonic::IntoRequest<super::GetMetadataImportRequest>) -> std::result::Result<tonic::Response<super::MetadataImport>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/GetMetadataImport");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "GetMetadataImport"));
self.inner.unary(req, path, codec).await
}
/// Creates a new MetadataImport in a given project and location.
pub async fn create_metadata_import(&mut self, request: impl tonic::IntoRequest<super::CreateMetadataImportRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/CreateMetadataImport");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "CreateMetadataImport"));
self.inner.unary(req, path, codec).await
}
/// Updates a single import.
/// Only the description field of MetadataImport is supported to be updated.
pub async fn update_metadata_import(&mut self, request: impl tonic::IntoRequest<super::UpdateMetadataImportRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/UpdateMetadataImport");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "UpdateMetadataImport"));
self.inner.unary(req, path, codec).await
}
/// Exports metadata from a service.
pub async fn export_metadata(&mut self, request: impl tonic::IntoRequest<super::ExportMetadataRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/ExportMetadata");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "ExportMetadata"));
self.inner.unary(req, path, codec).await
}
/// Restores a service from a backup.
pub async fn restore_service(&mut self, request: impl tonic::IntoRequest<super::RestoreServiceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/RestoreService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "RestoreService"));
self.inner.unary(req, path, codec).await
}
/// Lists backups in a service.
pub async fn list_backups(&mut self, request: impl tonic::IntoRequest<super::ListBackupsRequest>) -> std::result::Result<tonic::Response<super::ListBackupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/ListBackups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "ListBackups"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single backup.
pub async fn get_backup(&mut self, request: impl tonic::IntoRequest<super::GetBackupRequest>) -> std::result::Result<tonic::Response<super::Backup>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/GetBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "GetBackup"));
self.inner.unary(req, path, codec).await
}
/// Creates a new backup in a given project and location.
pub async fn create_backup(&mut self, request: impl tonic::IntoRequest<super::CreateBackupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/CreateBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "CreateBackup"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single backup.
pub async fn delete_backup(&mut self, request: impl tonic::IntoRequest<super::DeleteBackupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/DeleteBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "DeleteBackup"));
self.inner.unary(req, path, codec).await
}
/// Removes the attached IAM policies for a resource
pub async fn remove_iam_policy(&mut self, request: impl tonic::IntoRequest<super::RemoveIamPolicyRequest>) -> std::result::Result<tonic::Response<super::RemoveIamPolicyResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/RemoveIamPolicy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "RemoveIamPolicy"));
self.inner.unary(req, path, codec).await
}
/// Query DPMS metadata.
pub async fn query_metadata(&mut self, request: impl tonic::IntoRequest<super::QueryMetadataRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/QueryMetadata");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "QueryMetadata"));
self.inner.unary(req, path, codec).await
}
/// Move a table to another database.
pub async fn move_table_to_database(&mut self, request: impl tonic::IntoRequest<super::MoveTableToDatabaseRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/MoveTableToDatabase");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "MoveTableToDatabase"));
self.inner.unary(req, path, codec).await
}
/// Alter metadata resource location. The metadata resource can be a database,
/// table, or partition. This functionality only updates the parent directory
/// for the respective metadata resource and does not transfer any existing
/// data to the new location.
pub async fn alter_metadata_resource_location(&mut self, request: impl tonic::IntoRequest<super::AlterMetadataResourceLocationRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastore/AlterMetadataResourceLocation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastore", "AlterMetadataResourceLocation"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Federation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub version: ::prost::alloc::string::String,
#[prost(btree_map = "int32, message", tag = "6")]
pub backend_metastores: ::prost::alloc::collections::BTreeMap<i32, BackendMetastore>,
#[prost(string, tag = "7")]
pub endpoint_uri: ::prost::alloc::string::String,
#[prost(enumeration = "federation::State", tag = "8")]
pub state: i32,
#[prost(string, tag = "9")]
pub state_message: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub uid: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Federation`.
pub mod federation {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Active = 2,
Updating = 3,
Deleting = 4,
Error = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Active => "ACTIVE",
State::Updating => "UPDATING",
State::Deleting => "DELETING",
State::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"ACTIVE" => Some(Self::Active),
"UPDATING" => Some(Self::Updating),
"DELETING" => Some(Self::Deleting),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendMetastore {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "backend_metastore::MetastoreType", tag = "2")]
pub metastore_type: i32,
}
/// Nested message and enum types in `BackendMetastore`.
pub mod backend_metastore {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetastoreType {
Unspecified = 0,
Dataplex = 1,
Bigquery = 2,
DataprocMetastore = 3,
}
impl MetastoreType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MetastoreType::Unspecified => "METASTORE_TYPE_UNSPECIFIED",
MetastoreType::Dataplex => "DATAPLEX",
MetastoreType::Bigquery => "BIGQUERY",
MetastoreType::DataprocMetastore => "DATAPROC_METASTORE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"METASTORE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"DATAPLEX" => Some(Self::Dataplex),
"BIGQUERY" => Some(Self::Bigquery),
"DATAPROC_METASTORE" => Some(Self::DataprocMetastore),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFederationsResponse {
#[prost(message, repeated, tag = "1")]
pub federations: ::prost::alloc::vec::Vec<Federation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFederationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFederationRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub federation_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub federation: ::core::option::Option<Federation>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFederationRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub federation: ::core::option::Option<Federation>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFederationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod dataproc_metastore_federation_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Configures and manages metastore federation services.
/// Dataproc Metastore Federation Service allows federating a collection of
/// backend metastores like BigQuery, Dataplex Lakes, and other Dataproc
/// Metastores. The Federation Service exposes a gRPC URL through which metadata
/// from the backend metastores are served at query time.
///
/// The Dataproc Metastore Federation API defines the following resource model:
/// * The service works with a collection of Google Cloud projects.
/// * Each project has a collection of available locations.
/// * Each location has a collection of federations.
/// * Dataproc Metastore Federations are resources with names of the
/// form:
/// `projects/{project_number}/locations/{location_id}/federations/{federation_id}`.
#[derive(Debug, Clone)]
pub struct DataprocMetastoreFederationClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DataprocMetastoreFederationClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DataprocMetastoreFederationClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DataprocMetastoreFederationClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Lists federations in a project and location.
pub async fn list_federations(&mut self, request: impl tonic::IntoRequest<super::ListFederationsRequest>) -> std::result::Result<tonic::Response<super::ListFederationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastoreFederation/ListFederations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastoreFederation", "ListFederations"));
self.inner.unary(req, path, codec).await
}
/// Gets the details of a single federation.
pub async fn get_federation(&mut self, request: impl tonic::IntoRequest<super::GetFederationRequest>) -> std::result::Result<tonic::Response<super::Federation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastoreFederation/GetFederation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastoreFederation", "GetFederation"));
self.inner.unary(req, path, codec).await
}
/// Creates a metastore federation in a project and location.
pub async fn create_federation(&mut self, request: impl tonic::IntoRequest<super::CreateFederationRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastoreFederation/CreateFederation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastoreFederation", "CreateFederation"));
self.inner.unary(req, path, codec).await
}
/// Updates the fields of a federation.
pub async fn update_federation(&mut self, request: impl tonic::IntoRequest<super::UpdateFederationRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastoreFederation/UpdateFederation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastoreFederation", "UpdateFederation"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single federation.
pub async fn delete_federation(&mut self, request: impl tonic::IntoRequest<super::DeleteFederationRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.metastore.v1alpha.DataprocMetastoreFederation/DeleteFederation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.metastore.v1alpha.DataprocMetastoreFederation", "DeleteFederation"));
self.inner.unary(req, path, codec).await
}
}
}
