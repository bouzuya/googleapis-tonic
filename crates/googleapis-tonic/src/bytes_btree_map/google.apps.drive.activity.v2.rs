// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDriveActivityRequest {
    #[prost(message, optional, tag = "5")]
    pub consolidation_strategy: ::core::option::Option<ConsolidationStrategy>,
    #[prost(int32, tag = "6")]
    pub page_size: i32,
    #[prost(string, tag = "7")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub filter: ::prost::alloc::string::String,
    #[prost(oneof = "query_drive_activity_request::Key", tags = "1, 2")]
    pub key: ::core::option::Option<query_drive_activity_request::Key>,
}
/// Nested message and enum types in `QueryDriveActivityRequest`.
pub mod query_drive_activity_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Key {
        #[prost(string, tag = "1")]
        ItemName(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        AncestorName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConsolidationStrategy {
    #[prost(oneof = "consolidation_strategy::Strategy", tags = "1, 2")]
    pub strategy: ::core::option::Option<consolidation_strategy::Strategy>,
}
/// Nested message and enum types in `ConsolidationStrategy`.
pub mod consolidation_strategy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NoConsolidation {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Legacy {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Strategy {
        #[prost(message, tag = "1")]
        None(NoConsolidation),
        #[prost(message, tag = "2")]
        Legacy(Legacy),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Actor {
    #[prost(oneof = "actor::Type", tags = "1, 2, 3, 4, 5")]
    pub r#type: ::core::option::Option<actor::Type>,
}
/// Nested message and enum types in `Actor`.
pub mod actor {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        User(super::User),
        #[prost(message, tag = "2")]
        Anonymous(super::AnonymousUser),
        #[prost(message, tag = "3")]
        Impersonation(super::Impersonation),
        #[prost(message, tag = "4")]
        System(super::SystemEvent),
        #[prost(message, tag = "5")]
        Administrator(super::Administrator),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(oneof = "user::Type", tags = "2, 3, 4")]
    pub r#type: ::core::option::Option<user::Type>,
}
/// Nested message and enum types in `User`.
pub mod user {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KnownUser {
        #[prost(string, tag = "1")]
        pub person_name: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub is_current_user: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DeletedUser {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UnknownUser {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "2")]
        KnownUser(KnownUser),
        #[prost(message, tag = "3")]
        DeletedUser(DeletedUser),
        #[prost(message, tag = "4")]
        UnknownUser(UnknownUser),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnonymousUser {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Impersonation {
    #[prost(message, optional, tag = "1")]
    pub impersonated_user: ::core::option::Option<User>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemEvent {
    #[prost(enumeration = "system_event::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `SystemEvent`.
pub mod system_event {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        UserDeletion = 1,
        TrashAutoPurge = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::UserDeletion => "USER_DELETION",
                Type::TrashAutoPurge => "TRASH_AUTO_PURGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "USER_DELETION" => Some(Self::UserDeletion),
                "TRASH_AUTO_PURGE" => Some(Self::TrashAutoPurge),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Administrator {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeRange {
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Domain {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub legacy_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub team_drive: ::core::option::Option<TeamDrive>,
    #[prost(oneof = "target::Object", tags = "1, 5, 3")]
    pub object: ::core::option::Option<target::Object>,
}
/// Nested message and enum types in `Target`.
pub mod target {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        DriveItem(super::DriveItem),
        #[prost(message, tag = "5")]
        Drive(super::Drive),
        #[prost(message, tag = "3")]
        FileComment(super::FileComment),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetReference {
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub team_drive: ::core::option::Option<TeamDriveReference>,
    #[prost(oneof = "target_reference::Object", tags = "1, 3")]
    pub object: ::core::option::Option<target_reference::Object>,
}
/// Nested message and enum types in `TargetReference`.
pub mod target_reference {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        DriveItem(super::DriveItemReference),
        #[prost(message, tag = "3")]
        Drive(super::DriveReference),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileComment {
    #[prost(string, tag = "1")]
    pub legacy_comment_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub legacy_discussion_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub link_to_discussion: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub parent: ::core::option::Option<DriveItem>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DriveItem {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub file: ::core::option::Option<drive_item::File>,
    #[deprecated]
    #[prost(message, optional, tag = "4")]
    pub folder: ::core::option::Option<drive_item::Folder>,
    #[prost(string, tag = "6")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(oneof = "drive_item::ItemType", tags = "8, 9")]
    pub item_type: ::core::option::Option<drive_item::ItemType>,
}
/// Nested message and enum types in `DriveItem`.
pub mod drive_item {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct File {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Folder {
        #[prost(enumeration = "folder::Type", tag = "6")]
        pub r#type: i32,
    }
    /// Nested message and enum types in `Folder`.
    pub mod folder {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            MyDriveRoot = 1,
            TeamDriveRoot = 2,
            StandardFolder = 3,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::MyDriveRoot => "MY_DRIVE_ROOT",
                    Type::TeamDriveRoot => "TEAM_DRIVE_ROOT",
                    Type::StandardFolder => "STANDARD_FOLDER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "MY_DRIVE_ROOT" => Some(Self::MyDriveRoot),
                    "TEAM_DRIVE_ROOT" => Some(Self::TeamDriveRoot),
                    "STANDARD_FOLDER" => Some(Self::StandardFolder),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DriveFile {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DriveFolder {
        #[prost(enumeration = "drive_folder::Type", tag = "6")]
        pub r#type: i32,
    }
    /// Nested message and enum types in `DriveFolder`.
    pub mod drive_folder {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            MyDriveRoot = 1,
            SharedDriveRoot = 2,
            StandardFolder = 3,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::MyDriveRoot => "MY_DRIVE_ROOT",
                    Type::SharedDriveRoot => "SHARED_DRIVE_ROOT",
                    Type::StandardFolder => "STANDARD_FOLDER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "MY_DRIVE_ROOT" => Some(Self::MyDriveRoot),
                    "SHARED_DRIVE_ROOT" => Some(Self::SharedDriveRoot),
                    "STANDARD_FOLDER" => Some(Self::StandardFolder),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ItemType {
        #[prost(message, tag = "8")]
        DriveFile(DriveFile),
        #[prost(message, tag = "9")]
        DriveFolder(DriveFolder),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub team_drive: ::core::option::Option<TeamDriveReference>,
    #[prost(message, optional, tag = "3")]
    pub domain: ::core::option::Option<Domain>,
    #[prost(oneof = "owner::Owner", tags = "1, 4")]
    pub owner: ::core::option::Option<owner::Owner>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(message, tag = "1")]
        User(super::User),
        #[prost(message, tag = "4")]
        Drive(super::DriveReference),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamDrive {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub root: ::core::option::Option<DriveItem>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Drive {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub root: ::core::option::Option<DriveItem>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DriveItemReference {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub file: ::core::option::Option<drive_item::File>,
    #[deprecated]
    #[prost(message, optional, tag = "4")]
    pub folder: ::core::option::Option<drive_item::Folder>,
    #[prost(oneof = "drive_item_reference::ItemType", tags = "8, 9")]
    pub item_type: ::core::option::Option<drive_item_reference::ItemType>,
}
/// Nested message and enum types in `DriveItemReference`.
pub mod drive_item_reference {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ItemType {
        #[prost(message, tag = "8")]
        DriveFile(super::drive_item::DriveFile),
        #[prost(message, tag = "9")]
        DriveFolder(super::drive_item::DriveFolder),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamDriveReference {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DriveReference {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(message, optional, tag = "1")]
    pub detail: ::core::option::Option<ActionDetail>,
    #[prost(message, optional, tag = "3")]
    pub actor: ::core::option::Option<Actor>,
    #[prost(message, optional, tag = "4")]
    pub target: ::core::option::Option<Target>,
    #[prost(oneof = "action::Time", tags = "5, 6")]
    pub time: ::core::option::Option<action::Time>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Time {
        #[prost(message, tag = "5")]
        Timestamp(::prost_types::Timestamp),
        #[prost(message, tag = "6")]
        TimeRange(super::TimeRange),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionDetail {
    #[prost(
        oneof = "action_detail::ActionDetail",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 19"
    )]
    pub action_detail: ::core::option::Option<action_detail::ActionDetail>,
}
/// Nested message and enum types in `ActionDetail`.
pub mod action_detail {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ActionDetail {
        #[prost(message, tag = "1")]
        Create(super::Create),
        #[prost(message, tag = "2")]
        Edit(super::Edit),
        #[prost(message, tag = "3")]
        Move(super::Move),
        #[prost(message, tag = "4")]
        Rename(super::Rename),
        #[prost(message, tag = "5")]
        Delete(super::Delete),
        #[prost(message, tag = "6")]
        Restore(super::Restore),
        #[prost(message, tag = "7")]
        PermissionChange(super::PermissionChange),
        #[prost(message, tag = "8")]
        Comment(super::Comment),
        #[prost(message, tag = "9")]
        DlpChange(super::DataLeakPreventionChange),
        #[prost(message, tag = "12")]
        Reference(super::ApplicationReference),
        #[prost(message, tag = "13")]
        SettingsChange(super::SettingsChange),
        #[prost(message, tag = "19")]
        AppliedLabelChange(super::AppliedLabelChange),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Create {
    #[prost(oneof = "create::Origin", tags = "1, 2, 3")]
    pub origin: ::core::option::Option<create::Origin>,
}
/// Nested message and enum types in `Create`.
pub mod create {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct New {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Upload {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Copy {
        #[prost(message, optional, tag = "1")]
        pub original_object: ::core::option::Option<super::TargetReference>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Origin {
        #[prost(message, tag = "1")]
        New(New),
        #[prost(message, tag = "2")]
        Upload(Upload),
        #[prost(message, tag = "3")]
        Copy(Copy),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Edit {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Move {
    #[prost(message, repeated, tag = "1")]
    pub added_parents: ::prost::alloc::vec::Vec<TargetReference>,
    #[prost(message, repeated, tag = "2")]
    pub removed_parents: ::prost::alloc::vec::Vec<TargetReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rename {
    #[prost(string, tag = "1")]
    pub old_title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Delete {
    #[prost(enumeration = "delete::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `Delete`.
pub mod delete {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Trash = 1,
        PermanentDelete = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Trash => "TRASH",
                Type::PermanentDelete => "PERMANENT_DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TRASH" => Some(Self::Trash),
                "PERMANENT_DELETE" => Some(Self::PermanentDelete),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Restore {
    #[prost(enumeration = "restore::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `Restore`.
pub mod restore {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Untrash = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Untrash => "UNTRASH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNTRASH" => Some(Self::Untrash),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionChange {
    #[prost(message, repeated, tag = "1")]
    pub added_permissions: ::prost::alloc::vec::Vec<Permission>,
    #[prost(message, repeated, tag = "2")]
    pub removed_permissions: ::prost::alloc::vec::Vec<Permission>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permission {
    #[prost(enumeration = "permission::Role", tag = "1")]
    pub role: i32,
    #[prost(bool, tag = "6")]
    pub allow_discovery: bool,
    #[prost(oneof = "permission::Scope", tags = "2, 3, 4, 5")]
    pub scope: ::core::option::Option<permission::Scope>,
}
/// Nested message and enum types in `Permission`.
pub mod permission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Anyone {}
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Role {
        Unspecified = 0,
        Owner = 1,
        Organizer = 2,
        FileOrganizer = 3,
        Editor = 4,
        Commenter = 5,
        Viewer = 6,
        PublishedViewer = 7,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Role::Unspecified => "ROLE_UNSPECIFIED",
                Role::Owner => "OWNER",
                Role::Organizer => "ORGANIZER",
                Role::FileOrganizer => "FILE_ORGANIZER",
                Role::Editor => "EDITOR",
                Role::Commenter => "COMMENTER",
                Role::Viewer => "VIEWER",
                Role::PublishedViewer => "PUBLISHED_VIEWER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
                "OWNER" => Some(Self::Owner),
                "ORGANIZER" => Some(Self::Organizer),
                "FILE_ORGANIZER" => Some(Self::FileOrganizer),
                "EDITOR" => Some(Self::Editor),
                "COMMENTER" => Some(Self::Commenter),
                "VIEWER" => Some(Self::Viewer),
                "PUBLISHED_VIEWER" => Some(Self::PublishedViewer),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Scope {
        #[prost(message, tag = "2")]
        User(super::User),
        #[prost(message, tag = "3")]
        Group(super::Group),
        #[prost(message, tag = "4")]
        Domain(super::Domain),
        #[prost(message, tag = "5")]
        Anyone(Anyone),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Comment {
    #[prost(message, repeated, tag = "7")]
    pub mentioned_users: ::prost::alloc::vec::Vec<User>,
    #[prost(oneof = "comment::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<comment::Type>,
}
/// Nested message and enum types in `Comment`.
pub mod comment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Post {
        #[prost(enumeration = "post::Subtype", tag = "1")]
        pub subtype: i32,
    }
    /// Nested message and enum types in `Post`.
    pub mod post {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Subtype {
            Unspecified = 0,
            Added = 1,
            Deleted = 2,
            ReplyAdded = 3,
            ReplyDeleted = 4,
            Resolved = 5,
            Reopened = 6,
        }
        impl Subtype {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Subtype::Unspecified => "SUBTYPE_UNSPECIFIED",
                    Subtype::Added => "ADDED",
                    Subtype::Deleted => "DELETED",
                    Subtype::ReplyAdded => "REPLY_ADDED",
                    Subtype::ReplyDeleted => "REPLY_DELETED",
                    Subtype::Resolved => "RESOLVED",
                    Subtype::Reopened => "REOPENED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUBTYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ADDED" => Some(Self::Added),
                    "DELETED" => Some(Self::Deleted),
                    "REPLY_ADDED" => Some(Self::ReplyAdded),
                    "REPLY_DELETED" => Some(Self::ReplyDeleted),
                    "RESOLVED" => Some(Self::Resolved),
                    "REOPENED" => Some(Self::Reopened),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Assignment {
        #[prost(enumeration = "assignment::Subtype", tag = "1")]
        pub subtype: i32,
        #[prost(message, optional, tag = "7")]
        pub assigned_user: ::core::option::Option<super::User>,
    }
    /// Nested message and enum types in `Assignment`.
    pub mod assignment {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Subtype {
            Unspecified = 0,
            Added = 1,
            Deleted = 2,
            ReplyAdded = 3,
            ReplyDeleted = 4,
            Resolved = 5,
            Reopened = 6,
            Reassigned = 7,
        }
        impl Subtype {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Subtype::Unspecified => "SUBTYPE_UNSPECIFIED",
                    Subtype::Added => "ADDED",
                    Subtype::Deleted => "DELETED",
                    Subtype::ReplyAdded => "REPLY_ADDED",
                    Subtype::ReplyDeleted => "REPLY_DELETED",
                    Subtype::Resolved => "RESOLVED",
                    Subtype::Reopened => "REOPENED",
                    Subtype::Reassigned => "REASSIGNED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUBTYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ADDED" => Some(Self::Added),
                    "DELETED" => Some(Self::Deleted),
                    "REPLY_ADDED" => Some(Self::ReplyAdded),
                    "REPLY_DELETED" => Some(Self::ReplyDeleted),
                    "RESOLVED" => Some(Self::Resolved),
                    "REOPENED" => Some(Self::Reopened),
                    "REASSIGNED" => Some(Self::Reassigned),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Suggestion {
        #[prost(enumeration = "suggestion::Subtype", tag = "1")]
        pub subtype: i32,
    }
    /// Nested message and enum types in `Suggestion`.
    pub mod suggestion {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Subtype {
            Unspecified = 0,
            Added = 1,
            Deleted = 2,
            ReplyAdded = 3,
            ReplyDeleted = 4,
            Accepted = 7,
            Rejected = 8,
            AcceptDeleted = 9,
            RejectDeleted = 10,
        }
        impl Subtype {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Subtype::Unspecified => "SUBTYPE_UNSPECIFIED",
                    Subtype::Added => "ADDED",
                    Subtype::Deleted => "DELETED",
                    Subtype::ReplyAdded => "REPLY_ADDED",
                    Subtype::ReplyDeleted => "REPLY_DELETED",
                    Subtype::Accepted => "ACCEPTED",
                    Subtype::Rejected => "REJECTED",
                    Subtype::AcceptDeleted => "ACCEPT_DELETED",
                    Subtype::RejectDeleted => "REJECT_DELETED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUBTYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ADDED" => Some(Self::Added),
                    "DELETED" => Some(Self::Deleted),
                    "REPLY_ADDED" => Some(Self::ReplyAdded),
                    "REPLY_DELETED" => Some(Self::ReplyDeleted),
                    "ACCEPTED" => Some(Self::Accepted),
                    "REJECTED" => Some(Self::Rejected),
                    "ACCEPT_DELETED" => Some(Self::AcceptDeleted),
                    "REJECT_DELETED" => Some(Self::RejectDeleted),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        Post(Post),
        #[prost(message, tag = "2")]
        Assignment(Assignment),
        #[prost(message, tag = "3")]
        Suggestion(Suggestion),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataLeakPreventionChange {
    #[prost(enumeration = "data_leak_prevention_change::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `DataLeakPreventionChange`.
pub mod data_leak_prevention_change {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Flagged = 1,
        Cleared = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Flagged => "FLAGGED",
                Type::Cleared => "CLEARED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FLAGGED" => Some(Self::Flagged),
                "CLEARED" => Some(Self::Cleared),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApplicationReference {
    #[prost(enumeration = "application_reference::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `ApplicationReference`.
pub mod application_reference {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        UnspecifiedReferenceType = 0,
        Link = 1,
        Discuss = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UnspecifiedReferenceType => "UNSPECIFIED_REFERENCE_TYPE",
                Type::Link => "LINK",
                Type::Discuss => "DISCUSS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_REFERENCE_TYPE" => Some(Self::UnspecifiedReferenceType),
                "LINK" => Some(Self::Link),
                "DISCUSS" => Some(Self::Discuss),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingsChange {
    #[prost(message, repeated, tag = "1")]
    pub restriction_changes: ::prost::alloc::vec::Vec<settings_change::RestrictionChange>,
}
/// Nested message and enum types in `SettingsChange`.
pub mod settings_change {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RestrictionChange {
        #[prost(enumeration = "restriction_change::Feature", tag = "1")]
        pub feature: i32,
        #[prost(enumeration = "restriction_change::Restriction", tag = "2")]
        pub new_restriction: i32,
    }
    /// Nested message and enum types in `RestrictionChange`.
    pub mod restriction_change {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Feature {
            Unspecified = 0,
            SharingOutsideDomain = 1,
            DirectSharing = 2,
            ItemDuplication = 3,
            DriveFileStream = 4,
            FileOrganizerCanShareFolders = 5,
        }
        impl Feature {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Feature::Unspecified => "FEATURE_UNSPECIFIED",
                    Feature::SharingOutsideDomain => "SHARING_OUTSIDE_DOMAIN",
                    Feature::DirectSharing => "DIRECT_SHARING",
                    Feature::ItemDuplication => "ITEM_DUPLICATION",
                    Feature::DriveFileStream => "DRIVE_FILE_STREAM",
                    Feature::FileOrganizerCanShareFolders => "FILE_ORGANIZER_CAN_SHARE_FOLDERS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FEATURE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SHARING_OUTSIDE_DOMAIN" => Some(Self::SharingOutsideDomain),
                    "DIRECT_SHARING" => Some(Self::DirectSharing),
                    "ITEM_DUPLICATION" => Some(Self::ItemDuplication),
                    "DRIVE_FILE_STREAM" => Some(Self::DriveFileStream),
                    "FILE_ORGANIZER_CAN_SHARE_FOLDERS" => Some(Self::FileOrganizerCanShareFolders),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Restriction {
            Unspecified = 0,
            Unrestricted = 1,
            FullyRestricted = 2,
        }
        impl Restriction {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Restriction::Unspecified => "RESTRICTION_UNSPECIFIED",
                    Restriction::Unrestricted => "UNRESTRICTED",
                    Restriction::FullyRestricted => "FULLY_RESTRICTED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RESTRICTION_UNSPECIFIED" => Some(Self::Unspecified),
                    "UNRESTRICTED" => Some(Self::Unrestricted),
                    "FULLY_RESTRICTED" => Some(Self::FullyRestricted),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppliedLabelChange {
    #[prost(message, repeated, tag = "1")]
    pub changes: ::prost::alloc::vec::Vec<applied_label_change::AppliedLabelChangeDetail>,
}
/// Nested message and enum types in `AppliedLabelChange`.
pub mod applied_label_change {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppliedLabelChangeDetail {
        #[prost(string, tag = "1")]
        pub label: ::prost::alloc::string::String,
        #[prost(enumeration = "applied_label_change_detail::Type", repeated, tag = "2")]
        pub types: ::prost::alloc::vec::Vec<i32>,
        #[prost(string, tag = "3")]
        pub title: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub field_changes: ::prost::alloc::vec::Vec<applied_label_change_detail::FieldValueChange>,
    }
    /// Nested message and enum types in `AppliedLabelChangeDetail`.
    pub mod applied_label_change_detail {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FieldValueChange {
            #[prost(string, optional, tag = "1")]
            pub field_id: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "2")]
            pub old_value: ::core::option::Option<field_value_change::FieldValue>,
            #[prost(message, optional, tag = "3")]
            pub new_value: ::core::option::Option<field_value_change::FieldValue>,
            #[prost(string, optional, tag = "4")]
            pub display_name: ::core::option::Option<::prost::alloc::string::String>,
        }
        /// Nested message and enum types in `FieldValueChange`.
        pub mod field_value_change {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct FieldValue {
                #[prost(oneof = "field_value::Value", tags = "1, 3, 4, 5, 6, 7, 8, 9")]
                pub value: ::core::option::Option<field_value::Value>,
            }
            /// Nested message and enum types in `FieldValue`.
            pub mod field_value {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Text {
                    #[prost(string, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost::alloc::string::String>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TextList {
                    #[prost(message, repeated, tag = "1")]
                    pub values: ::prost::alloc::vec::Vec<Text>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Selection {
                    #[prost(string, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost::alloc::string::String>,
                    #[prost(string, optional, tag = "2")]
                    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct SelectionList {
                    #[prost(message, repeated, tag = "1")]
                    pub values: ::prost::alloc::vec::Vec<Selection>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Integer {
                    #[prost(int64, optional, tag = "1")]
                    pub value: ::core::option::Option<i64>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct SingleUser {
                    #[prost(string, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost::alloc::string::String>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct UserList {
                    #[prost(message, repeated, tag = "1")]
                    pub values: ::prost::alloc::vec::Vec<SingleUser>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct Date {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost_types::Timestamp>,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Value {
                    #[prost(message, tag = "1")]
                    Text(Text),
                    #[prost(message, tag = "3")]
                    TextList(TextList),
                    #[prost(message, tag = "4")]
                    Selection(Selection),
                    #[prost(message, tag = "5")]
                    SelectionList(SelectionList),
                    #[prost(message, tag = "6")]
                    Integer(Integer),
                    #[prost(message, tag = "7")]
                    User(SingleUser),
                    #[prost(message, tag = "8")]
                    UserList(UserList),
                    #[prost(message, tag = "9")]
                    Date(Date),
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            LabelAdded = 1,
            LabelRemoved = 2,
            LabelFieldValueChanged = 3,
            LabelAppliedByItemCreate = 4,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::LabelAdded => "LABEL_ADDED",
                    Type::LabelRemoved => "LABEL_REMOVED",
                    Type::LabelFieldValueChanged => "LABEL_FIELD_VALUE_CHANGED",
                    Type::LabelAppliedByItemCreate => "LABEL_APPLIED_BY_ITEM_CREATE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "LABEL_ADDED" => Some(Self::LabelAdded),
                    "LABEL_REMOVED" => Some(Self::LabelRemoved),
                    "LABEL_FIELD_VALUE_CHANGED" => Some(Self::LabelFieldValueChanged),
                    "LABEL_APPLIED_BY_ITEM_CREATE" => Some(Self::LabelAppliedByItemCreate),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDriveActivityResponse {
    #[prost(message, repeated, tag = "1")]
    pub activities: ::prost::alloc::vec::Vec<DriveActivity>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DriveActivity {
    #[prost(message, optional, tag = "2")]
    pub primary_action_detail: ::core::option::Option<ActionDetail>,
    #[prost(message, repeated, tag = "3")]
    pub actors: ::prost::alloc::vec::Vec<Actor>,
    #[prost(message, repeated, tag = "4")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(message, repeated, tag = "5")]
    pub targets: ::prost::alloc::vec::Vec<Target>,
    #[prost(oneof = "drive_activity::Time", tags = "6, 7")]
    pub time: ::core::option::Option<drive_activity::Time>,
}
/// Nested message and enum types in `DriveActivity`.
pub mod drive_activity {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Time {
        #[prost(message, tag = "6")]
        Timestamp(::prost_types::Timestamp),
        #[prost(message, tag = "7")]
        TimeRange(super::TimeRange),
    }
}
/// Generated client implementations.
pub mod drive_activity_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for querying activity on Drive items. Activity is user
    /// or system action on Drive items that happened in the past. A Drive item can
    /// be a file or folder, or a Team Drive.
    #[derive(Debug, Clone)]
    pub struct DriveActivityServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DriveActivityServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DriveActivityServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            DriveActivityServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Query past activity in Google Drive.
        pub async fn query_drive_activity(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryDriveActivityRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryDriveActivityResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.apps.drive.activity.v2.DriveActivityService/QueryDriveActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.apps.drive.activity.v2.DriveActivityService",
                "QueryDriveActivity",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
