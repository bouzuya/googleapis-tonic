// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "11")]
pub fleet: ::core::option::Option<Fleet>,
#[prost(message, optional, tag = "7")]
pub networking: ::core::option::Option<ClusterNetworking>,
#[prost(message, optional, tag = "9")]
pub authorization: ::core::option::Option<Authorization>,
#[prost(int32, tag = "8")]
pub default_max_pods_per_node: i32,
#[prost(string, tag = "6")]
pub endpoint: ::prost::alloc::string::String,
#[prost(int32, tag = "19")]
pub port: i32,
#[prost(string, tag = "10")]
pub cluster_ca_certificate: ::prost::alloc::string::String,
#[prost(message, optional, tag = "12")]
pub maintenance_policy: ::core::option::Option<MaintenancePolicy>,
#[prost(string, tag = "13")]
pub control_plane_version: ::prost::alloc::string::String,
#[prost(string, tag = "14")]
pub node_version: ::prost::alloc::string::String,
#[prost(message, optional, tag = "15")]
pub control_plane: ::core::option::Option<cluster::ControlPlane>,
#[prost(message, optional, tag = "16")]
pub system_addons_config: ::core::option::Option<cluster::SystemAddonsConfig>,
#[prost(string, repeated, tag = "17")]
pub external_load_balancer_ipv4_address_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "18")]
pub control_plane_encryption: ::core::option::Option<cluster::ControlPlaneEncryption>,
#[prost(enumeration = "cluster::Status", tag = "20")]
pub status: i32,
#[prost(message, repeated, tag = "21")]
pub maintenance_events: ::prost::alloc::vec::Vec<cluster::MaintenanceEvent>,
#[prost(string, tag = "22")]
pub target_version: ::prost::alloc::string::String,
#[prost(enumeration = "cluster::ReleaseChannel", tag = "23")]
pub release_channel: i32,
#[prost(message, optional, tag = "24")]
pub survivability_config: ::core::option::Option<cluster::SurvivabilityConfig>,
#[prost(string, repeated, tag = "25")]
pub external_load_balancer_ipv6_address_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlPlane {
#[prost(oneof = "control_plane::Config", tags = "1, 2")]
pub config: ::core::option::Option<control_plane::Config>,
}
/// Nested message and enum types in `ControlPlane`.
pub mod control_plane {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Remote {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Local {
#[prost(string, tag = "1")]
pub node_location: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub node_count: i32,
#[prost(string, tag = "3")]
pub machine_filter: ::prost::alloc::string::String,
#[prost(enumeration = "SharedDeploymentPolicy", tag = "4")]
pub shared_deployment_policy: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SharedDeploymentPolicy {
Unspecified = 0,
Allowed = 1,
Disallowed = 2,
}
impl SharedDeploymentPolicy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SharedDeploymentPolicy::Unspecified => "SHARED_DEPLOYMENT_POLICY_UNSPECIFIED",
SharedDeploymentPolicy::Allowed => "ALLOWED",
SharedDeploymentPolicy::Disallowed => "DISALLOWED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SHARED_DEPLOYMENT_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
"ALLOWED" => Some(Self::Allowed),
"DISALLOWED" => Some(Self::Disallowed),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Config {
#[prost(message, tag = "1")]
Remote(Remote),
#[prost(message, tag = "2")]
Local(Local),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemAddonsConfig {
#[prost(message, optional, tag = "1")]
pub ingress: ::core::option::Option<system_addons_config::Ingress>,
}
/// Nested message and enum types in `SystemAddonsConfig`.
pub mod system_addons_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ingress {
#[prost(bool, tag = "1")]
pub disabled: bool,
#[prost(string, tag = "2")]
pub ipv4_vip: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlPlaneEncryption {
#[prost(string, tag = "1")]
pub kms_key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub kms_key_active_version: ::prost::alloc::string::String,
#[prost(enumeration = "super::KmsKeyState", tag = "3")]
pub kms_key_state: i32,
#[prost(message, optional, tag = "4")]
pub kms_status: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceEvent {
#[prost(string, tag = "1")]
pub uuid: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub target_version: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub operation: ::prost::alloc::string::String,
#[prost(enumeration = "maintenance_event::Type", tag = "4")]
pub r#type: i32,
#[prost(enumeration = "maintenance_event::Schedule", tag = "5")]
pub schedule: i32,
#[prost(enumeration = "maintenance_event::State", tag = "6")]
pub state: i32,
#[prost(message, optional, tag = "7")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "10")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `MaintenanceEvent`.
pub mod maintenance_event {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
UserInitiatedUpgrade = 1,
GoogleDrivenUpgrade = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::UserInitiatedUpgrade => "USER_INITIATED_UPGRADE",
Type::GoogleDrivenUpgrade => "GOOGLE_DRIVEN_UPGRADE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"USER_INITIATED_UPGRADE" => Some(Self::UserInitiatedUpgrade),
"GOOGLE_DRIVEN_UPGRADE" => Some(Self::GoogleDrivenUpgrade),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Schedule {
Unspecified = 0,
Immediately = 1,
}
impl Schedule {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Schedule::Unspecified => "SCHEDULE_UNSPECIFIED",
Schedule::Immediately => "IMMEDIATELY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SCHEDULE_UNSPECIFIED" => Some(Self::Unspecified),
"IMMEDIATELY" => Some(Self::Immediately),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Reconciling = 1,
Succeeded = 2,
Failed = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Reconciling => "RECONCILING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"RECONCILING" => Some(Self::Reconciling),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SurvivabilityConfig {
#[prost(message, optional, tag = "1")]
pub offline_reboot_ttl: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
Unspecified = 0,
Provisioning = 1,
Running = 2,
Deleting = 3,
Error = 4,
Reconciling = 5,
}
impl Status {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Status::Unspecified => "STATUS_UNSPECIFIED",
Status::Provisioning => "PROVISIONING",
Status::Running => "RUNNING",
Status::Deleting => "DELETING",
Status::Error => "ERROR",
Status::Reconciling => "RECONCILING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATUS_UNSPECIFIED" => Some(Self::Unspecified),
"PROVISIONING" => Some(Self::Provisioning),
"RUNNING" => Some(Self::Running),
"DELETING" => Some(Self::Deleting),
"ERROR" => Some(Self::Error),
"RECONCILING" => Some(Self::Reconciling),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReleaseChannel {
Unspecified = 0,
None = 1,
Regular = 2,
}
impl ReleaseChannel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ReleaseChannel::Unspecified => "RELEASE_CHANNEL_UNSPECIFIED",
ReleaseChannel::None => "NONE",
ReleaseChannel::Regular => "REGULAR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RELEASE_CHANNEL_UNSPECIFIED" => Some(Self::Unspecified),
"NONE" => Some(Self::None),
"REGULAR" => Some(Self::Regular),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterNetworking {
#[prost(string, repeated, tag = "1")]
pub cluster_ipv4_cidr_blocks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "2")]
pub services_ipv4_cidr_blocks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fleet {
#[prost(string, tag = "1")]
pub project: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub membership: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterUser {
#[prost(string, tag = "1")]
pub username: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Authorization {
#[prost(message, optional, tag = "1")]
pub admin_users: ::core::option::Option<ClusterUser>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePool {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "8")]
pub node_location: ::prost::alloc::string::String,
#[prost(int32, tag = "6")]
pub node_count: i32,
#[prost(string, tag = "7")]
pub machine_filter: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub local_disk_encryption: ::core::option::Option<node_pool::LocalDiskEncryption>,
#[prost(string, tag = "10")]
pub node_version: ::prost::alloc::string::String,
#[prost(message, optional, tag = "11")]
pub node_config: ::core::option::Option<node_pool::NodeConfig>,
}
/// Nested message and enum types in `NodePool`.
pub mod node_pool {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalDiskEncryption {
#[prost(string, tag = "1")]
pub kms_key: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub kms_key_active_version: ::prost::alloc::string::String,
#[prost(enumeration = "super::KmsKeyState", tag = "3")]
pub kms_key_state: i32,
#[prost(message, optional, tag = "4")]
pub kms_status: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeConfig {
#[prost(btree_map = "string, string", tag = "1")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Machine {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub hosted_node: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub zone: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub version: ::prost::alloc::string::String,
#[prost(bool, tag = "8")]
pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnConnection {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "5")]
pub nat_gateway_ip: ::prost::alloc::string::String,
#[deprecated]
#[prost(enumeration = "vpn_connection::BgpRoutingMode", tag = "6")]
pub bgp_routing_mode: i32,
#[prost(string, tag = "7")]
pub cluster: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub vpc: ::prost::alloc::string::String,
#[prost(message, optional, tag = "11")]
pub vpc_project: ::core::option::Option<vpn_connection::VpcProject>,
#[prost(bool, tag = "9")]
pub enable_high_availability: bool,
#[prost(string, tag = "12")]
pub router: ::prost::alloc::string::String,
#[prost(message, optional, tag = "10")]
pub details: ::core::option::Option<vpn_connection::Details>,
}
/// Nested message and enum types in `VpnConnection`.
pub mod vpn_connection {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpcProject {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[deprecated]
#[prost(string, tag = "2")]
pub service_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Details {
#[prost(enumeration = "details::State", tag = "1")]
pub state: i32,
#[prost(string, tag = "2")]
pub error: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub cloud_router: ::core::option::Option<details::CloudRouter>,
#[prost(message, repeated, tag = "4")]
pub cloud_vpns: ::prost::alloc::vec::Vec<details::CloudVpn>,
}
/// Nested message and enum types in `Details`.
pub mod details {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRouter {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudVpn {
#[prost(string, tag = "1")]
pub gateway: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Connected = 1,
Connecting = 2,
Error = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Connected => "STATE_CONNECTED",
State::Connecting => "STATE_CONNECTING",
State::Error => "STATE_ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"STATE_CONNECTED" => Some(Self::Connected),
"STATE_CONNECTING" => Some(Self::Connecting),
"STATE_ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BgpRoutingMode {
Unspecified = 0,
Regional = 1,
Global = 2,
}
impl BgpRoutingMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
BgpRoutingMode::Unspecified => "BGP_ROUTING_MODE_UNSPECIFIED",
BgpRoutingMode::Regional => "REGIONAL",
BgpRoutingMode::Global => "GLOBAL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"BGP_ROUTING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"REGIONAL" => Some(Self::Regional),
"GLOBAL" => Some(Self::Global),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationMetadata {
#[prost(btree_map = "string, message", tag = "1")]
pub available_zones: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ZoneMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneMetadata {
#[prost(message, repeated, tag = "1")]
pub quota: ::prost::alloc::vec::Vec<Quota>,
#[prost(btree_map = "string, enumeration(zone_metadata::RackType)", tag = "2")]
pub rack_types: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
}
/// Nested message and enum types in `ZoneMetadata`.
pub mod zone_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RackType {
Unspecified = 0,
Base = 1,
Expansion = 2,
}
impl RackType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RackType::Unspecified => "RACK_TYPE_UNSPECIFIED",
RackType::Base => "BASE",
RackType::Expansion => "EXPANSION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RACK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"BASE" => Some(Self::Base),
"EXPANSION" => Some(Self::Expansion),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Quota {
#[prost(string, tag = "1")]
pub metric: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub limit: f64,
#[prost(double, tag = "3")]
pub usage: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenancePolicy {
#[prost(message, optional, tag = "1")]
pub window: ::core::option::Option<MaintenanceWindow>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceWindow {
#[prost(message, optional, tag = "1")]
pub recurring_window: ::core::option::Option<RecurringTimeWindow>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecurringTimeWindow {
#[prost(message, optional, tag = "1")]
pub window: ::core::option::Option<TimeWindow>,
#[prost(string, tag = "2")]
pub recurrence: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeWindow {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfig {
#[prost(btree_map = "string, message", tag = "1")]
pub channels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ChannelConfig>,
#[prost(message, repeated, tag = "2")]
pub versions: ::prost::alloc::vec::Vec<Version>,
#[prost(string, tag = "3")]
pub default_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelConfig {
#[prost(string, tag = "1")]
pub default_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KmsKeyState {
Unspecified = 0,
KeyAvailable = 1,
KeyUnavailable = 2,
}
impl KmsKeyState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
KmsKeyState::Unspecified => "KMS_KEY_STATE_UNSPECIFIED",
KmsKeyState::KeyAvailable => "KMS_KEY_STATE_KEY_AVAILABLE",
KmsKeyState::KeyUnavailable => "KMS_KEY_STATE_KEY_UNAVAILABLE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"KMS_KEY_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"KMS_KEY_STATE_KEY_AVAILABLE" => Some(Self::KeyAvailable),
"KMS_KEY_STATE_KEY_UNAVAILABLE" => Some(Self::KeyUnavailable),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "3")]
pub target: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub verb: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub status_message: ::prost::alloc::string::String,
#[prost(bool, tag = "6")]
pub requested_cancellation: bool,
#[prost(string, tag = "7")]
pub api_version: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "8")]
pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersResponse {
#[prost(message, repeated, tag = "1")]
pub clusters: ::prost::alloc::vec::Vec<Cluster>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClusterRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub cluster_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub cluster: ::core::option::Option<Cluster>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClusterRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub cluster: ::core::option::Option<Cluster>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeClusterRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub target_version: ::prost::alloc::string::String,
#[prost(enumeration = "upgrade_cluster_request::Schedule", tag = "3")]
pub schedule: i32,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UpgradeClusterRequest`.
pub mod upgrade_cluster_request {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Schedule {
Unspecified = 0,
Immediately = 1,
}
impl Schedule {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Schedule::Unspecified => "SCHEDULE_UNSPECIFIED",
Schedule::Immediately => "IMMEDIATELY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SCHEDULE_UNSPECIFIED" => Some(Self::Unspecified),
"IMMEDIATELY" => Some(Self::Immediately),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteClusterRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAccessTokenRequest {
#[prost(string, tag = "1")]
pub cluster: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAccessTokenResponse {
#[prost(string, tag = "1")]
pub access_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateOfflineCredentialRequest {
#[prost(string, tag = "1")]
pub cluster: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateOfflineCredentialResponse {
#[prost(string, tag = "1")]
pub client_certificate: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub client_key: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub user_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodePoolsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodePoolsResponse {
#[prost(message, repeated, tag = "1")]
pub node_pools: ::prost::alloc::vec::Vec<NodePool>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodePoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNodePoolRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub node_pool_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub node_pool: ::core::option::Option<NodePool>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNodePoolRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub node_pool: ::core::option::Option<NodePool>,
#[prost(string, tag = "3")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodePoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMachinesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMachinesResponse {
#[prost(message, repeated, tag = "1")]
pub machines: ::prost::alloc::vec::Vec<Machine>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMachineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVpnConnectionsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVpnConnectionsResponse {
#[prost(message, repeated, tag = "1")]
pub vpn_connections: ::prost::alloc::vec::Vec<VpnConnection>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVpnConnectionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVpnConnectionRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub vpn_connection_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub vpn_connection: ::core::option::Option<VpnConnection>,
#[prost(string, tag = "4")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVpnConnectionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerConfigRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod edge_container_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// EdgeContainer API provides management of Kubernetes Clusters on Google Edge
/// Cloud deployments.
#[derive(Debug, Clone)]
pub struct EdgeContainerClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> EdgeContainerClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> EdgeContainerClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
EdgeContainerClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Lists Clusters in a given project and location.
pub async fn list_clusters(&mut self, request: impl tonic::IntoRequest<super::ListClustersRequest>) -> std::result::Result<tonic::Response<super::ListClustersResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/ListClusters");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "ListClusters"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single Cluster.
pub async fn get_cluster(&mut self, request: impl tonic::IntoRequest<super::GetClusterRequest>) -> std::result::Result<tonic::Response<super::Cluster>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/GetCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "GetCluster"));
self.inner.unary(req, path, codec).await
}
/// Creates a new Cluster in a given project and location.
pub async fn create_cluster(&mut self, request: impl tonic::IntoRequest<super::CreateClusterRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/CreateCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "CreateCluster"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single Cluster.
pub async fn update_cluster(&mut self, request: impl tonic::IntoRequest<super::UpdateClusterRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/UpdateCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "UpdateCluster"));
self.inner.unary(req, path, codec).await
}
/// Upgrades a single cluster.
pub async fn upgrade_cluster(&mut self, request: impl tonic::IntoRequest<super::UpgradeClusterRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/UpgradeCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "UpgradeCluster"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single Cluster.
pub async fn delete_cluster(&mut self, request: impl tonic::IntoRequest<super::DeleteClusterRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/DeleteCluster");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "DeleteCluster"));
self.inner.unary(req, path, codec).await
}
/// Generates an access token for a Cluster.
pub async fn generate_access_token(&mut self, request: impl tonic::IntoRequest<super::GenerateAccessTokenRequest>) -> std::result::Result<tonic::Response<super::GenerateAccessTokenResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/GenerateAccessToken");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "GenerateAccessToken"));
self.inner.unary(req, path, codec).await
}
/// Generates an offline credential for a Cluster.
pub async fn generate_offline_credential(&mut self, request: impl tonic::IntoRequest<super::GenerateOfflineCredentialRequest>) -> std::result::Result<tonic::Response<super::GenerateOfflineCredentialResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/GenerateOfflineCredential");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "GenerateOfflineCredential"));
self.inner.unary(req, path, codec).await
}
/// Lists NodePools in a given project and location.
pub async fn list_node_pools(&mut self, request: impl tonic::IntoRequest<super::ListNodePoolsRequest>) -> std::result::Result<tonic::Response<super::ListNodePoolsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/ListNodePools");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "ListNodePools"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single NodePool.
pub async fn get_node_pool(&mut self, request: impl tonic::IntoRequest<super::GetNodePoolRequest>) -> std::result::Result<tonic::Response<super::NodePool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/GetNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "GetNodePool"));
self.inner.unary(req, path, codec).await
}
/// Creates a new NodePool in a given project and location.
pub async fn create_node_pool(&mut self, request: impl tonic::IntoRequest<super::CreateNodePoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/CreateNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "CreateNodePool"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single NodePool.
pub async fn update_node_pool(&mut self, request: impl tonic::IntoRequest<super::UpdateNodePoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/UpdateNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "UpdateNodePool"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single NodePool.
pub async fn delete_node_pool(&mut self, request: impl tonic::IntoRequest<super::DeleteNodePoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/DeleteNodePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "DeleteNodePool"));
self.inner.unary(req, path, codec).await
}
/// Lists Machines in a given project and location.
pub async fn list_machines(&mut self, request: impl tonic::IntoRequest<super::ListMachinesRequest>) -> std::result::Result<tonic::Response<super::ListMachinesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/ListMachines");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "ListMachines"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single Machine.
pub async fn get_machine(&mut self, request: impl tonic::IntoRequest<super::GetMachineRequest>) -> std::result::Result<tonic::Response<super::Machine>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/GetMachine");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "GetMachine"));
self.inner.unary(req, path, codec).await
}
/// Lists VPN connections in a given project and location.
pub async fn list_vpn_connections(&mut self, request: impl tonic::IntoRequest<super::ListVpnConnectionsRequest>) -> std::result::Result<tonic::Response<super::ListVpnConnectionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/ListVpnConnections");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "ListVpnConnections"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single VPN connection.
pub async fn get_vpn_connection(&mut self, request: impl tonic::IntoRequest<super::GetVpnConnectionRequest>) -> std::result::Result<tonic::Response<super::VpnConnection>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/GetVpnConnection");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "GetVpnConnection"));
self.inner.unary(req, path, codec).await
}
/// Creates a new VPN connection in a given project and location.
pub async fn create_vpn_connection(&mut self, request: impl tonic::IntoRequest<super::CreateVpnConnectionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/CreateVpnConnection");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "CreateVpnConnection"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single VPN connection.
pub async fn delete_vpn_connection(&mut self, request: impl tonic::IntoRequest<super::DeleteVpnConnectionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/DeleteVpnConnection");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "DeleteVpnConnection"));
self.inner.unary(req, path, codec).await
}
/// Gets the server config.
pub async fn get_server_config(&mut self, request: impl tonic::IntoRequest<super::GetServerConfigRequest>) -> std::result::Result<tonic::Response<super::ServerConfig>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.edgecontainer.v1.EdgeContainer/GetServerConfig");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.edgecontainer.v1.EdgeContainer", "GetServerConfig"));
self.inner.unary(req, path, codec).await
}
}
}
