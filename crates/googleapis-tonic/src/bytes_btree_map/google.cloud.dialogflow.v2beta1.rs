// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Context {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub lifespan_count: i32,
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsResponse {
    #[prost(message, repeated, tag = "1")]
    pub contexts: ::prost::alloc::vec::Vec<Context>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContextRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContextRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub context: ::core::option::Option<Context>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContextRequest {
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<Context>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContextRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAllContextsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod contexts_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing [Contexts][google.cloud.dialogflow.v2beta1.Context].
    #[derive(Debug, Clone)]
    pub struct ContextsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ContextsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContextsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ContextsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all contexts in the specified session.
        pub async fn list_contexts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContextsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListContextsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Contexts/ListContexts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Contexts",
                "ListContexts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified context.
        pub async fn get_context(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContextRequest>,
        ) -> std::result::Result<tonic::Response<super::Context>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Contexts/GetContext",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Contexts",
                "GetContext",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a context.
        ///
        /// If the specified context already exists, overrides the context.
        pub async fn create_context(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateContextRequest>,
        ) -> std::result::Result<tonic::Response<super::Context>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Contexts/CreateContext",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Contexts",
                "CreateContext",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified context.
        pub async fn update_context(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateContextRequest>,
        ) -> std::result::Result<tonic::Response<super::Context>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Contexts/UpdateContext",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Contexts",
                "UpdateContext",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified context.
        pub async fn delete_context(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteContextRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Contexts/DeleteContext",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Contexts",
                "DeleteContext",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes all active contexts in the specified session.
        pub async fn delete_all_contexts(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAllContextsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Contexts/DeleteAllContexts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Contexts",
                "DeleteAllContexts",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fulfillment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub enabled: bool,
    #[prost(message, repeated, tag = "5")]
    pub features: ::prost::alloc::vec::Vec<fulfillment::Feature>,
    #[prost(oneof = "fulfillment::Fulfillment", tags = "3")]
    pub fulfillment: ::core::option::Option<fulfillment::Fulfillment>,
}
/// Nested message and enum types in `Fulfillment`.
pub mod fulfillment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GenericWebService {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub username: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub password: ::prost::alloc::string::String,
        #[prost(btree_map = "string, string", tag = "4")]
        pub request_headers: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[deprecated]
        #[prost(bool, tag = "5")]
        pub is_cloud_function: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Feature {
        #[prost(enumeration = "feature::Type", tag = "1")]
        pub r#type: i32,
    }
    /// Nested message and enum types in `Feature`.
    pub mod feature {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            Smalltalk = 1,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::Smalltalk => "SMALLTALK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SMALLTALK" => Some(Self::Smalltalk),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Fulfillment {
        #[prost(message, tag = "3")]
        GenericWebService(GenericWebService),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFulfillmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFulfillmentRequest {
    #[prost(message, optional, tag = "1")]
    pub fulfillment: ::core::option::Option<Fulfillment>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod fulfillments_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [Fulfillments][google.cloud.dialogflow.v2beta1.Fulfillment].
    #[derive(Debug, Clone)]
    pub struct FulfillmentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FulfillmentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FulfillmentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            FulfillmentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the fulfillment.
        pub async fn get_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFulfillmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Fulfillment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Fulfillments/GetFulfillment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Fulfillments",
                "GetFulfillment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the fulfillment.
        pub async fn update_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFulfillmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Fulfillment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Fulfillments/UpdateFulfillment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Fulfillments",
                "UpdateFulfillment",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechContext {
    #[prost(string, repeated, tag = "1")]
    pub phrases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(float, tag = "2")]
    pub boost: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechWordInfo {
    #[prost(string, tag = "3")]
    pub word: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1")]
    pub start_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub end_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(float, tag = "4")]
    pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BargeInConfig {
    #[prost(message, optional, tag = "1")]
    pub no_barge_in_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub total_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputAudioConfig {
    #[prost(enumeration = "AudioEncoding", tag = "1")]
    pub audio_encoding: i32,
    #[prost(int32, tag = "2")]
    pub sample_rate_hertz: i32,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(bool, tag = "13")]
    pub enable_word_info: bool,
    #[deprecated]
    #[prost(string, repeated, tag = "4")]
    pub phrase_hints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "11")]
    pub speech_contexts: ::prost::alloc::vec::Vec<SpeechContext>,
    #[prost(string, tag = "7")]
    pub model: ::prost::alloc::string::String,
    #[prost(enumeration = "SpeechModelVariant", tag = "10")]
    pub model_variant: i32,
    #[prost(bool, tag = "8")]
    pub single_utterance: bool,
    #[prost(bool, tag = "14")]
    pub disable_no_speech_recognized_event: bool,
    #[prost(message, optional, tag = "15")]
    pub barge_in_config: ::core::option::Option<BargeInConfig>,
    #[prost(bool, tag = "17")]
    pub enable_automatic_punctuation: bool,
    #[prost(bool, tag = "26")]
    pub opt_out_conformer_model_migration: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoiceSelectionParams {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "SsmlVoiceGender", tag = "2")]
    pub ssml_gender: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynthesizeSpeechConfig {
    #[prost(double, tag = "1")]
    pub speaking_rate: f64,
    #[prost(double, tag = "2")]
    pub pitch: f64,
    #[prost(double, tag = "3")]
    pub volume_gain_db: f64,
    #[prost(string, repeated, tag = "5")]
    pub effects_profile_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub voice: ::core::option::Option<VoiceSelectionParams>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputAudioConfig {
    #[prost(enumeration = "OutputAudioEncoding", tag = "1")]
    pub audio_encoding: i32,
    #[prost(int32, tag = "2")]
    pub sample_rate_hertz: i32,
    #[prost(message, optional, tag = "3")]
    pub synthesize_speech_config: ::core::option::Option<SynthesizeSpeechConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TelephonyDtmfEvents {
    #[prost(enumeration = "TelephonyDtmf", repeated, tag = "1")]
    pub dtmf_events: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechToTextConfig {
    #[prost(enumeration = "SpeechModelVariant", tag = "1")]
    pub speech_model_variant: i32,
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub use_timeout_based_endpointing: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TelephonyDtmf {
    Unspecified = 0,
    DtmfOne = 1,
    DtmfTwo = 2,
    DtmfThree = 3,
    DtmfFour = 4,
    DtmfFive = 5,
    DtmfSix = 6,
    DtmfSeven = 7,
    DtmfEight = 8,
    DtmfNine = 9,
    DtmfZero = 10,
    DtmfA = 11,
    DtmfB = 12,
    DtmfC = 13,
    DtmfD = 14,
    DtmfStar = 15,
    DtmfPound = 16,
}
impl TelephonyDtmf {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TelephonyDtmf::Unspecified => "TELEPHONY_DTMF_UNSPECIFIED",
            TelephonyDtmf::DtmfOne => "DTMF_ONE",
            TelephonyDtmf::DtmfTwo => "DTMF_TWO",
            TelephonyDtmf::DtmfThree => "DTMF_THREE",
            TelephonyDtmf::DtmfFour => "DTMF_FOUR",
            TelephonyDtmf::DtmfFive => "DTMF_FIVE",
            TelephonyDtmf::DtmfSix => "DTMF_SIX",
            TelephonyDtmf::DtmfSeven => "DTMF_SEVEN",
            TelephonyDtmf::DtmfEight => "DTMF_EIGHT",
            TelephonyDtmf::DtmfNine => "DTMF_NINE",
            TelephonyDtmf::DtmfZero => "DTMF_ZERO",
            TelephonyDtmf::DtmfA => "DTMF_A",
            TelephonyDtmf::DtmfB => "DTMF_B",
            TelephonyDtmf::DtmfC => "DTMF_C",
            TelephonyDtmf::DtmfD => "DTMF_D",
            TelephonyDtmf::DtmfStar => "DTMF_STAR",
            TelephonyDtmf::DtmfPound => "DTMF_POUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TELEPHONY_DTMF_UNSPECIFIED" => Some(Self::Unspecified),
            "DTMF_ONE" => Some(Self::DtmfOne),
            "DTMF_TWO" => Some(Self::DtmfTwo),
            "DTMF_THREE" => Some(Self::DtmfThree),
            "DTMF_FOUR" => Some(Self::DtmfFour),
            "DTMF_FIVE" => Some(Self::DtmfFive),
            "DTMF_SIX" => Some(Self::DtmfSix),
            "DTMF_SEVEN" => Some(Self::DtmfSeven),
            "DTMF_EIGHT" => Some(Self::DtmfEight),
            "DTMF_NINE" => Some(Self::DtmfNine),
            "DTMF_ZERO" => Some(Self::DtmfZero),
            "DTMF_A" => Some(Self::DtmfA),
            "DTMF_B" => Some(Self::DtmfB),
            "DTMF_C" => Some(Self::DtmfC),
            "DTMF_D" => Some(Self::DtmfD),
            "DTMF_STAR" => Some(Self::DtmfStar),
            "DTMF_POUND" => Some(Self::DtmfPound),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AudioEncoding {
    Unspecified = 0,
    Linear16 = 1,
    Flac = 2,
    Mulaw = 3,
    Amr = 4,
    AmrWb = 5,
    OggOpus = 6,
    SpeexWithHeaderByte = 7,
}
impl AudioEncoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AudioEncoding::Unspecified => "AUDIO_ENCODING_UNSPECIFIED",
            AudioEncoding::Linear16 => "AUDIO_ENCODING_LINEAR_16",
            AudioEncoding::Flac => "AUDIO_ENCODING_FLAC",
            AudioEncoding::Mulaw => "AUDIO_ENCODING_MULAW",
            AudioEncoding::Amr => "AUDIO_ENCODING_AMR",
            AudioEncoding::AmrWb => "AUDIO_ENCODING_AMR_WB",
            AudioEncoding::OggOpus => "AUDIO_ENCODING_OGG_OPUS",
            AudioEncoding::SpeexWithHeaderByte => "AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUDIO_ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "AUDIO_ENCODING_LINEAR_16" => Some(Self::Linear16),
            "AUDIO_ENCODING_FLAC" => Some(Self::Flac),
            "AUDIO_ENCODING_MULAW" => Some(Self::Mulaw),
            "AUDIO_ENCODING_AMR" => Some(Self::Amr),
            "AUDIO_ENCODING_AMR_WB" => Some(Self::AmrWb),
            "AUDIO_ENCODING_OGG_OPUS" => Some(Self::OggOpus),
            "AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE" => Some(Self::SpeexWithHeaderByte),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpeechModelVariant {
    Unspecified = 0,
    UseBestAvailable = 1,
    UseStandard = 2,
    UseEnhanced = 3,
}
impl SpeechModelVariant {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SpeechModelVariant::Unspecified => "SPEECH_MODEL_VARIANT_UNSPECIFIED",
            SpeechModelVariant::UseBestAvailable => "USE_BEST_AVAILABLE",
            SpeechModelVariant::UseStandard => "USE_STANDARD",
            SpeechModelVariant::UseEnhanced => "USE_ENHANCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPEECH_MODEL_VARIANT_UNSPECIFIED" => Some(Self::Unspecified),
            "USE_BEST_AVAILABLE" => Some(Self::UseBestAvailable),
            "USE_STANDARD" => Some(Self::UseStandard),
            "USE_ENHANCED" => Some(Self::UseEnhanced),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SsmlVoiceGender {
    Unspecified = 0,
    Male = 1,
    Female = 2,
    Neutral = 3,
}
impl SsmlVoiceGender {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SsmlVoiceGender::Unspecified => "SSML_VOICE_GENDER_UNSPECIFIED",
            SsmlVoiceGender::Male => "SSML_VOICE_GENDER_MALE",
            SsmlVoiceGender::Female => "SSML_VOICE_GENDER_FEMALE",
            SsmlVoiceGender::Neutral => "SSML_VOICE_GENDER_NEUTRAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SSML_VOICE_GENDER_UNSPECIFIED" => Some(Self::Unspecified),
            "SSML_VOICE_GENDER_MALE" => Some(Self::Male),
            "SSML_VOICE_GENDER_FEMALE" => Some(Self::Female),
            "SSML_VOICE_GENDER_NEUTRAL" => Some(Self::Neutral),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OutputAudioEncoding {
    Unspecified = 0,
    Linear16 = 1,
    Mp3 = 2,
    Mp364Kbps = 4,
    OggOpus = 3,
    Mulaw = 5,
}
impl OutputAudioEncoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OutputAudioEncoding::Unspecified => "OUTPUT_AUDIO_ENCODING_UNSPECIFIED",
            OutputAudioEncoding::Linear16 => "OUTPUT_AUDIO_ENCODING_LINEAR_16",
            OutputAudioEncoding::Mp3 => "OUTPUT_AUDIO_ENCODING_MP3",
            OutputAudioEncoding::Mp364Kbps => "OUTPUT_AUDIO_ENCODING_MP3_64_KBPS",
            OutputAudioEncoding::OggOpus => "OUTPUT_AUDIO_ENCODING_OGG_OPUS",
            OutputAudioEncoding::Mulaw => "OUTPUT_AUDIO_ENCODING_MULAW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OUTPUT_AUDIO_ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "OUTPUT_AUDIO_ENCODING_LINEAR_16" => Some(Self::Linear16),
            "OUTPUT_AUDIO_ENCODING_MP3" => Some(Self::Mp3),
            "OUTPUT_AUDIO_ENCODING_MP3_64_KBPS" => Some(Self::Mp364Kbps),
            "OUTPUT_AUDIO_ENCODING_OGG_OPUS" => Some(Self::OggOpus),
            "OUTPUT_AUDIO_ENCODING_MULAW" => Some(Self::Mulaw),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationError {
    #[prost(enumeration = "validation_error::Severity", tag = "1")]
    pub severity: i32,
    #[prost(string, repeated, tag = "3")]
    pub entries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ValidationError`.
pub mod validation_error {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Severity {
        Unspecified = 0,
        Info = 1,
        Warning = 2,
        Error = 3,
        Critical = 4,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Severity::Unspecified => "SEVERITY_UNSPECIFIED",
                Severity::Info => "INFO",
                Severity::Warning => "WARNING",
                Severity::Error => "ERROR",
                Severity::Critical => "CRITICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "INFO" => Some(Self::Info),
                "WARNING" => Some(Self::Warning),
                "ERROR" => Some(Self::Error),
                "CRITICAL" => Some(Self::Critical),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationResult {
    #[prost(message, repeated, tag = "1")]
    pub validation_errors: ::prost::alloc::vec::Vec<ValidationError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Agent {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub default_language_code: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub supported_language_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub avatar_uri: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub enable_logging: bool,
    #[deprecated]
    #[prost(enumeration = "agent::MatchMode", tag = "9")]
    pub match_mode: i32,
    #[prost(float, tag = "10")]
    pub classification_threshold: f32,
    #[prost(enumeration = "agent::ApiVersion", tag = "14")]
    pub api_version: i32,
    #[prost(enumeration = "agent::Tier", tag = "15")]
    pub tier: i32,
}
/// Nested message and enum types in `Agent`.
pub mod agent {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MatchMode {
        Unspecified = 0,
        Hybrid = 1,
        MlOnly = 2,
    }
    impl MatchMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MatchMode::Unspecified => "MATCH_MODE_UNSPECIFIED",
                MatchMode::Hybrid => "MATCH_MODE_HYBRID",
                MatchMode::MlOnly => "MATCH_MODE_ML_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MATCH_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MATCH_MODE_HYBRID" => Some(Self::Hybrid),
                "MATCH_MODE_ML_ONLY" => Some(Self::MlOnly),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ApiVersion {
        Unspecified = 0,
        V1 = 1,
        V2 = 2,
        V2Beta1 = 3,
    }
    impl ApiVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ApiVersion::Unspecified => "API_VERSION_UNSPECIFIED",
                ApiVersion::V1 => "API_VERSION_V1",
                ApiVersion::V2 => "API_VERSION_V2",
                ApiVersion::V2Beta1 => "API_VERSION_V2_BETA_1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "API_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "API_VERSION_V1" => Some(Self::V1),
                "API_VERSION_V2" => Some(Self::V2),
                "API_VERSION_V2_BETA_1" => Some(Self::V2Beta1),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Tier {
        Unspecified = 0,
        Standard = 1,
        Enterprise = 2,
        EnterprisePlus = 3,
    }
    impl Tier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Tier::Unspecified => "TIER_UNSPECIFIED",
                Tier::Standard => "TIER_STANDARD",
                Tier::Enterprise => "TIER_ENTERPRISE",
                Tier::EnterprisePlus => "TIER_ENTERPRISE_PLUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "TIER_STANDARD" => Some(Self::Standard),
                "TIER_ENTERPRISE" => Some(Self::Enterprise),
                "TIER_ENTERPRISE_PLUS" => Some(Self::EnterprisePlus),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAgentRequest {
    #[prost(message, optional, tag = "1")]
    pub agent: ::core::option::Option<Agent>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAgentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubAgent {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub environment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAgentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAgentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub agents: ::prost::alloc::vec::Vec<Agent>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainAgentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportAgentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportAgentResponse {
    #[prost(oneof = "export_agent_response::Agent", tags = "1, 2")]
    pub agent: ::core::option::Option<export_agent_response::Agent>,
}
/// Nested message and enum types in `ExportAgentResponse`.
pub mod export_agent_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Agent {
        #[prost(string, tag = "1")]
        AgentUri(::prost::alloc::string::String),
        #[prost(bytes, tag = "2")]
        AgentContent(::prost::bytes::Bytes),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportAgentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(oneof = "import_agent_request::Agent", tags = "2, 3")]
    pub agent: ::core::option::Option<import_agent_request::Agent>,
}
/// Nested message and enum types in `ImportAgentRequest`.
pub mod import_agent_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Agent {
        #[prost(string, tag = "2")]
        AgentUri(::prost::alloc::string::String),
        #[prost(bytes, tag = "3")]
        AgentContent(::prost::bytes::Bytes),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreAgentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(oneof = "restore_agent_request::Agent", tags = "2, 3")]
    pub agent: ::core::option::Option<restore_agent_request::Agent>,
}
/// Nested message and enum types in `RestoreAgentRequest`.
pub mod restore_agent_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Agent {
        #[prost(string, tag = "2")]
        AgentUri(::prost::alloc::string::String),
        #[prost(bytes, tag = "3")]
        AgentContent(::prost::bytes::Bytes),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetValidationResultRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod agents_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing [Agents][google.cloud.dialogflow.v2beta1.Agent].
    #[derive(Debug, Clone)]
    pub struct AgentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AgentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AgentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AgentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the specified agent.
        pub async fn get_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAgentRequest>,
        ) -> std::result::Result<tonic::Response<super::Agent>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/GetAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "GetAgent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates/updates the specified agent.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn set_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::SetAgentRequest>,
        ) -> std::result::Result<tonic::Response<super::Agent>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/SetAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "SetAgent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified agent.
        pub async fn delete_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAgentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/DeleteAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "DeleteAgent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of agents.
        /// Since there is at most one conversational agent per project, this method is
        /// useful primarily for listing all agents across projects the caller has
        /// access to. One can achieve that with a wildcard project collection id "-".
        /// Refer to [List
        /// Sub-Collections](https://cloud.google.com/apis/design/design_patterns#list_sub-collections).
        pub async fn search_agents(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchAgentsRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchAgentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/SearchAgents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "SearchAgents",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Trains the specified agent.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn train_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::TrainAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/TrainAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "TrainAgent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Exports the specified agent to a ZIP file.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`:
        /// [ExportAgentResponse][google.cloud.dialogflow.v2beta1.ExportAgentResponse]
        pub async fn export_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/ExportAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "ExportAgent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Imports the specified agent from a ZIP file.
        ///
        /// Uploads new intents and entity types without deleting the existing ones.
        /// Intents and entity types with the same name are replaced with the new
        /// versions from
        /// [ImportAgentRequest][google.cloud.dialogflow.v2beta1.ImportAgentRequest].
        /// After the import, the imported draft agent will be trained automatically
        /// (unless disabled in agent settings). However, once the import is done,
        /// training may not be completed yet. Please call
        /// [TrainAgent][google.cloud.dialogflow.v2beta1.Agents.TrainAgent] and wait
        /// for the operation it returns in order to train explicitly.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// The operation only tracks when importing is complete, not when it is done
        /// training.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn import_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/ImportAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "ImportAgent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Restores the specified agent from a ZIP file.
        ///
        /// Replaces the current agent version with a new one. All the intents and
        /// entity types in the older version are deleted. After the restore, the
        /// restored draft agent will be trained automatically (unless disabled in
        /// agent settings). However, once the restore is done, training may not be
        /// completed yet. Please call
        /// [TrainAgent][google.cloud.dialogflow.v2beta1.Agents.TrainAgent] and wait
        /// for the operation it returns in order to train explicitly.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// The operation only tracks when restoring is complete, not when it is done
        /// training.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn restore_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/RestoreAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "RestoreAgent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets agent validation result. Agent validation is performed during
        /// training time and is updated automatically when training is completed.
        pub async fn get_validation_result(
            &mut self,
            request: impl tonic::IntoRequest<super::GetValidationResultRequest>,
        ) -> std::result::Result<tonic::Response<super::ValidationResult>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Agents/GetValidationResult",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Agents",
                "GetValidationResult",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Intent {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "intent::WebhookState", tag = "6")]
    pub webhook_state: i32,
    #[prost(int32, tag = "3")]
    pub priority: i32,
    #[prost(bool, tag = "4")]
    pub is_fallback: bool,
    #[deprecated]
    #[prost(bool, tag = "5")]
    pub ml_enabled: bool,
    #[prost(bool, tag = "19")]
    pub ml_disabled: bool,
    #[prost(bool, tag = "20")]
    pub live_agent_handoff: bool,
    #[prost(bool, tag = "21")]
    pub end_interaction: bool,
    #[prost(string, repeated, tag = "7")]
    pub input_context_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "9")]
    pub training_phrases: ::prost::alloc::vec::Vec<intent::TrainingPhrase>,
    #[prost(string, tag = "10")]
    pub action: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub output_contexts: ::prost::alloc::vec::Vec<Context>,
    #[prost(bool, tag = "12")]
    pub reset_contexts: bool,
    #[prost(message, repeated, tag = "13")]
    pub parameters: ::prost::alloc::vec::Vec<intent::Parameter>,
    #[prost(message, repeated, tag = "14")]
    pub messages: ::prost::alloc::vec::Vec<intent::Message>,
    #[prost(
        enumeration = "intent::message::Platform",
        repeated,
        packed = "false",
        tag = "15"
    )]
    pub default_response_platforms: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "16")]
    pub root_followup_intent_name: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub parent_followup_intent_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "18")]
    pub followup_intent_info: ::prost::alloc::vec::Vec<intent::FollowupIntentInfo>,
}
/// Nested message and enum types in `Intent`.
pub mod intent {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TrainingPhrase {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "training_phrase::Type", tag = "2")]
        pub r#type: i32,
        #[prost(message, repeated, tag = "3")]
        pub parts: ::prost::alloc::vec::Vec<training_phrase::Part>,
        #[prost(int32, tag = "4")]
        pub times_added_count: i32,
    }
    /// Nested message and enum types in `TrainingPhrase`.
    pub mod training_phrase {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Part {
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub entity_type: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub alias: ::prost::alloc::string::String,
            #[prost(bool, tag = "4")]
            pub user_defined: bool,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            Example = 1,
            Template = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::Example => "EXAMPLE",
                    Type::Template => "TEMPLATE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "EXAMPLE" => Some(Self::Example),
                    "TEMPLATE" => Some(Self::Template),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Parameter {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub value: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub default_value: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub entity_type_display_name: ::prost::alloc::string::String,
        #[prost(bool, tag = "6")]
        pub mandatory: bool,
        #[prost(string, repeated, tag = "7")]
        pub prompts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "8")]
        pub is_list: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Message {
        #[prost(enumeration = "message::Platform", tag = "6")]
        pub platform: i32,
        #[prost(
            oneof = "message::Message",
            tags = "1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 19, 20, 22, 23, 24"
        )]
        pub message: ::core::option::Option<message::Message>,
    }
    /// Nested message and enum types in `Message`.
    pub mod message {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Text {
            #[prost(string, repeated, tag = "1")]
            pub text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Image {
            #[prost(string, tag = "1")]
            pub image_uri: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub accessibility_text: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct QuickReplies {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub quick_replies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Card {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub subtitle: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub image_uri: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "4")]
            pub buttons: ::prost::alloc::vec::Vec<card::Button>,
        }
        /// Nested message and enum types in `Card`.
        pub mod card {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Button {
                #[prost(string, tag = "1")]
                pub text: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub postback: ::prost::alloc::string::String,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SimpleResponse {
            #[prost(string, tag = "1")]
            pub text_to_speech: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub ssml: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub display_text: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SimpleResponses {
            #[prost(message, repeated, tag = "1")]
            pub simple_responses: ::prost::alloc::vec::Vec<SimpleResponse>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BasicCard {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub subtitle: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub formatted_text: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "4")]
            pub image: ::core::option::Option<Image>,
            #[prost(message, repeated, tag = "5")]
            pub buttons: ::prost::alloc::vec::Vec<basic_card::Button>,
        }
        /// Nested message and enum types in `BasicCard`.
        pub mod basic_card {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Button {
                #[prost(string, tag = "1")]
                pub title: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub open_uri_action: ::core::option::Option<button::OpenUriAction>,
            }
            /// Nested message and enum types in `Button`.
            pub mod button {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct OpenUriAction {
                    #[prost(string, tag = "1")]
                    pub uri: ::prost::alloc::string::String,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Suggestion {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Suggestions {
            #[prost(message, repeated, tag = "1")]
            pub suggestions: ::prost::alloc::vec::Vec<Suggestion>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LinkOutSuggestion {
            #[prost(string, tag = "1")]
            pub destination_name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub uri: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ListSelect {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "2")]
            pub items: ::prost::alloc::vec::Vec<list_select::Item>,
            #[prost(string, tag = "3")]
            pub subtitle: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `ListSelect`.
        pub mod list_select {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Item {
                #[prost(message, optional, tag = "1")]
                pub info: ::core::option::Option<super::SelectItemInfo>,
                #[prost(string, tag = "2")]
                pub title: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub description: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub image: ::core::option::Option<super::Image>,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CarouselSelect {
            #[prost(message, repeated, tag = "1")]
            pub items: ::prost::alloc::vec::Vec<carousel_select::Item>,
        }
        /// Nested message and enum types in `CarouselSelect`.
        pub mod carousel_select {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Item {
                #[prost(message, optional, tag = "1")]
                pub info: ::core::option::Option<super::SelectItemInfo>,
                #[prost(string, tag = "2")]
                pub title: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub description: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub image: ::core::option::Option<super::Image>,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SelectItemInfo {
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub synonyms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TelephonyPlayAudio {
            #[prost(string, tag = "1")]
            pub audio_uri: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TelephonySynthesizeSpeech {
            #[prost(oneof = "telephony_synthesize_speech::Source", tags = "1, 2")]
            pub source: ::core::option::Option<telephony_synthesize_speech::Source>,
        }
        /// Nested message and enum types in `TelephonySynthesizeSpeech`.
        pub mod telephony_synthesize_speech {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Source {
                #[prost(string, tag = "1")]
                Text(::prost::alloc::string::String),
                #[prost(string, tag = "2")]
                Ssml(::prost::alloc::string::String),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TelephonyTransferCall {
            #[prost(string, tag = "1")]
            pub phone_number: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RbmText {
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "2")]
            pub rbm_suggestion: ::prost::alloc::vec::Vec<RbmSuggestion>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RbmCarouselCard {
            #[prost(enumeration = "rbm_carousel_card::CardWidth", tag = "1")]
            pub card_width: i32,
            #[prost(message, repeated, tag = "2")]
            pub card_contents: ::prost::alloc::vec::Vec<RbmCardContent>,
        }
        /// Nested message and enum types in `RbmCarouselCard`.
        pub mod rbm_carousel_card {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum CardWidth {
                Unspecified = 0,
                Small = 1,
                Medium = 2,
            }
            impl CardWidth {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        CardWidth::Unspecified => "CARD_WIDTH_UNSPECIFIED",
                        CardWidth::Small => "SMALL",
                        CardWidth::Medium => "MEDIUM",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CARD_WIDTH_UNSPECIFIED" => Some(Self::Unspecified),
                        "SMALL" => Some(Self::Small),
                        "MEDIUM" => Some(Self::Medium),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RbmStandaloneCard {
            #[prost(enumeration = "rbm_standalone_card::CardOrientation", tag = "1")]
            pub card_orientation: i32,
            #[prost(
                enumeration = "rbm_standalone_card::ThumbnailImageAlignment",
                tag = "2"
            )]
            pub thumbnail_image_alignment: i32,
            #[prost(message, optional, tag = "3")]
            pub card_content: ::core::option::Option<RbmCardContent>,
        }
        /// Nested message and enum types in `RbmStandaloneCard`.
        pub mod rbm_standalone_card {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum CardOrientation {
                Unspecified = 0,
                Horizontal = 1,
                Vertical = 2,
            }
            impl CardOrientation {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        CardOrientation::Unspecified => "CARD_ORIENTATION_UNSPECIFIED",
                        CardOrientation::Horizontal => "HORIZONTAL",
                        CardOrientation::Vertical => "VERTICAL",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CARD_ORIENTATION_UNSPECIFIED" => Some(Self::Unspecified),
                        "HORIZONTAL" => Some(Self::Horizontal),
                        "VERTICAL" => Some(Self::Vertical),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum ThumbnailImageAlignment {
                Unspecified = 0,
                Left = 1,
                Right = 2,
            }
            impl ThumbnailImageAlignment {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        ThumbnailImageAlignment::Unspecified => {
                            "THUMBNAIL_IMAGE_ALIGNMENT_UNSPECIFIED"
                        }
                        ThumbnailImageAlignment::Left => "LEFT",
                        ThumbnailImageAlignment::Right => "RIGHT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "THUMBNAIL_IMAGE_ALIGNMENT_UNSPECIFIED" => Some(Self::Unspecified),
                        "LEFT" => Some(Self::Left),
                        "RIGHT" => Some(Self::Right),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RbmCardContent {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub description: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub media: ::core::option::Option<rbm_card_content::RbmMedia>,
            #[prost(message, repeated, tag = "4")]
            pub suggestions: ::prost::alloc::vec::Vec<RbmSuggestion>,
        }
        /// Nested message and enum types in `RbmCardContent`.
        pub mod rbm_card_content {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RbmMedia {
                #[prost(string, tag = "1")]
                pub file_uri: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub thumbnail_uri: ::prost::alloc::string::String,
                #[prost(enumeration = "rbm_media::Height", tag = "3")]
                pub height: i32,
            }
            /// Nested message and enum types in `RbmMedia`.
            pub mod rbm_media {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Height {
                    Unspecified = 0,
                    Short = 1,
                    Medium = 2,
                    Tall = 3,
                }
                impl Height {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Height::Unspecified => "HEIGHT_UNSPECIFIED",
                            Height::Short => "SHORT",
                            Height::Medium => "MEDIUM",
                            Height::Tall => "TALL",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "HEIGHT_UNSPECIFIED" => Some(Self::Unspecified),
                            "SHORT" => Some(Self::Short),
                            "MEDIUM" => Some(Self::Medium),
                            "TALL" => Some(Self::Tall),
                            _ => None,
                        }
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RbmSuggestion {
            #[prost(oneof = "rbm_suggestion::Suggestion", tags = "1, 2")]
            pub suggestion: ::core::option::Option<rbm_suggestion::Suggestion>,
        }
        /// Nested message and enum types in `RbmSuggestion`.
        pub mod rbm_suggestion {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Suggestion {
                #[prost(message, tag = "1")]
                Reply(super::RbmSuggestedReply),
                #[prost(message, tag = "2")]
                Action(super::RbmSuggestedAction),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RbmSuggestedReply {
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub postback_data: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RbmSuggestedAction {
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub postback_data: ::prost::alloc::string::String,
            #[prost(oneof = "rbm_suggested_action::Action", tags = "3, 4, 5")]
            pub action: ::core::option::Option<rbm_suggested_action::Action>,
        }
        /// Nested message and enum types in `RbmSuggestedAction`.
        pub mod rbm_suggested_action {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RbmSuggestedActionDial {
                #[prost(string, tag = "1")]
                pub phone_number: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RbmSuggestedActionOpenUri {
                #[prost(string, tag = "1")]
                pub uri: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct RbmSuggestedActionShareLocation {}
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Action {
                #[prost(message, tag = "3")]
                Dial(RbmSuggestedActionDial),
                #[prost(message, tag = "4")]
                OpenUrl(RbmSuggestedActionOpenUri),
                #[prost(message, tag = "5")]
                ShareLocation(RbmSuggestedActionShareLocation),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MediaContent {
            #[prost(enumeration = "media_content::ResponseMediaType", tag = "1")]
            pub media_type: i32,
            #[prost(message, repeated, tag = "2")]
            pub media_objects: ::prost::alloc::vec::Vec<media_content::ResponseMediaObject>,
        }
        /// Nested message and enum types in `MediaContent`.
        pub mod media_content {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ResponseMediaObject {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub description: ::prost::alloc::string::String,
                #[prost(string, tag = "5")]
                pub content_url: ::prost::alloc::string::String,
                #[prost(oneof = "response_media_object::Image", tags = "3, 4")]
                pub image: ::core::option::Option<response_media_object::Image>,
            }
            /// Nested message and enum types in `ResponseMediaObject`.
            pub mod response_media_object {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Image {
                    #[prost(message, tag = "3")]
                    LargeImage(super::super::Image),
                    #[prost(message, tag = "4")]
                    Icon(super::super::Image),
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum ResponseMediaType {
                Unspecified = 0,
                Audio = 1,
            }
            impl ResponseMediaType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        ResponseMediaType::Unspecified => "RESPONSE_MEDIA_TYPE_UNSPECIFIED",
                        ResponseMediaType::Audio => "AUDIO",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "RESPONSE_MEDIA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "AUDIO" => Some(Self::Audio),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BrowseCarouselCard {
            #[prost(message, repeated, tag = "1")]
            pub items: ::prost::alloc::vec::Vec<browse_carousel_card::BrowseCarouselCardItem>,
            #[prost(enumeration = "browse_carousel_card::ImageDisplayOptions", tag = "2")]
            pub image_display_options: i32,
        }
        /// Nested message and enum types in `BrowseCarouselCard`.
        pub mod browse_carousel_card {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct BrowseCarouselCardItem {
                #[prost(message, optional, tag = "1")]
                pub open_uri_action:
                    ::core::option::Option<browse_carousel_card_item::OpenUrlAction>,
                #[prost(string, tag = "2")]
                pub title: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub description: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub image: ::core::option::Option<super::Image>,
                #[prost(string, tag = "5")]
                pub footer: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `BrowseCarouselCardItem`.
            pub mod browse_carousel_card_item {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct OpenUrlAction {
                    #[prost(string, tag = "1")]
                    pub url: ::prost::alloc::string::String,
                    #[prost(enumeration = "open_url_action::UrlTypeHint", tag = "3")]
                    pub url_type_hint: i32,
                }
                /// Nested message and enum types in `OpenUrlAction`.
                pub mod open_url_action {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum UrlTypeHint {
                        Unspecified = 0,
                        AmpAction = 1,
                        AmpContent = 2,
                    }
                    impl UrlTypeHint {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                UrlTypeHint::Unspecified => "URL_TYPE_HINT_UNSPECIFIED",
                                UrlTypeHint::AmpAction => "AMP_ACTION",
                                UrlTypeHint::AmpContent => "AMP_CONTENT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "URL_TYPE_HINT_UNSPECIFIED" => Some(Self::Unspecified),
                                "AMP_ACTION" => Some(Self::AmpAction),
                                "AMP_CONTENT" => Some(Self::AmpContent),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum ImageDisplayOptions {
                Unspecified = 0,
                Gray = 1,
                White = 2,
                Cropped = 3,
                BlurredBackground = 4,
            }
            impl ImageDisplayOptions {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        ImageDisplayOptions::Unspecified => "IMAGE_DISPLAY_OPTIONS_UNSPECIFIED",
                        ImageDisplayOptions::Gray => "GRAY",
                        ImageDisplayOptions::White => "WHITE",
                        ImageDisplayOptions::Cropped => "CROPPED",
                        ImageDisplayOptions::BlurredBackground => "BLURRED_BACKGROUND",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "IMAGE_DISPLAY_OPTIONS_UNSPECIFIED" => Some(Self::Unspecified),
                        "GRAY" => Some(Self::Gray),
                        "WHITE" => Some(Self::White),
                        "CROPPED" => Some(Self::Cropped),
                        "BLURRED_BACKGROUND" => Some(Self::BlurredBackground),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TableCard {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub subtitle: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub image: ::core::option::Option<Image>,
            #[prost(message, repeated, tag = "4")]
            pub column_properties: ::prost::alloc::vec::Vec<ColumnProperties>,
            #[prost(message, repeated, tag = "5")]
            pub rows: ::prost::alloc::vec::Vec<TableCardRow>,
            #[prost(message, repeated, tag = "6")]
            pub buttons: ::prost::alloc::vec::Vec<basic_card::Button>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ColumnProperties {
            #[prost(string, tag = "1")]
            pub header: ::prost::alloc::string::String,
            #[prost(enumeration = "column_properties::HorizontalAlignment", tag = "2")]
            pub horizontal_alignment: i32,
        }
        /// Nested message and enum types in `ColumnProperties`.
        pub mod column_properties {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum HorizontalAlignment {
                Unspecified = 0,
                Leading = 1,
                Center = 2,
                Trailing = 3,
            }
            impl HorizontalAlignment {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        HorizontalAlignment::Unspecified => "HORIZONTAL_ALIGNMENT_UNSPECIFIED",
                        HorizontalAlignment::Leading => "LEADING",
                        HorizontalAlignment::Center => "CENTER",
                        HorizontalAlignment::Trailing => "TRAILING",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => Some(Self::Unspecified),
                        "LEADING" => Some(Self::Leading),
                        "CENTER" => Some(Self::Center),
                        "TRAILING" => Some(Self::Trailing),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TableCardRow {
            #[prost(message, repeated, tag = "1")]
            pub cells: ::prost::alloc::vec::Vec<TableCardCell>,
            #[prost(bool, tag = "2")]
            pub divider_after: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TableCardCell {
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Platform {
            Unspecified = 0,
            Facebook = 1,
            Slack = 2,
            Telegram = 3,
            Kik = 4,
            Skype = 5,
            Line = 6,
            Viber = 7,
            ActionsOnGoogle = 8,
            Telephony = 10,
            GoogleHangouts = 11,
        }
        impl Platform {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Platform::Unspecified => "PLATFORM_UNSPECIFIED",
                    Platform::Facebook => "FACEBOOK",
                    Platform::Slack => "SLACK",
                    Platform::Telegram => "TELEGRAM",
                    Platform::Kik => "KIK",
                    Platform::Skype => "SKYPE",
                    Platform::Line => "LINE",
                    Platform::Viber => "VIBER",
                    Platform::ActionsOnGoogle => "ACTIONS_ON_GOOGLE",
                    Platform::Telephony => "TELEPHONY",
                    Platform::GoogleHangouts => "GOOGLE_HANGOUTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PLATFORM_UNSPECIFIED" => Some(Self::Unspecified),
                    "FACEBOOK" => Some(Self::Facebook),
                    "SLACK" => Some(Self::Slack),
                    "TELEGRAM" => Some(Self::Telegram),
                    "KIK" => Some(Self::Kik),
                    "SKYPE" => Some(Self::Skype),
                    "LINE" => Some(Self::Line),
                    "VIBER" => Some(Self::Viber),
                    "ACTIONS_ON_GOOGLE" => Some(Self::ActionsOnGoogle),
                    "TELEPHONY" => Some(Self::Telephony),
                    "GOOGLE_HANGOUTS" => Some(Self::GoogleHangouts),
                    _ => None,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Message {
            #[prost(message, tag = "1")]
            Text(Text),
            #[prost(message, tag = "2")]
            Image(Image),
            #[prost(message, tag = "3")]
            QuickReplies(QuickReplies),
            #[prost(message, tag = "4")]
            Card(Card),
            #[prost(message, tag = "5")]
            Payload(::prost_types::Struct),
            #[prost(message, tag = "7")]
            SimpleResponses(SimpleResponses),
            #[prost(message, tag = "8")]
            BasicCard(BasicCard),
            #[prost(message, tag = "9")]
            Suggestions(Suggestions),
            #[prost(message, tag = "10")]
            LinkOutSuggestion(LinkOutSuggestion),
            #[prost(message, tag = "11")]
            ListSelect(ListSelect),
            #[prost(message, tag = "12")]
            CarouselSelect(CarouselSelect),
            #[prost(message, tag = "13")]
            TelephonyPlayAudio(TelephonyPlayAudio),
            #[prost(message, tag = "14")]
            TelephonySynthesizeSpeech(TelephonySynthesizeSpeech),
            #[prost(message, tag = "15")]
            TelephonyTransferCall(TelephonyTransferCall),
            #[prost(message, tag = "18")]
            RbmText(RbmText),
            #[prost(message, tag = "19")]
            RbmStandaloneRichCard(RbmStandaloneCard),
            #[prost(message, tag = "20")]
            RbmCarouselRichCard(RbmCarouselCard),
            #[prost(message, tag = "22")]
            BrowseCarouselCard(BrowseCarouselCard),
            #[prost(message, tag = "23")]
            TableCard(TableCard),
            #[prost(message, tag = "24")]
            MediaContent(MediaContent),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FollowupIntentInfo {
        #[prost(string, tag = "1")]
        pub followup_intent_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub parent_followup_intent_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum WebhookState {
        Unspecified = 0,
        Enabled = 1,
        EnabledForSlotFilling = 2,
    }
    impl WebhookState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WebhookState::Unspecified => "WEBHOOK_STATE_UNSPECIFIED",
                WebhookState::Enabled => "WEBHOOK_STATE_ENABLED",
                WebhookState::EnabledForSlotFilling => "WEBHOOK_STATE_ENABLED_FOR_SLOT_FILLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WEBHOOK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "WEBHOOK_STATE_ENABLED" => Some(Self::Enabled),
                "WEBHOOK_STATE_ENABLED_FOR_SLOT_FILLING" => Some(Self::EnabledForSlotFilling),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIntentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(enumeration = "IntentView", tag = "3")]
    pub intent_view: i32,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIntentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub intents: ::prost::alloc::vec::Vec<Intent>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIntentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(enumeration = "IntentView", tag = "3")]
    pub intent_view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIntentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub intent: ::core::option::Option<Intent>,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(enumeration = "IntentView", tag = "4")]
    pub intent_view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIntentRequest {
    #[prost(message, optional, tag = "1")]
    pub intent: ::core::option::Option<Intent>,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(enumeration = "IntentView", tag = "4")]
    pub intent_view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIntentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateIntentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(enumeration = "IntentView", tag = "6")]
    pub intent_view: i32,
    #[prost(oneof = "batch_update_intents_request::IntentBatch", tags = "2, 3")]
    pub intent_batch: ::core::option::Option<batch_update_intents_request::IntentBatch>,
}
/// Nested message and enum types in `BatchUpdateIntentsRequest`.
pub mod batch_update_intents_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IntentBatch {
        #[prost(string, tag = "2")]
        IntentBatchUri(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        IntentBatchInline(super::IntentBatch),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateIntentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub intents: ::prost::alloc::vec::Vec<Intent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteIntentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub intents: ::prost::alloc::vec::Vec<Intent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentBatch {
    #[prost(message, repeated, tag = "1")]
    pub intents: ::prost::alloc::vec::Vec<Intent>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IntentView {
    Unspecified = 0,
    Full = 1,
}
impl IntentView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IntentView::Unspecified => "INTENT_VIEW_UNSPECIFIED",
            IntentView::Full => "INTENT_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTENT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "INTENT_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod intents_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing [Intents][google.cloud.dialogflow.v2beta1.Intent].
    #[derive(Debug, Clone)]
    pub struct IntentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> IntentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IntentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            IntentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all intents in the specified agent.
        pub async fn list_intents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIntentsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListIntentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Intents/ListIntents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Intents",
                "ListIntents",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified intent.
        pub async fn get_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::Intent>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Intents/GetIntent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Intents",
                "GetIntent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates an intent in the specified agent.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn create_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::Intent>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Intents/CreateIntent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Intents",
                "CreateIntent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified intent.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn update_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::Intent>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Intents/UpdateIntent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Intents",
                "UpdateIntent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified intent and its direct or indirect followup intents.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn delete_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIntentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Intents/DeleteIntent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Intents",
                "DeleteIntent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates/Creates multiple intents in the specified agent.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`:
        /// [BatchUpdateIntentsResponse][google.cloud.dialogflow.v2beta1.BatchUpdateIntentsResponse]
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn batch_update_intents(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateIntentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Intents/BatchUpdateIntents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Intents",
                "BatchUpdateIntents",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes intents in the specified agent.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn batch_delete_intents(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteIntentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Intents/BatchDeleteIntents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Intents",
                "BatchDeleteIntents",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "entity_type::Kind", tag = "3")]
    pub kind: i32,
    #[prost(enumeration = "entity_type::AutoExpansionMode", tag = "4")]
    pub auto_expansion_mode: i32,
    #[prost(message, repeated, tag = "6")]
    pub entities: ::prost::alloc::vec::Vec<entity_type::Entity>,
    #[prost(bool, tag = "7")]
    pub enable_fuzzy_extraction: bool,
}
/// Nested message and enum types in `EntityType`.
pub mod entity_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entity {
        #[prost(string, tag = "1")]
        pub value: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub synonyms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        Map = 1,
        List = 2,
        Regexp = 3,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Kind::Unspecified => "KIND_UNSPECIFIED",
                Kind::Map => "KIND_MAP",
                Kind::List => "KIND_LIST",
                Kind::Regexp => "KIND_REGEXP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "KIND_MAP" => Some(Self::Map),
                "KIND_LIST" => Some(Self::List),
                "KIND_REGEXP" => Some(Self::Regexp),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AutoExpansionMode {
        Unspecified = 0,
        Default = 1,
    }
    impl AutoExpansionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutoExpansionMode::Unspecified => "AUTO_EXPANSION_MODE_UNSPECIFIED",
                AutoExpansionMode::Default => "AUTO_EXPANSION_MODE_DEFAULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUTO_EXPANSION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTO_EXPANSION_MODE_DEFAULT" => Some(Self::Default),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntityTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntityTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entity_types: ::prost::alloc::vec::Vec<EntityType>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub entity_type: ::core::option::Option<EntityType>,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntityTypeRequest {
    #[prost(message, optional, tag = "1")]
    pub entity_type: ::core::option::Option<EntityType>,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateEntityTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(
        oneof = "batch_update_entity_types_request::EntityTypeBatch",
        tags = "2, 3"
    )]
    pub entity_type_batch:
        ::core::option::Option<batch_update_entity_types_request::EntityTypeBatch>,
}
/// Nested message and enum types in `BatchUpdateEntityTypesRequest`.
pub mod batch_update_entity_types_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EntityTypeBatch {
        #[prost(string, tag = "2")]
        EntityTypeBatchUri(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        EntityTypeBatchInline(super::EntityTypeBatch),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateEntityTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entity_types: ::prost::alloc::vec::Vec<EntityType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteEntityTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub entity_type_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateEntitiesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<entity_type::Entity>,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateEntitiesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<entity_type::Entity>,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteEntitiesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub entity_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityTypeBatch {
    #[prost(message, repeated, tag = "1")]
    pub entity_types: ::prost::alloc::vec::Vec<EntityType>,
}
/// Generated client implementations.
pub mod entity_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [EntityTypes][google.cloud.dialogflow.v2beta1.EntityType].
    #[derive(Debug, Clone)]
    pub struct EntityTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> EntityTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EntityTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            EntityTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all entity types in the specified agent.
        pub async fn list_entity_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntityTypesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListEntityTypesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/ListEntityTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "ListEntityTypes",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified entity type.
        pub async fn get_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::EntityType>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/GetEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "GetEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates an entity type in the specified agent.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn create_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::EntityType>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/CreateEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "CreateEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified entity type.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn update_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::EntityType>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/UpdateEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "UpdateEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified entity type.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn delete_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/DeleteEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "DeleteEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates/Creates multiple entity types in the specified agent.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`:
        /// [BatchUpdateEntityTypesResponse][google.cloud.dialogflow.v2beta1.BatchUpdateEntityTypesResponse]
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn batch_update_entity_types(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateEntityTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/BatchUpdateEntityTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "BatchUpdateEntityTypes",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes entity types in the specified agent.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn batch_delete_entity_types(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteEntityTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/BatchDeleteEntityTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "BatchDeleteEntityTypes",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates multiple new entities in the specified entity type.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn batch_create_entities(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/BatchCreateEntities",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "BatchCreateEntities",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates or creates multiple entities in the specified entity type. This
        /// method does not affect entities in the entity type that aren't explicitly
        /// specified in the request.
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        pub async fn batch_update_entities(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/BatchUpdateEntities",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "BatchUpdateEntities",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes entities in the specified entity type.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`: An empty [Struct
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct)
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// Note: You should always train an agent prior to sending it queries. See the
        /// [training
        /// documentation](https://cloud.google.com/dialogflow/es/docs/training).
        pub async fn batch_delete_entities(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.EntityTypes/BatchDeleteEntities",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.EntityTypes",
                "BatchDeleteEntities",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEntityType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "session_entity_type::EntityOverrideMode", tag = "2")]
    pub entity_override_mode: i32,
    #[prost(message, repeated, tag = "3")]
    pub entities: ::prost::alloc::vec::Vec<entity_type::Entity>,
}
/// Nested message and enum types in `SessionEntityType`.
pub mod session_entity_type {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EntityOverrideMode {
        Unspecified = 0,
        Override = 1,
        Supplement = 2,
    }
    impl EntityOverrideMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EntityOverrideMode::Unspecified => "ENTITY_OVERRIDE_MODE_UNSPECIFIED",
                EntityOverrideMode::Override => "ENTITY_OVERRIDE_MODE_OVERRIDE",
                EntityOverrideMode::Supplement => "ENTITY_OVERRIDE_MODE_SUPPLEMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTITY_OVERRIDE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENTITY_OVERRIDE_MODE_OVERRIDE" => Some(Self::Override),
                "ENTITY_OVERRIDE_MODE_SUPPLEMENT" => Some(Self::Supplement),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionEntityTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionEntityTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub session_entity_types: ::prost::alloc::vec::Vec<SessionEntityType>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub session_entity_type: ::core::option::Option<SessionEntityType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSessionEntityTypeRequest {
    #[prost(message, optional, tag = "1")]
    pub session_entity_type: ::core::option::Option<SessionEntityType>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSessionEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod session_entity_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [SessionEntityTypes][google.cloud.dialogflow.v2beta1.SessionEntityType].
    #[derive(Debug, Clone)]
    pub struct SessionEntityTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SessionEntityTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SessionEntityTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            SessionEntityTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all session entity types in the specified session.
        ///
        /// This method doesn't work with Google Assistant integration.
        /// Contact Dialogflow support if you need to use session entities
        /// with Google Assistant integration.
        pub async fn list_session_entity_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSessionEntityTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSessionEntityTypesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.SessionEntityTypes/ListSessionEntityTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.SessionEntityTypes",
                "ListSessionEntityTypes",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified session entity type.
        ///
        /// This method doesn't work with Google Assistant integration.
        /// Contact Dialogflow support if you need to use session entities
        /// with Google Assistant integration.
        pub async fn get_session_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSessionEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::SessionEntityType>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.SessionEntityTypes/GetSessionEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.SessionEntityTypes",
                "GetSessionEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a session entity type.
        ///
        /// If the specified session entity type already exists, overrides the
        /// session entity type.
        ///
        /// This method doesn't work with Google Assistant integration.
        /// Contact Dialogflow support if you need to use session entities
        /// with Google Assistant integration.
        pub async fn create_session_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSessionEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::SessionEntityType>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.SessionEntityTypes/CreateSessionEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.SessionEntityTypes",
                "CreateSessionEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified session entity type.
        ///
        /// This method doesn't work with Google Assistant integration.
        /// Contact Dialogflow support if you need to use session entities
        /// with Google Assistant integration.
        pub async fn update_session_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSessionEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::SessionEntityType>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.SessionEntityTypes/UpdateSessionEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.SessionEntityTypes",
                "UpdateSessionEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified session entity type.
        ///
        /// This method doesn't work with Google Assistant integration.
        /// Contact Dialogflow support if you need to use session entities
        /// with Google Assistant integration.
        pub async fn delete_session_entity_type(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSessionEntityTypeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.SessionEntityTypes/DeleteSessionEntityType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.SessionEntityTypes",
                "DeleteSessionEntityType",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectIntentRequest {
    #[prost(string, tag = "1")]
    pub session: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query_params: ::core::option::Option<QueryParameters>,
    #[prost(message, optional, tag = "3")]
    pub query_input: ::core::option::Option<QueryInput>,
    #[prost(message, optional, tag = "4")]
    pub output_audio_config: ::core::option::Option<OutputAudioConfig>,
    #[prost(message, optional, tag = "7")]
    pub output_audio_config_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bytes = "bytes", tag = "5")]
    pub input_audio: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectIntentResponse {
    #[prost(string, tag = "1")]
    pub response_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query_result: ::core::option::Option<QueryResult>,
    #[prost(message, repeated, tag = "5")]
    pub alternative_query_results: ::prost::alloc::vec::Vec<QueryResult>,
    #[prost(message, optional, tag = "3")]
    pub webhook_status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(bytes = "bytes", tag = "4")]
    pub output_audio: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "6")]
    pub output_audio_config: ::core::option::Option<OutputAudioConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParameters {
    #[prost(string, tag = "1")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub geo_location: ::core::option::Option<super::super::super::r#type::LatLng>,
    #[prost(message, repeated, tag = "3")]
    pub contexts: ::prost::alloc::vec::Vec<Context>,
    #[prost(bool, tag = "4")]
    pub reset_contexts: bool,
    #[prost(message, repeated, tag = "5")]
    pub session_entity_types: ::prost::alloc::vec::Vec<SessionEntityType>,
    #[prost(message, optional, tag = "6")]
    pub payload: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, repeated, tag = "12")]
    pub knowledge_base_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "10")]
    pub sentiment_analysis_request_config: ::core::option::Option<SentimentAnalysisRequestConfig>,
    #[prost(message, repeated, tag = "13")]
    pub sub_agents: ::prost::alloc::vec::Vec<SubAgent>,
    #[prost(btree_map = "string, string", tag = "14")]
    pub webhook_headers: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "18")]
    pub platform: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInput {
    #[prost(oneof = "query_input::Input", tags = "1, 2, 3, 4")]
    pub input: ::core::option::Option<query_input::Input>,
}
/// Nested message and enum types in `QueryInput`.
pub mod query_input {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Input {
        #[prost(message, tag = "1")]
        AudioConfig(super::InputAudioConfig),
        #[prost(message, tag = "2")]
        Text(super::TextInput),
        #[prost(message, tag = "3")]
        Event(super::EventInput),
        #[prost(message, tag = "4")]
        Dtmf(super::TelephonyDtmfEvents),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResult {
    #[prost(string, tag = "1")]
    pub query_text: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub speech_recognition_confidence: f32,
    #[prost(string, tag = "3")]
    pub action: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub parameters: ::core::option::Option<::prost_types::Struct>,
    #[prost(bool, tag = "5")]
    pub all_required_params_present: bool,
    #[prost(bool, tag = "21")]
    pub cancels_slot_filling: bool,
    #[prost(string, tag = "6")]
    pub fulfillment_text: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub fulfillment_messages: ::prost::alloc::vec::Vec<intent::Message>,
    #[prost(string, tag = "8")]
    pub webhook_source: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub webhook_payload: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, repeated, tag = "10")]
    pub output_contexts: ::prost::alloc::vec::Vec<Context>,
    #[prost(message, optional, tag = "11")]
    pub intent: ::core::option::Option<Intent>,
    #[prost(float, tag = "12")]
    pub intent_detection_confidence: f32,
    #[prost(message, optional, tag = "14")]
    pub diagnostic_info: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, optional, tag = "17")]
    pub sentiment_analysis_result: ::core::option::Option<SentimentAnalysisResult>,
    #[prost(message, optional, tag = "18")]
    pub knowledge_answers: ::core::option::Option<KnowledgeAnswers>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KnowledgeAnswers {
    #[prost(message, repeated, tag = "1")]
    pub answers: ::prost::alloc::vec::Vec<knowledge_answers::Answer>,
}
/// Nested message and enum types in `KnowledgeAnswers`.
pub mod knowledge_answers {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Answer {
        #[prost(string, tag = "1")]
        pub source: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub faq_question: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub answer: ::prost::alloc::string::String,
        #[prost(enumeration = "answer::MatchConfidenceLevel", tag = "4")]
        pub match_confidence_level: i32,
        #[prost(float, tag = "5")]
        pub match_confidence: f32,
    }
    /// Nested message and enum types in `Answer`.
    pub mod answer {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum MatchConfidenceLevel {
            Unspecified = 0,
            Low = 1,
            Medium = 2,
            High = 3,
        }
        impl MatchConfidenceLevel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    MatchConfidenceLevel::Unspecified => "MATCH_CONFIDENCE_LEVEL_UNSPECIFIED",
                    MatchConfidenceLevel::Low => "LOW",
                    MatchConfidenceLevel::Medium => "MEDIUM",
                    MatchConfidenceLevel::High => "HIGH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MATCH_CONFIDENCE_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                    "LOW" => Some(Self::Low),
                    "MEDIUM" => Some(Self::Medium),
                    "HIGH" => Some(Self::High),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingDetectIntentRequest {
    #[prost(string, tag = "1")]
    pub session: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query_params: ::core::option::Option<QueryParameters>,
    #[prost(message, optional, tag = "3")]
    pub query_input: ::core::option::Option<QueryInput>,
    #[deprecated]
    #[prost(bool, tag = "4")]
    pub single_utterance: bool,
    #[prost(message, optional, tag = "5")]
    pub output_audio_config: ::core::option::Option<OutputAudioConfig>,
    #[prost(message, optional, tag = "7")]
    pub output_audio_config_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bytes = "bytes", tag = "6")]
    pub input_audio: ::prost::bytes::Bytes,
    #[prost(bool, tag = "8")]
    pub enable_debugging_info: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudConversationDebuggingInfo {
    #[prost(int32, tag = "1")]
    pub audio_data_chunks: i32,
    #[prost(message, optional, tag = "2")]
    pub result_end_time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "3")]
    pub first_audio_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag = "5")]
    pub single_utterance: bool,
    #[prost(message, repeated, tag = "6")]
    pub speech_partial_results_end_times: ::prost::alloc::vec::Vec<::prost_types::Duration>,
    #[prost(message, repeated, tag = "7")]
    pub speech_final_results_end_times: ::prost::alloc::vec::Vec<::prost_types::Duration>,
    #[prost(int32, tag = "8")]
    pub partial_responses: i32,
    #[prost(int32, tag = "9")]
    pub speaker_id_passive_latency_ms_offset: i32,
    #[prost(bool, tag = "10")]
    pub bargein_event_triggered: bool,
    #[prost(bool, tag = "11")]
    pub speech_single_utterance: bool,
    #[prost(message, repeated, tag = "12")]
    pub dtmf_partial_results_times: ::prost::alloc::vec::Vec<::prost_types::Duration>,
    #[prost(message, repeated, tag = "13")]
    pub dtmf_final_results_times: ::prost::alloc::vec::Vec<::prost_types::Duration>,
    #[prost(message, optional, tag = "14")]
    pub single_utterance_end_time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "15")]
    pub no_speech_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "19")]
    pub endpointing_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag = "16")]
    pub is_input_text: bool,
    #[prost(message, optional, tag = "17")]
    pub client_half_close_time_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "18")]
    pub client_half_close_streaming_time_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingDetectIntentResponse {
    #[prost(string, tag = "1")]
    pub response_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub recognition_result: ::core::option::Option<StreamingRecognitionResult>,
    #[prost(message, optional, tag = "3")]
    pub query_result: ::core::option::Option<QueryResult>,
    #[prost(message, repeated, tag = "7")]
    pub alternative_query_results: ::prost::alloc::vec::Vec<QueryResult>,
    #[prost(message, optional, tag = "4")]
    pub webhook_status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(bytes = "bytes", tag = "5")]
    pub output_audio: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "6")]
    pub output_audio_config: ::core::option::Option<OutputAudioConfig>,
    #[prost(message, optional, tag = "8")]
    pub debugging_info: ::core::option::Option<CloudConversationDebuggingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingRecognitionResult {
    #[prost(enumeration = "streaming_recognition_result::MessageType", tag = "1")]
    pub message_type: i32,
    #[prost(string, tag = "2")]
    pub transcript: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_final: bool,
    #[prost(float, tag = "4")]
    pub confidence: f32,
    #[prost(float, tag = "6")]
    pub stability: f32,
    #[prost(message, repeated, tag = "7")]
    pub speech_word_info: ::prost::alloc::vec::Vec<SpeechWordInfo>,
    #[prost(message, optional, tag = "8")]
    pub speech_end_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "10")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub dtmf_digits: ::core::option::Option<TelephonyDtmfEvents>,
}
/// Nested message and enum types in `StreamingRecognitionResult`.
pub mod streaming_recognition_result {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MessageType {
        Unspecified = 0,
        Transcript = 1,
        DtmfDigits = 3,
        EndOfSingleUtterance = 2,
        PartialDtmfDigits = 4,
    }
    impl MessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MessageType::Unspecified => "MESSAGE_TYPE_UNSPECIFIED",
                MessageType::Transcript => "TRANSCRIPT",
                MessageType::DtmfDigits => "DTMF_DIGITS",
                MessageType::EndOfSingleUtterance => "END_OF_SINGLE_UTTERANCE",
                MessageType::PartialDtmfDigits => "PARTIAL_DTMF_DIGITS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TRANSCRIPT" => Some(Self::Transcript),
                "DTMF_DIGITS" => Some(Self::DtmfDigits),
                "END_OF_SINGLE_UTTERANCE" => Some(Self::EndOfSingleUtterance),
                "PARTIAL_DTMF_DIGITS" => Some(Self::PartialDtmfDigits),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInput {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventInput {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub parameters: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SentimentAnalysisRequestConfig {
    #[prost(bool, tag = "1")]
    pub analyze_query_text_sentiment: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SentimentAnalysisResult {
    #[prost(message, optional, tag = "1")]
    pub query_text_sentiment: ::core::option::Option<Sentiment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Sentiment {
    #[prost(float, tag = "1")]
    pub score: f32,
    #[prost(float, tag = "2")]
    pub magnitude: f32,
}
/// Generated client implementations.
pub mod sessions_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// A service used for session interactions.
    ///
    /// For more information, see the [API interactions
    /// guide](https://cloud.google.com/dialogflow/docs/api-overview).
    #[derive(Debug, Clone)]
    pub struct SessionsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SessionsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SessionsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            SessionsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Processes a natural language query and returns structured, actionable data
        /// as a result. This method is not idempotent, because it may cause contexts
        /// and session entity types to be updated, which in turn might affect
        /// results of future queries.
        ///
        /// If you might use
        /// [Agent Assist](https://cloud.google.com/dialogflow/docs/#aa)
        /// or other CCAI products now or in the future, consider using
        /// [AnalyzeContent][google.cloud.dialogflow.v2beta1.Participants.AnalyzeContent]
        /// instead of `DetectIntent`. `AnalyzeContent` has additional
        /// functionality for Agent Assist and other CCAI products.
        ///
        /// Note: Always use agent versions for production traffic.
        /// See [Versions and
        /// environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
        pub async fn detect_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::DetectIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::DetectIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Sessions/DetectIntent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Sessions",
                "DetectIntent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Processes a natural language query in audio format in a streaming fashion
        /// and returns structured, actionable data as a result. This method is only
        /// available via the gRPC API (not REST).
        ///
        /// If you might use
        /// [Agent Assist](https://cloud.google.com/dialogflow/docs/#aa)
        /// or other CCAI products now or in the future, consider using
        /// [StreamingAnalyzeContent][google.cloud.dialogflow.v2beta1.Participants.StreamingAnalyzeContent]
        /// instead of `StreamingDetectIntent`. `StreamingAnalyzeContent` has
        /// additional functionality for Agent Assist and other CCAI products.
        ///
        /// Note: Always use agent versions for production traffic.
        /// See [Versions and
        /// environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
        pub async fn streaming_detect_intent(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::StreamingDetectIntentRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamingDetectIntentResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Sessions/StreamingDetectIntent",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Sessions",
                "StreamingDetectIntent",
            ));
            self.inner.streaming(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Participant {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "participant::Role", tag = "2")]
    pub role: i32,
    #[prost(string, tag = "7")]
    pub obfuscated_external_user_id: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "8")]
    pub documents_metadata_filters: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Participant`.
pub mod participant {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Role {
        Unspecified = 0,
        HumanAgent = 1,
        AutomatedAgent = 2,
        EndUser = 3,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Role::Unspecified => "ROLE_UNSPECIFIED",
                Role::HumanAgent => "HUMAN_AGENT",
                Role::AutomatedAgent => "AUTOMATED_AGENT",
                Role::EndUser => "END_USER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
                "HUMAN_AGENT" => Some(Self::HumanAgent),
                "AUTOMATED_AGENT" => Some(Self::AutomatedAgent),
                "END_USER" => Some(Self::EndUser),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub participant: ::prost::alloc::string::String,
    #[prost(enumeration = "participant::Role", tag = "5")]
    pub participant_role: i32,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub send_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub message_annotation: ::core::option::Option<MessageAnnotation>,
    #[prost(message, optional, tag = "8")]
    pub sentiment_analysis: ::core::option::Option<SentimentAnalysisResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateParticipantRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub participant: ::core::option::Option<Participant>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetParticipantRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListParticipantsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListParticipantsResponse {
    #[prost(message, repeated, tag = "1")]
    pub participants: ::prost::alloc::vec::Vec<Participant>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateParticipantRequest {
    #[prost(message, optional, tag = "1")]
    pub participant: ::core::option::Option<Participant>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInput {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<InputAudioConfig>,
    #[prost(bytes = "bytes", tag = "2")]
    pub audio: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputAudio {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<OutputAudioConfig>,
    #[prost(bytes = "bytes", tag = "2")]
    pub audio: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomatedAgentReply {
    #[prost(message, repeated, tag = "3")]
    pub response_messages: ::prost::alloc::vec::Vec<ResponseMessage>,
    #[prost(float, tag = "9")]
    pub match_confidence: f32,
    #[prost(message, optional, tag = "10")]
    pub parameters: ::core::option::Option<::prost_types::Struct>,
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub cx_session_parameters: ::core::option::Option<::prost_types::Struct>,
    #[prost(
        enumeration = "automated_agent_reply::AutomatedAgentReplyType",
        tag = "7"
    )]
    pub automated_agent_reply_type: i32,
    #[prost(bool, tag = "8")]
    pub allow_cancellation: bool,
    #[prost(string, tag = "11")]
    pub cx_current_page: ::prost::alloc::string::String,
    #[prost(oneof = "automated_agent_reply::Response", tags = "1")]
    pub response: ::core::option::Option<automated_agent_reply::Response>,
    #[prost(oneof = "automated_agent_reply::Match", tags = "4, 5")]
    pub r#match: ::core::option::Option<automated_agent_reply::Match>,
}
/// Nested message and enum types in `AutomatedAgentReply`.
pub mod automated_agent_reply {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AutomatedAgentReplyType {
        Unspecified = 0,
        Partial = 1,
        Final = 2,
    }
    impl AutomatedAgentReplyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutomatedAgentReplyType::Unspecified => "AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED",
                AutomatedAgentReplyType::Partial => "PARTIAL",
                AutomatedAgentReplyType::Final => "FINAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PARTIAL" => Some(Self::Partial),
                "FINAL" => Some(Self::Final),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        DetectIntentResponse(super::DetectIntentResponse),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Match {
        #[prost(string, tag = "4")]
        Intent(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        Event(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestionInput {
    #[prost(string, tag = "1")]
    pub answer_record: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub text_override: ::core::option::Option<TextInput>,
    #[prost(message, optional, tag = "4")]
    pub parameters: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, optional, tag = "6")]
    pub intent_input: ::core::option::Option<IntentInput>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentInput {
    #[prost(string, tag = "1")]
    pub intent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SuggestionFeature {
    #[prost(enumeration = "suggestion_feature::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `SuggestionFeature`.
pub mod suggestion_feature {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        ArticleSuggestion = 1,
        Faq = 2,
        SmartReply = 3,
        DialogflowAssist = 4,
        ConversationSummarization = 8,
        KnowledgeSearch = 14,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::ArticleSuggestion => "ARTICLE_SUGGESTION",
                Type::Faq => "FAQ",
                Type::SmartReply => "SMART_REPLY",
                Type::DialogflowAssist => "DIALOGFLOW_ASSIST",
                Type::ConversationSummarization => "CONVERSATION_SUMMARIZATION",
                Type::KnowledgeSearch => "KNOWLEDGE_SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARTICLE_SUGGESTION" => Some(Self::ArticleSuggestion),
                "FAQ" => Some(Self::Faq),
                "SMART_REPLY" => Some(Self::SmartReply),
                "DIALOGFLOW_ASSIST" => Some(Self::DialogflowAssist),
                "CONVERSATION_SUMMARIZATION" => Some(Self::ConversationSummarization),
                "KNOWLEDGE_SEARCH" => Some(Self::KnowledgeSearch),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssistQueryParameters {
    #[prost(btree_map = "string, string", tag = "1")]
    pub documents_metadata_filters: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeContentRequest {
    #[prost(string, tag = "1")]
    pub participant: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub reply_audio_config: ::core::option::Option<OutputAudioConfig>,
    #[prost(message, optional, tag = "9")]
    pub query_params: ::core::option::Option<QueryParameters>,
    #[prost(message, optional, tag = "14")]
    pub assist_query_params: ::core::option::Option<AssistQueryParameters>,
    #[prost(message, optional, tag = "18")]
    pub cx_parameters: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "20")]
    pub cx_current_page: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub message_send_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "11")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(oneof = "analyze_content_request::Input", tags = "6, 7, 8, 12, 13")]
    pub input: ::core::option::Option<analyze_content_request::Input>,
}
/// Nested message and enum types in `AnalyzeContentRequest`.
pub mod analyze_content_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Input {
        #[prost(message, tag = "6")]
        TextInput(super::TextInput),
        #[prost(message, tag = "7")]
        AudioInput(super::AudioInput),
        #[prost(message, tag = "8")]
        EventInput(super::EventInput),
        #[prost(message, tag = "12")]
        SuggestionInput(super::SuggestionInput),
        #[prost(message, tag = "13")]
        IntentInput(super::IntentInput),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DtmfParameters {
    #[prost(bool, tag = "1")]
    pub accepts_dtmf_input: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeContentResponse {
    #[prost(string, tag = "1")]
    pub reply_text: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub reply_audio: ::core::option::Option<OutputAudio>,
    #[prost(message, optional, tag = "3")]
    pub automated_agent_reply: ::core::option::Option<AutomatedAgentReply>,
    #[prost(message, optional, tag = "5")]
    pub message: ::core::option::Option<Message>,
    #[prost(message, repeated, tag = "6")]
    pub human_agent_suggestion_results: ::prost::alloc::vec::Vec<SuggestionResult>,
    #[prost(message, repeated, tag = "7")]
    pub end_user_suggestion_results: ::prost::alloc::vec::Vec<SuggestionResult>,
    #[prost(message, optional, tag = "9")]
    pub dtmf_parameters: ::core::option::Option<DtmfParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputTextConfig {
    #[prost(string, tag = "1")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingAnalyzeContentRequest {
    #[prost(string, tag = "1")]
    pub participant: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub reply_audio_config: ::core::option::Option<OutputAudioConfig>,
    #[prost(message, optional, tag = "7")]
    pub query_params: ::core::option::Option<QueryParameters>,
    #[prost(message, optional, tag = "8")]
    pub assist_query_params: ::core::option::Option<AssistQueryParameters>,
    #[prost(message, optional, tag = "13")]
    pub cx_parameters: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "15")]
    pub cx_current_page: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub enable_extended_streaming: bool,
    #[prost(bool, tag = "12")]
    pub enable_partial_automated_agent_reply: bool,
    #[prost(bool, tag = "19")]
    pub enable_debugging_info: bool,
    #[prost(oneof = "streaming_analyze_content_request::Config", tags = "2, 3")]
    pub config: ::core::option::Option<streaming_analyze_content_request::Config>,
    #[prost(
        oneof = "streaming_analyze_content_request::Input",
        tags = "5, 6, 9, 17, 20"
    )]
    pub input: ::core::option::Option<streaming_analyze_content_request::Input>,
}
/// Nested message and enum types in `StreamingAnalyzeContentRequest`.
pub mod streaming_analyze_content_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        #[prost(message, tag = "2")]
        AudioConfig(super::InputAudioConfig),
        #[prost(message, tag = "3")]
        TextConfig(super::InputTextConfig),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Input {
        #[prost(bytes, tag = "5")]
        InputAudio(::prost::bytes::Bytes),
        #[prost(string, tag = "6")]
        InputText(::prost::alloc::string::String),
        #[prost(message, tag = "9")]
        InputDtmf(super::TelephonyDtmfEvents),
        #[prost(string, tag = "17")]
        InputIntent(::prost::alloc::string::String),
        #[prost(string, tag = "20")]
        InputEvent(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingAnalyzeContentResponse {
    #[prost(message, optional, tag = "1")]
    pub recognition_result: ::core::option::Option<StreamingRecognitionResult>,
    #[prost(string, tag = "2")]
    pub reply_text: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub reply_audio: ::core::option::Option<OutputAudio>,
    #[prost(message, optional, tag = "4")]
    pub automated_agent_reply: ::core::option::Option<AutomatedAgentReply>,
    #[prost(message, optional, tag = "6")]
    pub message: ::core::option::Option<Message>,
    #[prost(message, repeated, tag = "7")]
    pub human_agent_suggestion_results: ::prost::alloc::vec::Vec<SuggestionResult>,
    #[prost(message, repeated, tag = "8")]
    pub end_user_suggestion_results: ::prost::alloc::vec::Vec<SuggestionResult>,
    #[prost(message, optional, tag = "10")]
    pub dtmf_parameters: ::core::option::Option<DtmfParameters>,
    #[prost(message, optional, tag = "11")]
    pub debugging_info: ::core::option::Option<CloudConversationDebuggingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotatedMessagePart {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub formatted_value: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageAnnotation {
    #[prost(message, repeated, tag = "1")]
    pub parts: ::prost::alloc::vec::Vec<AnnotatedMessagePart>,
    #[prost(bool, tag = "2")]
    pub contain_entities: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArticleAnswer {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub snippets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(btree_map = "string, string", tag = "5")]
    pub metadata: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub answer_record: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaqAnswer {
    #[prost(string, tag = "1")]
    pub answer: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub confidence: f32,
    #[prost(string, tag = "3")]
    pub question: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub source: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "5")]
    pub metadata: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub answer_record: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartReplyAnswer {
    #[prost(string, tag = "1")]
    pub reply: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub confidence: f32,
    #[prost(string, tag = "3")]
    pub answer_record: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentSuggestion {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(oneof = "intent_suggestion::Intent", tags = "2")]
    pub intent: ::core::option::Option<intent_suggestion::Intent>,
}
/// Nested message and enum types in `IntentSuggestion`.
pub mod intent_suggestion {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Intent {
        #[prost(string, tag = "2")]
        IntentV2(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogflowAssistAnswer {
    #[prost(string, tag = "2")]
    pub answer_record: ::prost::alloc::string::String,
    #[prost(oneof = "dialogflow_assist_answer::Result", tags = "1, 5")]
    pub result: ::core::option::Option<dialogflow_assist_answer::Result>,
}
/// Nested message and enum types in `DialogflowAssistAnswer`.
pub mod dialogflow_assist_answer {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        QueryResult(super::QueryResult),
        #[prost(message, tag = "5")]
        IntentSuggestion(super::IntentSuggestion),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestionResult {
    #[prost(
        oneof = "suggestion_result::SuggestionResponse",
        tags = "1, 2, 3, 4, 5, 7"
    )]
    pub suggestion_response: ::core::option::Option<suggestion_result::SuggestionResponse>,
}
/// Nested message and enum types in `SuggestionResult`.
pub mod suggestion_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SuggestionResponse {
        #[prost(message, tag = "1")]
        Error(super::super::super::super::rpc::Status),
        #[prost(message, tag = "2")]
        SuggestArticlesResponse(super::SuggestArticlesResponse),
        #[prost(message, tag = "3")]
        SuggestFaqAnswersResponse(super::SuggestFaqAnswersResponse),
        #[prost(message, tag = "4")]
        SuggestSmartRepliesResponse(super::SuggestSmartRepliesResponse),
        #[prost(message, tag = "5")]
        SuggestDialogflowAssistsResponse(super::SuggestDialogflowAssistsResponse),
        #[prost(message, tag = "7")]
        SuggestEntityExtractionResponse(super::SuggestDialogflowAssistsResponse),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestArticlesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
    #[prost(message, optional, tag = "4")]
    pub assist_query_params: ::core::option::Option<AssistQueryParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestArticlesResponse {
    #[prost(message, repeated, tag = "1")]
    pub article_answers: ::prost::alloc::vec::Vec<ArticleAnswer>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestFaqAnswersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
    #[prost(message, optional, tag = "4")]
    pub assist_query_params: ::core::option::Option<AssistQueryParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestFaqAnswersResponse {
    #[prost(message, repeated, tag = "1")]
    pub faq_answers: ::prost::alloc::vec::Vec<FaqAnswer>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartRepliesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub current_text_input: ::core::option::Option<TextInput>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartRepliesResponse {
    #[prost(message, repeated, tag = "1")]
    pub smart_reply_answers: ::prost::alloc::vec::Vec<SmartReplyAnswer>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestDialogflowAssistsResponse {
    #[prost(message, repeated, tag = "1")]
    pub dialogflow_assist_answers: ::prost::alloc::vec::Vec<DialogflowAssistAnswer>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Suggestion {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub articles: ::prost::alloc::vec::Vec<suggestion::Article>,
    #[prost(message, repeated, tag = "4")]
    pub faq_answers: ::prost::alloc::vec::Vec<suggestion::FaqAnswer>,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "7")]
    pub latest_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Suggestion`.
pub mod suggestion {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Article {
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub uri: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "3")]
        pub snippets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(btree_map = "string, string", tag = "5")]
        pub metadata: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "6")]
        pub answer_record: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FaqAnswer {
        #[prost(string, tag = "1")]
        pub answer: ::prost::alloc::string::String,
        #[prost(float, tag = "2")]
        pub confidence: f32,
        #[prost(string, tag = "3")]
        pub question: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub source: ::prost::alloc::string::String,
        #[prost(btree_map = "string, string", tag = "5")]
        pub metadata: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "6")]
        pub answer_record: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSuggestionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSuggestionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub suggestions: ::prost::alloc::vec::Vec<Suggestion>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompileSuggestionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompileSuggestionResponse {
    #[prost(message, optional, tag = "1")]
    pub suggestion: ::core::option::Option<Suggestion>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseMessage {
    #[prost(oneof = "response_message::Message", tags = "1, 2, 3, 4, 5, 6")]
    pub message: ::core::option::Option<response_message::Message>,
}
/// Nested message and enum types in `ResponseMessage`.
pub mod response_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Text {
        #[prost(string, repeated, tag = "1")]
        pub text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveAgentHandoff {
        #[prost(message, optional, tag = "1")]
        pub metadata: ::core::option::Option<::prost_types::Struct>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct EndInteraction {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MixedAudio {
        #[prost(message, repeated, tag = "1")]
        pub segments: ::prost::alloc::vec::Vec<mixed_audio::Segment>,
    }
    /// Nested message and enum types in `MixedAudio`.
    pub mod mixed_audio {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Segment {
            #[prost(bool, tag = "3")]
            pub allow_playback_interruption: bool,
            #[prost(oneof = "segment::Content", tags = "1, 2")]
            pub content: ::core::option::Option<segment::Content>,
        }
        /// Nested message and enum types in `Segment`.
        pub mod segment {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Content {
                #[prost(bytes, tag = "1")]
                Audio(::prost::bytes::Bytes),
                #[prost(string, tag = "2")]
                Uri(::prost::alloc::string::String),
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TelephonyTransferCall {
        #[prost(oneof = "telephony_transfer_call::Endpoint", tags = "1, 2")]
        pub endpoint: ::core::option::Option<telephony_transfer_call::Endpoint>,
    }
    /// Nested message and enum types in `TelephonyTransferCall`.
    pub mod telephony_transfer_call {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Endpoint {
            #[prost(string, tag = "1")]
            PhoneNumber(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            SipUri(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        Text(Text),
        #[prost(message, tag = "2")]
        Payload(::prost_types::Struct),
        #[prost(message, tag = "3")]
        LiveAgentHandoff(LiveAgentHandoff),
        #[prost(message, tag = "4")]
        EndInteraction(EndInteraction),
        #[prost(message, tag = "5")]
        MixedAudio(MixedAudio),
        #[prost(message, tag = "6")]
        TelephonyTransferCall(TelephonyTransferCall),
    }
}
/// Generated client implementations.
pub mod participants_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [Participants][google.cloud.dialogflow.v2beta1.Participant].
    #[derive(Debug, Clone)]
    pub struct ParticipantsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ParticipantsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ParticipantsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ParticipantsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new participant in a conversation.
        pub async fn create_participant(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateParticipantRequest>,
        ) -> std::result::Result<tonic::Response<super::Participant>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/CreateParticipant",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "CreateParticipant",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a conversation participant.
        pub async fn get_participant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetParticipantRequest>,
        ) -> std::result::Result<tonic::Response<super::Participant>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/GetParticipant",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "GetParticipant",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of all participants in the specified conversation.
        pub async fn list_participants(
            &mut self,
            request: impl tonic::IntoRequest<super::ListParticipantsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListParticipantsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/ListParticipants",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "ListParticipants",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified participant.
        pub async fn update_participant(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateParticipantRequest>,
        ) -> std::result::Result<tonic::Response<super::Participant>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/UpdateParticipant",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "UpdateParticipant",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Adds a text (chat, for example), or audio (phone recording, for example)
        /// message from a participant into the conversation.
        ///
        /// Note: Always use agent versions for production traffic
        /// sent to virtual agents. See [Versions and
        /// environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
        pub async fn analyze_content(
            &mut self,
            request: impl tonic::IntoRequest<super::AnalyzeContentRequest>,
        ) -> std::result::Result<tonic::Response<super::AnalyzeContentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/AnalyzeContent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "AnalyzeContent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Adds a text (e.g., chat) or audio (e.g., phone recording) message from a
        /// participant into the conversation.
        /// Note: This method is only available through the gRPC API (not REST).
        ///
        /// The top-level message sent to the client by the server is
        /// `StreamingAnalyzeContentResponse`. Multiple response messages can be
        /// returned in order. The first one or more messages contain the
        /// `recognition_result` field. Each result represents a more complete
        /// transcript of what the user said. The next message contains the
        /// `reply_text` field, and potentially the `reply_audio` and/or the
        /// `automated_agent_reply` fields.
        ///
        /// Note: Always use agent versions for production traffic
        /// sent to virtual agents. See [Versions and
        /// environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
        pub async fn streaming_analyze_content(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::StreamingAnalyzeContentRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamingAnalyzeContentResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/StreamingAnalyzeContent",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "StreamingAnalyzeContent",
            ));
            self.inner.streaming(req, path, codec).await
        }
        /// Gets suggested articles for a participant based on specific historical
        /// messages.
        ///
        /// Note that
        /// [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
        /// will only list the auto-generated suggestions, while
        /// [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
        /// will try to compile suggestion based on the provided conversation context
        /// in the real time.
        pub async fn suggest_articles(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestArticlesRequest>,
        ) -> std::result::Result<tonic::Response<super::SuggestArticlesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/SuggestArticles",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "SuggestArticles",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets suggested faq answers for a participant based on specific historical
        /// messages.
        pub async fn suggest_faq_answers(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestFaqAnswersRequest>,
        ) -> std::result::Result<tonic::Response<super::SuggestFaqAnswersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/SuggestFaqAnswers",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "SuggestFaqAnswers",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets smart replies for a participant based on specific historical
        /// messages.
        pub async fn suggest_smart_replies(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestSmartRepliesRequest>,
        ) -> std::result::Result<tonic::Response<super::SuggestSmartRepliesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/SuggestSmartReplies",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "SuggestSmartReplies",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated: Use inline suggestion, event based suggestion or
        /// Suggestion* API instead.
        /// See
        /// [HumanAgentAssistantConfig.name][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.name]
        /// for more details. Removal Date: 2020-09-01.
        ///
        /// Retrieves suggestions for live agents.
        ///
        /// This method should be used by human agent client software to fetch auto
        /// generated suggestions in real-time, while the conversation with an end user
        /// is in progress. The functionality is implemented in terms of the
        /// [list
        /// pagination](https://cloud.google.com/apis/design/design_patterns#list_pagination)
        /// design pattern. The client app should use the `next_page_token` field
        /// to fetch the next batch of suggestions. `suggestions` are sorted by
        /// `create_time` in descending order.
        /// To fetch latest suggestion, just set `page_size` to 1.
        /// To fetch new suggestions without duplication, send request with filter
        /// `create_time_epoch_microseconds > [first item's create_time of previous
        /// request]` and empty page_token.
        pub async fn list_suggestions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSuggestionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListSuggestionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/ListSuggestions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "ListSuggestions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated. use
        /// [SuggestArticles][google.cloud.dialogflow.v2beta1.Participants.SuggestArticles]
        /// and
        /// [SuggestFaqAnswers][google.cloud.dialogflow.v2beta1.Participants.SuggestFaqAnswers]
        /// instead.
        ///
        /// Gets suggestions for a participant based on specific historical
        /// messages.
        ///
        /// Note that
        /// [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
        /// will only list the auto-generated suggestions, while
        /// [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
        /// will try to compile suggestion based on the provided conversation context
        /// in the real time.
        pub async fn compile_suggestion(
            &mut self,
            request: impl tonic::IntoRequest<super::CompileSuggestionRequest>,
        ) -> std::result::Result<tonic::Response<super::CompileSuggestionResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Participants/CompileSuggestion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Participants",
                "CompileSuggestion",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub automated_agent_config: ::core::option::Option<AutomatedAgentConfig>,
    #[prost(message, optional, tag = "4")]
    pub human_agent_assistant_config: ::core::option::Option<HumanAgentAssistantConfig>,
    #[prost(message, optional, tag = "5")]
    pub human_agent_handoff_config: ::core::option::Option<HumanAgentHandoffConfig>,
    #[prost(message, optional, tag = "6")]
    pub notification_config: ::core::option::Option<NotificationConfig>,
    #[prost(message, optional, tag = "7")]
    pub logging_config: ::core::option::Option<LoggingConfig>,
    #[prost(message, optional, tag = "8")]
    pub new_message_event_notification_config: ::core::option::Option<NotificationConfig>,
    #[prost(message, optional, tag = "9")]
    pub stt_config: ::core::option::Option<SpeechToTextConfig>,
    #[prost(string, tag = "10")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub security_settings: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "18")]
    pub tts_config: ::core::option::Option<SynthesizeSpeechConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomatedAgentConfig {
    #[prost(string, tag = "1")]
    pub agent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub session_ttl: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HumanAgentAssistantConfig {
    #[prost(message, optional, tag = "2")]
    pub notification_config: ::core::option::Option<NotificationConfig>,
    #[prost(message, optional, tag = "3")]
    pub human_agent_suggestion_config:
        ::core::option::Option<human_agent_assistant_config::SuggestionConfig>,
    #[prost(message, optional, tag = "4")]
    pub end_user_suggestion_config:
        ::core::option::Option<human_agent_assistant_config::SuggestionConfig>,
    #[prost(message, optional, tag = "5")]
    pub message_analysis_config:
        ::core::option::Option<human_agent_assistant_config::MessageAnalysisConfig>,
}
/// Nested message and enum types in `HumanAgentAssistantConfig`.
pub mod human_agent_assistant_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SuggestionTriggerSettings {
        #[prost(bool, tag = "1")]
        pub no_small_talk: bool,
        #[prost(bool, tag = "2")]
        pub only_end_user: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SuggestionFeatureConfig {
        #[prost(message, optional, tag = "5")]
        pub suggestion_feature: ::core::option::Option<super::SuggestionFeature>,
        #[prost(bool, tag = "3")]
        pub enable_event_based_suggestion: bool,
        #[prost(bool, tag = "14")]
        pub disable_agent_query_logging: bool,
        #[prost(bool, tag = "16")]
        pub enable_conversation_augmented_query: bool,
        #[prost(message, optional, tag = "10")]
        pub suggestion_trigger_settings: ::core::option::Option<SuggestionTriggerSettings>,
        #[prost(message, optional, tag = "6")]
        pub query_config: ::core::option::Option<SuggestionQueryConfig>,
        #[prost(message, optional, tag = "7")]
        pub conversation_model_config: ::core::option::Option<ConversationModelConfig>,
        #[prost(message, optional, tag = "8")]
        pub conversation_process_config: ::core::option::Option<ConversationProcessConfig>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SuggestionConfig {
        #[prost(message, repeated, tag = "2")]
        pub feature_configs: ::prost::alloc::vec::Vec<SuggestionFeatureConfig>,
        #[prost(bool, tag = "3")]
        pub group_suggestion_responses: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SuggestionQueryConfig {
        #[prost(int32, tag = "4")]
        pub max_results: i32,
        #[prost(float, tag = "5")]
        pub confidence_threshold: f32,
        #[prost(message, optional, tag = "7")]
        pub context_filter_settings:
            ::core::option::Option<suggestion_query_config::ContextFilterSettings>,
        #[prost(message, optional, tag = "8")]
        pub sections: ::core::option::Option<suggestion_query_config::Sections>,
        #[prost(oneof = "suggestion_query_config::QuerySource", tags = "1, 2, 3")]
        pub query_source: ::core::option::Option<suggestion_query_config::QuerySource>,
    }
    /// Nested message and enum types in `SuggestionQueryConfig`.
    pub mod suggestion_query_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct KnowledgeBaseQuerySource {
            #[prost(string, repeated, tag = "1")]
            pub knowledge_bases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DocumentQuerySource {
            #[prost(string, repeated, tag = "1")]
            pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DialogflowQuerySource {
            #[prost(string, tag = "1")]
            pub agent: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub human_agent_side_config:
                ::core::option::Option<dialogflow_query_source::HumanAgentSideConfig>,
        }
        /// Nested message and enum types in `DialogflowQuerySource`.
        pub mod dialogflow_query_source {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct HumanAgentSideConfig {
                #[prost(string, tag = "1")]
                pub agent: ::prost::alloc::string::String,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ContextFilterSettings {
            #[prost(bool, tag = "1")]
            pub drop_handoff_messages: bool,
            #[prost(bool, tag = "2")]
            pub drop_virtual_agent_messages: bool,
            #[prost(bool, tag = "3")]
            pub drop_ivr_messages: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Sections {
            #[prost(enumeration = "sections::SectionType", repeated, tag = "1")]
            pub section_types: ::prost::alloc::vec::Vec<i32>,
        }
        /// Nested message and enum types in `Sections`.
        pub mod sections {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum SectionType {
                Unspecified = 0,
                Situation = 1,
                Action = 2,
                Resolution = 3,
                ReasonForCancellation = 4,
                CustomerSatisfaction = 5,
                Entities = 6,
            }
            impl SectionType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        SectionType::Unspecified => "SECTION_TYPE_UNSPECIFIED",
                        SectionType::Situation => "SITUATION",
                        SectionType::Action => "ACTION",
                        SectionType::Resolution => "RESOLUTION",
                        SectionType::ReasonForCancellation => "REASON_FOR_CANCELLATION",
                        SectionType::CustomerSatisfaction => "CUSTOMER_SATISFACTION",
                        SectionType::Entities => "ENTITIES",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SECTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SITUATION" => Some(Self::Situation),
                        "ACTION" => Some(Self::Action),
                        "RESOLUTION" => Some(Self::Resolution),
                        "REASON_FOR_CANCELLATION" => Some(Self::ReasonForCancellation),
                        "CUSTOMER_SATISFACTION" => Some(Self::CustomerSatisfaction),
                        "ENTITIES" => Some(Self::Entities),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum QuerySource {
            #[prost(message, tag = "1")]
            KnowledgeBaseQuerySource(KnowledgeBaseQuerySource),
            #[prost(message, tag = "2")]
            DocumentQuerySource(DocumentQuerySource),
            #[prost(message, tag = "3")]
            DialogflowQuerySource(DialogflowQuerySource),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConversationModelConfig {
        #[prost(string, tag = "1")]
        pub model: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub baseline_model_version: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ConversationProcessConfig {
        #[prost(int32, tag = "2")]
        pub recent_sentences_count: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MessageAnalysisConfig {
        #[prost(bool, tag = "2")]
        pub enable_entity_extraction: bool,
        #[prost(bool, tag = "3")]
        pub enable_sentiment_analysis: bool,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HumanAgentHandoffConfig {
    #[prost(oneof = "human_agent_handoff_config::AgentService", tags = "1, 2")]
    pub agent_service: ::core::option::Option<human_agent_handoff_config::AgentService>,
}
/// Nested message and enum types in `HumanAgentHandoffConfig`.
pub mod human_agent_handoff_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LivePersonConfig {
        #[prost(string, tag = "1")]
        pub account_number: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SalesforceLiveAgentConfig {
        #[prost(string, tag = "1")]
        pub organization_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub deployment_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub button_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub endpoint_domain: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AgentService {
        #[prost(message, tag = "1")]
        LivePersonConfig(LivePersonConfig),
        #[prost(message, tag = "2")]
        SalesforceLiveAgentConfig(SalesforceLiveAgentConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationConfig {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(enumeration = "notification_config::MessageFormat", tag = "2")]
    pub message_format: i32,
}
/// Nested message and enum types in `NotificationConfig`.
pub mod notification_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MessageFormat {
        Unspecified = 0,
        Proto = 1,
        Json = 2,
    }
    impl MessageFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MessageFormat::Unspecified => "MESSAGE_FORMAT_UNSPECIFIED",
                MessageFormat::Proto => "PROTO",
                MessageFormat::Json => "JSON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MESSAGE_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "PROTO" => Some(Self::Proto),
                "JSON" => Some(Self::Json),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LoggingConfig {
    #[prost(bool, tag = "3")]
    pub enable_stackdriver_logging: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationProfilesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationProfilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub conversation_profiles: ::prost::alloc::vec::Vec<ConversationProfile>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationProfileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationProfileRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub conversation_profile: ::core::option::Option<ConversationProfile>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversationProfileRequest {
    #[prost(message, optional, tag = "1")]
    pub conversation_profile: ::core::option::Option<ConversationProfile>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConversationProfileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSuggestionFeatureConfigRequest {
    #[prost(string, tag = "1")]
    pub conversation_profile: ::prost::alloc::string::String,
    #[prost(enumeration = "participant::Role", tag = "2")]
    pub participant_role: i32,
    #[prost(message, optional, tag = "3")]
    pub suggestion_feature_config:
        ::core::option::Option<human_agent_assistant_config::SuggestionFeatureConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearSuggestionFeatureConfigRequest {
    #[prost(string, tag = "1")]
    pub conversation_profile: ::prost::alloc::string::String,
    #[prost(enumeration = "participant::Role", tag = "2")]
    pub participant_role: i32,
    #[prost(enumeration = "suggestion_feature::Type", tag = "3")]
    pub suggestion_feature_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSuggestionFeatureConfigOperationMetadata {
    #[prost(string, tag = "1")]
    pub conversation_profile: ::prost::alloc::string::String,
    #[prost(enumeration = "participant::Role", tag = "2")]
    pub participant_role: i32,
    #[prost(enumeration = "suggestion_feature::Type", tag = "3")]
    pub suggestion_feature_type: i32,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearSuggestionFeatureConfigOperationMetadata {
    #[prost(string, tag = "1")]
    pub conversation_profile: ::prost::alloc::string::String,
    #[prost(enumeration = "participant::Role", tag = "2")]
    pub participant_role: i32,
    #[prost(enumeration = "suggestion_feature::Type", tag = "3")]
    pub suggestion_feature_type: i32,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod conversation_profiles_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [ConversationProfiles][google.cloud.dialogflow.v2beta1.ConversationProfile].
    #[derive(Debug, Clone)]
    pub struct ConversationProfilesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ConversationProfilesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConversationProfilesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ConversationProfilesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all conversation profiles in the specified project.
        pub async fn list_conversation_profiles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversationProfilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConversationProfilesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.ConversationProfiles/ListConversationProfiles",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.ConversationProfiles",
                "ListConversationProfiles",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified conversation profile.
        pub async fn get_conversation_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversationProfileRequest>,
        ) -> std::result::Result<tonic::Response<super::ConversationProfile>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.ConversationProfiles/GetConversationProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.ConversationProfiles",
                "GetConversationProfile",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a conversation profile in the specified project.
        ///
        /// [ConversationProfile.CreateTime][] and [ConversationProfile.UpdateTime][]
        /// aren't populated in the response. You can retrieve them via
        /// [GetConversationProfile][google.cloud.dialogflow.v2beta1.ConversationProfiles.GetConversationProfile]
        /// API.
        pub async fn create_conversation_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversationProfileRequest>,
        ) -> std::result::Result<tonic::Response<super::ConversationProfile>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.ConversationProfiles/CreateConversationProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.ConversationProfiles",
                "CreateConversationProfile",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified conversation profile.
        ///
        /// [ConversationProfile.CreateTime][] and [ConversationProfile.UpdateTime][]
        /// aren't populated in the response. You can retrieve them via
        /// [GetConversationProfile][google.cloud.dialogflow.v2beta1.ConversationProfiles.GetConversationProfile]
        /// API.
        pub async fn update_conversation_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConversationProfileRequest>,
        ) -> std::result::Result<tonic::Response<super::ConversationProfile>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.ConversationProfiles/UpdateConversationProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.ConversationProfiles",
                "UpdateConversationProfile",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified conversation profile.
        pub async fn delete_conversation_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConversationProfileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.ConversationProfiles/DeleteConversationProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.ConversationProfiles",
                "DeleteConversationProfile",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Adds or updates a suggestion feature in a conversation profile.
        /// If the conversation profile contains the type of suggestion feature for
        /// the participant role, it will update it. Otherwise it will insert the
        /// suggestion feature.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`:
        /// [SetSuggestionFeatureConfigOperationMetadata][google.cloud.dialogflow.v2beta1.SetSuggestionFeatureConfigOperationMetadata]
        /// - `response`:
        /// [ConversationProfile][google.cloud.dialogflow.v2beta1.ConversationProfile]
        ///
        /// If a long running operation to add or update suggestion feature
        /// config for the same conversation profile, participant role and suggestion
        /// feature type exists, please cancel the existing long running operation
        /// before sending such request, otherwise the request will be rejected.
        pub async fn set_suggestion_feature_config(
            &mut self,
            request: impl tonic::IntoRequest<super::SetSuggestionFeatureConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.ConversationProfiles/SetSuggestionFeatureConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.ConversationProfiles",
                "SetSuggestionFeatureConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Clears a suggestion feature from a conversation profile for the given
        /// participant role.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/es/docs/how/long-running-operations).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`:
        /// [ClearSuggestionFeatureConfigOperationMetadata][google.cloud.dialogflow.v2beta1.ClearSuggestionFeatureConfigOperationMetadata]
        /// - `response`:
        /// [ConversationProfile][google.cloud.dialogflow.v2beta1.ConversationProfile]
        pub async fn clear_suggestion_feature_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ClearSuggestionFeatureConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.cloud.dialogflow.v2beta1.ConversationProfiles/ClearSuggestionFeatureConfig");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.ConversationProfiles",
                "ClearSuggestionFeatureConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSources {
    #[prost(string, repeated, tag = "2")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsDestination {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(
        enumeration = "document::KnowledgeType",
        repeated,
        packed = "false",
        tag = "4"
    )]
    pub knowledge_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "11")]
    pub enable_auto_reload: bool,
    #[prost(message, optional, tag = "12")]
    pub latest_reload_status: ::core::option::Option<document::ReloadStatus>,
    #[prost(btree_map = "string, string", tag = "7")]
    pub metadata: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "document::State", tag = "13")]
    pub state: i32,
    #[prost(oneof = "document::Source", tags = "5, 6, 9")]
    pub source: ::core::option::Option<document::Source>,
}
/// Nested message and enum types in `Document`.
pub mod document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReloadStatus {
        #[prost(message, optional, tag = "1")]
        pub time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub status: ::core::option::Option<super::super::super::super::rpc::Status>,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum KnowledgeType {
        Unspecified = 0,
        Faq = 1,
        ExtractiveQa = 2,
        ArticleSuggestion = 3,
        AgentFacingSmartReply = 4,
    }
    impl KnowledgeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KnowledgeType::Unspecified => "KNOWLEDGE_TYPE_UNSPECIFIED",
                KnowledgeType::Faq => "FAQ",
                KnowledgeType::ExtractiveQa => "EXTRACTIVE_QA",
                KnowledgeType::ArticleSuggestion => "ARTICLE_SUGGESTION",
                KnowledgeType::AgentFacingSmartReply => "AGENT_FACING_SMART_REPLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KNOWLEDGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FAQ" => Some(Self::Faq),
                "EXTRACTIVE_QA" => Some(Self::ExtractiveQa),
                "ARTICLE_SUGGESTION" => Some(Self::ArticleSuggestion),
                "AGENT_FACING_SMART_REPLY" => Some(Self::AgentFacingSmartReply),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
        Updating = 3,
        Reloading = 4,
        Deleting = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Updating => "UPDATING",
                State::Reloading => "RELOADING",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "RELOADING" => Some(Self::Reloading),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(string, tag = "5")]
        ContentUri(::prost::alloc::string::String),
        #[prost(string, tag = "6")]
        Content(::prost::alloc::string::String),
        #[prost(bytes, tag = "9")]
        RawContent(::prost::bytes::Bytes),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
    #[prost(bool, tag = "3")]
    pub import_gcs_custom_metadata: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub document_template: ::core::option::Option<ImportDocumentTemplate>,
    #[prost(bool, tag = "4")]
    pub import_gcs_custom_metadata: bool,
    #[prost(oneof = "import_documents_request::Source", tags = "2")]
    pub source: ::core::option::Option<import_documents_request::Source>,
}
/// Nested message and enum types in `ImportDocumentsRequest`.
pub mod import_documents_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        GcsSource(super::GcsSources),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentTemplate {
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(
        enumeration = "document::KnowledgeType",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub knowledge_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(btree_map = "string, string", tag = "3")]
    pub metadata: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub warnings: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub exported_gcs_destination: ::core::option::Option<GcsDestination>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KnowledgeOperationMetadata {
    #[prost(enumeration = "knowledge_operation_metadata::State", tag = "1")]
    pub state: i32,
    #[prost(string, tag = "3")]
    pub knowledge_base: ::prost::alloc::string::String,
    #[prost(oneof = "knowledge_operation_metadata::OperationMetadata", tags = "4")]
    pub operation_metadata: ::core::option::Option<knowledge_operation_metadata::OperationMetadata>,
}
/// Nested message and enum types in `KnowledgeOperationMetadata`.
pub mod knowledge_operation_metadata {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Pending = 1,
        Running = 2,
        Done = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Pending => "PENDING",
                State::Running => "RUNNING",
                State::Done => "DONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "DONE" => Some(Self::Done),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OperationMetadata {
        #[prost(message, tag = "4")]
        ExportOperationMetadata(super::ExportOperationMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReloadDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub import_gcs_custom_metadata: bool,
    #[prost(oneof = "reload_document_request::Source", tags = "3")]
    pub source: ::core::option::Option<reload_document_request::Source>,
}
/// Nested message and enum types in `ReloadDocumentRequest`.
pub mod reload_document_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
    }
}
/// Generated client implementations.
pub mod documents_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing knowledge
    /// [Documents][google.cloud.dialogflow.v2beta1.Document].
    #[derive(Debug, Clone)]
    pub struct DocumentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DocumentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DocumentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            DocumentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all documents of the knowledge base.
        ///
        /// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
        /// only use `projects.knowledgeBases.documents`.
        pub async fn list_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDocumentsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListDocumentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Documents/ListDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Documents",
                "ListDocuments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified document.
        ///
        /// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
        /// only use `projects.knowledgeBases.documents`.
        pub async fn get_document(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Documents/GetDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Documents",
                "GetDocument",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new document.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`:
        /// [KnowledgeOperationMetadata][google.cloud.dialogflow.v2beta1.KnowledgeOperationMetadata]
        /// - `response`: [Document][google.cloud.dialogflow.v2beta1.Document]
        ///
        /// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
        /// only use `projects.knowledgeBases.documents`.
        pub async fn create_document(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Documents/CreateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Documents",
                "CreateDocument",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Create documents by importing data from external sources.
        /// Dialogflow supports up to 350 documents in each request. If you try to
        /// import more, Dialogflow will return an error.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`:
        /// [KnowledgeOperationMetadata][google.cloud.dialogflow.v2beta1.KnowledgeOperationMetadata]
        /// - `response`:
        /// [ImportDocumentsResponse][google.cloud.dialogflow.v2beta1.ImportDocumentsResponse]
        pub async fn import_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Documents/ImportDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Documents",
                "ImportDocuments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified document.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`:
        /// [KnowledgeOperationMetadata][google.cloud.dialogflow.v2beta1.KnowledgeOperationMetadata]
        /// - `response`: An [Empty
        ///   message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty)
        ///
        /// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
        /// only use `projects.knowledgeBases.documents`.
        pub async fn delete_document(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Documents/DeleteDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Documents",
                "DeleteDocument",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified document.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`:
        /// [KnowledgeOperationMetadata][google.cloud.dialogflow.v2beta1.KnowledgeOperationMetadata]
        /// - `response`: [Document][google.cloud.dialogflow.v2beta1.Document]
        ///
        /// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
        /// only use `projects.knowledgeBases.documents`.
        pub async fn update_document(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Documents/UpdateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Documents",
                "UpdateDocument",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Reloads the specified document from its specified source, content_uri or
        /// content. The previously loaded content of the document will be deleted.
        /// Note: Even when the content of the document has not changed, there still
        /// may be side effects because of internal implementation changes.
        /// Note: If the document source is Google Cloud Storage URI, its metadata will
        /// be replaced with the custom metadata from Google Cloud Storage if the
        /// `import_gcs_custom_metadata` field is set to true in the request.
        ///
        /// This method is a [long-running
        /// operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
        /// The returned `Operation` type has the following method-specific fields:
        ///
        /// - `metadata`:
        /// [KnowledgeOperationMetadata][google.cloud.dialogflow.v2beta1.KnowledgeOperationMetadata]
        /// - `response`: [Document][google.cloud.dialogflow.v2beta1.Document]
        ///
        /// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
        /// only use `projects.knowledgeBases.documents`.
        pub async fn reload_document(
            &mut self,
            request: impl tonic::IntoRequest<super::ReloadDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Documents/ReloadDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Documents",
                "ReloadDocument",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KnowledgeBase {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKnowledgeBasesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKnowledgeBasesResponse {
    #[prost(message, repeated, tag = "1")]
    pub knowledge_bases: ::prost::alloc::vec::Vec<KnowledgeBase>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKnowledgeBaseRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateKnowledgeBaseRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub knowledge_base: ::core::option::Option<KnowledgeBase>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteKnowledgeBaseRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateKnowledgeBaseRequest {
    #[prost(message, optional, tag = "1")]
    pub knowledge_base: ::core::option::Option<KnowledgeBase>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod knowledge_bases_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [KnowledgeBases][google.cloud.dialogflow.v2beta1.KnowledgeBase].
    #[derive(Debug, Clone)]
    pub struct KnowledgeBasesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> KnowledgeBasesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> KnowledgeBasesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            KnowledgeBasesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all knowledge bases of the specified agent.
        ///
        /// Note: The `projects.agent.knowledgeBases` resource is deprecated;
        /// only use `projects.knowledgeBases`.
        pub async fn list_knowledge_bases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKnowledgeBasesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListKnowledgeBasesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.KnowledgeBases/ListKnowledgeBases",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.KnowledgeBases",
                "ListKnowledgeBases",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified knowledge base.
        ///
        /// Note: The `projects.agent.knowledgeBases` resource is deprecated;
        /// only use `projects.knowledgeBases`.
        pub async fn get_knowledge_base(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKnowledgeBaseRequest>,
        ) -> std::result::Result<tonic::Response<super::KnowledgeBase>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.KnowledgeBases/GetKnowledgeBase",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.KnowledgeBases",
                "GetKnowledgeBase",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a knowledge base.
        ///
        /// Note: The `projects.agent.knowledgeBases` resource is deprecated;
        /// only use `projects.knowledgeBases`.
        pub async fn create_knowledge_base(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateKnowledgeBaseRequest>,
        ) -> std::result::Result<tonic::Response<super::KnowledgeBase>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.KnowledgeBases/CreateKnowledgeBase",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.KnowledgeBases",
                "CreateKnowledgeBase",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified knowledge base.
        ///
        /// Note: The `projects.agent.knowledgeBases` resource is deprecated;
        /// only use `projects.knowledgeBases`.
        pub async fn delete_knowledge_base(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteKnowledgeBaseRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.KnowledgeBases/DeleteKnowledgeBase",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.KnowledgeBases",
                "DeleteKnowledgeBase",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified knowledge base.
        ///
        /// Note: The `projects.agent.knowledgeBases` resource is deprecated;
        /// only use `projects.knowledgeBases`.
        pub async fn update_knowledge_base(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateKnowledgeBaseRequest>,
        ) -> std::result::Result<tonic::Response<super::KnowledgeBase>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.KnowledgeBases/UpdateKnowledgeBase",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.KnowledgeBases",
                "UpdateKnowledgeBase",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HumanAgentAssistantEvent {
    #[prost(string, tag = "1")]
    pub conversation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub participant: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub suggestion_results: ::prost::alloc::vec::Vec<SuggestionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerRecord {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub answer_feedback: ::core::option::Option<AnswerFeedback>,
    #[prost(oneof = "answer_record::Record", tags = "4")]
    pub record: ::core::option::Option<answer_record::Record>,
}
/// Nested message and enum types in `AnswerRecord`.
pub mod answer_record {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Record {
        #[prost(message, tag = "4")]
        AgentAssistantRecord(super::AgentAssistantRecord),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentAssistantRecord {
    #[prost(oneof = "agent_assistant_record::Answer", tags = "5, 6, 7")]
    pub answer: ::core::option::Option<agent_assistant_record::Answer>,
}
/// Nested message and enum types in `AgentAssistantRecord`.
pub mod agent_assistant_record {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Answer {
        #[prost(message, tag = "5")]
        ArticleSuggestionAnswer(super::ArticleAnswer),
        #[prost(message, tag = "6")]
        FaqAnswer(super::FaqAnswer),
        #[prost(message, tag = "7")]
        DialogflowAssistAnswer(super::DialogflowAssistAnswer),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerFeedback {
    #[prost(enumeration = "answer_feedback::CorrectnessLevel", tag = "1")]
    pub correctness_level: i32,
    #[prost(bool, tag = "3")]
    pub clicked: bool,
    #[prost(message, optional, tag = "5")]
    pub click_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "4")]
    pub displayed: bool,
    #[prost(message, optional, tag = "6")]
    pub display_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "answer_feedback::DetailFeedback", tags = "2")]
    pub detail_feedback: ::core::option::Option<answer_feedback::DetailFeedback>,
}
/// Nested message and enum types in `AnswerFeedback`.
pub mod answer_feedback {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CorrectnessLevel {
        Unspecified = 0,
        NotCorrect = 1,
        PartiallyCorrect = 2,
        FullyCorrect = 3,
    }
    impl CorrectnessLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CorrectnessLevel::Unspecified => "CORRECTNESS_LEVEL_UNSPECIFIED",
                CorrectnessLevel::NotCorrect => "NOT_CORRECT",
                CorrectnessLevel::PartiallyCorrect => "PARTIALLY_CORRECT",
                CorrectnessLevel::FullyCorrect => "FULLY_CORRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CORRECTNESS_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_CORRECT" => Some(Self::NotCorrect),
                "PARTIALLY_CORRECT" => Some(Self::PartiallyCorrect),
                "FULLY_CORRECT" => Some(Self::FullyCorrect),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DetailFeedback {
        #[prost(message, tag = "2")]
        AgentAssistantDetailFeedback(super::AgentAssistantFeedback),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentAssistantFeedback {
    #[prost(enumeration = "agent_assistant_feedback::AnswerRelevance", tag = "1")]
    pub answer_relevance: i32,
    #[prost(
        enumeration = "agent_assistant_feedback::DocumentCorrectness",
        tag = "2"
    )]
    pub document_correctness: i32,
    #[prost(
        enumeration = "agent_assistant_feedback::DocumentEfficiency",
        tag = "3"
    )]
    pub document_efficiency: i32,
    #[prost(message, optional, tag = "4")]
    pub summarization_feedback:
        ::core::option::Option<agent_assistant_feedback::SummarizationFeedback>,
    #[prost(message, optional, tag = "5")]
    pub knowledge_search_feedback:
        ::core::option::Option<agent_assistant_feedback::KnowledgeSearchFeedback>,
}
/// Nested message and enum types in `AgentAssistantFeedback`.
pub mod agent_assistant_feedback {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SummarizationFeedback {
        #[prost(message, optional, tag = "1")]
        pub start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub submit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "3")]
        pub summary_text: ::prost::alloc::string::String,
        #[prost(btree_map = "string, string", tag = "4")]
        pub text_sections: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KnowledgeSearchFeedback {
        #[prost(bool, tag = "1")]
        pub answer_copied: bool,
        #[prost(string, repeated, tag = "2")]
        pub clicked_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AnswerRelevance {
        Unspecified = 0,
        Irrelevant = 1,
        Relevant = 2,
    }
    impl AnswerRelevance {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AnswerRelevance::Unspecified => "ANSWER_RELEVANCE_UNSPECIFIED",
                AnswerRelevance::Irrelevant => "IRRELEVANT",
                AnswerRelevance::Relevant => "RELEVANT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANSWER_RELEVANCE_UNSPECIFIED" => Some(Self::Unspecified),
                "IRRELEVANT" => Some(Self::Irrelevant),
                "RELEVANT" => Some(Self::Relevant),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DocumentCorrectness {
        Unspecified = 0,
        Incorrect = 1,
        Correct = 2,
    }
    impl DocumentCorrectness {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DocumentCorrectness::Unspecified => "DOCUMENT_CORRECTNESS_UNSPECIFIED",
                DocumentCorrectness::Incorrect => "INCORRECT",
                DocumentCorrectness::Correct => "CORRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DOCUMENT_CORRECTNESS_UNSPECIFIED" => Some(Self::Unspecified),
                "INCORRECT" => Some(Self::Incorrect),
                "CORRECT" => Some(Self::Correct),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DocumentEfficiency {
        Unspecified = 0,
        Inefficient = 1,
        Efficient = 2,
    }
    impl DocumentEfficiency {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DocumentEfficiency::Unspecified => "DOCUMENT_EFFICIENCY_UNSPECIFIED",
                DocumentEfficiency::Inefficient => "INEFFICIENT",
                DocumentEfficiency::Efficient => "EFFICIENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DOCUMENT_EFFICIENCY_UNSPECIFIED" => Some(Self::Unspecified),
                "INEFFICIENT" => Some(Self::Inefficient),
                "EFFICIENT" => Some(Self::Efficient),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnswerRecordRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnswerRecordsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnswerRecordsResponse {
    #[prost(message, repeated, tag = "1")]
    pub answer_records: ::prost::alloc::vec::Vec<AnswerRecord>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAnswerRecordRequest {
    #[prost(message, optional, tag = "1")]
    pub answer_record: ::core::option::Option<AnswerRecord>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod answer_records_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [AnswerRecords][google.cloud.dialogflow.v2beta1.AnswerRecord].
    #[derive(Debug, Clone)]
    pub struct AnswerRecordsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AnswerRecordsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AnswerRecordsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AnswerRecordsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deprecated.
        /// Retrieves a specific answer record.
        pub async fn get_answer_record(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnswerRecordRequest>,
        ) -> std::result::Result<tonic::Response<super::AnswerRecord>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.AnswerRecords/GetAnswerRecord",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.AnswerRecords",
                "GetAnswerRecord",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of all answer records in the specified project in reverse
        /// chronological order.
        pub async fn list_answer_records(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnswerRecordsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListAnswerRecordsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.AnswerRecords/ListAnswerRecords",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.AnswerRecords",
                "ListAnswerRecords",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified answer record.
        pub async fn update_answer_record(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAnswerRecordRequest>,
        ) -> std::result::Result<tonic::Response<super::AnswerRecord>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.AnswerRecords/UpdateAnswerRecord",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.AnswerRecords",
                "UpdateAnswerRecord",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "conversation::LifecycleState", tag = "2")]
    pub lifecycle_state: i32,
    #[prost(string, tag = "3")]
    pub conversation_profile: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub phone_number: ::core::option::Option<ConversationPhoneNumber>,
    #[prost(enumeration = "conversation::ConversationStage", tag = "7")]
    pub conversation_stage: i32,
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Conversation`.
pub mod conversation {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum LifecycleState {
        Unspecified = 0,
        InProgress = 1,
        Completed = 2,
    }
    impl LifecycleState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LifecycleState::Unspecified => "LIFECYCLE_STATE_UNSPECIFIED",
                LifecycleState::InProgress => "IN_PROGRESS",
                LifecycleState::Completed => "COMPLETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIFECYCLE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ConversationStage {
        Unspecified = 0,
        VirtualAgentStage = 1,
        HumanAssistStage = 2,
    }
    impl ConversationStage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversationStage::Unspecified => "CONVERSATION_STAGE_UNSPECIFIED",
                ConversationStage::VirtualAgentStage => "VIRTUAL_AGENT_STAGE",
                ConversationStage::HumanAssistStage => "HUMAN_ASSIST_STAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONVERSATION_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "VIRTUAL_AGENT_STAGE" => Some(Self::VirtualAgentStage),
                "HUMAN_ASSIST_STAGE" => Some(Self::HumanAssistStage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationPhoneNumber {
    #[prost(string, tag = "3")]
    pub phone_number: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub conversation: ::core::option::Option<Conversation>,
    #[prost(string, tag = "3")]
    pub conversation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteConversationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMessageRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateMessagesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateMessageRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateMessagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMessagesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMessagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestConversationSummaryRequest {
    #[prost(string, tag = "1")]
    pub conversation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub context_size: i32,
    #[prost(message, optional, tag = "5")]
    pub assist_query_params: ::core::option::Option<AssistQueryParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestConversationSummaryResponse {
    #[prost(message, optional, tag = "1")]
    pub summary: ::core::option::Option<suggest_conversation_summary_response::Summary>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
/// Nested message and enum types in `SuggestConversationSummaryResponse`.
pub mod suggest_conversation_summary_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Summary {
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        #[prost(btree_map = "string, string", tag = "4")]
        pub text_sections: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "3")]
        pub answer_record: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub baseline_model_version: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateStatelessSummaryRequest {
    #[prost(message, optional, tag = "1")]
    pub stateless_conversation:
        ::core::option::Option<generate_stateless_summary_request::MinimalConversation>,
    #[prost(message, optional, tag = "2")]
    pub conversation_profile: ::core::option::Option<ConversationProfile>,
    #[prost(string, tag = "3")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub max_context_size: i32,
}
/// Nested message and enum types in `GenerateStatelessSummaryRequest`.
pub mod generate_stateless_summary_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MinimalConversation {
        #[prost(message, repeated, tag = "1")]
        pub messages: ::prost::alloc::vec::Vec<super::Message>,
        #[prost(string, tag = "2")]
        pub parent: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateStatelessSummaryResponse {
    #[prost(message, optional, tag = "1")]
    pub summary: ::core::option::Option<generate_stateless_summary_response::Summary>,
    #[prost(string, tag = "2")]
    pub latest_message: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub context_size: i32,
}
/// Nested message and enum types in `GenerateStatelessSummaryResponse`.
pub mod generate_stateless_summary_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Summary {
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        #[prost(btree_map = "string, string", tag = "2")]
        pub text_sections: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "4")]
        pub baseline_model_version: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchKnowledgeRequest {
    #[prost(string, tag = "6")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1")]
    pub query: ::core::option::Option<TextInput>,
    #[prost(string, tag = "2")]
    pub conversation_profile: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub conversation: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub latest_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchKnowledgeResponse {
    #[prost(message, repeated, tag = "2")]
    pub answers: ::prost::alloc::vec::Vec<SearchKnowledgeAnswer>,
    #[prost(string, tag = "3")]
    pub rewritten_query: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchKnowledgeAnswer {
    #[prost(string, tag = "1")]
    pub answer: ::prost::alloc::string::String,
    #[prost(enumeration = "search_knowledge_answer::AnswerType", tag = "2")]
    pub answer_type: i32,
    #[prost(message, repeated, tag = "3")]
    pub answer_sources: ::prost::alloc::vec::Vec<search_knowledge_answer::AnswerSource>,
    #[prost(string, tag = "5")]
    pub answer_record: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SearchKnowledgeAnswer`.
pub mod search_knowledge_answer {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnswerSource {
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub uri: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub snippet: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AnswerType {
        Unspecified = 0,
        Faq = 1,
        Generative = 2,
        Intent = 3,
    }
    impl AnswerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AnswerType::Unspecified => "ANSWER_TYPE_UNSPECIFIED",
                AnswerType::Faq => "FAQ",
                AnswerType::Generative => "GENERATIVE",
                AnswerType::Intent => "INTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANSWER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FAQ" => Some(Self::Faq),
                "GENERATIVE" => Some(Self::Generative),
                "INTENT" => Some(Self::Intent),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod conversations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [Conversations][google.cloud.dialogflow.v2beta1.Conversation].
    #[derive(Debug, Clone)]
    pub struct ConversationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ConversationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConversationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ConversationsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new conversation. Conversations are auto-completed after 24
        /// hours.
        ///
        /// Conversation Lifecycle:
        /// There are two stages during a conversation: Automated Agent Stage and
        /// Assist Stage.
        ///
        /// For Automated Agent Stage, there will be a dialogflow agent responding to
        /// user queries.
        ///
        /// For Assist Stage, there's no dialogflow agent responding to user queries.
        /// But we will provide suggestions which are generated from conversation.
        ///
        /// If
        /// [Conversation.conversation_profile][google.cloud.dialogflow.v2beta1.Conversation.conversation_profile]
        /// is configured for a dialogflow agent, conversation will start from
        /// `Automated Agent Stage`, otherwise, it will start from `Assist Stage`. And
        /// during `Automated Agent Stage`, once an
        /// [Intent][google.cloud.dialogflow.v2beta1.Intent] with
        /// [Intent.live_agent_handoff][google.cloud.dialogflow.v2beta1.Intent.live_agent_handoff]
        /// is triggered, conversation will transfer to Assist Stage.
        pub async fn create_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/CreateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "CreateConversation",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of all conversations in the specified project.
        pub async fn list_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversationsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListConversationsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/ListConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "ListConversations",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specific conversation.
        pub async fn get_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/GetConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "GetConversation",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Completes the specified conversation. Finished conversations are purged
        /// from the database after 30 days.
        pub async fn complete_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/CompleteConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "CompleteConversation",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Batch ingests messages to conversation. Customers can use this RPC to
        /// ingest historical messages to conversation.
        pub async fn batch_create_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateMessagesRequest>,
        ) -> std::result::Result<tonic::Response<super::BatchCreateMessagesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/BatchCreateMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "BatchCreateMessages",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists messages that belong to a given conversation.
        /// `messages` are ordered by `create_time` in descending order. To fetch
        /// updates without duplication, send request with filter
        /// `create_time_epoch_microseconds >
        /// [first item's create_time of previous request]` and empty page_token.
        pub async fn list_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMessagesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListMessagesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/ListMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "ListMessages",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Suggest summary for a conversation based on specific historical messages.
        /// The range of the messages to be used for summary can be specified in the
        /// request.
        pub async fn suggest_conversation_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestConversationSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestConversationSummaryResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/SuggestConversationSummary",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "SuggestConversationSummary",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Generates and returns a summary for a conversation that does not have a
        /// resource created for it.
        pub async fn generate_stateless_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateStatelessSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateStatelessSummaryResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/GenerateStatelessSummary",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "GenerateStatelessSummary",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get answers for the given query based on knowledge documents.
        pub async fn search_knowledge(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchKnowledgeRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchKnowledgeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Conversations/SearchKnowledge",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Conversations",
                "SearchKnowledge",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Environment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub agent_version: ::prost::alloc::string::String,
    #[prost(enumeration = "environment::State", tag = "4")]
    pub state: i32,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub text_to_speech_settings: ::core::option::Option<TextToSpeechSettings>,
    #[prost(message, optional, tag = "8")]
    pub fulfillment: ::core::option::Option<Fulfillment>,
}
/// Nested message and enum types in `Environment`.
pub mod environment {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Stopped = 1,
        Loading = 2,
        Running = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Stopped => "STOPPED",
                State::Loading => "LOADING",
                State::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STOPPED" => Some(Self::Stopped),
                "LOADING" => Some(Self::Loading),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextToSpeechSettings {
    #[prost(bool, tag = "1")]
    pub enable_text_to_speech: bool,
    #[prost(enumeration = "OutputAudioEncoding", tag = "2")]
    pub output_audio_encoding: i32,
    #[prost(int32, tag = "3")]
    pub sample_rate_hertz: i32,
    #[prost(btree_map = "string, message", tag = "4")]
    pub synthesize_speech_configs: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        SynthesizeSpeechConfig,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnvironmentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnvironmentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub environments: ::prost::alloc::vec::Vec<Environment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEnvironmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEnvironmentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub environment: ::core::option::Option<Environment>,
    #[prost(string, tag = "3")]
    pub environment_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEnvironmentRequest {
    #[prost(message, optional, tag = "1")]
    pub environment: ::core::option::Option<Environment>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub allow_load_to_draft_and_discard_changes: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEnvironmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEnvironmentHistoryRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentHistory {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<environment_history::Entry>,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EnvironmentHistory`.
pub mod environment_history {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(string, tag = "1")]
        pub agent_version: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    }
}
/// Generated client implementations.
pub mod environments_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing
    /// [Environments][google.cloud.dialogflow.v2beta1.Environment].
    #[derive(Debug, Clone)]
    pub struct EnvironmentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> EnvironmentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EnvironmentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            EnvironmentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all non-draft environments of the specified agent.
        pub async fn list_environments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEnvironmentsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListEnvironmentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Environments/ListEnvironments",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Environments",
                "ListEnvironments",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified agent environment.
        pub async fn get_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEnvironmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Environment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Environments/GetEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Environments",
                "GetEnvironment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates an agent environment.
        pub async fn create_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEnvironmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Environment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Environments/CreateEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Environments",
                "CreateEnvironment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified agent environment.
        ///
        /// This method allows you to deploy new agent versions into the environment.
        /// When an environment is pointed to a new agent version by setting
        /// `environment.agent_version`, the environment is temporarily set to the
        /// `LOADING` state. During that time, the environment keeps on serving the
        /// previous version of the agent. After the new agent version is done loading,
        /// the environment is set back to the `RUNNING` state.
        /// You can use "-" as Environment ID in environment name to update version
        /// in "draft" environment. WARNING: this will negate all recent changes to
        /// draft and can't be undone. You may want to save the draft to a version
        /// before calling this function.
        pub async fn update_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEnvironmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Environment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Environments/UpdateEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Environments",
                "UpdateEnvironment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified agent environment.
        pub async fn delete_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEnvironmentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Environments/DeleteEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Environments",
                "DeleteEnvironment",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the history of the specified environment.
        pub async fn get_environment_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEnvironmentHistoryRequest>,
        ) -> std::result::Result<tonic::Response<super::EnvironmentHistory>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Environments/GetEnvironmentHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Environments",
                "GetEnvironmentHistory",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationEvent {
    #[prost(string, tag = "1")]
    pub conversation: ::prost::alloc::string::String,
    #[prost(enumeration = "conversation_event::Type", tag = "2")]
    pub r#type: i32,
    #[prost(message, optional, tag = "3")]
    pub error_status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(oneof = "conversation_event::Payload", tags = "4")]
    pub payload: ::core::option::Option<conversation_event::Payload>,
}
/// Nested message and enum types in `ConversationEvent`.
pub mod conversation_event {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        ConversationStarted = 1,
        ConversationFinished = 2,
        HumanInterventionNeeded = 3,
        NewMessage = 5,
        UnrecoverableError = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::ConversationStarted => "CONVERSATION_STARTED",
                Type::ConversationFinished => "CONVERSATION_FINISHED",
                Type::HumanInterventionNeeded => "HUMAN_INTERVENTION_NEEDED",
                Type::NewMessage => "NEW_MESSAGE",
                Type::UnrecoverableError => "UNRECOVERABLE_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONVERSATION_STARTED" => Some(Self::ConversationStarted),
                "CONVERSATION_FINISHED" => Some(Self::ConversationFinished),
                "HUMAN_INTERVENTION_NEEDED" => Some(Self::HumanInterventionNeeded),
                "NEW_MESSAGE" => Some(Self::NewMessage),
                "UNRECOVERABLE_ERROR" => Some(Self::UnrecoverableError),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "4")]
        NewMessagePayload(super::Message),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookRequest {
    #[prost(string, tag = "4")]
    pub session: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub response_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query_result: ::core::option::Option<QueryResult>,
    #[prost(message, repeated, tag = "5")]
    pub alternative_query_results: ::prost::alloc::vec::Vec<QueryResult>,
    #[prost(message, optional, tag = "3")]
    pub original_detect_intent_request: ::core::option::Option<OriginalDetectIntentRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookResponse {
    #[prost(string, tag = "1")]
    pub fulfillment_text: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub fulfillment_messages: ::prost::alloc::vec::Vec<intent::Message>,
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub payload: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, repeated, tag = "5")]
    pub output_contexts: ::prost::alloc::vec::Vec<Context>,
    #[prost(message, optional, tag = "6")]
    pub followup_event_input: ::core::option::Option<EventInput>,
    #[prost(bool, tag = "7")]
    pub live_agent_handoff: bool,
    #[prost(bool, tag = "8")]
    pub end_interaction: bool,
    #[prost(message, repeated, tag = "10")]
    pub session_entity_types: ::prost::alloc::vec::Vec<SessionEntityType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OriginalDetectIntentRequest {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub payload: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub version_number: i32,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "version::VersionStatus", tag = "6")]
    pub status: i32,
}
/// Nested message and enum types in `Version`.
pub mod version {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum VersionStatus {
        Unspecified = 0,
        InProgress = 1,
        Ready = 2,
        Failed = 3,
    }
    impl VersionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VersionStatus::Unspecified => "VERSION_STATUS_UNSPECIFIED",
                VersionStatus::InProgress => "IN_PROGRESS",
                VersionStatus::Ready => "READY",
                VersionStatus::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERSION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "READY" => Some(Self::Ready),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub versions: ::prost::alloc::vec::Vec<Version>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVersionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<Version>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVersionRequest {
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<Version>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod versions_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing [Versions][google.cloud.dialogflow.v2beta1.Version].
    #[derive(Debug, Clone)]
    pub struct VersionsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VersionsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VersionsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            VersionsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the list of all versions of the specified agent.
        pub async fn list_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVersionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListVersionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Versions/ListVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Versions",
                "ListVersions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified agent version.
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Versions/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Versions",
                "GetVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates an agent version.
        ///
        /// The new version points to the agent instance in the "default" environment.
        pub async fn create_version(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Versions/CreateVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Versions",
                "CreateVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified agent version.
        ///
        /// Note that this method does not allow you to update the state of the agent
        /// the given version points to. It allows you to update only mutable
        /// properties of the version resource.
        pub async fn update_version(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Versions/UpdateVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Versions",
                "UpdateVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Delete the specified agent version.
        pub async fn delete_version(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVersionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dialogflow.v2beta1.Versions/DeleteVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.dialogflow.v2beta1.Versions",
                "DeleteVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
