// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublisherAccount {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub publisher_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub reporting_time_zone: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub currency_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkReportSpec {
#[prost(message, optional, tag = "1")]
pub date_range: ::core::option::Option<DateRange>,
#[prost(enumeration = "network_report_spec::Dimension", repeated, tag = "2")]
pub dimensions: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "network_report_spec::Metric", repeated, tag = "3")]
pub metrics: ::prost::alloc::vec::Vec<i32>,
#[prost(message, repeated, tag = "4")]
pub dimension_filters: ::prost::alloc::vec::Vec<network_report_spec::DimensionFilter>,
#[prost(message, repeated, tag = "5")]
pub sort_conditions: ::prost::alloc::vec::Vec<network_report_spec::SortCondition>,
#[prost(message, optional, tag = "6")]
pub localization_settings: ::core::option::Option<LocalizationSettings>,
#[prost(int32, tag = "7")]
pub max_report_rows: i32,
#[prost(string, tag = "8")]
pub time_zone: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NetworkReportSpec`.
pub mod network_report_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DimensionFilter {
#[prost(enumeration = "Dimension", tag = "1")]
pub dimension: i32,
#[prost(oneof = "dimension_filter::Operator", tags = "2")]
pub operator: ::core::option::Option<dimension_filter::Operator>,
}
/// Nested message and enum types in `DimensionFilter`.
pub mod dimension_filter {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operator {
#[prost(message, tag = "2")]
MatchesAny(super::super::StringList),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SortCondition {
#[prost(enumeration = "super::SortOrder", tag = "3")]
pub order: i32,
#[prost(oneof = "sort_condition::SortOn", tags = "1, 2")]
pub sort_on: ::core::option::Option<sort_condition::SortOn>,
}
/// Nested message and enum types in `SortCondition`.
pub mod sort_condition {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum SortOn {
#[prost(enumeration = "super::Dimension", tag = "1")]
Dimension(i32),
#[prost(enumeration = "super::Metric", tag = "2")]
Metric(i32),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Dimension {
Unspecified = 0,
Date = 1,
Month = 2,
Week = 3,
AdUnit = 4,
App = 5,
AdType = 6,
Country = 7,
Format = 8,
Platform = 9,
}
impl Dimension {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Dimension::Unspecified => "DIMENSION_UNSPECIFIED",
Dimension::Date => "DATE",
Dimension::Month => "MONTH",
Dimension::Week => "WEEK",
Dimension::AdUnit => "AD_UNIT",
Dimension::App => "APP",
Dimension::AdType => "AD_TYPE",
Dimension::Country => "COUNTRY",
Dimension::Format => "FORMAT",
Dimension::Platform => "PLATFORM",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DIMENSION_UNSPECIFIED" => Some(Self::Unspecified),
"DATE" => Some(Self::Date),
"MONTH" => Some(Self::Month),
"WEEK" => Some(Self::Week),
"AD_UNIT" => Some(Self::AdUnit),
"APP" => Some(Self::App),
"AD_TYPE" => Some(Self::AdType),
"COUNTRY" => Some(Self::Country),
"FORMAT" => Some(Self::Format),
"PLATFORM" => Some(Self::Platform),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Metric {
Unspecified = 0,
AdRequests = 1,
Clicks = 2,
EstimatedEarnings = 3,
Impressions = 4,
ImpressionCtr = 5,
ImpressionRpm = 6,
MatchedRequests = 7,
MatchRate = 8,
ShowRate = 9,
}
impl Metric {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Metric::Unspecified => "METRIC_UNSPECIFIED",
Metric::AdRequests => "AD_REQUESTS",
Metric::Clicks => "CLICKS",
Metric::EstimatedEarnings => "ESTIMATED_EARNINGS",
Metric::Impressions => "IMPRESSIONS",
Metric::ImpressionCtr => "IMPRESSION_CTR",
Metric::ImpressionRpm => "IMPRESSION_RPM",
Metric::MatchedRequests => "MATCHED_REQUESTS",
Metric::MatchRate => "MATCH_RATE",
Metric::ShowRate => "SHOW_RATE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"METRIC_UNSPECIFIED" => Some(Self::Unspecified),
"AD_REQUESTS" => Some(Self::AdRequests),
"CLICKS" => Some(Self::Clicks),
"ESTIMATED_EARNINGS" => Some(Self::EstimatedEarnings),
"IMPRESSIONS" => Some(Self::Impressions),
"IMPRESSION_CTR" => Some(Self::ImpressionCtr),
"IMPRESSION_RPM" => Some(Self::ImpressionRpm),
"MATCHED_REQUESTS" => Some(Self::MatchedRequests),
"MATCH_RATE" => Some(Self::MatchRate),
"SHOW_RATE" => Some(Self::ShowRate),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediationReportSpec {
#[prost(message, optional, tag = "1")]
pub date_range: ::core::option::Option<DateRange>,
#[prost(enumeration = "mediation_report_spec::Dimension", repeated, tag = "2")]
pub dimensions: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "mediation_report_spec::Metric", repeated, tag = "3")]
pub metrics: ::prost::alloc::vec::Vec<i32>,
#[prost(message, repeated, tag = "4")]
pub dimension_filters: ::prost::alloc::vec::Vec<mediation_report_spec::DimensionFilter>,
#[prost(message, repeated, tag = "5")]
pub sort_conditions: ::prost::alloc::vec::Vec<mediation_report_spec::SortCondition>,
#[prost(message, optional, tag = "6")]
pub localization_settings: ::core::option::Option<LocalizationSettings>,
#[prost(int32, tag = "7")]
pub max_report_rows: i32,
#[prost(string, tag = "8")]
pub time_zone: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MediationReportSpec`.
pub mod mediation_report_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DimensionFilter {
#[prost(enumeration = "Dimension", tag = "1")]
pub dimension: i32,
#[prost(oneof = "dimension_filter::Operator", tags = "2")]
pub operator: ::core::option::Option<dimension_filter::Operator>,
}
/// Nested message and enum types in `DimensionFilter`.
pub mod dimension_filter {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operator {
#[prost(message, tag = "2")]
MatchesAny(super::super::StringList),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SortCondition {
#[prost(enumeration = "super::SortOrder", tag = "3")]
pub order: i32,
#[prost(oneof = "sort_condition::SortOn", tags = "1, 2")]
pub sort_on: ::core::option::Option<sort_condition::SortOn>,
}
/// Nested message and enum types in `SortCondition`.
pub mod sort_condition {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum SortOn {
#[prost(enumeration = "super::Dimension", tag = "1")]
Dimension(i32),
#[prost(enumeration = "super::Metric", tag = "2")]
Metric(i32),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Dimension {
Unspecified = 0,
Date = 1,
Month = 2,
Week = 3,
AdSource = 4,
AdSourceInstance = 5,
AdUnit = 6,
App = 7,
MediationGroup = 11,
Country = 8,
Format = 9,
Platform = 10,
}
impl Dimension {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Dimension::Unspecified => "DIMENSION_UNSPECIFIED",
Dimension::Date => "DATE",
Dimension::Month => "MONTH",
Dimension::Week => "WEEK",
Dimension::AdSource => "AD_SOURCE",
Dimension::AdSourceInstance => "AD_SOURCE_INSTANCE",
Dimension::AdUnit => "AD_UNIT",
Dimension::App => "APP",
Dimension::MediationGroup => "MEDIATION_GROUP",
Dimension::Country => "COUNTRY",
Dimension::Format => "FORMAT",
Dimension::Platform => "PLATFORM",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DIMENSION_UNSPECIFIED" => Some(Self::Unspecified),
"DATE" => Some(Self::Date),
"MONTH" => Some(Self::Month),
"WEEK" => Some(Self::Week),
"AD_SOURCE" => Some(Self::AdSource),
"AD_SOURCE_INSTANCE" => Some(Self::AdSourceInstance),
"AD_UNIT" => Some(Self::AdUnit),
"APP" => Some(Self::App),
"MEDIATION_GROUP" => Some(Self::MediationGroup),
"COUNTRY" => Some(Self::Country),
"FORMAT" => Some(Self::Format),
"PLATFORM" => Some(Self::Platform),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Metric {
Unspecified = 0,
AdRequests = 1,
Clicks = 2,
EstimatedEarnings = 3,
Impressions = 4,
ImpressionCtr = 5,
MatchedRequests = 6,
MatchRate = 7,
ObservedEcpm = 8,
}
impl Metric {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Metric::Unspecified => "METRIC_UNSPECIFIED",
Metric::AdRequests => "AD_REQUESTS",
Metric::Clicks => "CLICKS",
Metric::EstimatedEarnings => "ESTIMATED_EARNINGS",
Metric::Impressions => "IMPRESSIONS",
Metric::ImpressionCtr => "IMPRESSION_CTR",
Metric::MatchedRequests => "MATCHED_REQUESTS",
Metric::MatchRate => "MATCH_RATE",
Metric::ObservedEcpm => "OBSERVED_ECPM",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"METRIC_UNSPECIFIED" => Some(Self::Unspecified),
"AD_REQUESTS" => Some(Self::AdRequests),
"CLICKS" => Some(Self::Clicks),
"ESTIMATED_EARNINGS" => Some(Self::EstimatedEarnings),
"IMPRESSIONS" => Some(Self::Impressions),
"IMPRESSION_CTR" => Some(Self::ImpressionCtr),
"MATCHED_REQUESTS" => Some(Self::MatchedRequests),
"MATCH_RATE" => Some(Self::MatchRate),
"OBSERVED_ECPM" => Some(Self::ObservedEcpm),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportRow {
#[prost(btree_map = "string, message", tag = "1")]
pub dimension_values: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, report_row::DimensionValue>,
#[prost(btree_map = "string, message", tag = "2")]
pub metric_values: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, report_row::MetricValue>,
}
/// Nested message and enum types in `ReportRow`.
pub mod report_row {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DimensionValue {
#[prost(string, tag = "1")]
pub value: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_label: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetricValue {
#[prost(oneof = "metric_value::Value", tags = "1, 2, 3")]
pub value: ::core::option::Option<metric_value::Value>,
}
/// Nested message and enum types in `MetricValue`.
pub mod metric_value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(int64, tag = "1")]
IntegerValue(i64),
#[prost(double, tag = "2")]
DoubleValue(f64),
#[prost(int64, tag = "3")]
MicrosValue(i64),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportWarning {
#[prost(enumeration = "report_warning::Type", tag = "1")]
pub r#type: i32,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ReportWarning`.
pub mod report_warning {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
DataBeforeAccountTimezoneChange = 1,
DataDelayed = 2,
Other = 3,
ReportCurrencyNotAccountCurrency = 4,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::DataBeforeAccountTimezoneChange => "DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE",
Type::DataDelayed => "DATA_DELAYED",
Type::Other => "OTHER",
Type::ReportCurrencyNotAccountCurrency => "REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE" => Some(Self::DataBeforeAccountTimezoneChange),
"DATA_DELAYED" => Some(Self::DataDelayed),
"OTHER" => Some(Self::Other),
"REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY" => Some(Self::ReportCurrencyNotAccountCurrency),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportHeader {
#[prost(message, optional, tag = "1")]
pub date_range: ::core::option::Option<DateRange>,
#[prost(message, optional, tag = "2")]
pub localization_settings: ::core::option::Option<LocalizationSettings>,
#[prost(string, tag = "3")]
pub reporting_time_zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportFooter {
#[prost(message, repeated, tag = "1")]
pub warnings: ::prost::alloc::vec::Vec<ReportWarning>,
#[prost(int64, tag = "2")]
pub matching_row_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateRange {
#[prost(message, optional, tag = "1")]
pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
#[prost(message, optional, tag = "2")]
pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizationSettings {
#[prost(string, tag = "1")]
pub currency_code: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringList {
#[prost(string, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortOrder {
Unspecified = 0,
Ascending = 1,
Descending = 2,
}
impl SortOrder {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SortOrder::Unspecified => "SORT_ORDER_UNSPECIFIED",
SortOrder::Ascending => "ASCENDING",
SortOrder::Descending => "DESCENDING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SORT_ORDER_UNSPECIFIED" => Some(Self::Unspecified),
"ASCENDING" => Some(Self::Ascending),
"DESCENDING" => Some(Self::Descending),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublisherAccountRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublisherAccountsRequest {
#[prost(int32, tag = "1")]
pub page_size: i32,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublisherAccountsResponse {
#[prost(message, repeated, tag = "1")]
pub account: ::prost::alloc::vec::Vec<PublisherAccount>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateMediationReportRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub report_spec: ::core::option::Option<MediationReportSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateMediationReportResponse {
#[prost(oneof = "generate_mediation_report_response::Payload", tags = "1, 2, 3")]
pub payload: ::core::option::Option<generate_mediation_report_response::Payload>,
}
/// Nested message and enum types in `GenerateMediationReportResponse`.
pub mod generate_mediation_report_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Payload {
#[prost(message, tag = "1")]
Header(super::ReportHeader),
#[prost(message, tag = "2")]
Row(super::ReportRow),
#[prost(message, tag = "3")]
Footer(super::ReportFooter),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateNetworkReportRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub report_spec: ::core::option::Option<NetworkReportSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateNetworkReportResponse {
#[prost(oneof = "generate_network_report_response::Payload", tags = "1, 2, 3")]
pub payload: ::core::option::Option<generate_network_report_response::Payload>,
}
/// Nested message and enum types in `GenerateNetworkReportResponse`.
pub mod generate_network_report_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Payload {
#[prost(message, tag = "1")]
Header(super::ReportHeader),
#[prost(message, tag = "2")]
Row(super::ReportRow),
#[prost(message, tag = "3")]
Footer(super::ReportFooter),
}
}
/// Generated client implementations.
pub mod ad_mob_api_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The AdMob API allows AdMob publishers programmatically get information about
/// their AdMob account.
#[derive(Debug, Clone)]
pub struct AdMobApiClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> AdMobApiClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> AdMobApiClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
AdMobApiClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets information about the specified AdMob publisher account.
pub async fn get_publisher_account(&mut self, request: impl tonic::IntoRequest<super::GetPublisherAccountRequest>) -> std::result::Result<tonic::Response<super::PublisherAccount>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.admob.v1.AdMobApi/GetPublisherAccount");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.admob.v1.AdMobApi", "GetPublisherAccount"));
self.inner.unary(req, path, codec).await
}
/// Lists the AdMob publisher account accessible with the client credential.
/// Currently, all credentials have access to at most one AdMob account.
pub async fn list_publisher_accounts(&mut self, request: impl tonic::IntoRequest<super::ListPublisherAccountsRequest>) -> std::result::Result<tonic::Response<super::ListPublisherAccountsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.admob.v1.AdMobApi/ListPublisherAccounts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.admob.v1.AdMobApi", "ListPublisherAccounts"));
self.inner.unary(req, path, codec).await
}
/// Generates an AdMob Network report based on the provided report
/// specification.
pub async fn generate_network_report(&mut self, request: impl tonic::IntoRequest<super::GenerateNetworkReportRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::GenerateNetworkReportResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.admob.v1.AdMobApi/GenerateNetworkReport");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.admob.v1.AdMobApi", "GenerateNetworkReport"));
self.inner.server_streaming(req, path, codec).await
}
/// Generates an AdMob Mediation report based on the provided report
/// specification.
pub async fn generate_mediation_report(&mut self, request: impl tonic::IntoRequest<super::GenerateMediationReportRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::GenerateMediationReportResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.ads.admob.v1.AdMobApi/GenerateMediationReport");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.ads.admob.v1.AdMobApi", "GenerateMediationReport"));
self.inner.server_streaming(req, path, codec).await
}
}
}
