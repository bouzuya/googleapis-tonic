// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceInfo {
#[prost(string, tag = "2")]
pub location: ::prost::alloc::string::String,
#[prost(int32, repeated, tag = "3")]
pub line_offsets: ::prost::alloc::vec::Vec<i32>,
#[prost(btree_map = "int32, int32", tag = "4")]
pub positions: ::prost::alloc::collections::BTreeMap<i32, i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourcePosition {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub offset: i32,
#[prost(int32, tag = "3")]
pub line: i32,
#[prost(int32, tag = "4")]
pub column: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParsedExpr {
#[prost(message, optional, tag = "2")]
pub expr: ::core::option::Option<Expr>,
#[prost(message, optional, tag = "3")]
pub source_info: ::core::option::Option<SourceInfo>,
#[prost(string, tag = "4")]
pub syntax_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Expr {
#[prost(int32, tag = "2")]
pub id: i32,
#[prost(oneof = "expr::ExprKind", tags = "3, 4, 5, 6, 7, 8, 9")]
pub expr_kind: ::core::option::Option<expr::ExprKind>,
}
/// Nested message and enum types in `Expr`.
pub mod expr {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ident {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Select {
#[prost(message, optional, boxed, tag = "1")]
pub operand: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
#[prost(string, tag = "2")]
pub field: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub test_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Call {
#[prost(message, optional, boxed, tag = "1")]
pub target: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
#[prost(string, tag = "2")]
pub function: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub args: ::prost::alloc::vec::Vec<super::Expr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateList {
#[prost(message, repeated, tag = "1")]
pub elements: ::prost::alloc::vec::Vec<super::Expr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStruct {
#[prost(string, tag = "1")]
pub r#type: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub entries: ::prost::alloc::vec::Vec<create_struct::Entry>,
}
/// Nested message and enum types in `CreateStruct`.
pub mod create_struct {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entry {
#[prost(int32, tag = "1")]
pub id: i32,
#[prost(message, optional, tag = "4")]
pub value: ::core::option::Option<super::super::Expr>,
#[prost(oneof = "entry::KeyKind", tags = "2, 3")]
pub key_kind: ::core::option::Option<entry::KeyKind>,
}
/// Nested message and enum types in `Entry`.
pub mod entry {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum KeyKind {
#[prost(string, tag = "2")]
FieldKey(::prost::alloc::string::String),
#[prost(message, tag = "3")]
MapKey(super::super::super::Expr),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Comprehension {
#[prost(string, tag = "1")]
pub iter_var: ::prost::alloc::string::String,
#[prost(message, optional, boxed, tag = "2")]
pub iter_range: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
#[prost(string, tag = "3")]
pub accu_var: ::prost::alloc::string::String,
#[prost(message, optional, boxed, tag = "4")]
pub accu_init: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
#[prost(message, optional, boxed, tag = "5")]
pub loop_condition: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
#[prost(message, optional, boxed, tag = "6")]
pub loop_step: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
#[prost(message, optional, boxed, tag = "7")]
pub result: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ExprKind {
#[prost(message, tag = "3")]
LiteralExpr(super::Literal),
#[prost(message, tag = "4")]
IdentExpr(Ident),
#[prost(message, tag = "5")]
SelectExpr(::prost::alloc::boxed::Box<Select>),
#[prost(message, tag = "6")]
CallExpr(::prost::alloc::boxed::Box<Call>),
#[prost(message, tag = "7")]
ListExpr(CreateList),
#[prost(message, tag = "8")]
StructExpr(CreateStruct),
#[prost(message, tag = "9")]
ComprehensionExpr(::prost::alloc::boxed::Box<Comprehension>),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Literal {
#[prost(oneof = "literal::ConstantKind", tags = "1, 2, 3, 4, 5, 6, 7")]
pub constant_kind: ::core::option::Option<literal::ConstantKind>,
}
/// Nested message and enum types in `Literal`.
pub mod literal {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ConstantKind {
#[prost(enumeration = "::prost_types::NullValue", tag = "1")]
NullValue(i32),
#[prost(bool, tag = "2")]
BoolValue(bool),
#[prost(int64, tag = "3")]
Int64Value(i64),
#[prost(uint64, tag = "4")]
Uint64Value(u64),
#[prost(double, tag = "5")]
DoubleValue(f64),
#[prost(string, tag = "6")]
StringValue(::prost::alloc::string::String),
#[prost(bytes, tag = "7")]
BytesValue(::prost::bytes::Bytes),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decl {
#[prost(int32, tag = "1")]
pub id: i32,
#[prost(string, tag = "2")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub doc: ::prost::alloc::string::String,
#[prost(oneof = "decl::Kind", tags = "4, 5")]
pub kind: ::core::option::Option<decl::Kind>,
}
/// Nested message and enum types in `Decl`.
pub mod decl {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(message, tag = "4")]
Ident(super::IdentDecl),
#[prost(message, tag = "5")]
Function(super::FunctionDecl),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeclType {
#[prost(int32, tag = "1")]
pub id: i32,
#[prost(string, tag = "2")]
pub r#type: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub type_params: ::prost::alloc::vec::Vec<DeclType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentDecl {
#[prost(message, optional, tag = "3")]
pub r#type: ::core::option::Option<DeclType>,
#[prost(message, optional, tag = "4")]
pub value: ::core::option::Option<Expr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionDecl {
#[prost(message, repeated, tag = "1")]
pub args: ::prost::alloc::vec::Vec<IdentDecl>,
#[prost(message, optional, tag = "2")]
pub return_type: ::core::option::Option<DeclType>,
#[prost(bool, tag = "3")]
pub receiver_function: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
#[prost(oneof = "value::Kind", tags = "1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 15")]
pub kind: ::core::option::Option<value::Kind>,
}
/// Nested message and enum types in `Value`.
pub mod value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(enumeration = "::prost_types::NullValue", tag = "1")]
NullValue(i32),
#[prost(bool, tag = "2")]
BoolValue(bool),
#[prost(int64, tag = "3")]
Int64Value(i64),
#[prost(uint64, tag = "4")]
Uint64Value(u64),
#[prost(double, tag = "5")]
DoubleValue(f64),
#[prost(string, tag = "6")]
StringValue(::prost::alloc::string::String),
#[prost(bytes, tag = "7")]
BytesValue(::prost::bytes::Bytes),
#[prost(message, tag = "9")]
EnumValue(super::EnumValue),
#[prost(message, tag = "10")]
ObjectValue(::prost_types::Any),
#[prost(message, tag = "11")]
MapValue(super::MapValue),
#[prost(message, tag = "12")]
ListValue(super::ListValue),
#[prost(string, tag = "15")]
TypeValue(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumValue {
#[prost(string, tag = "1")]
pub r#type: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub value: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListValue {
#[prost(message, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapValue {
#[prost(message, repeated, tag = "1")]
pub entries: ::prost::alloc::vec::Vec<map_value::Entry>,
}
/// Nested message and enum types in `MapValue`.
pub mod map_value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entry {
#[prost(message, optional, tag = "1")]
pub key: ::core::option::Option<super::Value>,
#[prost(message, optional, tag = "2")]
pub value: ::core::option::Option<super::Value>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvalState {
#[prost(message, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<ExprValue>,
#[prost(message, repeated, tag = "3")]
pub results: ::prost::alloc::vec::Vec<eval_state::Result>,
}
/// Nested message and enum types in `EvalState`.
pub mod eval_state {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Result {
#[prost(message, optional, tag = "1")]
pub expr: ::core::option::Option<super::IdRef>,
#[prost(int32, tag = "2")]
pub value: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExprValue {
#[prost(oneof = "expr_value::Kind", tags = "1, 2, 3")]
pub kind: ::core::option::Option<expr_value::Kind>,
}
/// Nested message and enum types in `ExprValue`.
pub mod expr_value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(message, tag = "1")]
Value(super::Value),
#[prost(message, tag = "2")]
Error(super::ErrorSet),
#[prost(message, tag = "3")]
Unknown(super::UnknownSet),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorSet {
#[prost(message, repeated, tag = "1")]
pub errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnknownSet {
#[prost(message, repeated, tag = "1")]
pub exprs: ::prost::alloc::vec::Vec<IdRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdRef {
#[prost(int32, tag = "1")]
pub id: i32,
}
