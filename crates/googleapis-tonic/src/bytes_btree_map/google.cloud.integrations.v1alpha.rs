// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Coordinate {
#[prost(int32, tag = "1")]
pub x: i32,
#[prost(int32, tag = "2")]
pub y: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueType {
#[prost(oneof = "value_type::Value", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
pub value: ::core::option::Option<value_type::Value>,
}
/// Nested message and enum types in `ValueType`.
pub mod value_type {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(string, tag = "1")]
StringValue(::prost::alloc::string::String),
#[prost(int64, tag = "2")]
IntValue(i64),
#[prost(double, tag = "3")]
DoubleValue(f64),
#[prost(bool, tag = "4")]
BooleanValue(bool),
#[prost(message, tag = "5")]
StringArray(super::StringParameterArray),
#[prost(message, tag = "6")]
IntArray(super::IntParameterArray),
#[prost(message, tag = "7")]
DoubleArray(super::DoubleParameterArray),
#[prost(message, tag = "8")]
BooleanArray(super::BooleanParameterArray),
#[prost(string, tag = "9")]
JsonValue(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringParameterArray {
#[prost(string, repeated, tag = "1")]
pub string_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntParameterArray {
#[prost(int64, repeated, tag = "1")]
pub int_values: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleParameterArray {
#[prost(double, repeated, tag = "1")]
pub double_values: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BooleanParameterArray {
#[prost(bool, repeated, tag = "1")]
pub boolean_values: ::prost::alloc::vec::Vec<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventParameter {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub value: ::core::option::Option<ValueType>,
#[prost(bool, tag = "3")]
pub masked: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonValidationOption {
Unspecified = 0,
Skip = 1,
PreExecution = 2,
PostExecution = 3,
PrePostExecution = 4,
}
impl JsonValidationOption {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JsonValidationOption::Unspecified => "JSON_VALIDATION_OPTION_UNSPECIFIED",
JsonValidationOption::Skip => "SKIP",
JsonValidationOption::PreExecution => "PRE_EXECUTION",
JsonValidationOption::PostExecution => "POST_EXECUTION",
JsonValidationOption::PrePostExecution => "PRE_POST_EXECUTION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JSON_VALIDATION_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
"SKIP" => Some(Self::Skip),
"PRE_EXECUTION" => Some(Self::PreExecution),
"POST_EXECUTION" => Some(Self::PostExecution),
"PRE_POST_EXECUTION" => Some(Self::PrePostExecution),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskConfig {
#[prost(string, tag = "1")]
pub task: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub task_id: ::prost::alloc::string::String,
#[prost(btree_map = "string, message", tag = "3")]
pub parameters: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, EventParameter>,
#[prost(message, optional, tag = "4")]
pub failure_policy: ::core::option::Option<FailurePolicy>,
#[prost(message, optional, tag = "5")]
pub synchronous_call_failure_policy: ::core::option::Option<FailurePolicy>,
#[prost(message, repeated, tag = "6")]
pub next_tasks: ::prost::alloc::vec::Vec<NextTask>,
#[prost(enumeration = "task_config::NextTasksExecutionPolicy", tag = "7")]
pub next_tasks_execution_policy: i32,
#[prost(enumeration = "task_config::TaskExecutionStrategy", tag = "8")]
pub task_execution_strategy: i32,
#[prost(string, tag = "9")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "10")]
pub success_policy: ::core::option::Option<SuccessPolicy>,
#[prost(enumeration = "JsonValidationOption", tag = "11")]
pub json_validation_option: i32,
#[prost(string, tag = "12")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "13")]
pub task_template: ::prost::alloc::string::String,
#[prost(string, tag = "17")]
pub error_catcher_id: ::prost::alloc::string::String,
#[prost(enumeration = "task_config::ExternalTaskType", tag = "15")]
pub external_task_type: i32,
#[prost(message, optional, tag = "16")]
pub position: ::core::option::Option<Coordinate>,
}
/// Nested message and enum types in `TaskConfig`.
pub mod task_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NextTasksExecutionPolicy {
Unspecified = 0,
RunAllMatch = 1,
RunFirstMatch = 2,
}
impl NextTasksExecutionPolicy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
NextTasksExecutionPolicy::Unspecified => "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED",
NextTasksExecutionPolicy::RunAllMatch => "RUN_ALL_MATCH",
NextTasksExecutionPolicy::RunFirstMatch => "RUN_FIRST_MATCH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
"RUN_ALL_MATCH" => Some(Self::RunAllMatch),
"RUN_FIRST_MATCH" => Some(Self::RunFirstMatch),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskExecutionStrategy {
Unspecified = 0,
WhenAllSucceed = 1,
WhenAnySucceed = 2,
WhenAllTasksAndConditionsSucceed = 3,
}
impl TaskExecutionStrategy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TaskExecutionStrategy::Unspecified => "TASK_EXECUTION_STRATEGY_UNSPECIFIED",
TaskExecutionStrategy::WhenAllSucceed => "WHEN_ALL_SUCCEED",
TaskExecutionStrategy::WhenAnySucceed => "WHEN_ANY_SUCCEED",
TaskExecutionStrategy::WhenAllTasksAndConditionsSucceed => "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TASK_EXECUTION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
"WHEN_ALL_SUCCEED" => Some(Self::WhenAllSucceed),
"WHEN_ANY_SUCCEED" => Some(Self::WhenAnySucceed),
"WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED" => Some(Self::WhenAllTasksAndConditionsSucceed),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExternalTaskType {
Unspecified = 0,
NormalTask = 1,
ErrorTask = 2,
}
impl ExternalTaskType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ExternalTaskType::Unspecified => "EXTERNAL_TASK_TYPE_UNSPECIFIED",
ExternalTaskType::NormalTask => "NORMAL_TASK",
ExternalTaskType::ErrorTask => "ERROR_TASK",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EXTERNAL_TASK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"NORMAL_TASK" => Some(Self::NormalTask),
"ERROR_TASK" => Some(Self::ErrorTask),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SuccessPolicy {
#[prost(enumeration = "success_policy::FinalState", tag = "1")]
pub final_state: i32,
}
/// Nested message and enum types in `SuccessPolicy`.
pub mod success_policy {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FinalState {
Unspecified = 0,
Succeeded = 1,
Suspended = 2,
}
impl FinalState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FinalState::Unspecified => "FINAL_STATE_UNSPECIFIED",
FinalState::Succeeded => "SUCCEEDED",
FinalState::Suspended => "SUSPENDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FINAL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"SUCCEEDED" => Some(Self::Succeeded),
"SUSPENDED" => Some(Self::Suspended),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailurePolicy {
#[prost(enumeration = "failure_policy::RetryStrategy", tag = "1")]
pub retry_strategy: i32,
#[prost(int32, tag = "2")]
pub max_retries: i32,
#[prost(message, optional, tag = "3")]
pub interval_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `FailurePolicy`.
pub mod failure_policy {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RetryStrategy {
Unspecified = 0,
Ignore = 1,
None = 2,
Fatal = 3,
FixedInterval = 4,
LinearBackoff = 5,
ExponentialBackoff = 6,
RestartIntegrationWithBackoff = 7,
}
impl RetryStrategy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RetryStrategy::Unspecified => "RETRY_STRATEGY_UNSPECIFIED",
RetryStrategy::Ignore => "IGNORE",
RetryStrategy::None => "NONE",
RetryStrategy::Fatal => "FATAL",
RetryStrategy::FixedInterval => "FIXED_INTERVAL",
RetryStrategy::LinearBackoff => "LINEAR_BACKOFF",
RetryStrategy::ExponentialBackoff => "EXPONENTIAL_BACKOFF",
RetryStrategy::RestartIntegrationWithBackoff => "RESTART_INTEGRATION_WITH_BACKOFF",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RETRY_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
"IGNORE" => Some(Self::Ignore),
"NONE" => Some(Self::None),
"FATAL" => Some(Self::Fatal),
"FIXED_INTERVAL" => Some(Self::FixedInterval),
"LINEAR_BACKOFF" => Some(Self::LinearBackoff),
"EXPONENTIAL_BACKOFF" => Some(Self::ExponentialBackoff),
"RESTART_INTEGRATION_WITH_BACKOFF" => Some(Self::RestartIntegrationWithBackoff),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NextTask {
#[prost(string, tag = "1")]
pub task_config_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub task_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub condition: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub description: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Product {
Unspecified = 0,
Ip = 1,
Apigee = 2,
Security = 3,
}
impl Product {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Product::Unspecified => "PRODUCT_UNSPECIFIED",
Product::Ip => "IP",
Product::Apigee => "APIGEE",
Product::Security => "SECURITY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PRODUCT_UNSPECIFIED" => Some(Self::Unspecified),
"IP" => Some(Self::Ip),
"APIGEE" => Some(Self::Apigee),
"SECURITY" => Some(Self::Security),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CloudLoggingDetails {
#[prost(enumeration = "cloud_logging_details::CloudLoggingSeverity", optional, tag = "1")]
pub cloud_logging_severity: ::core::option::Option<i32>,
#[prost(bool, optional, tag = "2")]
pub enable_cloud_logging: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CloudLoggingDetails`.
pub mod cloud_logging_details {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudLoggingSeverity {
Unspecified = 0,
Info = 2,
Error = 3,
Warning = 4,
}
impl CloudLoggingSeverity {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
CloudLoggingSeverity::Unspecified => "CLOUD_LOGGING_SEVERITY_UNSPECIFIED",
CloudLoggingSeverity::Info => "INFO",
CloudLoggingSeverity::Error => "ERROR",
CloudLoggingSeverity::Warning => "WARNING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CLOUD_LOGGING_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
"INFO" => Some(Self::Info),
"ERROR" => Some(Self::Error),
"WARNING" => Some(Self::Warning),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IntegrationState {
Unspecified = 0,
Draft = 1,
Active = 2,
Archived = 3,
Snapshot = 4,
}
impl IntegrationState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
IntegrationState::Unspecified => "INTEGRATION_STATE_UNSPECIFIED",
IntegrationState::Draft => "DRAFT",
IntegrationState::Active => "ACTIVE",
IntegrationState::Archived => "ARCHIVED",
IntegrationState::Snapshot => "SNAPSHOT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INTEGRATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"DRAFT" => Some(Self::Draft),
"ACTIVE" => Some(Self::Active),
"ARCHIVED" => Some(Self::Archived),
"SNAPSHOT" => Some(Self::Snapshot),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionInfo {
#[prost(string, tag = "2")]
pub integration: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub trigger_id: ::prost::alloc::string::String,
#[prost(btree_map = "string, message", tag = "6")]
pub request_params: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, EventParameter>,
#[prost(btree_map = "string, message", tag = "7")]
pub response_params: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, EventParameter>,
#[prost(message, repeated, tag = "10")]
pub errors: ::prost::alloc::vec::Vec<ErrorDetail>,
#[prost(message, repeated, tag = "13")]
pub task_configs: ::prost::alloc::vec::Vec<TaskConfig>,
#[prost(string, tag = "14")]
pub integration_version_number: ::prost::alloc::string::String,
#[prost(string, tag = "15")]
pub execution_id: ::prost::alloc::string::String,
#[prost(enumeration = "IntegrationState", tag = "16")]
pub integration_version_state: i32,
#[prost(bool, tag = "17")]
pub enable_database_persistence: bool,
#[prost(message, optional, tag = "18")]
pub cloud_logging_details: ::core::option::Option<CloudLoggingDetails>,
#[prost(message, optional, tag = "19")]
pub integration_execution_details: ::core::option::Option<IntegrationExecutionDetails>,
#[prost(enumeration = "ExecutionType", tag = "20")]
pub execution_type: i32,
#[prost(enumeration = "execution_info::ExecutionMethod", tag = "21")]
pub execution_method: i32,
#[prost(int64, tag = "22")]
pub integration_snapshot_number: i64,
}
/// Nested message and enum types in `ExecutionInfo`.
pub mod execution_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionMethod {
Unspecified = 0,
Post = 1,
Schedule = 2,
PostToQueue = 3,
}
impl ExecutionMethod {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ExecutionMethod::Unspecified => "EXECUTION_METHOD_UNSPECIFIED",
ExecutionMethod::Post => "POST",
ExecutionMethod::Schedule => "SCHEDULE",
ExecutionMethod::PostToQueue => "POST_TO_QUEUE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EXECUTION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
"POST" => Some(Self::Post),
"SCHEDULE" => Some(Self::Schedule),
"POST_TO_QUEUE" => Some(Self::PostToQueue),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegrationExecutionDetails {
#[prost(enumeration = "integration_execution_details::IntegrationExecutionState", tag = "1")]
pub integration_execution_state: i32,
#[prost(message, repeated, tag = "2")]
pub integration_execution_snapshot: ::prost::alloc::vec::Vec<IntegrationExecutionSnapshot>,
#[prost(message, repeated, tag = "3")]
pub execution_attempt_stats: ::prost::alloc::vec::Vec<AttemptStats>,
#[prost(message, optional, tag = "4")]
pub next_execution_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int32, tag = "5")]
pub execution_retries_count: i32,
}
/// Nested message and enum types in `IntegrationExecutionDetails`.
pub mod integration_execution_details {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IntegrationExecutionState {
Unspecified = 0,
OnHold = 1,
InProcess = 2,
Succeeded = 3,
Failed = 4,
Cancelled = 5,
RetryOnHold = 6,
Suspended = 7,
}
impl IntegrationExecutionState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
IntegrationExecutionState::Unspecified => "INTEGRATION_EXECUTION_STATE_UNSPECIFIED",
IntegrationExecutionState::OnHold => "ON_HOLD",
IntegrationExecutionState::InProcess => "IN_PROCESS",
IntegrationExecutionState::Succeeded => "SUCCEEDED",
IntegrationExecutionState::Failed => "FAILED",
IntegrationExecutionState::Cancelled => "CANCELLED",
IntegrationExecutionState::RetryOnHold => "RETRY_ON_HOLD",
IntegrationExecutionState::Suspended => "SUSPENDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INTEGRATION_EXECUTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ON_HOLD" => Some(Self::OnHold),
"IN_PROCESS" => Some(Self::InProcess),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"CANCELLED" => Some(Self::Cancelled),
"RETRY_ON_HOLD" => Some(Self::RetryOnHold),
"SUSPENDED" => Some(Self::Suspended),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegrationExecutionSnapshot {
#[prost(string, tag = "1")]
pub checkpoint_task_number: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub snapshot_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub integration_execution_snapshot_metadata: ::core::option::Option<integration_execution_snapshot::IntegrationExecutionSnapshotMetadata>,
#[prost(message, repeated, tag = "4")]
pub task_execution_details: ::prost::alloc::vec::Vec<TaskExecutionDetails>,
#[prost(message, repeated, tag = "5")]
pub condition_results: ::prost::alloc::vec::Vec<ConditionResult>,
#[prost(btree_map = "string, message", tag = "6")]
pub execution_params: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, EventParameter>,
}
/// Nested message and enum types in `IntegrationExecutionSnapshot`.
pub mod integration_execution_snapshot {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegrationExecutionSnapshotMetadata {
#[prost(string, tag = "1")]
pub task_number: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub task: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub integration_execution_attempt_num: i32,
#[prost(int32, tag = "4")]
pub task_attempt_num: i32,
#[prost(string, tag = "5")]
pub task_label: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "6")]
pub ancestor_task_numbers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "7")]
pub ancestor_iteration_numbers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "8")]
pub integration: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskExecutionDetails {
#[prost(string, tag = "1")]
pub task_number: ::prost::alloc::string::String,
#[prost(enumeration = "task_execution_details::TaskExecutionState", tag = "2")]
pub task_execution_state: i32,
#[prost(message, repeated, tag = "3")]
pub task_attempt_stats: ::prost::alloc::vec::Vec<AttemptStats>,
}
/// Nested message and enum types in `TaskExecutionDetails`.
pub mod task_execution_details {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskExecutionState {
Unspecified = 0,
PendingExecution = 1,
InProcess = 2,
Succeed = 3,
Failed = 4,
Fatal = 5,
RetryOnHold = 6,
Skipped = 7,
Cancelled = 8,
PendingRollback = 9,
RollbackInProcess = 10,
Rolledback = 11,
Suspended = 12,
}
impl TaskExecutionState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TaskExecutionState::Unspecified => "TASK_EXECUTION_STATE_UNSPECIFIED",
TaskExecutionState::PendingExecution => "PENDING_EXECUTION",
TaskExecutionState::InProcess => "IN_PROCESS",
TaskExecutionState::Succeed => "SUCCEED",
TaskExecutionState::Failed => "FAILED",
TaskExecutionState::Fatal => "FATAL",
TaskExecutionState::RetryOnHold => "RETRY_ON_HOLD",
TaskExecutionState::Skipped => "SKIPPED",
TaskExecutionState::Cancelled => "CANCELLED",
TaskExecutionState::PendingRollback => "PENDING_ROLLBACK",
TaskExecutionState::RollbackInProcess => "ROLLBACK_IN_PROCESS",
TaskExecutionState::Rolledback => "ROLLEDBACK",
TaskExecutionState::Suspended => "SUSPENDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TASK_EXECUTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING_EXECUTION" => Some(Self::PendingExecution),
"IN_PROCESS" => Some(Self::InProcess),
"SUCCEED" => Some(Self::Succeed),
"FAILED" => Some(Self::Failed),
"FATAL" => Some(Self::Fatal),
"RETRY_ON_HOLD" => Some(Self::RetryOnHold),
"SKIPPED" => Some(Self::Skipped),
"CANCELLED" => Some(Self::Cancelled),
"PENDING_ROLLBACK" => Some(Self::PendingRollback),
"ROLLBACK_IN_PROCESS" => Some(Self::RollbackInProcess),
"ROLLEDBACK" => Some(Self::Rolledback),
"SUSPENDED" => Some(Self::Suspended),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttemptStats {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetail {
#[prost(string, tag = "1")]
pub error_message: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub task_number: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionResult {
#[prost(string, tag = "1")]
pub current_task_number: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub next_task_number: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub result: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionType {
Unspecified = 0,
IntegrationVersion = 1,
TestCase = 2,
}
impl ExecutionType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ExecutionType::Unspecified => "EXECUTION_TYPE_UNSPECIFIED",
ExecutionType::IntegrationVersion => "INTEGRATION_VERSION",
ExecutionType::TestCase => "TEST_CASE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EXECUTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"INTEGRATION_VERSION" => Some(Self::IntegrationVersion),
"TEST_CASE" => Some(Self::TestCase),
_ => None,
}
}
}
