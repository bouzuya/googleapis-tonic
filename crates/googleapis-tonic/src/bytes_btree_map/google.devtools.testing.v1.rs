// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceIpBlock {
    #[prost(string, tag = "1")]
    pub block: ::prost::alloc::string::String,
    #[prost(enumeration = "DeviceForm", tag = "2")]
    pub form: i32,
    #[prost(message, optional, tag = "3")]
    pub added_date: ::core::option::Option<super::super::super::r#type::Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTestEnvironmentCatalogRequest {
    #[prost(
        enumeration = "get_test_environment_catalog_request::EnvironmentType",
        tag = "1"
    )]
    pub environment_type: i32,
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GetTestEnvironmentCatalogRequest`.
pub mod get_test_environment_catalog_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EnvironmentType {
        Unspecified = 0,
        Android = 1,
        Ios = 3,
        NetworkConfiguration = 4,
        ProvidedSoftware = 5,
        DeviceIpBlocks = 6,
    }
    impl EnvironmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EnvironmentType::Unspecified => "ENVIRONMENT_TYPE_UNSPECIFIED",
                EnvironmentType::Android => "ANDROID",
                EnvironmentType::Ios => "IOS",
                EnvironmentType::NetworkConfiguration => "NETWORK_CONFIGURATION",
                EnvironmentType::ProvidedSoftware => "PROVIDED_SOFTWARE",
                EnvironmentType::DeviceIpBlocks => "DEVICE_IP_BLOCKS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENVIRONMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ANDROID" => Some(Self::Android),
                "IOS" => Some(Self::Ios),
                "NETWORK_CONFIGURATION" => Some(Self::NetworkConfiguration),
                "PROVIDED_SOFTWARE" => Some(Self::ProvidedSoftware),
                "DEVICE_IP_BLOCKS" => Some(Self::DeviceIpBlocks),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestEnvironmentCatalog {
    #[prost(
        oneof = "test_environment_catalog::EnvironmentCatalog",
        tags = "1, 3, 4, 5, 6"
    )]
    pub environment_catalog: ::core::option::Option<test_environment_catalog::EnvironmentCatalog>,
}
/// Nested message and enum types in `TestEnvironmentCatalog`.
pub mod test_environment_catalog {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EnvironmentCatalog {
        #[prost(message, tag = "1")]
        AndroidDeviceCatalog(super::AndroidDeviceCatalog),
        #[prost(message, tag = "3")]
        IosDeviceCatalog(super::IosDeviceCatalog),
        #[prost(message, tag = "4")]
        NetworkConfigurationCatalog(super::NetworkConfigurationCatalog),
        #[prost(message, tag = "5")]
        SoftwareCatalog(super::ProvidedSoftwareCatalog),
        #[prost(message, tag = "6")]
        DeviceIpBlockCatalog(super::DeviceIpBlockCatalog),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceIpBlockCatalog {
    #[prost(message, repeated, tag = "1")]
    pub ip_blocks: ::prost::alloc::vec::Vec<DeviceIpBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidDeviceCatalog {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<AndroidModel>,
    #[prost(message, repeated, tag = "2")]
    pub versions: ::prost::alloc::vec::Vec<AndroidVersion>,
    #[prost(message, optional, tag = "3")]
    pub runtime_configuration: ::core::option::Option<AndroidRuntimeConfiguration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidRuntimeConfiguration {
    #[prost(message, repeated, tag = "1")]
    pub locales: ::prost::alloc::vec::Vec<Locale>,
    #[prost(message, repeated, tag = "2")]
    pub orientations: ::prost::alloc::vec::Vec<Orientation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidModel {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub manufacturer: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub brand: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub codename: ::prost::alloc::string::String,
    #[prost(enumeration = "DeviceForm", tag = "4")]
    pub form: i32,
    #[prost(enumeration = "DeviceFormFactor", tag = "16")]
    pub form_factor: i32,
    #[prost(message, repeated, tag = "21")]
    pub per_version_info: ::prost::alloc::vec::Vec<PerAndroidVersionInfo>,
    #[prost(int32, tag = "5")]
    pub screen_x: i32,
    #[prost(int32, tag = "6")]
    pub screen_y: i32,
    #[prost(int32, tag = "12")]
    pub screen_density: i32,
    #[prost(bool, tag = "17")]
    pub low_fps_video_recording: bool,
    #[prost(string, repeated, tag = "7")]
    pub supported_version_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "11")]
    pub supported_abis: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "19")]
    pub thumbnail_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidVersion {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version_string: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub api_level: i32,
    #[prost(string, tag = "4")]
    pub code_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub release_date: ::core::option::Option<super::super::super::r#type::Date>,
    #[prost(message, optional, tag = "6")]
    pub distribution: ::core::option::Option<Distribution>,
    #[prost(string, repeated, tag = "7")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerAndroidVersionInfo {
    #[prost(string, tag = "1")]
    pub version_id: ::prost::alloc::string::String,
    #[prost(enumeration = "DeviceCapacity", tag = "2")]
    pub device_capacity: i32,
    #[prost(message, optional, tag = "3")]
    pub interactive_device_availability_estimate: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub direct_access_version_info: ::core::option::Option<DirectAccessVersionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectAccessVersionInfo {
    #[prost(bool, tag = "1")]
    pub direct_access_supported: bool,
    #[prost(string, tag = "2")]
    pub minimum_android_studio_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Distribution {
    #[prost(message, optional, tag = "1")]
    pub measurement_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(double, tag = "2")]
    pub market_share: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosDeviceCatalog {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<IosModel>,
    #[prost(message, repeated, tag = "2")]
    pub versions: ::prost::alloc::vec::Vec<IosVersion>,
    #[prost(message, repeated, tag = "4")]
    pub xcode_versions: ::prost::alloc::vec::Vec<XcodeVersion>,
    #[prost(message, optional, tag = "3")]
    pub runtime_configuration: ::core::option::Option<IosRuntimeConfiguration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosRuntimeConfiguration {
    #[prost(message, repeated, tag = "1")]
    pub locales: ::prost::alloc::vec::Vec<Locale>,
    #[prost(message, repeated, tag = "2")]
    pub orientations: ::prost::alloc::vec::Vec<Orientation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosModel {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub supported_version_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub device_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "7")]
    pub screen_x: i32,
    #[prost(int32, tag = "8")]
    pub screen_y: i32,
    #[prost(int32, tag = "9")]
    pub screen_density: i32,
    #[prost(enumeration = "DeviceFormFactor", tag = "6")]
    pub form_factor: i32,
    #[prost(message, repeated, tag = "14")]
    pub per_version_info: ::prost::alloc::vec::Vec<PerIosVersionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosVersion {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub major_version: i32,
    #[prost(int32, tag = "4")]
    pub minor_version: i32,
    #[prost(string, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub supported_xcode_version_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerIosVersionInfo {
    #[prost(string, tag = "1")]
    pub version_id: ::prost::alloc::string::String,
    #[prost(enumeration = "DeviceCapacity", tag = "2")]
    pub device_capacity: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Locale {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Orientation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XcodeVersion {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfigurationCatalog {
    #[prost(message, repeated, tag = "1")]
    pub configurations: ::prost::alloc::vec::Vec<NetworkConfiguration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfiguration {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub up_rule: ::core::option::Option<TrafficRule>,
    #[prost(message, optional, tag = "3")]
    pub down_rule: ::core::option::Option<TrafficRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrafficRule {
    #[prost(message, optional, tag = "1")]
    pub delay: ::core::option::Option<::prost_types::Duration>,
    #[prost(float, tag = "2")]
    pub packet_loss_ratio: f32,
    #[prost(float, tag = "3")]
    pub packet_duplication_ratio: f32,
    #[prost(float, tag = "4")]
    pub bandwidth: f32,
    #[prost(float, tag = "5")]
    pub burst: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvidedSoftwareCatalog {
    #[deprecated]
    #[prost(string, tag = "1")]
    pub orchestrator_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub androidx_orchestrator_version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceForm {
    Unspecified = 0,
    Virtual = 1,
    Physical = 2,
    Emulator = 3,
}
impl DeviceForm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DeviceForm::Unspecified => "DEVICE_FORM_UNSPECIFIED",
            DeviceForm::Virtual => "VIRTUAL",
            DeviceForm::Physical => "PHYSICAL",
            DeviceForm::Emulator => "EMULATOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEVICE_FORM_UNSPECIFIED" => Some(Self::Unspecified),
            "VIRTUAL" => Some(Self::Virtual),
            "PHYSICAL" => Some(Self::Physical),
            "EMULATOR" => Some(Self::Emulator),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceFormFactor {
    Unspecified = 0,
    Phone = 1,
    Tablet = 2,
    Wearable = 3,
}
impl DeviceFormFactor {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DeviceFormFactor::Unspecified => "DEVICE_FORM_FACTOR_UNSPECIFIED",
            DeviceFormFactor::Phone => "PHONE",
            DeviceFormFactor::Tablet => "TABLET",
            DeviceFormFactor::Wearable => "WEARABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEVICE_FORM_FACTOR_UNSPECIFIED" => Some(Self::Unspecified),
            "PHONE" => Some(Self::Phone),
            "TABLET" => Some(Self::Tablet),
            "WEARABLE" => Some(Self::Wearable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceCapacity {
    Unspecified = 0,
    High = 1,
    Medium = 2,
    Low = 3,
    None = 4,
}
impl DeviceCapacity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DeviceCapacity::Unspecified => "DEVICE_CAPACITY_UNSPECIFIED",
            DeviceCapacity::High => "DEVICE_CAPACITY_HIGH",
            DeviceCapacity::Medium => "DEVICE_CAPACITY_MEDIUM",
            DeviceCapacity::Low => "DEVICE_CAPACITY_LOW",
            DeviceCapacity::None => "DEVICE_CAPACITY_NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEVICE_CAPACITY_UNSPECIFIED" => Some(Self::Unspecified),
            "DEVICE_CAPACITY_HIGH" => Some(Self::High),
            "DEVICE_CAPACITY_MEDIUM" => Some(Self::Medium),
            "DEVICE_CAPACITY_LOW" => Some(Self::Low),
            "DEVICE_CAPACITY_NONE" => Some(Self::None),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod test_environment_discovery_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for discovering environments supported by the TestExecutionService.
    ///
    /// Over time the TestService may add or remove devices or configuration options
    /// (e.g., when new devices and APIs are released).  Clients should check here
    /// periodically to discover what options are supported.
    ///
    /// It defines the following resource model:
    ///
    /// - The API a collection of [TestEnvironmentCatalog]
    ///   [google.devtools.test.v1.TestEnvironmentCatalog] resources, named
    ///   `testEnvironmentCatalog/*`
    ///
    /// - Each TestEnvironmentCatalog resource describes a set of supported
    ///   environments.
    ///
    /// - An [AndroidDeviceCatalog][google.devtools.test.v1.AndroidDeviceCatalog]
    ///   describes supported Android devices. It contains lists of supported
    ///   [AndroidModels][google.devtools.test.v1.AndroidModel] and
    ///   [AndroidVersions][google.devtools.test.v1.AndroidVersion] along with a
    ///   [AndroidRuntimeConfiguration][google.devtools.test.v1.AndroidRuntimeConfiguration].
    ///   Each AndroidModel contains a list of Versions it supports. All
    ///   models support all locales and orientations described by the
    ///   AndroidRuntimeConfiguration
    ///
    /// - An [IosDeviceCatalog][google.devtools.test.v1.IosDeviceCatalog]
    ///   describes supported iOS devices. It contains lists of supported
    ///   [IosModels][google.devtools.test.v1.IosModel] and
    ///   [IosVersions][google.devtools.test.v1.IosVersion] along with a
    ///   [IosRuntimeConfiguration][google.devtools.test.v1.IosRuntimeConfiguration].
    ///   Each IosModel contains a list of Versions it supports. All
    ///   models support all locales and orientations described by the
    ///   IosRuntimeConfiguration.
    #[derive(Debug, Clone)]
    pub struct TestEnvironmentDiscoveryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TestEnvironmentDiscoveryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TestEnvironmentDiscoveryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            TestEnvironmentDiscoveryServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets the catalog of supported test environments.
        ///
        /// May return any of the following canonical error codes:
        ///
        /// - INVALID_ARGUMENT - if the request is malformed
        /// - NOT_FOUND - if the environment type does not exist
        /// - INTERNAL - if an internal error occurred
        pub async fn get_test_environment_catalog(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTestEnvironmentCatalogRequest>,
        ) -> std::result::Result<tonic::Response<super::TestEnvironmentCatalog>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.devtools.testing.v1.TestEnvironmentDiscoveryService/GetTestEnvironmentCatalog");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.TestEnvironmentDiscoveryService",
                "GetTestEnvironmentCatalog",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestMatrix {
    #[prost(string, tag = "1")]
    pub test_matrix_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub client_info: ::core::option::Option<ClientInfo>,
    #[prost(message, optional, tag = "3")]
    pub test_specification: ::core::option::Option<TestSpecification>,
    #[prost(message, optional, tag = "4")]
    pub environment_matrix: ::core::option::Option<EnvironmentMatrix>,
    #[prost(message, repeated, tag = "5")]
    pub test_executions: ::prost::alloc::vec::Vec<TestExecution>,
    #[prost(message, optional, tag = "6")]
    pub result_storage: ::core::option::Option<ResultStorage>,
    #[prost(enumeration = "TestState", tag = "8")]
    pub state: i32,
    #[prost(message, optional, tag = "9")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "InvalidMatrixDetails", tag = "11")]
    pub invalid_matrix_details: i32,
    #[prost(message, repeated, tag = "22")]
    pub extended_invalid_matrix_details: ::prost::alloc::vec::Vec<MatrixErrorDetail>,
    #[prost(int32, tag = "13")]
    pub flaky_test_attempts: i32,
    #[prost(enumeration = "OutcomeSummary", tag = "14")]
    pub outcome_summary: i32,
    #[prost(bool, tag = "17")]
    pub fail_fast: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatrixErrorDetail {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestExecution {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub matrix_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub test_specification: ::core::option::Option<TestSpecification>,
    #[prost(message, optional, tag = "12")]
    pub shard: ::core::option::Option<Shard>,
    #[prost(message, optional, tag = "4")]
    pub environment: ::core::option::Option<Environment>,
    #[prost(enumeration = "TestState", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "11")]
    pub tool_results_step: ::core::option::Option<ToolResultsStep>,
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub test_details: ::core::option::Option<TestDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestSpecification {
    #[prost(message, optional, tag = "1")]
    pub test_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag = "10")]
    pub disable_video_recording: bool,
    #[prost(bool, tag = "11")]
    pub disable_performance_metrics: bool,
    #[prost(oneof = "test_specification::Setup", tags = "6, 14")]
    pub setup: ::core::option::Option<test_specification::Setup>,
    #[prost(oneof = "test_specification::Test", tags = "2, 3, 9, 13, 15, 17")]
    pub test: ::core::option::Option<test_specification::Test>,
}
/// Nested message and enum types in `TestSpecification`.
pub mod test_specification {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Setup {
        #[prost(message, tag = "6")]
        TestSetup(super::TestSetup),
        #[prost(message, tag = "14")]
        IosTestSetup(super::IosTestSetup),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Test {
        #[prost(message, tag = "2")]
        AndroidInstrumentationTest(super::AndroidInstrumentationTest),
        #[prost(message, tag = "3")]
        AndroidRoboTest(super::AndroidRoboTest),
        #[prost(message, tag = "9")]
        AndroidTestLoop(super::AndroidTestLoop),
        #[prost(message, tag = "13")]
        IosXcTest(super::IosXcTest),
        #[prost(message, tag = "15")]
        IosTestLoop(super::IosTestLoop),
        #[prost(message, tag = "17")]
        IosRoboTest(super::IosRoboTest),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystraceSetup {
    #[deprecated]
    #[prost(int32, tag = "1")]
    pub duration_seconds: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestSetup {
    #[prost(message, repeated, tag = "1")]
    pub files_to_push: ::prost::alloc::vec::Vec<DeviceFile>,
    #[prost(string, repeated, tag = "2")]
    pub directories_to_pull: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "29")]
    pub initial_setup_apks: ::prost::alloc::vec::Vec<Apk>,
    #[prost(message, repeated, tag = "3")]
    pub additional_apks: ::prost::alloc::vec::Vec<Apk>,
    #[prost(message, optional, tag = "4")]
    pub account: ::core::option::Option<Account>,
    #[prost(string, tag = "5")]
    pub network_profile: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub environment_variables: ::prost::alloc::vec::Vec<EnvironmentVariable>,
    #[deprecated]
    #[prost(message, optional, tag = "9")]
    pub systrace: ::core::option::Option<SystraceSetup>,
    #[prost(bool, tag = "23")]
    pub dont_autogrant_permissions: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosTestSetup {
    #[prost(string, tag = "1")]
    pub network_profile: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub additional_ipas: ::prost::alloc::vec::Vec<FileReference>,
    #[prost(message, repeated, tag = "3")]
    pub push_files: ::prost::alloc::vec::Vec<IosDeviceFile>,
    #[prost(message, repeated, tag = "4")]
    pub pull_directories: ::prost::alloc::vec::Vec<IosDeviceFile>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentVariable {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(oneof = "account::AccountType", tags = "1")]
    pub account_type: ::core::option::Option<account::AccountType>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum AccountType {
        #[prost(message, tag = "1")]
        GoogleAuto(super::GoogleAuto),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleAuto {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Apk {
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<FileReference>,
    #[prost(string, tag = "2")]
    pub package_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppBundle {
    #[prost(oneof = "app_bundle::Bundle", tags = "1")]
    pub bundle: ::core::option::Option<app_bundle::Bundle>,
}
/// Nested message and enum types in `AppBundle`.
pub mod app_bundle {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Bundle {
        #[prost(message, tag = "1")]
        BundleLocation(super::FileReference),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceFile {
    #[prost(oneof = "device_file::DeviceFile", tags = "1, 2")]
    pub device_file: ::core::option::Option<device_file::DeviceFile>,
}
/// Nested message and enum types in `DeviceFile`.
pub mod device_file {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DeviceFile {
        #[prost(message, tag = "1")]
        ObbFile(super::ObbFile),
        #[prost(message, tag = "2")]
        RegularFile(super::RegularFile),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObbFile {
    #[prost(string, tag = "1")]
    pub obb_file_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub obb: ::core::option::Option<FileReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegularFile {
    #[prost(message, optional, tag = "1")]
    pub content: ::core::option::Option<FileReference>,
    #[prost(string, tag = "2")]
    pub device_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosDeviceFile {
    #[prost(message, optional, tag = "1")]
    pub content: ::core::option::Option<FileReference>,
    #[prost(string, tag = "2")]
    pub bundle_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub device_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidTestLoop {
    #[prost(string, tag = "2")]
    pub app_package_id: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "3")]
    pub scenarios: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "4")]
    pub scenario_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "android_test_loop::AppUnderTest", tags = "1, 5")]
    pub app_under_test: ::core::option::Option<android_test_loop::AppUnderTest>,
}
/// Nested message and enum types in `AndroidTestLoop`.
pub mod android_test_loop {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AppUnderTest {
        #[prost(message, tag = "1")]
        AppApk(super::FileReference),
        #[prost(message, tag = "5")]
        AppBundle(super::AppBundle),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosXcTest {
    #[prost(message, optional, tag = "1")]
    pub tests_zip: ::core::option::Option<FileReference>,
    #[prost(message, optional, tag = "2")]
    pub xctestrun: ::core::option::Option<FileReference>,
    #[prost(string, tag = "3")]
    pub xcode_version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub app_bundle_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub test_special_entitlements: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosTestLoop {
    #[prost(message, optional, tag = "1")]
    pub app_ipa: ::core::option::Option<FileReference>,
    #[prost(int32, repeated, tag = "2")]
    pub scenarios: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "3")]
    pub app_bundle_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosRoboTest {
    #[prost(message, optional, tag = "1")]
    pub app_ipa: ::core::option::Option<FileReference>,
    #[prost(string, tag = "4")]
    pub app_bundle_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub robo_script: ::core::option::Option<FileReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidInstrumentationTest {
    #[prost(message, optional, tag = "2")]
    pub test_apk: ::core::option::Option<FileReference>,
    #[prost(string, tag = "3")]
    pub app_package_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub test_package_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub test_runner_class: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub test_targets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "OrchestratorOption", tag = "7")]
    pub orchestrator_option: i32,
    #[prost(message, optional, tag = "9")]
    pub sharding_option: ::core::option::Option<ShardingOption>,
    #[prost(oneof = "android_instrumentation_test::AppUnderTest", tags = "1, 8")]
    pub app_under_test: ::core::option::Option<android_instrumentation_test::AppUnderTest>,
}
/// Nested message and enum types in `AndroidInstrumentationTest`.
pub mod android_instrumentation_test {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AppUnderTest {
        #[prost(message, tag = "1")]
        AppApk(super::FileReference),
        #[prost(message, tag = "8")]
        AppBundle(super::AppBundle),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidRoboTest {
    #[prost(string, tag = "2")]
    pub app_package_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub app_initial_activity: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(int32, tag = "7")]
    pub max_depth: i32,
    #[deprecated]
    #[prost(int32, tag = "8")]
    pub max_steps: i32,
    #[prost(message, repeated, tag = "11")]
    pub robo_directives: ::prost::alloc::vec::Vec<RoboDirective>,
    #[prost(enumeration = "RoboMode", tag = "14")]
    pub robo_mode: i32,
    #[prost(message, optional, tag = "13")]
    pub robo_script: ::core::option::Option<FileReference>,
    #[prost(message, repeated, tag = "15")]
    pub starting_intents: ::prost::alloc::vec::Vec<RoboStartingIntent>,
    #[prost(oneof = "android_robo_test::AppUnderTest", tags = "1, 16")]
    pub app_under_test: ::core::option::Option<android_robo_test::AppUnderTest>,
}
/// Nested message and enum types in `AndroidRoboTest`.
pub mod android_robo_test {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AppUnderTest {
        #[prost(message, tag = "1")]
        AppApk(super::FileReference),
        #[prost(message, tag = "16")]
        AppBundle(super::AppBundle),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoboDirective {
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub input_text: ::prost::alloc::string::String,
    #[prost(enumeration = "RoboActionType", tag = "3")]
    pub action_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoboStartingIntent {
    #[prost(message, optional, tag = "3")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(oneof = "robo_starting_intent::StartingIntent", tags = "1, 2, 4")]
    pub starting_intent: ::core::option::Option<robo_starting_intent::StartingIntent>,
}
/// Nested message and enum types in `RoboStartingIntent`.
pub mod robo_starting_intent {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StartingIntent {
        #[prost(message, tag = "1")]
        LauncherActivity(super::LauncherActivityIntent),
        #[prost(message, tag = "2")]
        StartActivity(super::StartActivityIntent),
        #[prost(message, tag = "4")]
        NoActivity(super::NoActivityIntent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LauncherActivityIntent {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartActivityIntent {
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoActivityIntent {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentMatrix {
    #[prost(oneof = "environment_matrix::EnvironmentMatrix", tags = "1, 2, 3")]
    pub environment_matrix: ::core::option::Option<environment_matrix::EnvironmentMatrix>,
}
/// Nested message and enum types in `EnvironmentMatrix`.
pub mod environment_matrix {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EnvironmentMatrix {
        #[prost(message, tag = "1")]
        AndroidMatrix(super::AndroidMatrix),
        #[prost(message, tag = "2")]
        AndroidDeviceList(super::AndroidDeviceList),
        #[prost(message, tag = "3")]
        IosDeviceList(super::IosDeviceList),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidDeviceList {
    #[prost(message, repeated, tag = "1")]
    pub android_devices: ::prost::alloc::vec::Vec<AndroidDevice>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosDeviceList {
    #[prost(message, repeated, tag = "1")]
    pub ios_devices: ::prost::alloc::vec::Vec<IosDevice>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidMatrix {
    #[prost(string, repeated, tag = "1")]
    pub android_model_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub android_version_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub locales: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub orientations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub client_info_details: ::prost::alloc::vec::Vec<ClientInfoDetail>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientInfoDetail {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultStorage {
    #[prost(message, optional, tag = "1")]
    pub google_cloud_storage: ::core::option::Option<GoogleCloudStorage>,
    #[prost(message, optional, tag = "5")]
    pub tool_results_history: ::core::option::Option<ToolResultsHistory>,
    #[prost(message, optional, tag = "6")]
    pub tool_results_execution: ::core::option::Option<ToolResultsExecution>,
    #[prost(string, tag = "7")]
    pub results_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolResultsHistory {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub history_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolResultsExecution {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub history_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolResultsStep {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub history_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub step_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleCloudStorage {
    #[prost(string, tag = "1")]
    pub gcs_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileReference {
    #[prost(oneof = "file_reference::File", tags = "1")]
    pub file: ::core::option::Option<file_reference::File>,
}
/// Nested message and enum types in `FileReference`.
pub mod file_reference {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum File {
        #[prost(string, tag = "1")]
        GcsPath(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Environment {
    #[prost(oneof = "environment::Environment", tags = "1, 2")]
    pub environment: ::core::option::Option<environment::Environment>,
}
/// Nested message and enum types in `Environment`.
pub mod environment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Environment {
        #[prost(message, tag = "1")]
        AndroidDevice(super::AndroidDevice),
        #[prost(message, tag = "2")]
        IosDevice(super::IosDevice),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidDevice {
    #[prost(string, tag = "1")]
    pub android_model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub android_version_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub locale: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub orientation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosDevice {
    #[prost(string, tag = "1")]
    pub ios_model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ios_version_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub locale: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub orientation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestDetails {
    #[prost(string, repeated, tag = "3")]
    pub progress_messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvalidRequestDetail {
    #[prost(enumeration = "invalid_request_detail::Reason", tag = "1")]
    pub reason: i32,
}
/// Nested message and enum types in `InvalidRequestDetail`.
pub mod invalid_request_detail {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Reason {
        Unspecified = 0,
        RequestInvalid = 1,
        ResourceTooBig = 2,
        ResourceNotFound = 3,
        Unsupported = 4,
        NotImplemented = 5,
        ResultStoragePermissionDenied = 6,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unspecified => "REASON_UNSPECIFIED",
                Reason::RequestInvalid => "REQUEST_INVALID",
                Reason::ResourceTooBig => "RESOURCE_TOO_BIG",
                Reason::ResourceNotFound => "RESOURCE_NOT_FOUND",
                Reason::Unsupported => "UNSUPPORTED",
                Reason::NotImplemented => "NOT_IMPLEMENTED",
                Reason::ResultStoragePermissionDenied => "RESULT_STORAGE_PERMISSION_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "REQUEST_INVALID" => Some(Self::RequestInvalid),
                "RESOURCE_TOO_BIG" => Some(Self::ResourceTooBig),
                "RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
                "UNSUPPORTED" => Some(Self::Unsupported),
                "NOT_IMPLEMENTED" => Some(Self::NotImplemented),
                "RESULT_STORAGE_PERMISSION_DENIED" => Some(Self::ResultStoragePermissionDenied),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardingOption {
    #[prost(oneof = "sharding_option::Option", tags = "1, 2, 3")]
    pub option: ::core::option::Option<sharding_option::Option>,
}
/// Nested message and enum types in `ShardingOption`.
pub mod sharding_option {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Option {
        #[prost(message, tag = "1")]
        UniformSharding(super::UniformSharding),
        #[prost(message, tag = "2")]
        ManualSharding(super::ManualSharding),
        #[prost(message, tag = "3")]
        SmartSharding(super::SmartSharding),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UniformSharding {
    #[prost(int32, tag = "1")]
    pub num_shards: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManualSharding {
    #[prost(message, repeated, tag = "1")]
    pub test_targets_for_shard: ::prost::alloc::vec::Vec<TestTargetsForShard>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestTargetsForShard {
    #[prost(string, repeated, tag = "1")]
    pub test_targets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartSharding {
    #[prost(message, optional, tag = "1")]
    pub targeted_shard_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shard {
    #[prost(int32, tag = "1")]
    pub shard_index: i32,
    #[prost(int32, tag = "2")]
    pub num_shards: i32,
    #[prost(message, optional, tag = "3")]
    pub test_targets_for_shard: ::core::option::Option<TestTargetsForShard>,
    #[prost(message, optional, tag = "4")]
    pub estimated_shard_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTestMatrixRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub test_matrix: ::core::option::Option<TestMatrix>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTestMatrixRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub test_matrix_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTestMatrixRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub test_matrix_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelTestMatrixResponse {
    #[prost(enumeration = "TestState", tag = "1")]
    pub test_state: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrchestratorOption {
    Unspecified = 0,
    UseOrchestrator = 1,
    DoNotUseOrchestrator = 2,
}
impl OrchestratorOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrchestratorOption::Unspecified => "ORCHESTRATOR_OPTION_UNSPECIFIED",
            OrchestratorOption::UseOrchestrator => "USE_ORCHESTRATOR",
            OrchestratorOption::DoNotUseOrchestrator => "DO_NOT_USE_ORCHESTRATOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORCHESTRATOR_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
            "USE_ORCHESTRATOR" => Some(Self::UseOrchestrator),
            "DO_NOT_USE_ORCHESTRATOR" => Some(Self::DoNotUseOrchestrator),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoboMode {
    Unspecified = 0,
    RoboVersion1 = 1,
    RoboVersion2 = 2,
}
impl RoboMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RoboMode::Unspecified => "ROBO_MODE_UNSPECIFIED",
            RoboMode::RoboVersion1 => "ROBO_VERSION_1",
            RoboMode::RoboVersion2 => "ROBO_VERSION_2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROBO_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "ROBO_VERSION_1" => Some(Self::RoboVersion1),
            "ROBO_VERSION_2" => Some(Self::RoboVersion2),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoboActionType {
    ActionTypeUnspecified = 0,
    SingleClick = 1,
    EnterText = 2,
    Ignore = 3,
}
impl RoboActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RoboActionType::ActionTypeUnspecified => "ACTION_TYPE_UNSPECIFIED",
            RoboActionType::SingleClick => "SINGLE_CLICK",
            RoboActionType::EnterText => "ENTER_TEXT",
            RoboActionType::Ignore => "IGNORE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_TYPE_UNSPECIFIED" => Some(Self::ActionTypeUnspecified),
            "SINGLE_CLICK" => Some(Self::SingleClick),
            "ENTER_TEXT" => Some(Self::EnterText),
            "IGNORE" => Some(Self::Ignore),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InvalidMatrixDetails {
    Unspecified = 0,
    DetailsUnavailable = 1,
    MalformedApk = 2,
    MalformedTestApk = 3,
    NoManifest = 4,
    NoPackageName = 5,
    InvalidPackageName = 31,
    TestSameAsApp = 6,
    NoInstrumentation = 7,
    NoSignature = 20,
    InstrumentationOrchestratorIncompatible = 18,
    NoTestRunnerClass = 19,
    NoLauncherActivity = 8,
    ForbiddenPermissions = 9,
    InvalidRoboDirectives = 10,
    InvalidResourceName = 33,
    InvalidDirectiveAction = 34,
    TestLoopIntentFilterNotFound = 12,
    ScenarioLabelNotDeclared = 13,
    ScenarioLabelMalformed = 14,
    ScenarioNotDeclared = 15,
    DeviceAdminReceiver = 17,
    MalformedXcTestZip = 11,
    BuiltForIosSimulator = 24,
    NoTestsInXcTestZip = 25,
    UseDestinationArtifacts = 26,
    TestNotAppHosted = 28,
    PlistCannotBeParsed = 30,
    TestOnlyApk = 21,
    MalformedIpa = 22,
    MissingUrlScheme = 35,
    MalformedAppBundle = 36,
    NoCodeApk = 23,
    InvalidInputApk = 27,
    InvalidApkPreviewSdk = 29,
    MatrixTooLarge = 37,
    TestQuotaExceeded = 39,
    ServiceNotActivated = 40,
    UnknownPermissionError = 41,
}
impl InvalidMatrixDetails {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InvalidMatrixDetails::Unspecified => "INVALID_MATRIX_DETAILS_UNSPECIFIED",
            InvalidMatrixDetails::DetailsUnavailable => "DETAILS_UNAVAILABLE",
            InvalidMatrixDetails::MalformedApk => "MALFORMED_APK",
            InvalidMatrixDetails::MalformedTestApk => "MALFORMED_TEST_APK",
            InvalidMatrixDetails::NoManifest => "NO_MANIFEST",
            InvalidMatrixDetails::NoPackageName => "NO_PACKAGE_NAME",
            InvalidMatrixDetails::InvalidPackageName => "INVALID_PACKAGE_NAME",
            InvalidMatrixDetails::TestSameAsApp => "TEST_SAME_AS_APP",
            InvalidMatrixDetails::NoInstrumentation => "NO_INSTRUMENTATION",
            InvalidMatrixDetails::NoSignature => "NO_SIGNATURE",
            InvalidMatrixDetails::InstrumentationOrchestratorIncompatible => {
                "INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE"
            }
            InvalidMatrixDetails::NoTestRunnerClass => "NO_TEST_RUNNER_CLASS",
            InvalidMatrixDetails::NoLauncherActivity => "NO_LAUNCHER_ACTIVITY",
            InvalidMatrixDetails::ForbiddenPermissions => "FORBIDDEN_PERMISSIONS",
            InvalidMatrixDetails::InvalidRoboDirectives => "INVALID_ROBO_DIRECTIVES",
            InvalidMatrixDetails::InvalidResourceName => "INVALID_RESOURCE_NAME",
            InvalidMatrixDetails::InvalidDirectiveAction => "INVALID_DIRECTIVE_ACTION",
            InvalidMatrixDetails::TestLoopIntentFilterNotFound => {
                "TEST_LOOP_INTENT_FILTER_NOT_FOUND"
            }
            InvalidMatrixDetails::ScenarioLabelNotDeclared => "SCENARIO_LABEL_NOT_DECLARED",
            InvalidMatrixDetails::ScenarioLabelMalformed => "SCENARIO_LABEL_MALFORMED",
            InvalidMatrixDetails::ScenarioNotDeclared => "SCENARIO_NOT_DECLARED",
            InvalidMatrixDetails::DeviceAdminReceiver => "DEVICE_ADMIN_RECEIVER",
            InvalidMatrixDetails::MalformedXcTestZip => "MALFORMED_XC_TEST_ZIP",
            InvalidMatrixDetails::BuiltForIosSimulator => "BUILT_FOR_IOS_SIMULATOR",
            InvalidMatrixDetails::NoTestsInXcTestZip => "NO_TESTS_IN_XC_TEST_ZIP",
            InvalidMatrixDetails::UseDestinationArtifacts => "USE_DESTINATION_ARTIFACTS",
            InvalidMatrixDetails::TestNotAppHosted => "TEST_NOT_APP_HOSTED",
            InvalidMatrixDetails::PlistCannotBeParsed => "PLIST_CANNOT_BE_PARSED",
            InvalidMatrixDetails::TestOnlyApk => "TEST_ONLY_APK",
            InvalidMatrixDetails::MalformedIpa => "MALFORMED_IPA",
            InvalidMatrixDetails::MissingUrlScheme => "MISSING_URL_SCHEME",
            InvalidMatrixDetails::MalformedAppBundle => "MALFORMED_APP_BUNDLE",
            InvalidMatrixDetails::NoCodeApk => "NO_CODE_APK",
            InvalidMatrixDetails::InvalidInputApk => "INVALID_INPUT_APK",
            InvalidMatrixDetails::InvalidApkPreviewSdk => "INVALID_APK_PREVIEW_SDK",
            InvalidMatrixDetails::MatrixTooLarge => "MATRIX_TOO_LARGE",
            InvalidMatrixDetails::TestQuotaExceeded => "TEST_QUOTA_EXCEEDED",
            InvalidMatrixDetails::ServiceNotActivated => "SERVICE_NOT_ACTIVATED",
            InvalidMatrixDetails::UnknownPermissionError => "UNKNOWN_PERMISSION_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVALID_MATRIX_DETAILS_UNSPECIFIED" => Some(Self::Unspecified),
            "DETAILS_UNAVAILABLE" => Some(Self::DetailsUnavailable),
            "MALFORMED_APK" => Some(Self::MalformedApk),
            "MALFORMED_TEST_APK" => Some(Self::MalformedTestApk),
            "NO_MANIFEST" => Some(Self::NoManifest),
            "NO_PACKAGE_NAME" => Some(Self::NoPackageName),
            "INVALID_PACKAGE_NAME" => Some(Self::InvalidPackageName),
            "TEST_SAME_AS_APP" => Some(Self::TestSameAsApp),
            "NO_INSTRUMENTATION" => Some(Self::NoInstrumentation),
            "NO_SIGNATURE" => Some(Self::NoSignature),
            "INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE" => {
                Some(Self::InstrumentationOrchestratorIncompatible)
            }
            "NO_TEST_RUNNER_CLASS" => Some(Self::NoTestRunnerClass),
            "NO_LAUNCHER_ACTIVITY" => Some(Self::NoLauncherActivity),
            "FORBIDDEN_PERMISSIONS" => Some(Self::ForbiddenPermissions),
            "INVALID_ROBO_DIRECTIVES" => Some(Self::InvalidRoboDirectives),
            "INVALID_RESOURCE_NAME" => Some(Self::InvalidResourceName),
            "INVALID_DIRECTIVE_ACTION" => Some(Self::InvalidDirectiveAction),
            "TEST_LOOP_INTENT_FILTER_NOT_FOUND" => Some(Self::TestLoopIntentFilterNotFound),
            "SCENARIO_LABEL_NOT_DECLARED" => Some(Self::ScenarioLabelNotDeclared),
            "SCENARIO_LABEL_MALFORMED" => Some(Self::ScenarioLabelMalformed),
            "SCENARIO_NOT_DECLARED" => Some(Self::ScenarioNotDeclared),
            "DEVICE_ADMIN_RECEIVER" => Some(Self::DeviceAdminReceiver),
            "MALFORMED_XC_TEST_ZIP" => Some(Self::MalformedXcTestZip),
            "BUILT_FOR_IOS_SIMULATOR" => Some(Self::BuiltForIosSimulator),
            "NO_TESTS_IN_XC_TEST_ZIP" => Some(Self::NoTestsInXcTestZip),
            "USE_DESTINATION_ARTIFACTS" => Some(Self::UseDestinationArtifacts),
            "TEST_NOT_APP_HOSTED" => Some(Self::TestNotAppHosted),
            "PLIST_CANNOT_BE_PARSED" => Some(Self::PlistCannotBeParsed),
            "TEST_ONLY_APK" => Some(Self::TestOnlyApk),
            "MALFORMED_IPA" => Some(Self::MalformedIpa),
            "MISSING_URL_SCHEME" => Some(Self::MissingUrlScheme),
            "MALFORMED_APP_BUNDLE" => Some(Self::MalformedAppBundle),
            "NO_CODE_APK" => Some(Self::NoCodeApk),
            "INVALID_INPUT_APK" => Some(Self::InvalidInputApk),
            "INVALID_APK_PREVIEW_SDK" => Some(Self::InvalidApkPreviewSdk),
            "MATRIX_TOO_LARGE" => Some(Self::MatrixTooLarge),
            "TEST_QUOTA_EXCEEDED" => Some(Self::TestQuotaExceeded),
            "SERVICE_NOT_ACTIVATED" => Some(Self::ServiceNotActivated),
            "UNKNOWN_PERMISSION_ERROR" => Some(Self::UnknownPermissionError),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestState {
    Unspecified = 0,
    Validating = 8,
    Pending = 1,
    Running = 2,
    Finished = 3,
    Error = 4,
    UnsupportedEnvironment = 5,
    IncompatibleEnvironment = 9,
    IncompatibleArchitecture = 10,
    Cancelled = 6,
    Invalid = 7,
}
impl TestState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TestState::Unspecified => "TEST_STATE_UNSPECIFIED",
            TestState::Validating => "VALIDATING",
            TestState::Pending => "PENDING",
            TestState::Running => "RUNNING",
            TestState::Finished => "FINISHED",
            TestState::Error => "ERROR",
            TestState::UnsupportedEnvironment => "UNSUPPORTED_ENVIRONMENT",
            TestState::IncompatibleEnvironment => "INCOMPATIBLE_ENVIRONMENT",
            TestState::IncompatibleArchitecture => "INCOMPATIBLE_ARCHITECTURE",
            TestState::Cancelled => "CANCELLED",
            TestState::Invalid => "INVALID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEST_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "VALIDATING" => Some(Self::Validating),
            "PENDING" => Some(Self::Pending),
            "RUNNING" => Some(Self::Running),
            "FINISHED" => Some(Self::Finished),
            "ERROR" => Some(Self::Error),
            "UNSUPPORTED_ENVIRONMENT" => Some(Self::UnsupportedEnvironment),
            "INCOMPATIBLE_ENVIRONMENT" => Some(Self::IncompatibleEnvironment),
            "INCOMPATIBLE_ARCHITECTURE" => Some(Self::IncompatibleArchitecture),
            "CANCELLED" => Some(Self::Cancelled),
            "INVALID" => Some(Self::Invalid),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OutcomeSummary {
    Unspecified = 0,
    Success = 1,
    Failure = 2,
    Inconclusive = 3,
    Skipped = 4,
}
impl OutcomeSummary {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OutcomeSummary::Unspecified => "OUTCOME_SUMMARY_UNSPECIFIED",
            OutcomeSummary::Success => "SUCCESS",
            OutcomeSummary::Failure => "FAILURE",
            OutcomeSummary::Inconclusive => "INCONCLUSIVE",
            OutcomeSummary::Skipped => "SKIPPED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OUTCOME_SUMMARY_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCESS" => Some(Self::Success),
            "FAILURE" => Some(Self::Failure),
            "INCONCLUSIVE" => Some(Self::Inconclusive),
            "SKIPPED" => Some(Self::Skipped),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod test_execution_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// A service for requesting test executions and querying their status.
    ///
    /// This service is part of Firebase Test Lab. To learn about how to use the
    /// product, and how to integrate it with your system,
    /// visit https://firebase.google.com/docs/test-lab.
    ///
    /// Each test execution will wait for available capacity. It will then be
    /// invoked as described. The test may be invoked multiple times if an
    /// infrastructure failure is detected. Results and other files generated by
    /// the test will be stored in an external storage system.
    ///
    /// The TestExecutionService models this behavior using two resource types:
    ///
    /// - TestMatrix: a group of one or more TestExecutions, built by taking a
    ///   product of values over a pre-defined set of axes. In the case of Android
    ///   Tests, for example, device model and OS version are two axes of the matrix.
    ///
    /// - TestExecution: a single execution of one or more test targets on a
    ///   single device. These are created automatically when a TestMatrix is
    ///   created.
    ///
    /// This service returns any error codes from the canonical error space (i.e.
    /// google.rpc.Code). The errors which may be returned are specified on each
    /// method. In addition, any method may return UNAVAILABLE or INTERNAL.
    #[derive(Debug, Clone)]
    pub struct TestExecutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TestExecutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TestExecutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            TestExecutionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates and runs a matrix of tests according to the given specifications.
        /// Unsupported environments will be returned in the state UNSUPPORTED.
        /// A test matrix is limited to use at most 2000 devices in parallel.
        ///
        /// The returned matrix will not yet contain the executions that will be
        /// created for this matrix. Execution creation happens later on and will
        /// require a call to GetTestMatrix.
        ///
        /// May return any of the following canonical error codes:
        ///
        /// - PERMISSION_DENIED - if the user is not authorized to write to project
        /// - INVALID_ARGUMENT - if the request is malformed or if the matrix tries
        ///                      to use too many simultaneous devices.
        pub async fn create_test_matrix(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTestMatrixRequest>,
        ) -> std::result::Result<tonic::Response<super::TestMatrix>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.TestExecutionService/CreateTestMatrix",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.TestExecutionService",
                "CreateTestMatrix",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Checks the status of a test matrix and the executions once they
        /// are created.
        ///
        /// The test matrix will contain the list of test executions to run if and only
        /// if the resultStorage.toolResultsExecution fields have been populated.
        ///
        /// Note: Flaky test executions may be added to the matrix at a later stage.
        ///
        /// May return any of the following canonical error codes:
        ///
        /// - PERMISSION_DENIED - if the user is not authorized to read project
        /// - INVALID_ARGUMENT - if the request is malformed
        /// - NOT_FOUND - if the Test Matrix does not exist
        pub async fn get_test_matrix(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTestMatrixRequest>,
        ) -> std::result::Result<tonic::Response<super::TestMatrix>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.TestExecutionService/GetTestMatrix",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.TestExecutionService",
                "GetTestMatrix",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Cancels unfinished test executions in a test matrix.
        /// This call returns immediately and cancellation proceeds asynchronously.
        /// If the matrix is already final, this operation will have no effect.
        ///
        /// May return any of the following canonical error codes:
        ///
        /// - PERMISSION_DENIED - if the user is not authorized to read project
        /// - INVALID_ARGUMENT - if the request is malformed
        /// - NOT_FOUND - if the Test Matrix does not exist
        pub async fn cancel_test_matrix(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelTestMatrixRequest>,
        ) -> std::result::Result<tonic::Response<super::CancelTestMatrixResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.TestExecutionService/CancelTestMatrix",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.TestExecutionService",
                "CancelTestMatrix",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceMessage {
    #[prost(oneof = "device_message::Contents", tags = "1, 2, 3")]
    pub contents: ::core::option::Option<device_message::Contents>,
}
/// Nested message and enum types in `DeviceMessage`.
pub mod device_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Contents {
        #[prost(message, tag = "1")]
        StatusUpdate(super::StatusUpdate),
        #[prost(message, tag = "2")]
        StreamStatus(super::StreamStatus),
        #[prost(message, tag = "3")]
        StreamData(super::StreamData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdbMessage {
    #[prost(oneof = "adb_message::Contents", tags = "1, 2")]
    pub contents: ::core::option::Option<adb_message::Contents>,
}
/// Nested message and enum types in `AdbMessage`.
pub mod adb_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Contents {
        #[prost(message, tag = "1")]
        Open(super::Open),
        #[prost(message, tag = "2")]
        StreamData(super::StreamData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusUpdate {
    #[prost(enumeration = "status_update::DeviceState", tag = "1")]
    pub state: i32,
    #[prost(btree_map = "string, string", tag = "2")]
    pub properties: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "3")]
    pub features: ::prost::alloc::string::String,
}
/// Nested message and enum types in `StatusUpdate`.
pub mod status_update {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DeviceState {
        Unspecified = 0,
        Device = 1,
        Recovery = 2,
        Rescue = 3,
        Sideload = 4,
        Missing = 10,
        Offline = 11,
        Unauthorized = 12,
        Authorizing = 13,
        Connecting = 14,
    }
    impl DeviceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeviceState::Unspecified => "DEVICE_STATE_UNSPECIFIED",
                DeviceState::Device => "DEVICE",
                DeviceState::Recovery => "RECOVERY",
                DeviceState::Rescue => "RESCUE",
                DeviceState::Sideload => "SIDELOAD",
                DeviceState::Missing => "MISSING",
                DeviceState::Offline => "OFFLINE",
                DeviceState::Unauthorized => "UNAUTHORIZED",
                DeviceState::Authorizing => "AUTHORIZING",
                DeviceState::Connecting => "CONNECTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEVICE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DEVICE" => Some(Self::Device),
                "RECOVERY" => Some(Self::Recovery),
                "RESCUE" => Some(Self::Rescue),
                "SIDELOAD" => Some(Self::Sideload),
                "MISSING" => Some(Self::Missing),
                "OFFLINE" => Some(Self::Offline),
                "UNAUTHORIZED" => Some(Self::Unauthorized),
                "AUTHORIZING" => Some(Self::Authorizing),
                "CONNECTING" => Some(Self::Connecting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamStatus {
    #[prost(int32, tag = "1")]
    pub stream_id: i32,
    #[prost(oneof = "stream_status::Status", tags = "2, 3")]
    pub status: ::core::option::Option<stream_status::Status>,
}
/// Nested message and enum types in `StreamStatus`.
pub mod stream_status {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Status {
        #[prost(message, tag = "2")]
        Okay(super::Okay),
        #[prost(message, tag = "3")]
        Fail(super::Fail),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Open {
    #[prost(int32, tag = "1")]
    pub stream_id: i32,
    #[prost(string, tag = "2")]
    pub service: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamData {
    #[prost(int32, tag = "1")]
    pub stream_id: i32,
    #[prost(oneof = "stream_data::Contents", tags = "2, 3")]
    pub contents: ::core::option::Option<stream_data::Contents>,
}
/// Nested message and enum types in `StreamData`.
pub mod stream_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Contents {
        #[prost(bytes, tag = "2")]
        Data(::prost::bytes::Bytes),
        #[prost(message, tag = "3")]
        Close(super::Close),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Okay {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fail {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Close {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeviceSessionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub device_session: ::core::option::Option<DeviceSession>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeviceSessionsRequest {
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeviceSessionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub device_sessions: ::prost::alloc::vec::Vec<DeviceSession>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeviceSessionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelDeviceSessionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeviceSessionRequest {
    #[prost(message, optional, tag = "1")]
    pub device_session: ::core::option::Option<DeviceSession>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSession {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "device_session::SessionState", tag = "3")]
    pub state: i32,
    #[prost(message, repeated, tag = "14")]
    pub state_histories: ::prost::alloc::vec::Vec<device_session::SessionStateEvent>,
    #[prost(message, optional, tag = "7")]
    pub inactivity_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub active_start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "15")]
    pub android_device: ::core::option::Option<AndroidDevice>,
    #[prost(oneof = "device_session::Expiration", tags = "13, 5")]
    pub expiration: ::core::option::Option<device_session::Expiration>,
}
/// Nested message and enum types in `DeviceSession`.
pub mod device_session {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionStateEvent {
        #[prost(enumeration = "SessionState", tag = "1")]
        pub session_state: i32,
        #[prost(message, optional, tag = "2")]
        pub event_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "3")]
        pub state_message: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SessionState {
        Unspecified = 0,
        Requested = 1,
        Pending = 2,
        Active = 3,
        Expired = 4,
        Finished = 5,
        Unavailable = 6,
        Error = 7,
    }
    impl SessionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SessionState::Unspecified => "SESSION_STATE_UNSPECIFIED",
                SessionState::Requested => "REQUESTED",
                SessionState::Pending => "PENDING",
                SessionState::Active => "ACTIVE",
                SessionState::Expired => "EXPIRED",
                SessionState::Finished => "FINISHED",
                SessionState::Unavailable => "UNAVAILABLE",
                SessionState::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SESSION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REQUESTED" => Some(Self::Requested),
                "PENDING" => Some(Self::Pending),
                "ACTIVE" => Some(Self::Active),
                "EXPIRED" => Some(Self::Expired),
                "FINISHED" => Some(Self::Finished),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        #[prost(message, tag = "13")]
        Ttl(::prost_types::Duration),
        #[prost(message, tag = "5")]
        ExpireTime(::prost_types::Timestamp),
    }
}
/// Generated client implementations.
pub mod direct_access_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// A service for allocating devices and interacting with the live-allocated
    /// devices.
    ///
    /// This service is part of Firebase Test Lab. To learn about how to use the
    /// product, and how to integrate it with your system,
    /// visit https://firebase.google.com/docs/test-lab.
    ///
    /// Each Session will wait for available capacity, at a higher
    /// priority over Test Execution. When allocated, the session will be exposed
    /// through a stream for integration.
    ///
    /// DirectAccessService is currently available as a preview to select developers.
    /// You can register today on behalf of you and your team at
    /// https://developer.android.com/studio/preview/android-device-streaming
    #[derive(Debug, Clone)]
    pub struct DirectAccessServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DirectAccessServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DirectAccessServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            DirectAccessServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// POST /v1/projects/{project_id}/deviceSessions
        pub async fn create_device_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDeviceSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::DeviceSession>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.DirectAccessService/CreateDeviceSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.DirectAccessService",
                "CreateDeviceSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GET /v1/projects/{project_id}/deviceSessions
        /// Lists device Sessions owned by the project user.
        pub async fn list_device_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeviceSessionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListDeviceSessionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.DirectAccessService/ListDeviceSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.DirectAccessService",
                "ListDeviceSessions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GET /v1/projects/{project_id}/deviceSessions/{device_session_id}
        /// Return a DeviceSession, which documents the allocation status and
        /// whether the device is allocated. Clients making requests from this API
        /// must poll GetDeviceSession.
        pub async fn get_device_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeviceSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::DeviceSession>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.DirectAccessService/GetDeviceSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.DirectAccessService",
                "GetDeviceSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// POST
        /// /v1/projects/{project_id}/deviceSessions/{device_session_id}:cancel
        /// Changes the DeviceSession to state FINISHED and terminates all connections.
        /// Canceled sessions are not deleted and can be retrieved or
        /// listed by the user until they expire based on the 28 day deletion policy.
        pub async fn cancel_device_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelDeviceSessionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.DirectAccessService/CancelDeviceSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.DirectAccessService",
                "CancelDeviceSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// PATCH
        /// /v1/projects/{projectId}/deviceSessions/deviceSessionId}:updateDeviceSession
        /// Updates the current device session to the fields described by the
        /// update_mask.
        pub async fn update_device_session(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeviceSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::DeviceSession>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.DirectAccessService/UpdateDeviceSession",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.DirectAccessService",
                "UpdateDeviceSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Exposes ADB connection for use with the Adb Device Forwarder project
        /// if the reserved device supports ADB.
        /// gRPC headers are used to authenticate the Connect RPC, as well as
        /// associate to a particular device session.
        /// In particular, the user must specify the "X-FTL-Session-Name" header.
        pub async fn adb_connect(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::AdbMessage>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DeviceMessage>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.DirectAccessService/AdbConnect",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.DirectAccessService",
                "AdbConnect",
            ));
            self.inner.streaming(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApkDetail {
    #[prost(message, optional, tag = "1")]
    pub apk_manifest: ::core::option::Option<ApkManifest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApkManifest {
    #[prost(string, tag = "1")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub min_sdk_version: i32,
    #[prost(int32, tag = "3")]
    pub max_sdk_version: i32,
    #[prost(int32, tag = "6")]
    pub target_sdk_version: i32,
    #[prost(string, tag = "4")]
    pub application_label: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub intent_filters: ::prost::alloc::vec::Vec<IntentFilter>,
    #[prost(string, repeated, tag = "7")]
    pub uses_permission: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "8")]
    pub version_code: i64,
    #[prost(string, tag = "9")]
    pub version_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "10")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
    #[prost(message, repeated, tag = "11")]
    pub uses_feature: ::prost::alloc::vec::Vec<UsesFeature>,
    #[prost(message, repeated, tag = "12")]
    pub services: ::prost::alloc::vec::Vec<Service>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub intent_filter: ::prost::alloc::vec::Vec<IntentFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentFilter {
    #[prost(string, repeated, tag = "1")]
    pub action_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub category_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub mime_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsesFeature {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_required: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApkDetailsRequest {
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<FileReference>,
    #[prost(message, optional, tag = "2")]
    pub bundle_location: ::core::option::Option<FileReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApkDetailsResponse {
    #[prost(message, optional, tag = "1")]
    pub apk_detail: ::core::option::Option<ApkDetail>,
}
/// Generated client implementations.
pub mod application_detail_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// A service which parses input applications and returns details that can be
    /// useful in the context of testing.
    #[derive(Debug, Clone)]
    pub struct ApplicationDetailServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ApplicationDetailServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApplicationDetailServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ApplicationDetailServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets the details of an Android application APK.
        pub async fn get_apk_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApkDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetApkDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.testing.v1.ApplicationDetailService/GetApkDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.devtools.testing.v1.ApplicationDetailService",
                "GetApkDetails",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
