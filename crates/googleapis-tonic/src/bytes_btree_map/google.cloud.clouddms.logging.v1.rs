// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatabaseType {
    #[prost(enumeration = "DatabaseProvider", tag = "1")]
    pub provider: i32,
    #[prost(enumeration = "DatabaseEngine", tag = "2")]
    pub engine: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedMigrationJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "2")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "logged_migration_job::State", tag = "4")]
    pub state: i32,
    #[prost(enumeration = "logged_migration_job::Phase", tag = "5")]
    pub phase: i32,
    #[prost(enumeration = "logged_migration_job::Type", tag = "6")]
    pub r#type: i32,
    #[prost(string, tag = "7")]
    pub dump_path: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub destination: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "logged_migration_job::ConnectivityType", tag = "11")]
    pub connectivity_type: i32,
    #[prost(message, optional, tag = "12")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "13")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub source_database: ::core::option::Option<DatabaseType>,
    #[prost(message, optional, tag = "15")]
    pub destination_database: ::core::option::Option<DatabaseType>,
}
/// Nested message and enum types in `LoggedMigrationJob`.
pub mod logged_migration_job {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Maintenance = 1,
        Draft = 2,
        Creating = 3,
        NotStarted = 4,
        Running = 5,
        Failed = 6,
        Completed = 7,
        Deleting = 8,
        Stopping = 9,
        Stopped = 10,
        Deleted = 11,
        Updating = 12,
        Starting = 13,
        Restarting = 14,
        Resuming = 15,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Maintenance => "MAINTENANCE",
                State::Draft => "DRAFT",
                State::Creating => "CREATING",
                State::NotStarted => "NOT_STARTED",
                State::Running => "RUNNING",
                State::Failed => "FAILED",
                State::Completed => "COMPLETED",
                State::Deleting => "DELETING",
                State::Stopping => "STOPPING",
                State::Stopped => "STOPPED",
                State::Deleted => "DELETED",
                State::Updating => "UPDATING",
                State::Starting => "STARTING",
                State::Restarting => "RESTARTING",
                State::Resuming => "RESUMING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "MAINTENANCE" => Some(Self::Maintenance),
                "DRAFT" => Some(Self::Draft),
                "CREATING" => Some(Self::Creating),
                "NOT_STARTED" => Some(Self::NotStarted),
                "RUNNING" => Some(Self::Running),
                "FAILED" => Some(Self::Failed),
                "COMPLETED" => Some(Self::Completed),
                "DELETING" => Some(Self::Deleting),
                "STOPPING" => Some(Self::Stopping),
                "STOPPED" => Some(Self::Stopped),
                "DELETED" => Some(Self::Deleted),
                "UPDATING" => Some(Self::Updating),
                "STARTING" => Some(Self::Starting),
                "RESTARTING" => Some(Self::Restarting),
                "RESUMING" => Some(Self::Resuming),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Phase {
        Unspecified = 0,
        FullDump = 1,
        Cdc = 2,
        PromoteInProgress = 3,
        WaitingForSourceWritesToStop = 4,
        PreparingTheDump = 5,
    }
    impl Phase {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Phase::Unspecified => "PHASE_UNSPECIFIED",
                Phase::FullDump => "FULL_DUMP",
                Phase::Cdc => "CDC",
                Phase::PromoteInProgress => "PROMOTE_IN_PROGRESS",
                Phase::WaitingForSourceWritesToStop => "WAITING_FOR_SOURCE_WRITES_TO_STOP",
                Phase::PreparingTheDump => "PREPARING_THE_DUMP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PHASE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL_DUMP" => Some(Self::FullDump),
                "CDC" => Some(Self::Cdc),
                "PROMOTE_IN_PROGRESS" => Some(Self::PromoteInProgress),
                "WAITING_FOR_SOURCE_WRITES_TO_STOP" => Some(Self::WaitingForSourceWritesToStop),
                "PREPARING_THE_DUMP" => Some(Self::PreparingTheDump),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        OneTime = 1,
        Continuous = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::OneTime => "ONE_TIME",
                Type::Continuous => "CONTINUOUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ONE_TIME" => Some(Self::OneTime),
                "CONTINUOUS" => Some(Self::Continuous),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ConnectivityType {
        Unspecified = 0,
        StaticIp = 1,
        ReverseSsh = 2,
        VpcPeering = 3,
    }
    impl ConnectivityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConnectivityType::Unspecified => "CONNECTIVITY_TYPE_UNSPECIFIED",
                ConnectivityType::StaticIp => "STATIC_IP",
                ConnectivityType::ReverseSsh => "REVERSE_SSH",
                ConnectivityType::VpcPeering => "VPC_PEERING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTIVITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STATIC_IP" => Some(Self::StaticIp),
                "REVERSE_SSH" => Some(Self::ReverseSsh),
                "VPC_PEERING" => Some(Self::VpcPeering),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlConnectionProfile {
    #[prost(enumeration = "my_sql_connection_profile::Version", tag = "1")]
    pub version: i32,
    #[prost(string, tag = "2")]
    pub cloud_sql_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MySqlConnectionProfile`.
pub mod my_sql_connection_profile {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Version {
        Unspecified = 0,
        V55 = 1,
        V56 = 2,
        V57 = 3,
        V80 = 4,
    }
    impl Version {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Version::Unspecified => "VERSION_UNSPECIFIED",
                Version::V55 => "V5_5",
                Version::V56 => "V5_6",
                Version::V57 => "V5_7",
                Version::V80 => "V8_0",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "V5_5" => Some(Self::V55),
                "V5_6" => Some(Self::V56),
                "V5_7" => Some(Self::V57),
                "V8_0" => Some(Self::V80),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgreSqlConnectionProfile {
    #[prost(enumeration = "postgre_sql_connection_profile::Version", tag = "1")]
    pub version: i32,
    #[prost(string, tag = "2")]
    pub cloud_sql_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PostgreSqlConnectionProfile`.
pub mod postgre_sql_connection_profile {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Version {
        Unspecified = 0,
        V96 = 1,
        V11 = 2,
        V10 = 3,
        V12 = 4,
        V13 = 5,
    }
    impl Version {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Version::Unspecified => "VERSION_UNSPECIFIED",
                Version::V96 => "V9_6",
                Version::V11 => "V11",
                Version::V10 => "V10",
                Version::V12 => "V12",
                Version::V13 => "V13",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "V9_6" => Some(Self::V96),
                "V11" => Some(Self::V11),
                "V10" => Some(Self::V10),
                "V12" => Some(Self::V12),
                "V13" => Some(Self::V13),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudSqlConnectionProfile {
    #[prost(string, tag = "1")]
    pub cloud_sql_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OracleConnectionProfile {
    #[prost(enumeration = "oracle_connection_profile::ConnectivityType", tag = "1")]
    pub connectivity_type: i32,
}
/// Nested message and enum types in `OracleConnectionProfile`.
pub mod oracle_connection_profile {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ConnectivityType {
        Unspecified = 0,
        StaticServiceIp = 1,
        ForwardSshTunnel = 2,
        PrivateConnectivity = 3,
    }
    impl ConnectivityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConnectivityType::Unspecified => "CONNECTIVITY_TYPE_UNSPECIFIED",
                ConnectivityType::StaticServiceIp => "STATIC_SERVICE_IP",
                ConnectivityType::ForwardSshTunnel => "FORWARD_SSH_TUNNEL",
                ConnectivityType::PrivateConnectivity => "PRIVATE_CONNECTIVITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTIVITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STATIC_SERVICE_IP" => Some(Self::StaticServiceIp),
                "FORWARD_SSH_TUNNEL" => Some(Self::ForwardSshTunnel),
                "PRIVATE_CONNECTIVITY" => Some(Self::PrivateConnectivity),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedConnectionProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "2")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "logged_connection_profile::State", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    #[prost(enumeration = "DatabaseProvider", tag = "6")]
    pub provider: i32,
    #[prost(
        oneof = "logged_connection_profile::ConnectionProfile",
        tags = "100, 101, 102, 103"
    )]
    pub connection_profile: ::core::option::Option<logged_connection_profile::ConnectionProfile>,
}
/// Nested message and enum types in `LoggedConnectionProfile`.
pub mod logged_connection_profile {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Draft = 1,
        Creating = 2,
        Ready = 3,
        Updating = 4,
        Deleting = 5,
        Deleted = 6,
        Failed = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Draft => "DRAFT",
                State::Creating => "CREATING",
                State::Ready => "READY",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Deleted => "DELETED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConnectionProfile {
        #[prost(message, tag = "100")]
        Mysql(super::MySqlConnectionProfile),
        #[prost(message, tag = "101")]
        Postgresql(super::PostgreSqlConnectionProfile),
        #[prost(message, tag = "102")]
        Cloudsql(super::CloudSqlConnectionProfile),
        #[prost(message, tag = "103")]
        Oracle(super::OracleConnectionProfile),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationJobEventLog {
    #[prost(message, optional, tag = "1")]
    pub migration_job: ::core::option::Option<LoggedMigrationJob>,
    #[prost(message, optional, tag = "2")]
    pub occurrence_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "3")]
    pub code: i32,
    #[prost(string, tag = "4")]
    pub text_message: ::prost::alloc::string::String,
    #[prost(oneof = "migration_job_event_log::OriginalCause", tags = "200, 201")]
    pub original_cause: ::core::option::Option<migration_job_event_log::OriginalCause>,
}
/// Nested message and enum types in `MigrationJobEventLog`.
pub mod migration_job_event_log {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OriginalCause {
        #[prost(int32, tag = "200")]
        OriginalCode(i32),
        #[prost(string, tag = "201")]
        OriginalMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionProfileEventLog {
    #[prost(message, optional, tag = "1")]
    pub connection_profile: ::core::option::Option<LoggedConnectionProfile>,
    #[prost(message, optional, tag = "2")]
    pub occurrence_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "3")]
    pub code: i32,
    #[prost(string, tag = "4")]
    pub text_message: ::prost::alloc::string::String,
    #[prost(
        oneof = "connection_profile_event_log::OriginalCause",
        tags = "200, 201"
    )]
    pub original_cause: ::core::option::Option<connection_profile_event_log::OriginalCause>,
}
/// Nested message and enum types in `ConnectionProfileEventLog`.
pub mod connection_profile_event_log {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OriginalCause {
        #[prost(int32, tag = "200")]
        OriginalCode(i32),
        #[prost(string, tag = "201")]
        OriginalMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedPrivateConnection {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "2")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "logged_private_connection::State", tag = "4")]
    pub state: i32,
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "100")]
    pub vpc_peering_config: ::core::option::Option<VpcPeeringConfig>,
}
/// Nested message and enum types in `LoggedPrivateConnection`.
pub mod logged_private_connection {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Created = 2,
        Failed = 3,
        Deleting = 4,
        FailedToDelete = 5,
        Deleted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Created => "CREATED",
                State::Failed => "FAILED",
                State::Deleting => "DELETING",
                State::FailedToDelete => "FAILED_TO_DELETE",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "CREATED" => Some(Self::Created),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                "FAILED_TO_DELETE" => Some(Self::FailedToDelete),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpcPeeringConfig {
    #[prost(string, tag = "1")]
    pub vpc_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subnet: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateConnectionEventLog {
    #[prost(message, optional, tag = "1")]
    pub private_connection: ::core::option::Option<LoggedPrivateConnection>,
    #[prost(message, optional, tag = "2")]
    pub occurrence_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "3")]
    pub code: i32,
    #[prost(string, tag = "4")]
    pub text_message: ::prost::alloc::string::String,
    #[prost(
        oneof = "private_connection_event_log::OriginalCause",
        tags = "200, 201"
    )]
    pub original_cause: ::core::option::Option<private_connection_event_log::OriginalCause>,
}
/// Nested message and enum types in `PrivateConnectionEventLog`.
pub mod private_connection_event_log {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OriginalCause {
        #[prost(int32, tag = "200")]
        OriginalCode(i32),
        #[prost(string, tag = "201")]
        OriginalMessage(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseEngine {
    Unspecified = 0,
    Mysql = 1,
    Postgresql = 2,
    Sqlserver = 3,
    Oracle = 4,
    Spanner = 5,
}
impl DatabaseEngine {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseEngine::Unspecified => "DATABASE_ENGINE_UNSPECIFIED",
            DatabaseEngine::Mysql => "MYSQL",
            DatabaseEngine::Postgresql => "POSTGRESQL",
            DatabaseEngine::Sqlserver => "SQLSERVER",
            DatabaseEngine::Oracle => "ORACLE",
            DatabaseEngine::Spanner => "SPANNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_ENGINE_UNSPECIFIED" => Some(Self::Unspecified),
            "MYSQL" => Some(Self::Mysql),
            "POSTGRESQL" => Some(Self::Postgresql),
            "SQLSERVER" => Some(Self::Sqlserver),
            "ORACLE" => Some(Self::Oracle),
            "SPANNER" => Some(Self::Spanner),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseProvider {
    Unspecified = 0,
    Cloudsql = 1,
    Rds = 2,
    Aurora = 3,
    Alloydb = 4,
}
impl DatabaseProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseProvider::Unspecified => "DATABASE_PROVIDER_UNSPECIFIED",
            DatabaseProvider::Cloudsql => "CLOUDSQL",
            DatabaseProvider::Rds => "RDS",
            DatabaseProvider::Aurora => "AURORA",
            DatabaseProvider::Alloydb => "ALLOYDB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOUDSQL" => Some(Self::Cloudsql),
            "RDS" => Some(Self::Rds),
            "AURORA" => Some(Self::Aurora),
            "ALLOYDB" => Some(Self::Alloydb),
            _ => None,
        }
    }
}
