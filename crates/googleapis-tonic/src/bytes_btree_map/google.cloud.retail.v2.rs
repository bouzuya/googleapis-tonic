// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    #[prost(message, repeated, tag = "1")]
    pub query_terms: ::prost::alloc::vec::Vec<condition::QueryTerm>,
    #[prost(message, repeated, tag = "3")]
    pub active_time_range: ::prost::alloc::vec::Vec<condition::TimeRange>,
    #[prost(string, repeated, tag = "4")]
    pub page_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryTerm {
        #[prost(string, tag = "1")]
        pub value: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub full_match: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TimeRange {
        #[prost(message, optional, tag = "1")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    #[prost(message, optional, tag = "1")]
    pub condition: ::core::option::Option<Condition>,
    #[prost(oneof = "rule::Action", tags = "2, 3, 6, 7, 8, 9, 10, 11, 12, 13")]
    pub action: ::core::option::Option<rule::Action>,
}
/// Nested message and enum types in `Rule`.
pub mod rule {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoostAction {
        #[prost(float, tag = "1")]
        pub boost: f32,
        #[prost(string, tag = "2")]
        pub products_filter: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilterAction {
        #[prost(string, tag = "1")]
        pub filter: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RedirectAction {
        #[prost(string, tag = "1")]
        pub redirect_uri: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TwowaySynonymsAction {
        #[prost(string, repeated, tag = "1")]
        pub synonyms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OnewaySynonymsAction {
        #[prost(string, repeated, tag = "3")]
        pub query_terms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub synonyms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub oneway_terms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DoNotAssociateAction {
        #[prost(string, repeated, tag = "2")]
        pub query_terms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub do_not_associate_terms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "1")]
        pub terms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReplacementAction {
        #[prost(string, repeated, tag = "2")]
        pub query_terms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "3")]
        pub replacement_term: ::prost::alloc::string::String,
        #[prost(string, tag = "1")]
        pub term: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IgnoreAction {
        #[prost(string, repeated, tag = "1")]
        pub ignore_terms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ForceReturnFacetAction {
        #[prost(message, repeated, tag = "1")]
        pub facet_position_adjustments:
            ::prost::alloc::vec::Vec<force_return_facet_action::FacetPositionAdjustment>,
    }
    /// Nested message and enum types in `ForceReturnFacetAction`.
    pub mod force_return_facet_action {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FacetPositionAdjustment {
            #[prost(string, tag = "1")]
            pub attribute_name: ::prost::alloc::string::String,
            #[prost(int32, tag = "2")]
            pub position: i32,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveFacetAction {
        #[prost(string, repeated, tag = "1")]
        pub attribute_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "2")]
        BoostAction(BoostAction),
        #[prost(message, tag = "3")]
        RedirectAction(RedirectAction),
        #[prost(message, tag = "6")]
        OnewaySynonymsAction(OnewaySynonymsAction),
        #[prost(message, tag = "7")]
        DoNotAssociateAction(DoNotAssociateAction),
        #[prost(message, tag = "8")]
        ReplacementAction(ReplacementAction),
        #[prost(message, tag = "9")]
        IgnoreAction(IgnoreAction),
        #[prost(message, tag = "10")]
        FilterAction(FilterAction),
        #[prost(message, tag = "11")]
        TwowaySynonymsAction(TwowaySynonymsAction),
        #[prost(message, tag = "12")]
        ForceReturnFacetAction(ForceReturnFacetAction),
        #[prost(message, tag = "13")]
        RemoveFacetAction(RemoveFacetAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Audience {
    #[prost(string, repeated, tag = "1")]
    pub genders: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub age_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColorInfo {
    #[prost(string, repeated, tag = "1")]
    pub color_families: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub colors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAttribute {
    #[prost(string, repeated, tag = "1")]
    pub text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, repeated, tag = "2")]
    pub numbers: ::prost::alloc::vec::Vec<f64>,
    #[deprecated]
    #[prost(bool, optional, tag = "3")]
    pub searchable: ::core::option::Option<bool>,
    #[deprecated]
    #[prost(bool, optional, tag = "4")]
    pub indexable: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillmentInfo {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub place_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub height: i32,
    #[prost(int32, tag = "3")]
    pub width: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Interval {
    #[prost(oneof = "interval::Min", tags = "1, 2")]
    pub min: ::core::option::Option<interval::Min>,
    #[prost(oneof = "interval::Max", tags = "3, 4")]
    pub max: ::core::option::Option<interval::Max>,
}
/// Nested message and enum types in `Interval`.
pub mod interval {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Min {
        #[prost(double, tag = "1")]
        Minimum(f64),
        #[prost(double, tag = "2")]
        ExclusiveMinimum(f64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Max {
        #[prost(double, tag = "3")]
        Maximum(f64),
        #[prost(double, tag = "4")]
        ExclusiveMaximum(f64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriceInfo {
    #[prost(string, tag = "1")]
    pub currency_code: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub price: f32,
    #[prost(float, tag = "3")]
    pub original_price: f32,
    #[prost(float, tag = "4")]
    pub cost: f32,
    #[prost(message, optional, tag = "5")]
    pub price_effective_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub price_expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub price_range: ::core::option::Option<price_info::PriceRange>,
}
/// Nested message and enum types in `PriceInfo`.
pub mod price_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PriceRange {
        #[prost(message, optional, tag = "1")]
        pub price: ::core::option::Option<super::Interval>,
        #[prost(message, optional, tag = "2")]
        pub original_price: ::core::option::Option<super::Interval>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rating {
    #[prost(int32, tag = "1")]
    pub rating_count: i32,
    #[prost(float, tag = "2")]
    pub average_rating: f32,
    #[prost(int32, repeated, tag = "3")]
    pub rating_histogram: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub user_agent: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub direct_user_request: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalInventory {
    #[prost(string, tag = "1")]
    pub place_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub price_info: ::core::option::Option<PriceInfo>,
    #[prost(btree_map = "string, message", tag = "3")]
    pub attributes:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, CustomAttribute>,
    #[prost(string, repeated, tag = "4")]
    pub fulfillment_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AttributeConfigLevel {
    Unspecified = 0,
    ProductLevelAttributeConfig = 1,
    CatalogLevelAttributeConfig = 2,
}
impl AttributeConfigLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AttributeConfigLevel::Unspecified => "ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED",
            AttributeConfigLevel::ProductLevelAttributeConfig => "PRODUCT_LEVEL_ATTRIBUTE_CONFIG",
            AttributeConfigLevel::CatalogLevelAttributeConfig => "CATALOG_LEVEL_ATTRIBUTE_CONFIG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "PRODUCT_LEVEL_ATTRIBUTE_CONFIG" => Some(Self::ProductLevelAttributeConfig),
            "CATALOG_LEVEL_ATTRIBUTE_CONFIG" => Some(Self::CatalogLevelAttributeConfig),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolutionType {
    Unspecified = 0,
    Recommendation = 1,
    Search = 2,
}
impl SolutionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SolutionType::Unspecified => "SOLUTION_TYPE_UNSPECIFIED",
            SolutionType::Recommendation => "SOLUTION_TYPE_RECOMMENDATION",
            SolutionType::Search => "SOLUTION_TYPE_SEARCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOLUTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SOLUTION_TYPE_RECOMMENDATION" => Some(Self::Recommendation),
            "SOLUTION_TYPE_SEARCH" => Some(Self::Search),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecommendationsFilteringOption {
    Unspecified = 0,
    RecommendationsFilteringDisabled = 1,
    RecommendationsFilteringEnabled = 3,
}
impl RecommendationsFilteringOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RecommendationsFilteringOption::Unspecified => {
                "RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED"
            }
            RecommendationsFilteringOption::RecommendationsFilteringDisabled => {
                "RECOMMENDATIONS_FILTERING_DISABLED"
            }
            RecommendationsFilteringOption::RecommendationsFilteringEnabled => {
                "RECOMMENDATIONS_FILTERING_ENABLED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
            "RECOMMENDATIONS_FILTERING_DISABLED" => Some(Self::RecommendationsFilteringDisabled),
            "RECOMMENDATIONS_FILTERING_ENABLED" => Some(Self::RecommendationsFilteringEnabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchSolutionUseCase {
    Unspecified = 0,
    Search = 1,
    Browse = 2,
}
impl SearchSolutionUseCase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SearchSolutionUseCase::Unspecified => "SEARCH_SOLUTION_USE_CASE_UNSPECIFIED",
            SearchSolutionUseCase::Search => "SEARCH_SOLUTION_USE_CASE_SEARCH",
            SearchSolutionUseCase::Browse => "SEARCH_SOLUTION_USE_CASE_BROWSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEARCH_SOLUTION_USE_CASE_UNSPECIFIED" => Some(Self::Unspecified),
            "SEARCH_SOLUTION_USE_CASE_SEARCH" => Some(Self::Search),
            "SEARCH_SOLUTION_USE_CASE_BROWSE" => Some(Self::Browse),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Promotion {
    #[prost(string, tag = "1")]
    pub promotion_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Product {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "product::Type", tag = "3")]
    pub r#type: i32,
    #[prost(string, tag = "4")]
    pub primary_product_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub collection_member_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub gtin: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub brands: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(btree_map = "string, message", tag = "12")]
    pub attributes:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, CustomAttribute>,
    #[prost(string, repeated, tag = "13")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "14")]
    pub price_info: ::core::option::Option<PriceInfo>,
    #[prost(message, optional, tag = "15")]
    pub rating: ::core::option::Option<Rating>,
    #[prost(message, optional, tag = "18")]
    pub available_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "product::Availability", tag = "19")]
    pub availability: i32,
    #[prost(message, optional, tag = "20")]
    pub available_quantity: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "21")]
    pub fulfillment_info: ::prost::alloc::vec::Vec<FulfillmentInfo>,
    #[prost(string, tag = "22")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "23")]
    pub images: ::prost::alloc::vec::Vec<Image>,
    #[prost(message, optional, tag = "24")]
    pub audience: ::core::option::Option<Audience>,
    #[prost(message, optional, tag = "25")]
    pub color_info: ::core::option::Option<ColorInfo>,
    #[prost(string, repeated, tag = "26")]
    pub sizes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "27")]
    pub materials: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "28")]
    pub patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "29")]
    pub conditions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "34")]
    pub promotions: ::prost::alloc::vec::Vec<Promotion>,
    #[prost(message, optional, tag = "33")]
    pub publish_time: ::core::option::Option<::prost_types::Timestamp>,
    #[deprecated]
    #[prost(message, optional, tag = "30")]
    pub retrievable_fields: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, repeated, tag = "31")]
    pub variants: ::prost::alloc::vec::Vec<Product>,
    #[prost(message, repeated, tag = "35")]
    pub local_inventories: ::prost::alloc::vec::Vec<LocalInventory>,
    #[prost(oneof = "product::Expiration", tags = "16, 17")]
    pub expiration: ::core::option::Option<product::Expiration>,
}
/// Nested message and enum types in `Product`.
pub mod product {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Primary = 1,
        Variant = 2,
        Collection = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Primary => "PRIMARY",
                Type::Variant => "VARIANT",
                Type::Collection => "COLLECTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIMARY" => Some(Self::Primary),
                "VARIANT" => Some(Self::Variant),
                "COLLECTION" => Some(Self::Collection),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Availability {
        Unspecified = 0,
        InStock = 1,
        OutOfStock = 2,
        Preorder = 3,
        Backorder = 4,
    }
    impl Availability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Availability::Unspecified => "AVAILABILITY_UNSPECIFIED",
                Availability::InStock => "IN_STOCK",
                Availability::OutOfStock => "OUT_OF_STOCK",
                Availability::Preorder => "PREORDER",
                Availability::Backorder => "BACKORDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AVAILABILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_STOCK" => Some(Self::InStock),
                "OUT_OF_STOCK" => Some(Self::OutOfStock),
                "PREORDER" => Some(Self::Preorder),
                "BACKORDER" => Some(Self::Backorder),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        #[prost(message, tag = "16")]
        ExpireTime(::prost_types::Timestamp),
        #[prost(message, tag = "17")]
        Ttl(::prost_types::Duration),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserEvent {
    #[prost(string, tag = "1")]
    pub event_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub visitor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag = "4")]
    pub experiment_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub attribution_token: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub product_details: ::prost::alloc::vec::Vec<ProductDetail>,
    #[prost(message, optional, tag = "22")]
    pub completion_detail: ::core::option::Option<CompletionDetail>,
    #[prost(btree_map = "string, message", tag = "7")]
    pub attributes:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, CustomAttribute>,
    #[prost(string, tag = "8")]
    pub cart_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub purchase_transaction: ::core::option::Option<PurchaseTransaction>,
    #[prost(string, tag = "10")]
    pub search_query: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "18")]
    pub offset: i32,
    #[prost(string, repeated, tag = "11")]
    pub page_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "12")]
    pub user_info: ::core::option::Option<UserInfo>,
    #[prost(string, tag = "13")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub referrer_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub page_view_id: ::prost::alloc::string::String,
    #[prost(string, tag = "23")]
    pub entity: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductDetail {
    #[prost(message, optional, tag = "1")]
    pub product: ::core::option::Option<Product>,
    #[prost(message, optional, tag = "2")]
    pub quantity: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionDetail {
    #[prost(string, tag = "1")]
    pub completion_attribution_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub selected_suggestion: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub selected_position: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurchaseTransaction {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub revenue: f32,
    #[prost(float, tag = "3")]
    pub tax: f32,
    #[prost(float, tag = "4")]
    pub cost: f32,
    #[prost(string, tag = "5")]
    pub currency_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    #[prost(string, repeated, tag = "1")]
    pub input_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub data_schema: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuerySource {
    #[prost(string, tag = "5")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub data_schema: ::prost::alloc::string::String,
    #[prost(oneof = "big_query_source::Partition", tags = "6")]
    pub partition: ::core::option::Option<big_query_source::Partition>,
}
/// Nested message and enum types in `BigQuerySource`.
pub mod big_query_source {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Partition {
        #[prost(message, tag = "6")]
        PartitionDate(super::super::super::super::r#type::Date),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductInlineSource {
    #[prost(message, repeated, tag = "1")]
    pub products: ::prost::alloc::vec::Vec<Product>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserEventInlineSource {
    #[prost(message, repeated, tag = "1")]
    pub user_events: ::prost::alloc::vec::Vec<UserEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportErrorsConfig {
    #[prost(oneof = "import_errors_config::Destination", tags = "1")]
    pub destination: ::core::option::Option<import_errors_config::Destination>,
}
/// Nested message and enum types in `ImportErrorsConfig`.
pub mod import_errors_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(string, tag = "1")]
        GcsPrefix(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportProductsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input_config: ::core::option::Option<ProductInputConfig>,
    #[prost(message, optional, tag = "3")]
    pub errors_config: ::core::option::Option<ImportErrorsConfig>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(enumeration = "import_products_request::ReconciliationMode", tag = "5")]
    pub reconciliation_mode: i32,
    #[prost(string, tag = "7")]
    pub notification_pubsub_topic: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ImportProductsRequest`.
pub mod import_products_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ReconciliationMode {
        Unspecified = 0,
        Incremental = 1,
        Full = 2,
    }
    impl ReconciliationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReconciliationMode::Unspecified => "RECONCILIATION_MODE_UNSPECIFIED",
                ReconciliationMode::Incremental => "INCREMENTAL",
                ReconciliationMode::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECONCILIATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCREMENTAL" => Some(Self::Incremental),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input_config: ::core::option::Option<UserEventInputConfig>,
    #[prost(message, optional, tag = "3")]
    pub errors_config: ::core::option::Option<ImportErrorsConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCompletionDataRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input_config: ::core::option::Option<CompletionDataInputConfig>,
    #[prost(string, tag = "3")]
    pub notification_pubsub_topic: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductInputConfig {
    #[prost(oneof = "product_input_config::Source", tags = "1, 2, 3")]
    pub source: ::core::option::Option<product_input_config::Source>,
}
/// Nested message and enum types in `ProductInputConfig`.
pub mod product_input_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        ProductInlineSource(super::ProductInlineSource),
        #[prost(message, tag = "2")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "3")]
        BigQuerySource(super::BigQuerySource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserEventInputConfig {
    #[prost(oneof = "user_event_input_config::Source", tags = "1, 2, 3")]
    pub source: ::core::option::Option<user_event_input_config::Source>,
}
/// Nested message and enum types in `UserEventInputConfig`.
pub mod user_event_input_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        UserEventInlineSource(super::UserEventInlineSource),
        #[prost(message, tag = "2")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "3")]
        BigQuerySource(super::BigQuerySource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionDataInputConfig {
    #[prost(oneof = "completion_data_input_config::Source", tags = "1")]
    pub source: ::core::option::Option<completion_data_input_config::Source>,
}
/// Nested message and enum types in `CompletionDataInputConfig`.
pub mod completion_data_input_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        BigQuerySource(super::BigQuerySource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
    #[deprecated]
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub notification_pubsub_topic: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportProductsResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "2")]
    pub errors_config: ::core::option::Option<ImportErrorsConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "2")]
    pub errors_config: ::core::option::Option<ImportErrorsConfig>,
    #[prost(message, optional, tag = "3")]
    pub import_summary: ::core::option::Option<UserEventImportSummary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserEventImportSummary {
    #[prost(int64, tag = "1")]
    pub joined_events_count: i64,
    #[prost(int64, tag = "2")]
    pub unjoined_events_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCompletionDataResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeProductsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeProductsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeProductsResponse {
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    #[prost(string, repeated, tag = "2")]
    pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeUserEventsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeUserEventsResponse {
    #[prost(int64, tag = "1")]
    pub purged_events_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteUserEventRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub user_event: ::core::option::Option<UserEvent>,
    #[prost(bool, tag = "3")]
    pub write_async: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectUserEventRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_event: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub ets: i64,
    #[prost(string, tag = "5")]
    pub raw_json: ::prost::alloc::string::String,
    #[prost(oneof = "collect_user_event_request::ConversionRule", tags = "6")]
    pub conversion_rule: ::core::option::Option<collect_user_event_request::ConversionRule>,
}
/// Nested message and enum types in `CollectUserEventRequest`.
pub mod collect_user_event_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConversionRule {
        #[prost(string, tag = "6")]
        PrebuiltRule(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejoinUserEventsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(
        enumeration = "rejoin_user_events_request::UserEventRejoinScope",
        tag = "2"
    )]
    pub user_event_rejoin_scope: i32,
}
/// Nested message and enum types in `RejoinUserEventsRequest`.
pub mod rejoin_user_events_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum UserEventRejoinScope {
        Unspecified = 0,
        JoinedEvents = 1,
        UnjoinedEvents = 2,
    }
    impl UserEventRejoinScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserEventRejoinScope::Unspecified => "USER_EVENT_REJOIN_SCOPE_UNSPECIFIED",
                UserEventRejoinScope::JoinedEvents => "JOINED_EVENTS",
                UserEventRejoinScope::UnjoinedEvents => "UNJOINED_EVENTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "USER_EVENT_REJOIN_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "JOINED_EVENTS" => Some(Self::JoinedEvents),
                "UNJOINED_EVENTS" => Some(Self::UnjoinedEvents),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RejoinUserEventsResponse {
    #[prost(int64, tag = "1")]
    pub rejoined_user_events_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RejoinUserEventsMetadata {}
/// Generated client implementations.
pub mod user_event_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for ingesting end user actions on the customer website.
    #[derive(Debug, Clone)]
    pub struct UserEventServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> UserEventServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserEventServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            UserEventServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Writes a single user event.
        pub async fn write_user_event(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteUserEventRequest>,
        ) -> std::result::Result<tonic::Response<super::UserEvent>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.UserEventService/WriteUserEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.UserEventService",
                "WriteUserEvent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Writes a single user event from the browser. This uses a GET request to
        /// due to browser restriction of POST-ing to a 3rd party domain.
        ///
        /// This method is used only by the Retail API JavaScript pixel and Google Tag
        /// Manager. Users should not call this method directly.
        pub async fn collect_user_event(
            &mut self,
            request: impl tonic::IntoRequest<super::CollectUserEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.UserEventService/CollectUserEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.UserEventService",
                "CollectUserEvent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes permanently all user events specified by the filter provided.
        /// Depending on the number of events specified by the filter, this operation
        /// could take hours or days to complete. To test a filter, use the list
        /// command first.
        pub async fn purge_user_events(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeUserEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.UserEventService/PurgeUserEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.UserEventService",
                "PurgeUserEvents",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Bulk import of User events. Request processing might be
        /// synchronous. Events that already exist are skipped.
        /// Use this method for backfilling historical user events.
        ///
        /// `Operation.response` is of type `ImportResponse`. Note that it is
        /// possible for a subset of the items to be successfully inserted.
        /// `Operation.metadata` is of type `ImportMetadata`.
        pub async fn import_user_events(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportUserEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.UserEventService/ImportUserEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.UserEventService",
                "ImportUserEvents",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Starts a user-event rejoin operation with latest product catalog. Events
        /// are not annotated with detailed product information for products that are
        /// missing from the catalog when the user event is ingested. These
        /// events are stored as unjoined events with limited usage on training and
        /// serving. You can use this method to start a join operation on specified
        /// events with the latest version of product catalog. You can also use this
        /// method to correct events joined with the wrong product catalog. A rejoin
        /// operation can take hours or days to complete.
        pub async fn rejoin_user_events(
            &mut self,
            request: impl tonic::IntoRequest<super::RejoinUserEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.UserEventService/RejoinUserEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.UserEventService",
                "RejoinUserEvents",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryRequest {
    #[prost(string, tag = "1")]
    pub catalog: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub visitor_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub language_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub device_type: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub dataset: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub max_suggestions: i32,
    #[prost(bool, tag = "9")]
    pub enable_attribute_suggestions: bool,
    #[prost(string, tag = "10")]
    pub entity: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub completion_results: ::prost::alloc::vec::Vec<complete_query_response::CompletionResult>,
    #[prost(string, tag = "2")]
    pub attribution_token: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(message, repeated, tag = "3")]
    pub recent_search_results:
        ::prost::alloc::vec::Vec<complete_query_response::RecentSearchResult>,
}
/// Nested message and enum types in `CompleteQueryResponse`.
pub mod complete_query_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompletionResult {
        #[prost(string, tag = "1")]
        pub suggestion: ::prost::alloc::string::String,
        #[prost(btree_map = "string, message", tag = "2")]
        pub attributes: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            super::CustomAttribute,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RecentSearchResult {
        #[prost(string, tag = "1")]
        pub recent_search: ::prost::alloc::string::String,
    }
}
/// Generated client implementations.
pub mod completion_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Autocomplete service for retail.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    #[derive(Debug, Clone)]
    pub struct CompletionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CompletionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CompletionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            CompletionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Completes the specified prefix with keyword suggestions.
        ///
        /// This feature is only available for users who have Retail Search enabled.
        /// Enable Retail Search on Cloud Console before using this feature.
        pub async fn complete_query(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteQueryRequest>,
        ) -> std::result::Result<tonic::Response<super::CompleteQueryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CompletionService/CompleteQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CompletionService",
                "CompleteQuery",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Bulk import of processed completion dataset.
        ///
        /// Request processing is asynchronous. Partial updating is not supported.
        ///
        /// The operation is successfully finished only after the imported suggestions
        /// are indexed successfully and ready for serving. The process takes hours.
        ///
        /// This feature is only available for users who have Retail Search enabled.
        /// Enable Retail Search on Cloud Console before using this feature.
        pub async fn import_completion_data(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportCompletionDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CompletionService/ImportCompletionData",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CompletionService",
                "ImportCompletionData",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductLevelConfig {
    #[prost(string, tag = "1")]
    pub ingestion_product_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub merchant_center_product_id_field: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CatalogAttribute {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub in_use: bool,
    #[prost(enumeration = "catalog_attribute::AttributeType", tag = "10")]
    pub r#type: i32,
    #[prost(enumeration = "catalog_attribute::IndexableOption", tag = "5")]
    pub indexable_option: i32,
    #[prost(enumeration = "catalog_attribute::DynamicFacetableOption", tag = "6")]
    pub dynamic_facetable_option: i32,
    #[prost(enumeration = "catalog_attribute::SearchableOption", tag = "7")]
    pub searchable_option: i32,
    #[prost(enumeration = "catalog_attribute::ExactSearchableOption", tag = "11")]
    pub exact_searchable_option: i32,
    #[prost(enumeration = "catalog_attribute::RetrievableOption", tag = "12")]
    pub retrievable_option: i32,
    #[prost(message, optional, tag = "13")]
    pub facet_config: ::core::option::Option<catalog_attribute::FacetConfig>,
}
/// Nested message and enum types in `CatalogAttribute`.
pub mod catalog_attribute {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FacetConfig {
        #[prost(message, repeated, tag = "1")]
        pub facet_intervals: ::prost::alloc::vec::Vec<super::Interval>,
        #[prost(message, repeated, tag = "2")]
        pub ignored_facet_values: ::prost::alloc::vec::Vec<facet_config::IgnoredFacetValues>,
        #[prost(message, repeated, tag = "3")]
        pub merged_facet_values: ::prost::alloc::vec::Vec<facet_config::MergedFacetValue>,
        #[prost(message, optional, tag = "4")]
        pub merged_facet: ::core::option::Option<facet_config::MergedFacet>,
        #[prost(message, optional, tag = "5")]
        pub rerank_config: ::core::option::Option<facet_config::RerankConfig>,
    }
    /// Nested message and enum types in `FacetConfig`.
    pub mod facet_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct IgnoredFacetValues {
            #[prost(string, repeated, tag = "1")]
            pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "2")]
            pub start_time: ::core::option::Option<::prost_types::Timestamp>,
            #[prost(message, optional, tag = "3")]
            pub end_time: ::core::option::Option<::prost_types::Timestamp>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MergedFacetValue {
            #[prost(string, repeated, tag = "1")]
            pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, tag = "2")]
            pub merged_value: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MergedFacet {
            #[prost(string, tag = "1")]
            pub merged_facet_key: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RerankConfig {
            #[prost(bool, tag = "1")]
            pub rerank_facet: bool,
            #[prost(string, repeated, tag = "2")]
            pub facet_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AttributeType {
        Unknown = 0,
        Textual = 1,
        Numerical = 2,
    }
    impl AttributeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttributeType::Unknown => "UNKNOWN",
                AttributeType::Textual => "TEXTUAL",
                AttributeType::Numerical => "NUMERICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "TEXTUAL" => Some(Self::Textual),
                "NUMERICAL" => Some(Self::Numerical),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum IndexableOption {
        Unspecified = 0,
        IndexableEnabled = 1,
        IndexableDisabled = 2,
    }
    impl IndexableOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IndexableOption::Unspecified => "INDEXABLE_OPTION_UNSPECIFIED",
                IndexableOption::IndexableEnabled => "INDEXABLE_ENABLED",
                IndexableOption::IndexableDisabled => "INDEXABLE_DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INDEXABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                "INDEXABLE_ENABLED" => Some(Self::IndexableEnabled),
                "INDEXABLE_DISABLED" => Some(Self::IndexableDisabled),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DynamicFacetableOption {
        Unspecified = 0,
        DynamicFacetableEnabled = 1,
        DynamicFacetableDisabled = 2,
    }
    impl DynamicFacetableOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DynamicFacetableOption::Unspecified => "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED",
                DynamicFacetableOption::DynamicFacetableEnabled => "DYNAMIC_FACETABLE_ENABLED",
                DynamicFacetableOption::DynamicFacetableDisabled => "DYNAMIC_FACETABLE_DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                "DYNAMIC_FACETABLE_ENABLED" => Some(Self::DynamicFacetableEnabled),
                "DYNAMIC_FACETABLE_DISABLED" => Some(Self::DynamicFacetableDisabled),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SearchableOption {
        Unspecified = 0,
        SearchableEnabled = 1,
        SearchableDisabled = 2,
    }
    impl SearchableOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchableOption::Unspecified => "SEARCHABLE_OPTION_UNSPECIFIED",
                SearchableOption::SearchableEnabled => "SEARCHABLE_ENABLED",
                SearchableOption::SearchableDisabled => "SEARCHABLE_DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEARCHABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                "SEARCHABLE_ENABLED" => Some(Self::SearchableEnabled),
                "SEARCHABLE_DISABLED" => Some(Self::SearchableDisabled),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ExactSearchableOption {
        Unspecified = 0,
        ExactSearchableEnabled = 1,
        ExactSearchableDisabled = 2,
    }
    impl ExactSearchableOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExactSearchableOption::Unspecified => "EXACT_SEARCHABLE_OPTION_UNSPECIFIED",
                ExactSearchableOption::ExactSearchableEnabled => "EXACT_SEARCHABLE_ENABLED",
                ExactSearchableOption::ExactSearchableDisabled => "EXACT_SEARCHABLE_DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXACT_SEARCHABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                "EXACT_SEARCHABLE_ENABLED" => Some(Self::ExactSearchableEnabled),
                "EXACT_SEARCHABLE_DISABLED" => Some(Self::ExactSearchableDisabled),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum RetrievableOption {
        Unspecified = 0,
        RetrievableEnabled = 1,
        RetrievableDisabled = 2,
    }
    impl RetrievableOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RetrievableOption::Unspecified => "RETRIEVABLE_OPTION_UNSPECIFIED",
                RetrievableOption::RetrievableEnabled => "RETRIEVABLE_ENABLED",
                RetrievableOption::RetrievableDisabled => "RETRIEVABLE_DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RETRIEVABLE_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                "RETRIEVABLE_ENABLED" => Some(Self::RetrievableEnabled),
                "RETRIEVABLE_DISABLED" => Some(Self::RetrievableDisabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributesConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(btree_map = "string, message", tag = "2")]
    pub catalog_attributes:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, CatalogAttribute>,
    #[prost(enumeration = "AttributeConfigLevel", tag = "3")]
    pub attribute_config_level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub matching_order: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub max_suggestions: i32,
    #[prost(int32, tag = "4")]
    pub min_prefix_length: i32,
    #[prost(bool, tag = "11")]
    pub auto_learning: bool,
    #[prost(message, optional, tag = "5")]
    pub suggestions_input_config: ::core::option::Option<CompletionDataInputConfig>,
    #[prost(string, tag = "6")]
    pub last_suggestions_import_operation: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub denylist_input_config: ::core::option::Option<CompletionDataInputConfig>,
    #[prost(string, tag = "8")]
    pub last_denylist_import_operation: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub allowlist_input_config: ::core::option::Option<CompletionDataInputConfig>,
    #[prost(string, tag = "10")]
    pub last_allowlist_import_operation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Catalog {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub product_level_config: ::core::option::Option<ProductLevelConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictRequest {
    #[prost(string, tag = "1")]
    pub placement: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub user_event: ::core::option::Option<UserEvent>,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[deprecated]
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub validate_only: bool,
    #[prost(btree_map = "string, message", tag = "7")]
    pub params:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost_types::Value>,
    #[prost(btree_map = "string, string", tag = "8")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<predict_response::PredictionResult>,
    #[prost(string, tag = "2")]
    pub attribution_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub missing_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Nested message and enum types in `PredictResponse`.
pub mod predict_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PredictionResult {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(btree_map = "string, message", tag = "2")]
        pub metadata: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost_types::Value,
        >,
    }
}
/// Generated client implementations.
pub mod prediction_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for making recommendation prediction.
    #[derive(Debug, Clone)]
    pub struct PredictionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> PredictionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PredictionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            PredictionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Makes a recommendation prediction.
        pub async fn predict(
            &mut self,
            request: impl tonic::IntoRequest<super::PredictRequest>,
        ) -> std::result::Result<tonic::Response<super::PredictResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.PredictionService/Predict",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.PredictionService",
                "Predict",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub product: ::core::option::Option<Product>,
    #[prost(string, tag = "3")]
    pub product_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductRequest {
    #[prost(message, optional, tag = "1")]
    pub product: ::core::option::Option<Product>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteProductRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsResponse {
    #[prost(message, repeated, tag = "1")]
    pub products: ::prost::alloc::vec::Vec<Product>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetInventoryRequest {
    #[prost(message, optional, tag = "1")]
    pub inventory: ::core::option::Option<Product>,
    #[prost(message, optional, tag = "2")]
    pub set_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "3")]
    pub set_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetInventoryMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetInventoryResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddFulfillmentPlacesRequest {
    #[prost(string, tag = "1")]
    pub product: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub place_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub add_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "5")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddFulfillmentPlacesMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddFulfillmentPlacesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddLocalInventoriesRequest {
    #[prost(string, tag = "1")]
    pub product: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub local_inventories: ::prost::alloc::vec::Vec<LocalInventory>,
    #[prost(message, optional, tag = "4")]
    pub add_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "5")]
    pub add_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "6")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddLocalInventoriesMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddLocalInventoriesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveLocalInventoriesRequest {
    #[prost(string, tag = "1")]
    pub product: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub place_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub remove_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveLocalInventoriesMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveLocalInventoriesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveFulfillmentPlacesRequest {
    #[prost(string, tag = "1")]
    pub product: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub place_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub remove_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "5")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveFulfillmentPlacesMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveFulfillmentPlacesResponse {}
/// Generated client implementations.
pub mod product_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for ingesting [Product][google.cloud.retail.v2.Product] information
    /// of the customer's website.
    #[derive(Debug, Clone)]
    pub struct ProductServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ProductServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProductServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ProductServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a [Product][google.cloud.retail.v2.Product].
        pub async fn create_product(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProductRequest>,
        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/CreateProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "CreateProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a [Product][google.cloud.retail.v2.Product].
        pub async fn get_product(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProductRequest>,
        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/GetProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "GetProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of [Product][google.cloud.retail.v2.Product]s.
        pub async fn list_products(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProductsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListProductsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/ListProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "ListProducts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a [Product][google.cloud.retail.v2.Product].
        pub async fn update_product(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateProductRequest>,
        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/UpdateProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "UpdateProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a [Product][google.cloud.retail.v2.Product].
        pub async fn delete_product(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteProductRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/DeleteProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "DeleteProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes all selected [Product][google.cloud.retail.v2.Product]s
        /// under a branch.
        ///
        /// This process is asynchronous. If the request is valid, the removal will be
        /// enqueued and processed offline. Depending on the number of
        /// [Product][google.cloud.retail.v2.Product]s, this operation could take hours
        /// to complete. Before the operation completes, some
        /// [Product][google.cloud.retail.v2.Product]s may still be returned by
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
        /// or
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
        ///
        /// Depending on the number of [Product][google.cloud.retail.v2.Product]s, this
        /// operation could take hours to complete. To get a sample of
        /// [Product][google.cloud.retail.v2.Product]s that would be deleted, set
        /// [PurgeProductsRequest.force][google.cloud.retail.v2.PurgeProductsRequest.force]
        /// to false.
        pub async fn purge_products(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeProductsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/PurgeProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "PurgeProducts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Bulk import of multiple [Product][google.cloud.retail.v2.Product]s.
        ///
        /// Request processing may be synchronous.
        /// Non-existing items are created.
        ///
        /// Note that it is possible for a subset of the
        /// [Product][google.cloud.retail.v2.Product]s to be successfully updated.
        pub async fn import_products(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportProductsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/ImportProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "ImportProducts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates inventory information for a
        /// [Product][google.cloud.retail.v2.Product] while respecting the last update
        /// timestamps of each inventory field.
        ///
        /// This process is asynchronous and does not require the
        /// [Product][google.cloud.retail.v2.Product] to exist before updating
        /// fulfillment information. If the request is valid, the update is enqueued
        /// and processed downstream. As a consequence, when a response is returned,
        /// updates are not immediately manifested in the
        /// [Product][google.cloud.retail.v2.Product] queried by
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
        /// or
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
        ///
        /// When inventory is updated with
        /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
        /// and
        /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct],
        /// the specified inventory field value(s) overwrite any existing value(s)
        /// while ignoring the last update time for this field. Furthermore, the last
        /// update times for the specified inventory fields are overwritten by the
        /// times of the
        /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
        /// or
        /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
        /// request.
        ///
        /// If no inventory fields are set in
        /// [CreateProductRequest.product][google.cloud.retail.v2.CreateProductRequest.product],
        /// then any pre-existing inventory information for this product is used.
        ///
        /// If no inventory fields are set in
        /// [SetInventoryRequest.set_mask][google.cloud.retail.v2.SetInventoryRequest.set_mask],
        /// then any existing inventory information is preserved.
        ///
        /// Pre-existing inventory information can only be updated with
        /// [ProductService.SetInventory][google.cloud.retail.v2.ProductService.SetInventory],
        /// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces],
        /// and
        /// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces].
        ///
        /// The returned [Operation][google.longrunning.Operation]s is obsolete after
        /// one day, and the [GetOperation][google.longrunning.Operations.GetOperation]
        /// API returns `NOT_FOUND` afterwards.
        ///
        /// If conflicting updates are issued, the
        /// [Operation][google.longrunning.Operation]s associated with the stale
        /// updates are not marked as [done][google.longrunning.Operation.done] until
        /// they are obsolete.
        pub async fn set_inventory(
            &mut self,
            request: impl tonic::IntoRequest<super::SetInventoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/SetInventory",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "SetInventory",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// We recommend that you use the
        /// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
        /// method instead of the
        /// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]
        /// method.
        /// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
        /// achieves the same results but provides more fine-grained control over
        /// ingesting local inventory data.
        ///
        /// Incrementally adds place IDs to
        /// [Product.fulfillment_info.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids].
        ///
        /// This process is asynchronous and does not require the
        /// [Product][google.cloud.retail.v2.Product] to exist before updating
        /// fulfillment information. If the request is valid, the update will be
        /// enqueued and processed downstream. As a consequence, when a response is
        /// returned, the added place IDs are not immediately manifested in the
        /// [Product][google.cloud.retail.v2.Product] queried by
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
        /// or
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
        ///
        /// The returned [Operation][google.longrunning.Operation]s will be obsolete
        /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
        /// API will return NOT_FOUND afterwards.
        ///
        /// If conflicting updates are issued, the
        /// [Operation][google.longrunning.Operation]s associated with the stale
        /// updates will not be marked as [done][google.longrunning.Operation.done]
        /// until being obsolete.
        pub async fn add_fulfillment_places(
            &mut self,
            request: impl tonic::IntoRequest<super::AddFulfillmentPlacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/AddFulfillmentPlaces",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "AddFulfillmentPlaces",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// We recommend that you use the
        /// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
        /// method instead of the
        /// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]
        /// method.
        /// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
        /// achieves the same results but provides more fine-grained control over
        /// ingesting local inventory data.
        ///
        /// Incrementally removes place IDs from a
        /// [Product.fulfillment_info.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids].
        ///
        /// This process is asynchronous and does not require the
        /// [Product][google.cloud.retail.v2.Product] to exist before updating
        /// fulfillment information. If the request is valid, the update will be
        /// enqueued and processed downstream. As a consequence, when a response is
        /// returned, the removed place IDs are not immediately manifested in the
        /// [Product][google.cloud.retail.v2.Product] queried by
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
        /// or
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
        ///
        /// The returned [Operation][google.longrunning.Operation]s will be obsolete
        /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
        /// API will return NOT_FOUND afterwards.
        ///
        /// If conflicting updates are issued, the
        /// [Operation][google.longrunning.Operation]s associated with the stale
        /// updates will not be marked as [done][google.longrunning.Operation.done]
        /// until being obsolete.
        pub async fn remove_fulfillment_places(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveFulfillmentPlacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/RemoveFulfillmentPlaces",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "RemoveFulfillmentPlaces",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates local inventory information for a
        /// [Product][google.cloud.retail.v2.Product] at a list of places, while
        /// respecting the last update timestamps of each inventory field.
        ///
        /// This process is asynchronous and does not require the
        /// [Product][google.cloud.retail.v2.Product] to exist before updating
        /// inventory information. If the request is valid, the update will be enqueued
        /// and processed downstream. As a consequence, when a response is returned,
        /// updates are not immediately manifested in the
        /// [Product][google.cloud.retail.v2.Product] queried by
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
        /// or
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
        ///
        /// Local inventory information can only be modified using this method.
        /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
        /// and
        /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
        /// has no effect on local inventories.
        ///
        /// The returned [Operation][google.longrunning.Operation]s will be obsolete
        /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
        /// API will return NOT_FOUND afterwards.
        ///
        /// If conflicting updates are issued, the
        /// [Operation][google.longrunning.Operation]s associated with the stale
        /// updates will not be marked as [done][google.longrunning.Operation.done]
        /// until being obsolete.
        pub async fn add_local_inventories(
            &mut self,
            request: impl tonic::IntoRequest<super::AddLocalInventoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/AddLocalInventories",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "AddLocalInventories",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Remove local inventory information for a
        /// [Product][google.cloud.retail.v2.Product] at a list of places at a removal
        /// timestamp.
        ///
        /// This process is asynchronous. If the request is valid, the removal will be
        /// enqueued and processed downstream. As a consequence, when a response is
        /// returned, removals are not immediately manifested in the
        /// [Product][google.cloud.retail.v2.Product] queried by
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
        /// or
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
        ///
        /// Local inventory information can only be removed using this method.
        /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
        /// and
        /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
        /// has no effect on local inventories.
        ///
        /// The returned [Operation][google.longrunning.Operation]s will be obsolete
        /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
        /// API will return NOT_FOUND afterwards.
        ///
        /// If conflicting updates are issued, the
        /// [Operation][google.longrunning.Operation]s associated with the stale
        /// updates will not be marked as [done][google.longrunning.Operation.done]
        /// until being obsolete.
        pub async fn remove_local_inventories(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveLocalInventoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ProductService/RemoveLocalInventories",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ProductService",
                "RemoveLocalInventories",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRequest {
    #[prost(string, tag = "1")]
    pub placement: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub branch: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub visitor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub user_info: ::core::option::Option<UserInfo>,
    #[prost(int32, tag = "7")]
    pub page_size: i32,
    #[prost(string, tag = "8")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "9")]
    pub offset: i32,
    #[prost(string, tag = "10")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "28")]
    pub canonical_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "12")]
    pub facet_specs: ::prost::alloc::vec::Vec<search_request::FacetSpec>,
    #[deprecated]
    #[prost(message, optional, tag = "21")]
    pub dynamic_facet_spec: ::core::option::Option<search_request::DynamicFacetSpec>,
    #[prost(message, optional, tag = "13")]
    pub boost_spec: ::core::option::Option<search_request::BoostSpec>,
    #[prost(message, optional, tag = "14")]
    pub query_expansion_spec: ::core::option::Option<search_request::QueryExpansionSpec>,
    #[prost(string, repeated, tag = "17")]
    pub variant_rollup_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "23")]
    pub page_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "search_request::SearchMode", tag = "31")]
    pub search_mode: i32,
    #[prost(message, optional, tag = "32")]
    pub personalization_spec: ::core::option::Option<search_request::PersonalizationSpec>,
    #[prost(btree_map = "string, string", tag = "34")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "35")]
    pub spell_correction_spec: ::core::option::Option<search_request::SpellCorrectionSpec>,
    #[prost(string, tag = "38")]
    pub entity: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SearchRequest`.
pub mod search_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FacetSpec {
        #[prost(message, optional, tag = "1")]
        pub facet_key: ::core::option::Option<facet_spec::FacetKey>,
        #[prost(int32, tag = "2")]
        pub limit: i32,
        #[prost(string, repeated, tag = "3")]
        pub excluded_filter_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "4")]
        pub enable_dynamic_position: bool,
    }
    /// Nested message and enum types in `FacetSpec`.
    pub mod facet_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FacetKey {
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "2")]
            pub intervals: ::prost::alloc::vec::Vec<super::super::Interval>,
            #[prost(string, repeated, tag = "3")]
            pub restricted_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, repeated, tag = "8")]
            pub prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, repeated, tag = "9")]
            pub contains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, tag = "10")]
            pub case_insensitive: bool,
            #[prost(string, tag = "4")]
            pub order_by: ::prost::alloc::string::String,
            #[prost(string, tag = "5")]
            pub query: ::prost::alloc::string::String,
            #[prost(bool, tag = "11")]
            pub return_min_max: bool,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DynamicFacetSpec {
        #[prost(enumeration = "dynamic_facet_spec::Mode", tag = "1")]
        pub mode: i32,
    }
    /// Nested message and enum types in `DynamicFacetSpec`.
    pub mod dynamic_facet_spec {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            Disabled = 1,
            Enabled = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Mode::Unspecified => "MODE_UNSPECIFIED",
                    Mode::Disabled => "DISABLED",
                    Mode::Enabled => "ENABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "DISABLED" => Some(Self::Disabled),
                    "ENABLED" => Some(Self::Enabled),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoostSpec {
        #[prost(message, repeated, tag = "1")]
        pub condition_boost_specs: ::prost::alloc::vec::Vec<boost_spec::ConditionBoostSpec>,
        #[prost(bool, optional, tag = "2")]
        pub skip_boost_spec_validation: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `BoostSpec`.
    pub mod boost_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ConditionBoostSpec {
            #[prost(string, tag = "1")]
            pub condition: ::prost::alloc::string::String,
            #[prost(float, tag = "2")]
            pub boost: f32,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QueryExpansionSpec {
        #[prost(enumeration = "query_expansion_spec::Condition", tag = "1")]
        pub condition: i32,
        #[prost(bool, tag = "2")]
        pub pin_unexpanded_results: bool,
    }
    /// Nested message and enum types in `QueryExpansionSpec`.
    pub mod query_expansion_spec {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Condition {
            Unspecified = 0,
            Disabled = 1,
            Auto = 3,
        }
        impl Condition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Condition::Unspecified => "CONDITION_UNSPECIFIED",
                    Condition::Disabled => "DISABLED",
                    Condition::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                    "DISABLED" => Some(Self::Disabled),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PersonalizationSpec {
        #[prost(enumeration = "personalization_spec::Mode", tag = "1")]
        pub mode: i32,
    }
    /// Nested message and enum types in `PersonalizationSpec`.
    pub mod personalization_spec {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            Auto = 1,
            Disabled = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Mode::Unspecified => "MODE_UNSPECIFIED",
                    Mode::Auto => "AUTO",
                    Mode::Disabled => "DISABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "AUTO" => Some(Self::Auto),
                    "DISABLED" => Some(Self::Disabled),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SpellCorrectionSpec {
        #[prost(enumeration = "spell_correction_spec::Mode", tag = "1")]
        pub mode: i32,
    }
    /// Nested message and enum types in `SpellCorrectionSpec`.
    pub mod spell_correction_spec {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            SuggestionOnly = 1,
            Auto = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Mode::Unspecified => "MODE_UNSPECIFIED",
                    Mode::SuggestionOnly => "SUGGESTION_ONLY",
                    Mode::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SUGGESTION_ONLY" => Some(Self::SuggestionOnly),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SearchMode {
        Unspecified = 0,
        ProductSearchOnly = 1,
        FacetedSearchOnly = 2,
    }
    impl SearchMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchMode::Unspecified => "SEARCH_MODE_UNSPECIFIED",
                SearchMode::ProductSearchOnly => "PRODUCT_SEARCH_ONLY",
                SearchMode::FacetedSearchOnly => "FACETED_SEARCH_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEARCH_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRODUCT_SEARCH_ONLY" => Some(Self::ProductSearchOnly),
                "FACETED_SEARCH_ONLY" => Some(Self::FacetedSearchOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<search_response::SearchResult>,
    #[prost(message, repeated, tag = "2")]
    pub facets: ::prost::alloc::vec::Vec<search_response::Facet>,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
    #[prost(string, tag = "4")]
    pub corrected_query: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub attribution_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub query_expansion_info: ::core::option::Option<search_response::QueryExpansionInfo>,
    #[prost(string, tag = "10")]
    pub redirect_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "12")]
    pub applied_controls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "14")]
    pub invalid_condition_boost_specs:
        ::prost::alloc::vec::Vec<search_request::boost_spec::ConditionBoostSpec>,
    #[prost(message, repeated, tag = "17")]
    pub experiment_info: ::prost::alloc::vec::Vec<ExperimentInfo>,
}
/// Nested message and enum types in `SearchResponse`.
pub mod search_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SearchResult {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub product: ::core::option::Option<super::Product>,
        #[prost(int32, tag = "3")]
        pub matching_variant_count: i32,
        #[prost(btree_map = "string, message", tag = "4")]
        pub matching_variant_fields: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost_types::FieldMask,
        >,
        #[prost(btree_map = "string, message", tag = "5")]
        pub variant_rollup_values: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost_types::Value,
        >,
        #[prost(string, repeated, tag = "7")]
        pub personal_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Facet {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub values: ::prost::alloc::vec::Vec<facet::FacetValue>,
        #[prost(bool, tag = "3")]
        pub dynamic_facet: bool,
    }
    /// Nested message and enum types in `Facet`.
    pub mod facet {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FacetValue {
            #[prost(int64, tag = "3")]
            pub count: i64,
            #[prost(double, tag = "5")]
            pub min_value: f64,
            #[prost(double, tag = "6")]
            pub max_value: f64,
            #[prost(oneof = "facet_value::FacetValue", tags = "1, 2")]
            pub facet_value: ::core::option::Option<facet_value::FacetValue>,
        }
        /// Nested message and enum types in `FacetValue`.
        pub mod facet_value {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum FacetValue {
                #[prost(string, tag = "1")]
                Value(::prost::alloc::string::String),
                #[prost(message, tag = "2")]
                Interval(super::super::super::Interval),
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QueryExpansionInfo {
        #[prost(bool, tag = "1")]
        pub expanded_query: bool,
        #[prost(int64, tag = "2")]
        pub pinned_result_count: i64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExperimentInfo {
    #[prost(string, tag = "1")]
    pub experiment: ::prost::alloc::string::String,
    #[prost(oneof = "experiment_info::ExperimentMetadata", tags = "2")]
    pub experiment_metadata: ::core::option::Option<experiment_info::ExperimentMetadata>,
}
/// Nested message and enum types in `ExperimentInfo`.
pub mod experiment_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServingConfigExperiment {
        #[prost(string, tag = "1")]
        pub original_serving_config: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub experiment_serving_config: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExperimentMetadata {
        #[prost(message, tag = "2")]
        ServingConfigExperiment(ServingConfigExperiment),
    }
}
/// Generated client implementations.
pub mod search_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for search.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    #[derive(Debug, Clone)]
    pub struct SearchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SearchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SearchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            SearchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Performs a search.
        ///
        /// This feature is only available for users who have Retail Search enabled.
        /// Enable Retail Search on Cloud Console before using this feature.
        pub async fn search(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.SearchService/Search",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.SearchService",
                "Search",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServingConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub price_reranking_level: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub facet_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub dynamic_facet_spec: ::core::option::Option<search_request::DynamicFacetSpec>,
    #[prost(string, repeated, tag = "7")]
    pub boost_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "9")]
    pub filter_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "10")]
    pub redirect_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "18")]
    pub twoway_synonyms_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "12")]
    pub oneway_synonyms_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "13")]
    pub do_not_associate_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "14")]
    pub replacement_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "15")]
    pub ignore_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub diversity_level: ::prost::alloc::string::String,
    #[prost(enumeration = "serving_config::DiversityType", tag = "20")]
    pub diversity_type: i32,
    #[prost(string, tag = "16")]
    pub enable_category_filter_level: ::prost::alloc::string::String,
    #[prost(bool, tag = "24")]
    pub ignore_recs_denylist: bool,
    #[prost(message, optional, tag = "21")]
    pub personalization_spec: ::core::option::Option<search_request::PersonalizationSpec>,
    #[prost(enumeration = "SolutionType", repeated, packed = "false", tag = "19")]
    pub solution_types: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `ServingConfig`.
pub mod serving_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DiversityType {
        Unspecified = 0,
        RuleBasedDiversity = 2,
        DataDrivenDiversity = 3,
    }
    impl DiversityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DiversityType::Unspecified => "DIVERSITY_TYPE_UNSPECIFIED",
                DiversityType::RuleBasedDiversity => "RULE_BASED_DIVERSITY",
                DiversityType::DataDrivenDiversity => "DATA_DRIVEN_DIVERSITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIVERSITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RULE_BASED_DIVERSITY" => Some(Self::RuleBasedDiversity),
                "DATA_DRIVEN_DIVERSITY" => Some(Self::DataDrivenDiversity),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServingConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub serving_config: ::core::option::Option<ServingConfig>,
    #[prost(string, tag = "3")]
    pub serving_config_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServingConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub serving_config: ::core::option::Option<ServingConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServingConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServingConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServingConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServingConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub serving_configs: ::prost::alloc::vec::Vec<ServingConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddControlRequest {
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub control_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveControlRequest {
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub control_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod serving_config_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for modifying ServingConfig.
    #[derive(Debug, Clone)]
    pub struct ServingConfigServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ServingConfigServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ServingConfigServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ServingConfigServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a ServingConfig.
        ///
        /// A maximum of 100 [ServingConfig][google.cloud.retail.v2.ServingConfig]s are
        /// allowed in a [Catalog][google.cloud.retail.v2.Catalog], otherwise a
        /// FAILED_PRECONDITION error is returned.
        pub async fn create_serving_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateServingConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ServingConfigService/CreateServingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ServingConfigService",
                "CreateServingConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a ServingConfig.
        ///
        /// Returns a NotFound error if the ServingConfig does not exist.
        pub async fn delete_serving_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServingConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ServingConfigService/DeleteServingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ServingConfigService",
                "DeleteServingConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a ServingConfig.
        pub async fn update_serving_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServingConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ServingConfigService/UpdateServingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ServingConfigService",
                "UpdateServingConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a ServingConfig.
        ///
        /// Returns a NotFound error if the ServingConfig does not exist.
        pub async fn get_serving_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServingConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ServingConfigService/GetServingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ServingConfigService",
                "GetServingConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all ServingConfigs linked to this catalog.
        pub async fn list_serving_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListServingConfigsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListServingConfigsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ServingConfigService/ListServingConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ServingConfigService",
                "ListServingConfigs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Enables a Control on the specified ServingConfig.
        /// The control is added in the last position of the list of controls
        /// it belongs to (e.g. if it's a facet spec control it will be applied
        /// in the last position of servingConfig.facetSpecIds)
        /// Returns a ALREADY_EXISTS error if the control has already been applied.
        /// Returns a FAILED_PRECONDITION error if the addition could exceed maximum
        /// number of control allowed for that type of control.
        pub async fn add_control(
            &mut self,
            request: impl tonic::IntoRequest<super::AddControlRequest>,
        ) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ServingConfigService/AddControl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ServingConfigService",
                "AddControl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Disables a Control on the specified ServingConfig.
        /// The control is removed from the ServingConfig.
        /// Returns a NOT_FOUND error if the Control is not enabled for the
        /// ServingConfig.
        pub async fn remove_control(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveControlRequest>,
        ) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ServingConfigService/RemoveControl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ServingConfigService",
                "RemoveControl",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputConfig {
    #[prost(oneof = "output_config::Destination", tags = "1, 2")]
    pub destination: ::core::option::Option<output_config::Destination>,
}
/// Nested message and enum types in `OutputConfig`.
pub mod output_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsDestination {
        #[prost(string, tag = "1")]
        pub output_uri_prefix: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQueryDestination {
        #[prost(string, tag = "1")]
        pub dataset_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub table_id_prefix: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub table_type: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(message, tag = "1")]
        GcsDestination(GcsDestination),
        #[prost(message, tag = "2")]
        BigqueryDestination(BigQueryDestination),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportErrorsConfig {
    #[prost(oneof = "export_errors_config::Destination", tags = "1")]
    pub destination: ::core::option::Option<export_errors_config::Destination>,
}
/// Nested message and enum types in `ExportErrorsConfig`.
pub mod export_errors_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(string, tag = "1")]
        GcsPrefix(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportAnalyticsMetricsRequest {
    #[prost(string, tag = "1")]
    pub catalog: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub output_config: ::core::option::Option<OutputConfig>,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportAnalyticsMetricsResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "2")]
    pub errors_config: ::core::option::Option<ExportErrorsConfig>,
    #[prost(message, optional, tag = "3")]
    pub output_result: ::core::option::Option<OutputResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputResult {
    #[prost(message, repeated, tag = "1")]
    pub bigquery_result: ::prost::alloc::vec::Vec<BigQueryOutputResult>,
    #[prost(message, repeated, tag = "2")]
    pub gcs_result: ::prost::alloc::vec::Vec<GcsOutputResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryOutputResult {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub table_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsOutputResult {
    #[prost(string, tag = "1")]
    pub output_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Control {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub associated_serving_config_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "SolutionType", repeated, packed = "false", tag = "6")]
    pub solution_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "SearchSolutionUseCase", repeated, tag = "7")]
    pub search_solution_use_case: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof = "control::Control", tags = "4")]
    pub control: ::core::option::Option<control::Control>,
}
/// Nested message and enum types in `Control`.
pub mod control {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Control {
        #[prost(message, tag = "4")]
        Rule(super::Rule),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCatalogsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCatalogsResponse {
    #[prost(message, repeated, tag = "1")]
    pub catalogs: ::prost::alloc::vec::Vec<Catalog>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCatalogRequest {
    #[prost(message, optional, tag = "1")]
    pub catalog: ::core::option::Option<Catalog>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetDefaultBranchRequest {
    #[prost(string, tag = "1")]
    pub catalog: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub branch_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub note: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDefaultBranchRequest {
    #[prost(string, tag = "1")]
    pub catalog: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDefaultBranchResponse {
    #[prost(string, tag = "1")]
    pub branch: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub set_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub note: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompletionConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCompletionConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub completion_config: ::core::option::Option<CompletionConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAttributesConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAttributesConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub attributes_config: ::core::option::Option<AttributesConfig>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddCatalogAttributeRequest {
    #[prost(string, tag = "1")]
    pub attributes_config: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub catalog_attribute: ::core::option::Option<CatalogAttribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveCatalogAttributeRequest {
    #[prost(string, tag = "1")]
    pub attributes_config: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplaceCatalogAttributeRequest {
    #[prost(string, tag = "1")]
    pub attributes_config: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub catalog_attribute: ::core::option::Option<CatalogAttribute>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod catalog_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing catalog configuration.
    #[derive(Debug, Clone)]
    pub struct CatalogServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CatalogServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CatalogServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            CatalogServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all the [Catalog][google.cloud.retail.v2.Catalog]s associated with
        /// the project.
        pub async fn list_catalogs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCatalogsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListCatalogsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/ListCatalogs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "ListCatalogs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the [Catalog][google.cloud.retail.v2.Catalog]s.
        pub async fn update_catalog(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCatalogRequest>,
        ) -> std::result::Result<tonic::Response<super::Catalog>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/UpdateCatalog",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "UpdateCatalog",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Set a specified branch id as default branch. API methods such as
        /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search],
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct],
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts]
        /// will treat requests using "default_branch" to the actual branch id set as
        /// default.
        ///
        /// For example, if `projects/*/locations/*/catalogs/*/branches/1` is set as
        /// default, setting
        /// [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
        /// `projects/*/locations/*/catalogs/*/branches/default_branch` is equivalent
        /// to setting
        /// [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
        /// `projects/*/locations/*/catalogs/*/branches/1`.
        ///
        /// Using multiple branches can be useful when developers would like
        /// to have a staging branch to test and verify for future usage. When it
        /// becomes ready, developers switch on the staging branch using this API while
        /// keeping using `projects/*/locations/*/catalogs/*/branches/default_branch`
        /// as [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
        /// route the traffic to this staging branch.
        ///
        /// CAUTION: If you have live predict/search traffic, switching the default
        /// branch could potentially cause outages if the ID space of the new branch is
        /// very different from the old one.
        ///
        /// More specifically:
        ///
        /// * PredictionService will only return product IDs from branch {newBranch}.
        /// * SearchService will only return product IDs from branch {newBranch}
        ///   (if branch is not explicitly set).
        /// * UserEventService will only join events with products from branch
        ///   {newBranch}.
        pub async fn set_default_branch(
            &mut self,
            request: impl tonic::IntoRequest<super::SetDefaultBranchRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/SetDefaultBranch",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "SetDefaultBranch",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get which branch is currently default branch set by
        /// [CatalogService.SetDefaultBranch][google.cloud.retail.v2.CatalogService.SetDefaultBranch]
        /// method under a specified parent catalog.
        pub async fn get_default_branch(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDefaultBranchRequest>,
        ) -> std::result::Result<tonic::Response<super::GetDefaultBranchResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/GetDefaultBranch",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "GetDefaultBranch",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a [CompletionConfig][google.cloud.retail.v2.CompletionConfig].
        pub async fn get_completion_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCompletionConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::CompletionConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/GetCompletionConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "GetCompletionConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the [CompletionConfig][google.cloud.retail.v2.CompletionConfig]s.
        pub async fn update_completion_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCompletionConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::CompletionConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/UpdateCompletionConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "UpdateCompletionConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets an [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
        pub async fn get_attributes_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAttributesConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::AttributesConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/GetAttributesConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "GetAttributesConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
        ///
        /// The catalog attributes in the request will be updated in the catalog, or
        /// inserted if they do not exist. Existing catalog attributes not included in
        /// the request will remain unchanged. Attributes that are assigned to
        /// products, but do not exist at the catalog level, are always included in the
        /// response. The product attribute is assigned default values for missing
        /// catalog attribute fields, e.g., searchable and dynamic facetable options.
        pub async fn update_attributes_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAttributesConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::AttributesConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/UpdateAttributesConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "UpdateAttributesConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Adds the specified
        /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to the
        /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
        ///
        /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to add
        /// already exists, an ALREADY_EXISTS error is returned.
        pub async fn add_catalog_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::AddCatalogAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::AttributesConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/AddCatalogAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "AddCatalogAttribute",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Removes the specified
        /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] from the
        /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
        ///
        /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to
        /// remove does not exist, a NOT_FOUND error is returned.
        pub async fn remove_catalog_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveCatalogAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::AttributesConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/RemoveCatalogAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "RemoveCatalogAttribute",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Replaces the specified
        /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] in the
        /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig] by updating the
        /// catalog attribute with the same
        /// [CatalogAttribute.key][google.cloud.retail.v2.CatalogAttribute.key].
        ///
        /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to
        /// replace does not exist, a NOT_FOUND error is returned.
        pub async fn replace_catalog_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::ReplaceCatalogAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::AttributesConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.CatalogService/ReplaceCatalogAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.CatalogService",
                "ReplaceCatalogAttribute",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod analytics_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for managing & accessing retail search business metric.
    /// Retail recommendation business metric is currently not available.
    #[derive(Debug, Clone)]
    pub struct AnalyticsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AnalyticsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AnalyticsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AnalyticsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Exports analytics metrics.
        ///
        /// `Operation.response` is of type `ExportAnalyticsMetricsResponse`.
        /// `Operation.metadata` is of type `ExportMetadata`.
        pub async fn export_analytics_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportAnalyticsMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.AnalyticsService/ExportAnalyticsMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.AnalyticsService",
                "ExportAnalyticsMetrics",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "model::TrainingState", tag = "3")]
    pub training_state: i32,
    #[prost(enumeration = "model::ServingState", tag = "4")]
    pub serving_state: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "7")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub optimization_objective: ::prost::alloc::string::String,
    #[prost(enumeration = "model::PeriodicTuningState", tag = "11")]
    pub periodic_tuning_state: i32,
    #[prost(message, optional, tag = "12")]
    pub last_tune_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "15")]
    pub tuning_operation: ::prost::alloc::string::String,
    #[prost(enumeration = "model::DataState", tag = "16")]
    pub data_state: i32,
    #[prost(enumeration = "RecommendationsFilteringOption", tag = "18")]
    pub filtering_option: i32,
    #[prost(message, repeated, tag = "19")]
    pub serving_config_lists: ::prost::alloc::vec::Vec<model::ServingConfigList>,
    #[prost(message, optional, tag = "22")]
    pub model_features_config: ::core::option::Option<model::ModelFeaturesConfig>,
}
/// Nested message and enum types in `Model`.
pub mod model {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServingConfigList {
        #[prost(string, repeated, tag = "1")]
        pub serving_config_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FrequentlyBoughtTogetherFeaturesConfig {
        #[prost(enumeration = "ContextProductsType", tag = "2")]
        pub context_products_type: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ModelFeaturesConfig {
        #[prost(oneof = "model_features_config::TypeDedicatedConfig", tags = "1")]
        pub type_dedicated_config:
            ::core::option::Option<model_features_config::TypeDedicatedConfig>,
    }
    /// Nested message and enum types in `ModelFeaturesConfig`.
    pub mod model_features_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum TypeDedicatedConfig {
            #[prost(message, tag = "1")]
            FrequentlyBoughtTogetherConfig(super::FrequentlyBoughtTogetherFeaturesConfig),
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ServingState {
        Unspecified = 0,
        Inactive = 1,
        Active = 2,
        Tuned = 3,
    }
    impl ServingState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ServingState::Unspecified => "SERVING_STATE_UNSPECIFIED",
                ServingState::Inactive => "INACTIVE",
                ServingState::Active => "ACTIVE",
                ServingState::Tuned => "TUNED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "ACTIVE" => Some(Self::Active),
                "TUNED" => Some(Self::Tuned),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TrainingState {
        Unspecified = 0,
        Paused = 1,
        Training = 2,
    }
    impl TrainingState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TrainingState::Unspecified => "TRAINING_STATE_UNSPECIFIED",
                TrainingState::Paused => "PAUSED",
                TrainingState::Training => "TRAINING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRAINING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PAUSED" => Some(Self::Paused),
                "TRAINING" => Some(Self::Training),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PeriodicTuningState {
        Unspecified = 0,
        PeriodicTuningDisabled = 1,
        AllTuningDisabled = 3,
        PeriodicTuningEnabled = 2,
    }
    impl PeriodicTuningState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PeriodicTuningState::Unspecified => "PERIODIC_TUNING_STATE_UNSPECIFIED",
                PeriodicTuningState::PeriodicTuningDisabled => "PERIODIC_TUNING_DISABLED",
                PeriodicTuningState::AllTuningDisabled => "ALL_TUNING_DISABLED",
                PeriodicTuningState::PeriodicTuningEnabled => "PERIODIC_TUNING_ENABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERIODIC_TUNING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PERIODIC_TUNING_DISABLED" => Some(Self::PeriodicTuningDisabled),
                "ALL_TUNING_DISABLED" => Some(Self::AllTuningDisabled),
                "PERIODIC_TUNING_ENABLED" => Some(Self::PeriodicTuningEnabled),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DataState {
        Unspecified = 0,
        DataOk = 1,
        DataError = 2,
    }
    impl DataState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataState::Unspecified => "DATA_STATE_UNSPECIFIED",
                DataState::DataOk => "DATA_OK",
                DataState::DataError => "DATA_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATA_OK" => Some(Self::DataOk),
                "DATA_ERROR" => Some(Self::DataError),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ContextProductsType {
        Unspecified = 0,
        SingleContextProduct = 1,
        MultipleContextProducts = 2,
    }
    impl ContextProductsType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContextProductsType::Unspecified => "CONTEXT_PRODUCTS_TYPE_UNSPECIFIED",
                ContextProductsType::SingleContextProduct => "SINGLE_CONTEXT_PRODUCT",
                ContextProductsType::MultipleContextProducts => "MULTIPLE_CONTEXT_PRODUCTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTEXT_PRODUCTS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SINGLE_CONTEXT_PRODUCT" => Some(Self::SingleContextProduct),
                "MULTIPLE_CONTEXT_PRODUCTS" => Some(Self::MultipleContextProducts),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateControlRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub control: ::core::option::Option<Control>,
    #[prost(string, tag = "3")]
    pub control_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateControlRequest {
    #[prost(message, optional, tag = "1")]
    pub control: ::core::option::Option<Control>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteControlRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetControlRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsResponse {
    #[prost(message, repeated, tag = "1")]
    pub controls: ::prost::alloc::vec::Vec<Control>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod control_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for modifying Control.
    #[derive(Debug, Clone)]
    pub struct ControlServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ControlServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ControlServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ControlServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a Control.
        ///
        /// If the [Control][google.cloud.retail.v2.Control] to create already exists,
        /// an ALREADY_EXISTS error is returned.
        pub async fn create_control(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ControlService/CreateControl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ControlService",
                "CreateControl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Control.
        ///
        /// If the [Control][google.cloud.retail.v2.Control] to delete does not exist,
        /// a NOT_FOUND error is returned.
        pub async fn delete_control(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteControlRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ControlService/DeleteControl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ControlService",
                "DeleteControl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Control.
        ///
        /// [Control][google.cloud.retail.v2.Control] cannot be set to a different
        /// oneof field, if so an INVALID_ARGUMENT is returned. If the
        /// [Control][google.cloud.retail.v2.Control] to update does not exist, a
        /// NOT_FOUND error is returned.
        pub async fn update_control(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ControlService/UpdateControl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ControlService",
                "UpdateControl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Control.
        pub async fn get_control(
            &mut self,
            request: impl tonic::IntoRequest<super::GetControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ControlService/GetControl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ControlService",
                "GetControl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Controls by their parent
        /// [Catalog][google.cloud.retail.v2.Catalog].
        pub async fn list_controls(
            &mut self,
            request: impl tonic::IntoRequest<super::ListControlsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListControlsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ControlService/ListControls",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ControlService",
                "ListControls",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModelRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub model: ::core::option::Option<Model>,
    #[prost(bool, tag = "3")]
    pub dry_run: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelRequest {
    #[prost(message, optional, tag = "1")]
    pub model: ::core::option::Option<Model>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsResponse {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<Model>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuneModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModelMetadata {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuneModelMetadata {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TuneModelResponse {}
/// Generated client implementations.
pub mod model_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service for performing CRUD operations on models.
    /// Recommendation models contain all the metadata necessary to generate a set of
    /// models for the `Predict()` API. A model is queried
    /// indirectly via a ServingConfig, which associates a model with a
    /// given Placement (e.g. Frequently Bought Together on Home Page).
    ///
    /// This service allows you to do the following:
    ///
    /// * Initiate training of a model.
    /// * Pause training of an existing model.
    /// * List all the available models along with their metadata.
    /// * Control their tuning schedule.
    #[derive(Debug, Clone)]
    pub struct ModelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ModelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ModelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ModelServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new model.
        pub async fn create_model(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/CreateModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "CreateModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a model.
        pub async fn get_model(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/GetModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "GetModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Pauses the training of an existing model.
        pub async fn pause_model(
            &mut self,
            request: impl tonic::IntoRequest<super::PauseModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/PauseModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "PauseModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Resumes the training of an existing model.
        pub async fn resume_model(
            &mut self,
            request: impl tonic::IntoRequest<super::ResumeModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/ResumeModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "ResumeModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an existing model.
        pub async fn delete_model(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteModelRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/DeleteModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "DeleteModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the models linked to this event store.
        pub async fn list_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListModelsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListModelsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/ListModels",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "ListModels",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Update of model metadata. Only fields that
        /// currently can be updated are: `filtering_option` and
        /// `periodic_tuning_state`.
        /// If other values are provided, this API method ignores them.
        pub async fn update_model(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/UpdateModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "UpdateModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Tunes an existing model.
        pub async fn tune_model(
            &mut self,
            request: impl tonic::IntoRequest<super::TuneModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.retail.v2.ModelService/TuneModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.retail.v2.ModelService",
                "TuneModel",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
