// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexField {
#[prost(string, tag = "1")]
pub field_path: ::prost::alloc::string::String,
#[prost(enumeration = "index_field::Mode", tag = "2")]
pub mode: i32,
}
/// Nested message and enum types in `IndexField`.
pub mod index_field {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Mode {
Unspecified = 0,
Ascending = 2,
Descending = 3,
ArrayContains = 4,
}
impl Mode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Mode::Unspecified => "MODE_UNSPECIFIED",
Mode::Ascending => "ASCENDING",
Mode::Descending => "DESCENDING",
Mode::ArrayContains => "ARRAY_CONTAINS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODE_UNSPECIFIED" => Some(Self::Unspecified),
"ASCENDING" => Some(Self::Ascending),
"DESCENDING" => Some(Self::Descending),
"ARRAY_CONTAINS" => Some(Self::ArrayContains),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub collection_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub fields: ::prost::alloc::vec::Vec<IndexField>,
#[prost(enumeration = "index::State", tag = "6")]
pub state: i32,
}
/// Nested message and enum types in `Index`.
pub mod index {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 3,
Ready = 2,
Error = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Ready => "READY",
State::Error => "ERROR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"READY" => Some(Self::Ready),
"ERROR" => Some(Self::Error),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexOperationMetadata {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "3")]
pub index: ::prost::alloc::string::String,
#[prost(enumeration = "index_operation_metadata::OperationType", tag = "4")]
pub operation_type: i32,
#[prost(bool, tag = "5")]
pub cancelled: bool,
#[prost(message, optional, tag = "6")]
pub document_progress: ::core::option::Option<Progress>,
}
/// Nested message and enum types in `IndexOperationMetadata`.
pub mod index_operation_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationType {
Unspecified = 0,
CreatingIndex = 1,
}
impl OperationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OperationType::Unspecified => "OPERATION_TYPE_UNSPECIFIED",
OperationType::CreatingIndex => "CREATING_INDEX",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING_INDEX" => Some(Self::CreatingIndex),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Progress {
#[prost(int64, tag = "1")]
pub work_completed: i64,
#[prost(int64, tag = "2")]
pub work_estimated: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub index: ::core::option::Option<Index>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIndexRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesResponse {
#[prost(message, repeated, tag = "1")]
pub indexes: ::prost::alloc::vec::Vec<Index>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDocumentsRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub collection_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub output_uri_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub collection_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub input_uri_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDocumentsResponse {
#[prost(string, tag = "1")]
pub output_uri_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDocumentsMetadata {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "OperationState", tag = "3")]
pub operation_state: i32,
#[prost(message, optional, tag = "4")]
pub progress_documents: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "5")]
pub progress_bytes: ::core::option::Option<Progress>,
#[prost(string, repeated, tag = "6")]
pub collection_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub output_uri_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsMetadata {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "OperationState", tag = "3")]
pub operation_state: i32,
#[prost(message, optional, tag = "4")]
pub progress_documents: ::core::option::Option<Progress>,
#[prost(message, optional, tag = "5")]
pub progress_bytes: ::core::option::Option<Progress>,
#[prost(string, repeated, tag = "6")]
pub collection_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub input_uri_prefix: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationState {
StateUnspecified = 0,
Initializing = 1,
Processing = 2,
Cancelling = 3,
Finalizing = 4,
Successful = 5,
Failed = 6,
Cancelled = 7,
}
impl OperationState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OperationState::StateUnspecified => "STATE_UNSPECIFIED",
OperationState::Initializing => "INITIALIZING",
OperationState::Processing => "PROCESSING",
OperationState::Cancelling => "CANCELLING",
OperationState::Finalizing => "FINALIZING",
OperationState::Successful => "SUCCESSFUL",
OperationState::Failed => "FAILED",
OperationState::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::StateUnspecified),
"INITIALIZING" => Some(Self::Initializing),
"PROCESSING" => Some(Self::Processing),
"CANCELLING" => Some(Self::Cancelling),
"FINALIZING" => Some(Self::Finalizing),
"SUCCESSFUL" => Some(Self::Successful),
"FAILED" => Some(Self::Failed),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
/// Generated client implementations.
pub mod firestore_admin_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The Cloud Firestore Admin API.
///
/// This API provides several administrative services for Cloud Firestore.
///
/// # Concepts
///
/// Project, Database, Namespace, Collection, and Document are used as defined in
/// the Google Cloud Firestore API.
///
/// Operation: An Operation represents work being performed in the background.
///
///
/// # Services
///
/// ## Index
///
/// The index service manages Cloud Firestore indexes.
///
/// Index creation is performed asynchronously.
/// An Operation resource is created for each such asynchronous operation.
/// The state of the operation (including any errors encountered)
/// may be queried via the Operation resource.
///
/// ## Metadata
///
/// Provides metadata and statistical information about data in Cloud Firestore.
/// The data provided as part of this API may be stale.
///
/// ## Operation
///
/// The Operations collection provides a record of actions performed for the
/// specified Project (including any Operations in progress). Operations are not
/// created directly but through calls on other collections or resources.
///
/// An Operation that is not yet done may be cancelled. The request to cancel is
/// asynchronous and the Operation may continue to run for some time after the
/// request to cancel is made.
///
/// An Operation that is done may be deleted so that it is no longer listed as
/// part of the Operation collection.
///
/// Operations are created by service `FirestoreAdmin`, but are accessed via
/// service `google.longrunning.Operations`.
#[derive(Debug, Clone)]
pub struct FirestoreAdminClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FirestoreAdminClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FirestoreAdminClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FirestoreAdminClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates the specified index.
/// A newly created index's initial state is `CREATING`. On completion of the
/// returned [google.longrunning.Operation][google.longrunning.Operation], the state will be `READY`.
/// If the index already exists, the call will return an `ALREADY_EXISTS`
/// status.
///
/// During creation, the process could result in an error, in which case the
/// index will move to the `ERROR` state. The process can be recovered by
/// fixing the data that caused the error, removing the index with
/// [delete][google.firestore.admin.v1beta1.FirestoreAdmin.DeleteIndex], then re-creating the index with
/// [create][google.firestore.admin.v1beta1.FirestoreAdmin.CreateIndex].
///
/// Indexes with a single field cannot be created.
pub async fn create_index(&mut self, request: impl tonic::IntoRequest<super::CreateIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.firestore.admin.v1beta1.FirestoreAdmin/CreateIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.firestore.admin.v1beta1.FirestoreAdmin", "CreateIndex"));
self.inner.unary(req, path, codec).await
}
/// Lists the indexes that match the specified filters.
pub async fn list_indexes(&mut self, request: impl tonic::IntoRequest<super::ListIndexesRequest>) -> std::result::Result<tonic::Response<super::ListIndexesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.firestore.admin.v1beta1.FirestoreAdmin/ListIndexes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.firestore.admin.v1beta1.FirestoreAdmin", "ListIndexes"));
self.inner.unary(req, path, codec).await
}
/// Gets an index.
pub async fn get_index(&mut self, request: impl tonic::IntoRequest<super::GetIndexRequest>) -> std::result::Result<tonic::Response<super::Index>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.firestore.admin.v1beta1.FirestoreAdmin/GetIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.firestore.admin.v1beta1.FirestoreAdmin", "GetIndex"));
self.inner.unary(req, path, codec).await
}
/// Deletes an index.
pub async fn delete_index(&mut self, request: impl tonic::IntoRequest<super::DeleteIndexRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.firestore.admin.v1beta1.FirestoreAdmin/DeleteIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.firestore.admin.v1beta1.FirestoreAdmin", "DeleteIndex"));
self.inner.unary(req, path, codec).await
}
/// Exports a copy of all or a subset of documents from Google Cloud Firestore
/// to another storage system, such as Google Cloud Storage. Recent updates to
/// documents may not be reflected in the export. The export occurs in the
/// background and its progress can be monitored and managed via the
/// Operation resource that is created. The output of an export may only be
/// used once the associated operation is done. If an export operation is
/// cancelled before completion it may leave partial data behind in Google
/// Cloud Storage.
pub async fn export_documents(&mut self, request: impl tonic::IntoRequest<super::ExportDocumentsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.firestore.admin.v1beta1.FirestoreAdmin/ExportDocuments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.firestore.admin.v1beta1.FirestoreAdmin", "ExportDocuments"));
self.inner.unary(req, path, codec).await
}
/// Imports documents into Google Cloud Firestore. Existing documents with the
/// same name are overwritten. The import occurs in the background and its
/// progress can be monitored and managed via the Operation resource that is
/// created. If an ImportDocuments operation is cancelled, it is possible
/// that a subset of the data has already been imported to Cloud Firestore.
pub async fn import_documents(&mut self, request: impl tonic::IntoRequest<super::ImportDocumentsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.firestore.admin.v1beta1.FirestoreAdmin/ImportDocuments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.firestore.admin.v1beta1.FirestoreAdmin", "ImportDocuments"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationMetadata {}
