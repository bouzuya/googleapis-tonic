// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Context {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "9")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "10")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "11")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, repeated, tag = "12")]
pub parent_contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "13")]
pub schema_title: ::prost::alloc::string::String,
#[prost(string, tag = "14")]
pub schema_version: ::prost::alloc::string::String,
#[prost(message, optional, tag = "15")]
pub metadata: ::core::option::Option<::prost_types::Struct>,
#[prost(string, tag = "16")]
pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationMetadata {
#[prost(btree_map = "string, message", tag = "1")]
pub inputs: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, explanation_metadata::InputMetadata>,
#[prost(btree_map = "string, message", tag = "2")]
pub outputs: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, explanation_metadata::OutputMetadata>,
#[prost(string, tag = "3")]
pub feature_attributions_schema_uri: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub latent_space_source: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExplanationMetadata`.
pub mod explanation_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputMetadata {
#[prost(message, repeated, tag = "1")]
pub input_baselines: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(string, tag = "2")]
pub input_tensor_name: ::prost::alloc::string::String,
#[prost(enumeration = "input_metadata::Encoding", tag = "3")]
pub encoding: i32,
#[prost(string, tag = "4")]
pub modality: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub feature_value_domain: ::core::option::Option<input_metadata::FeatureValueDomain>,
#[prost(string, tag = "6")]
pub indices_tensor_name: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub dense_shape_tensor_name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "8")]
pub index_feature_mapping: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "9")]
pub encoded_tensor_name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "10")]
pub encoded_baselines: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(message, optional, tag = "11")]
pub visualization: ::core::option::Option<input_metadata::Visualization>,
#[prost(string, tag = "12")]
pub group_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `InputMetadata`.
pub mod input_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeatureValueDomain {
#[prost(float, tag = "1")]
pub min_value: f32,
#[prost(float, tag = "2")]
pub max_value: f32,
#[prost(float, tag = "3")]
pub original_mean: f32,
#[prost(float, tag = "4")]
pub original_stddev: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Visualization {
#[prost(enumeration = "visualization::Type", tag = "1")]
pub r#type: i32,
#[prost(enumeration = "visualization::Polarity", tag = "2")]
pub polarity: i32,
#[prost(enumeration = "visualization::ColorMap", tag = "3")]
pub color_map: i32,
#[prost(float, tag = "4")]
pub clip_percent_upperbound: f32,
#[prost(float, tag = "5")]
pub clip_percent_lowerbound: f32,
#[prost(enumeration = "visualization::OverlayType", tag = "6")]
pub overlay_type: i32,
}
/// Nested message and enum types in `Visualization`.
pub mod visualization {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Pixels = 1,
Outlines = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Pixels => "PIXELS",
Type::Outlines => "OUTLINES",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PIXELS" => Some(Self::Pixels),
"OUTLINES" => Some(Self::Outlines),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Polarity {
Unspecified = 0,
Positive = 1,
Negative = 2,
Both = 3,
}
impl Polarity {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Polarity::Unspecified => "POLARITY_UNSPECIFIED",
Polarity::Positive => "POSITIVE",
Polarity::Negative => "NEGATIVE",
Polarity::Both => "BOTH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"POLARITY_UNSPECIFIED" => Some(Self::Unspecified),
"POSITIVE" => Some(Self::Positive),
"NEGATIVE" => Some(Self::Negative),
"BOTH" => Some(Self::Both),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ColorMap {
Unspecified = 0,
PinkGreen = 1,
Viridis = 2,
Red = 3,
Green = 4,
RedGreen = 6,
PinkWhiteGreen = 5,
}
impl ColorMap {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ColorMap::Unspecified => "COLOR_MAP_UNSPECIFIED",
ColorMap::PinkGreen => "PINK_GREEN",
ColorMap::Viridis => "VIRIDIS",
ColorMap::Red => "RED",
ColorMap::Green => "GREEN",
ColorMap::RedGreen => "RED_GREEN",
ColorMap::PinkWhiteGreen => "PINK_WHITE_GREEN",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"COLOR_MAP_UNSPECIFIED" => Some(Self::Unspecified),
"PINK_GREEN" => Some(Self::PinkGreen),
"VIRIDIS" => Some(Self::Viridis),
"RED" => Some(Self::Red),
"GREEN" => Some(Self::Green),
"RED_GREEN" => Some(Self::RedGreen),
"PINK_WHITE_GREEN" => Some(Self::PinkWhiteGreen),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OverlayType {
Unspecified = 0,
None = 1,
Original = 2,
Grayscale = 3,
MaskBlack = 4,
}
impl OverlayType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OverlayType::Unspecified => "OVERLAY_TYPE_UNSPECIFIED",
OverlayType::None => "NONE",
OverlayType::Original => "ORIGINAL",
OverlayType::Grayscale => "GRAYSCALE",
OverlayType::MaskBlack => "MASK_BLACK",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OVERLAY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"NONE" => Some(Self::None),
"ORIGINAL" => Some(Self::Original),
"GRAYSCALE" => Some(Self::Grayscale),
"MASK_BLACK" => Some(Self::MaskBlack),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
Unspecified = 0,
Identity = 1,
BagOfFeatures = 2,
BagOfFeaturesSparse = 3,
Indicator = 4,
CombinedEmbedding = 5,
ConcatEmbedding = 6,
}
impl Encoding {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Encoding::Unspecified => "ENCODING_UNSPECIFIED",
Encoding::Identity => "IDENTITY",
Encoding::BagOfFeatures => "BAG_OF_FEATURES",
Encoding::BagOfFeaturesSparse => "BAG_OF_FEATURES_SPARSE",
Encoding::Indicator => "INDICATOR",
Encoding::CombinedEmbedding => "COMBINED_EMBEDDING",
Encoding::ConcatEmbedding => "CONCAT_EMBEDDING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
"IDENTITY" => Some(Self::Identity),
"BAG_OF_FEATURES" => Some(Self::BagOfFeatures),
"BAG_OF_FEATURES_SPARSE" => Some(Self::BagOfFeaturesSparse),
"INDICATOR" => Some(Self::Indicator),
"COMBINED_EMBEDDING" => Some(Self::CombinedEmbedding),
"CONCAT_EMBEDDING" => Some(Self::ConcatEmbedding),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputMetadata {
#[prost(string, tag = "3")]
pub output_tensor_name: ::prost::alloc::string::String,
#[prost(oneof = "output_metadata::DisplayNameMapping", tags = "1, 2")]
pub display_name_mapping: ::core::option::Option<output_metadata::DisplayNameMapping>,
}
/// Nested message and enum types in `OutputMetadata`.
pub mod output_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DisplayNameMapping {
#[prost(message, tag = "1")]
IndexDisplayNameMapping(::prost_types::Value),
#[prost(string, tag = "2")]
DisplayNameMappingKey(::prost::alloc::string::String),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvroSource {
#[prost(message, optional, tag = "1")]
pub gcs_source: ::core::option::Option<GcsSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvSource {
#[prost(message, optional, tag = "1")]
pub gcs_source: ::core::option::Option<GcsSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
#[prost(string, repeated, tag = "1")]
pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsDestination {
#[prost(string, tag = "1")]
pub output_uri_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuerySource {
#[prost(string, tag = "1")]
pub input_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryDestination {
#[prost(string, tag = "1")]
pub output_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvDestination {
#[prost(message, optional, tag = "1")]
pub gcs_destination: ::core::option::Option<GcsDestination>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TfRecordDestination {
#[prost(message, optional, tag = "1")]
pub gcs_destination: ::core::option::Option<GcsDestination>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerRegistryDestination {
#[prost(string, tag = "1")]
pub output_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Explanation {
#[prost(message, repeated, tag = "1")]
pub attributions: ::prost::alloc::vec::Vec<Attribution>,
#[prost(message, repeated, tag = "2")]
pub neighbors: ::prost::alloc::vec::Vec<Neighbor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelExplanation {
#[prost(message, repeated, tag = "1")]
pub mean_attributions: ::prost::alloc::vec::Vec<Attribution>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attribution {
#[prost(double, tag = "1")]
pub baseline_output_value: f64,
#[prost(double, tag = "2")]
pub instance_output_value: f64,
#[prost(message, optional, tag = "3")]
pub feature_attributions: ::core::option::Option<::prost_types::Value>,
#[prost(int32, repeated, packed = "false", tag = "4")]
pub output_index: ::prost::alloc::vec::Vec<i32>,
#[prost(string, tag = "5")]
pub output_display_name: ::prost::alloc::string::String,
#[prost(double, tag = "6")]
pub approximation_error: f64,
#[prost(string, tag = "7")]
pub output_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Neighbor {
#[prost(string, tag = "1")]
pub neighbor_id: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub neighbor_distance: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationSpec {
#[prost(message, optional, tag = "1")]
pub parameters: ::core::option::Option<ExplanationParameters>,
#[prost(message, optional, tag = "2")]
pub metadata: ::core::option::Option<ExplanationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationParameters {
#[prost(int32, tag = "4")]
pub top_k: i32,
#[prost(message, optional, tag = "5")]
pub output_indices: ::core::option::Option<::prost_types::ListValue>,
#[prost(oneof = "explanation_parameters::Method", tags = "1, 2, 3, 7")]
pub method: ::core::option::Option<explanation_parameters::Method>,
}
/// Nested message and enum types in `ExplanationParameters`.
pub mod explanation_parameters {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Method {
#[prost(message, tag = "1")]
SampledShapleyAttribution(super::SampledShapleyAttribution),
#[prost(message, tag = "2")]
IntegratedGradientsAttribution(super::IntegratedGradientsAttribution),
#[prost(message, tag = "3")]
XraiAttribution(super::XraiAttribution),
#[prost(message, tag = "7")]
Examples(super::Examples),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SampledShapleyAttribution {
#[prost(int32, tag = "1")]
pub path_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegratedGradientsAttribution {
#[prost(int32, tag = "1")]
pub step_count: i32,
#[prost(message, optional, tag = "2")]
pub smooth_grad_config: ::core::option::Option<SmoothGradConfig>,
#[prost(message, optional, tag = "3")]
pub blur_baseline_config: ::core::option::Option<BlurBaselineConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XraiAttribution {
#[prost(int32, tag = "1")]
pub step_count: i32,
#[prost(message, optional, tag = "2")]
pub smooth_grad_config: ::core::option::Option<SmoothGradConfig>,
#[prost(message, optional, tag = "3")]
pub blur_baseline_config: ::core::option::Option<BlurBaselineConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmoothGradConfig {
#[prost(int32, tag = "3")]
pub noisy_sample_count: i32,
#[prost(oneof = "smooth_grad_config::GradientNoiseSigma", tags = "1, 2")]
pub gradient_noise_sigma: ::core::option::Option<smooth_grad_config::GradientNoiseSigma>,
}
/// Nested message and enum types in `SmoothGradConfig`.
pub mod smooth_grad_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum GradientNoiseSigma {
#[prost(float, tag = "1")]
NoiseSigma(f32),
#[prost(message, tag = "2")]
FeatureNoiseSigma(super::FeatureNoiseSigma),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureNoiseSigma {
#[prost(message, repeated, tag = "1")]
pub noise_sigma: ::prost::alloc::vec::Vec<feature_noise_sigma::NoiseSigmaForFeature>,
}
/// Nested message and enum types in `FeatureNoiseSigma`.
pub mod feature_noise_sigma {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NoiseSigmaForFeature {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(float, tag = "2")]
pub sigma: f32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlurBaselineConfig {
#[prost(float, tag = "1")]
pub max_blur_sigma: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Examples {
#[prost(int32, tag = "3")]
pub neighbor_count: i32,
#[prost(oneof = "examples::Source", tags = "5")]
pub source: ::core::option::Option<examples::Source>,
#[prost(oneof = "examples::Config", tags = "2, 4")]
pub config: ::core::option::Option<examples::Config>,
}
/// Nested message and enum types in `Examples`.
pub mod examples {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExampleGcsSource {
#[prost(enumeration = "example_gcs_source::DataFormat", tag = "1")]
pub data_format: i32,
#[prost(message, optional, tag = "2")]
pub gcs_source: ::core::option::Option<super::GcsSource>,
}
/// Nested message and enum types in `ExampleGcsSource`.
pub mod example_gcs_source {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataFormat {
Unspecified = 0,
Jsonl = 1,
}
impl DataFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DataFormat::Unspecified => "DATA_FORMAT_UNSPECIFIED",
DataFormat::Jsonl => "JSONL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DATA_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"JSONL" => Some(Self::Jsonl),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "5")]
ExampleGcsSource(ExampleGcsSource),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Config {
#[prost(message, tag = "2")]
NearestNeighborSearchConfig(::prost_types::Value),
#[prost(message, tag = "4")]
Presets(super::Presets),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Presets {
#[prost(enumeration = "presets::Query", optional, tag = "1")]
pub query: ::core::option::Option<i32>,
#[prost(enumeration = "presets::Modality", tag = "2")]
pub modality: i32,
}
/// Nested message and enum types in `Presets`.
pub mod presets {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Query {
Precise = 0,
Fast = 1,
}
impl Query {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Query::Precise => "PRECISE",
Query::Fast => "FAST",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PRECISE" => Some(Self::Precise),
"FAST" => Some(Self::Fast),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Modality {
Unspecified = 0,
Image = 1,
Text = 2,
Tabular = 3,
}
impl Modality {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Modality::Unspecified => "MODALITY_UNSPECIFIED",
Modality::Image => "IMAGE",
Modality::Text => "TEXT",
Modality::Tabular => "TABULAR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODALITY_UNSPECIFIED" => Some(Self::Unspecified),
"IMAGE" => Some(Self::Image),
"TEXT" => Some(Self::Text),
"TABULAR" => Some(Self::Tabular),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationSpecOverride {
#[prost(message, optional, tag = "1")]
pub parameters: ::core::option::Option<ExplanationParameters>,
#[prost(message, optional, tag = "2")]
pub metadata: ::core::option::Option<ExplanationMetadataOverride>,
#[prost(message, optional, tag = "3")]
pub examples_override: ::core::option::Option<ExamplesOverride>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationMetadataOverride {
#[prost(btree_map = "string, message", tag = "1")]
pub inputs: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, explanation_metadata_override::InputMetadataOverride>,
}
/// Nested message and enum types in `ExplanationMetadataOverride`.
pub mod explanation_metadata_override {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputMetadataOverride {
#[prost(message, repeated, tag = "1")]
pub input_baselines: ::prost::alloc::vec::Vec<::prost_types::Value>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExamplesOverride {
#[prost(int32, tag = "1")]
pub neighbor_count: i32,
#[prost(int32, tag = "2")]
pub crowding_count: i32,
#[prost(message, repeated, tag = "3")]
pub restrictions: ::prost::alloc::vec::Vec<ExamplesRestrictionsNamespace>,
#[prost(bool, tag = "4")]
pub return_embeddings: bool,
#[prost(enumeration = "examples_override::DataFormat", tag = "5")]
pub data_format: i32,
}
/// Nested message and enum types in `ExamplesOverride`.
pub mod examples_override {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataFormat {
Unspecified = 0,
Instances = 1,
Embeddings = 2,
}
impl DataFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DataFormat::Unspecified => "DATA_FORMAT_UNSPECIFIED",
DataFormat::Instances => "INSTANCES",
DataFormat::Embeddings => "EMBEDDINGS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DATA_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"INSTANCES" => Some(Self::Instances),
"EMBEDDINGS" => Some(Self::Embeddings),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExamplesRestrictionsNamespace {
#[prost(string, tag = "1")]
pub namespace_name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub allow: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub deny: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluatedAnnotation {
#[prost(enumeration = "evaluated_annotation::EvaluatedAnnotationType", tag = "1")]
pub r#type: i32,
#[prost(message, repeated, tag = "2")]
pub predictions: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(message, repeated, tag = "3")]
pub ground_truths: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(message, optional, tag = "5")]
pub data_item_payload: ::core::option::Option<::prost_types::Value>,
#[prost(string, tag = "6")]
pub evaluated_data_item_view_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "8")]
pub explanations: ::prost::alloc::vec::Vec<EvaluatedAnnotationExplanation>,
#[prost(message, repeated, tag = "9")]
pub error_analysis_annotations: ::prost::alloc::vec::Vec<ErrorAnalysisAnnotation>,
}
/// Nested message and enum types in `EvaluatedAnnotation`.
pub mod evaluated_annotation {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EvaluatedAnnotationType {
Unspecified = 0,
TruePositive = 1,
FalsePositive = 2,
FalseNegative = 3,
}
impl EvaluatedAnnotationType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EvaluatedAnnotationType::Unspecified => "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED",
EvaluatedAnnotationType::TruePositive => "TRUE_POSITIVE",
EvaluatedAnnotationType::FalsePositive => "FALSE_POSITIVE",
EvaluatedAnnotationType::FalseNegative => "FALSE_NEGATIVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EVALUATED_ANNOTATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"TRUE_POSITIVE" => Some(Self::TruePositive),
"FALSE_POSITIVE" => Some(Self::FalsePositive),
"FALSE_NEGATIVE" => Some(Self::FalseNegative),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluatedAnnotationExplanation {
#[prost(string, tag = "1")]
pub explanation_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub explanation: ::core::option::Option<Explanation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorAnalysisAnnotation {
#[prost(message, repeated, tag = "1")]
pub attributed_items: ::prost::alloc::vec::Vec<error_analysis_annotation::AttributedItem>,
#[prost(enumeration = "error_analysis_annotation::QueryType", tag = "2")]
pub query_type: i32,
#[prost(double, tag = "3")]
pub outlier_score: f64,
#[prost(double, tag = "4")]
pub outlier_threshold: f64,
}
/// Nested message and enum types in `ErrorAnalysisAnnotation`.
pub mod error_analysis_annotation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributedItem {
#[prost(string, tag = "1")]
pub annotation_resource_name: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub distance: f64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryType {
Unspecified = 0,
AllSimilar = 1,
SameClassSimilar = 2,
SameClassDissimilar = 3,
}
impl QueryType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
QueryType::Unspecified => "QUERY_TYPE_UNSPECIFIED",
QueryType::AllSimilar => "ALL_SIMILAR",
QueryType::SameClassSimilar => "SAME_CLASS_SIMILAR",
QueryType::SameClassDissimilar => "SAME_CLASS_DISSIMILAR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"QUERY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ALL_SIMILAR" => Some(Self::AllSimilar),
"SAME_CLASS_SIMILAR" => Some(Self::SameClassSimilar),
"SAME_CLASS_DISSIMILAR" => Some(Self::SameClassDissimilar),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericOperationMetadata {
#[prost(message, repeated, tag = "1")]
pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifact {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "10")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "11")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "12")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "artifact::State", tag = "13")]
pub state: i32,
#[prost(string, tag = "14")]
pub schema_title: ::prost::alloc::string::String,
#[prost(string, tag = "15")]
pub schema_version: ::prost::alloc::string::String,
#[prost(message, optional, tag = "16")]
pub metadata: ::core::option::Option<::prost_types::Struct>,
#[prost(string, tag = "17")]
pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Artifact`.
pub mod artifact {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Live = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Live => "LIVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"LIVE" => Some(Self::Live),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionSpec {
#[prost(string, tag = "1")]
pub kms_key_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Execution {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "execution::State", tag = "6")]
pub state: i32,
#[prost(string, tag = "9")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "10")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "11")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "12")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "13")]
pub schema_title: ::prost::alloc::string::String,
#[prost(string, tag = "14")]
pub schema_version: ::prost::alloc::string::String,
#[prost(message, optional, tag = "15")]
pub metadata: ::core::option::Option<::prost_types::Struct>,
#[prost(string, tag = "16")]
pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Execution`.
pub mod execution {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
New = 1,
Running = 2,
Complete = 3,
Failed = 4,
Cached = 5,
Cancelled = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::New => "NEW",
State::Running => "RUNNING",
State::Complete => "COMPLETE",
State::Failed => "FAILED",
State::Cached => "CACHED",
State::Cancelled => "CANCELLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"NEW" => Some(Self::New),
"RUNNING" => Some(Self::Running),
"COMPLETE" => Some(Self::Complete),
"FAILED" => Some(Self::Failed),
"CACHED" => Some(Self::Cached),
"CANCELLED" => Some(Self::Cancelled),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PipelineFailurePolicy {
Unspecified = 0,
FailSlow = 1,
FailFast = 2,
}
impl PipelineFailurePolicy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PipelineFailurePolicy::Unspecified => "PIPELINE_FAILURE_POLICY_UNSPECIFIED",
PipelineFailurePolicy::FailSlow => "PIPELINE_FAILURE_POLICY_FAIL_SLOW",
PipelineFailurePolicy::FailFast => "PIPELINE_FAILURE_POLICY_FAIL_FAST",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PIPELINE_FAILURE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
"PIPELINE_FAILURE_POLICY_FAIL_SLOW" => Some(Self::FailSlow),
"PIPELINE_FAILURE_POLICY_FAIL_FAST" => Some(Self::FailFast),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PipelineState {
Unspecified = 0,
Queued = 1,
Pending = 2,
Running = 3,
Succeeded = 4,
Failed = 5,
Cancelling = 6,
Cancelled = 7,
Paused = 8,
}
impl PipelineState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PipelineState::Unspecified => "PIPELINE_STATE_UNSPECIFIED",
PipelineState::Queued => "PIPELINE_STATE_QUEUED",
PipelineState::Pending => "PIPELINE_STATE_PENDING",
PipelineState::Running => "PIPELINE_STATE_RUNNING",
PipelineState::Succeeded => "PIPELINE_STATE_SUCCEEDED",
PipelineState::Failed => "PIPELINE_STATE_FAILED",
PipelineState::Cancelling => "PIPELINE_STATE_CANCELLING",
PipelineState::Cancelled => "PIPELINE_STATE_CANCELLED",
PipelineState::Paused => "PIPELINE_STATE_PAUSED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PIPELINE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PIPELINE_STATE_QUEUED" => Some(Self::Queued),
"PIPELINE_STATE_PENDING" => Some(Self::Pending),
"PIPELINE_STATE_RUNNING" => Some(Self::Running),
"PIPELINE_STATE_SUCCEEDED" => Some(Self::Succeeded),
"PIPELINE_STATE_FAILED" => Some(Self::Failed),
"PIPELINE_STATE_CANCELLING" => Some(Self::Cancelling),
"PIPELINE_STATE_CANCELLED" => Some(Self::Cancelled),
"PIPELINE_STATE_PAUSED" => Some(Self::Paused),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
#[prost(oneof = "value::Value", tags = "1, 2, 3")]
pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(int64, tag = "1")]
IntValue(i64),
#[prost(double, tag = "2")]
DoubleValue(f64),
#[prost(string, tag = "3")]
StringValue(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub pipeline_spec: ::core::option::Option<::prost_types::Struct>,
#[prost(enumeration = "PipelineState", tag = "8")]
pub state: i32,
#[prost(message, optional, tag = "9")]
pub job_detail: ::core::option::Option<PipelineJobDetail>,
#[prost(message, optional, tag = "10")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(btree_map = "string, string", tag = "11")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "12")]
pub runtime_config: ::core::option::Option<pipeline_job::RuntimeConfig>,
#[prost(message, optional, tag = "16")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(string, tag = "17")]
pub service_account: ::prost::alloc::string::String,
#[prost(string, tag = "18")]
pub network: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "25")]
pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "19")]
pub template_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "20")]
pub template_metadata: ::core::option::Option<PipelineTemplateMetadata>,
#[prost(string, tag = "22")]
pub schedule_name: ::prost::alloc::string::String,
#[prost(bool, tag = "26")]
pub preflight_validations: bool,
}
/// Nested message and enum types in `PipelineJob`.
pub mod pipeline_job {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeConfig {
#[prost(btree_map = "string, message", tag = "1")]
pub parameters: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::Value>,
#[prost(string, tag = "2")]
pub gcs_output_directory: ::prost::alloc::string::String,
#[prost(btree_map = "string, message", tag = "3")]
pub parameter_values: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost_types::Value>,
#[prost(enumeration = "super::PipelineFailurePolicy", tag = "4")]
pub failure_policy: i32,
#[prost(btree_map = "string, message", tag = "5")]
pub input_artifacts: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, runtime_config::InputArtifact>,
}
/// Nested message and enum types in `RuntimeConfig`.
pub mod runtime_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputArtifact {
#[prost(oneof = "input_artifact::Kind", tags = "1")]
pub kind: ::core::option::Option<input_artifact::Kind>,
}
/// Nested message and enum types in `InputArtifact`.
pub mod input_artifact {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(string, tag = "1")]
ArtifactId(::prost::alloc::string::String),
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineTemplateMetadata {
#[prost(string, tag = "3")]
pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineJobDetail {
#[prost(message, optional, tag = "1")]
pub pipeline_context: ::core::option::Option<Context>,
#[prost(message, optional, tag = "2")]
pub pipeline_run_context: ::core::option::Option<Context>,
#[prost(message, repeated, tag = "3")]
pub task_details: ::prost::alloc::vec::Vec<PipelineTaskDetail>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineTaskDetail {
#[prost(int64, tag = "1")]
pub task_id: i64,
#[prost(int64, tag = "12")]
pub parent_task_id: i64,
#[prost(string, tag = "2")]
pub task_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub executor_detail: ::core::option::Option<PipelineTaskExecutorDetail>,
#[prost(enumeration = "pipeline_task_detail::State", tag = "7")]
pub state: i32,
#[prost(message, optional, tag = "8")]
pub execution: ::core::option::Option<Execution>,
#[prost(message, optional, tag = "9")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "13")]
pub pipeline_task_status: ::prost::alloc::vec::Vec<pipeline_task_detail::PipelineTaskStatus>,
#[prost(btree_map = "string, message", tag = "10")]
pub inputs: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, pipeline_task_detail::ArtifactList>,
#[prost(btree_map = "string, message", tag = "11")]
pub outputs: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, pipeline_task_detail::ArtifactList>,
}
/// Nested message and enum types in `PipelineTaskDetail`.
pub mod pipeline_task_detail {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineTaskStatus {
#[prost(message, optional, tag = "1")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "State", tag = "2")]
pub state: i32,
#[prost(message, optional, tag = "3")]
pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactList {
#[prost(message, repeated, tag = "1")]
pub artifacts: ::prost::alloc::vec::Vec<super::Artifact>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Pending = 1,
Running = 2,
Succeeded = 3,
CancelPending = 4,
Cancelling = 5,
Cancelled = 6,
Failed = 7,
Skipped = 8,
NotTriggered = 9,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Pending => "PENDING",
State::Running => "RUNNING",
State::Succeeded => "SUCCEEDED",
State::CancelPending => "CANCEL_PENDING",
State::Cancelling => "CANCELLING",
State::Cancelled => "CANCELLED",
State::Failed => "FAILED",
State::Skipped => "SKIPPED",
State::NotTriggered => "NOT_TRIGGERED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"RUNNING" => Some(Self::Running),
"SUCCEEDED" => Some(Self::Succeeded),
"CANCEL_PENDING" => Some(Self::CancelPending),
"CANCELLING" => Some(Self::Cancelling),
"CANCELLED" => Some(Self::Cancelled),
"FAILED" => Some(Self::Failed),
"SKIPPED" => Some(Self::Skipped),
"NOT_TRIGGERED" => Some(Self::NotTriggered),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineTaskExecutorDetail {
#[prost(oneof = "pipeline_task_executor_detail::Details", tags = "1, 2")]
pub details: ::core::option::Option<pipeline_task_executor_detail::Details>,
}
/// Nested message and enum types in `PipelineTaskExecutorDetail`.
pub mod pipeline_task_executor_detail {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerDetail {
#[prost(string, tag = "1")]
pub main_job: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub pre_caching_check_job: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub failed_main_jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub failed_pre_caching_check_jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomJobDetail {
#[prost(string, tag = "1")]
pub job: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub failed_jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Details {
#[prost(message, tag = "1")]
ContainerDetail(ContainerDetail),
#[prost(message, tag = "2")]
CustomJobDetail(CustomJobDetail),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedModelRef {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployed_model_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvVar {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "28")]
pub version_id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "29")]
pub version_aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "31")]
pub version_create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "32")]
pub version_update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "30")]
pub version_description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub predict_schemata: ::core::option::Option<PredictSchemata>,
#[prost(string, tag = "5")]
pub metadata_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub metadata: ::core::option::Option<::prost_types::Value>,
#[prost(message, repeated, tag = "20")]
pub supported_export_formats: ::prost::alloc::vec::Vec<model::ExportFormat>,
#[prost(string, tag = "7")]
pub training_pipeline: ::prost::alloc::string::String,
#[prost(string, tag = "47")]
pub pipeline_job: ::prost::alloc::string::String,
#[prost(message, optional, tag = "9")]
pub container_spec: ::core::option::Option<ModelContainerSpec>,
#[prost(string, tag = "26")]
pub artifact_uri: ::prost::alloc::string::String,
#[prost(enumeration = "model::DeploymentResourcesType", repeated, packed = "false", tag = "10")]
pub supported_deployment_resources_types: ::prost::alloc::vec::Vec<i32>,
#[prost(string, repeated, tag = "11")]
pub supported_input_storage_formats: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "12")]
pub supported_output_storage_formats: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "13")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "14")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, repeated, tag = "15")]
pub deployed_models: ::prost::alloc::vec::Vec<DeployedModelRef>,
#[prost(message, optional, tag = "23")]
pub explanation_spec: ::core::option::Option<ExplanationSpec>,
#[prost(string, tag = "16")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "17")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "21")]
pub data_stats: ::core::option::Option<model::DataStats>,
#[prost(message, optional, tag = "24")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(message, optional, tag = "38")]
pub model_source_info: ::core::option::Option<ModelSourceInfo>,
#[prost(message, optional, tag = "34")]
pub original_model_info: ::core::option::Option<model::OriginalModelInfo>,
#[prost(string, tag = "44")]
pub metadata_artifact: ::prost::alloc::string::String,
#[prost(message, optional, tag = "50")]
pub base_model_source: ::core::option::Option<model::BaseModelSource>,
#[prost(bool, tag = "51")]
pub satisfies_pzs: bool,
#[prost(bool, tag = "52")]
pub satisfies_pzi: bool,
}
/// Nested message and enum types in `Model`.
pub mod model {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFormat {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(enumeration = "export_format::ExportableContent", repeated, packed = "false", tag = "2")]
pub exportable_contents: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `ExportFormat`.
pub mod export_format {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExportableContent {
Unspecified = 0,
Artifact = 1,
Image = 2,
}
impl ExportableContent {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ExportableContent::Unspecified => "EXPORTABLE_CONTENT_UNSPECIFIED",
ExportableContent::Artifact => "ARTIFACT",
ExportableContent::Image => "IMAGE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EXPORTABLE_CONTENT_UNSPECIFIED" => Some(Self::Unspecified),
"ARTIFACT" => Some(Self::Artifact),
"IMAGE" => Some(Self::Image),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataStats {
#[prost(int64, tag = "1")]
pub training_data_items_count: i64,
#[prost(int64, tag = "2")]
pub validation_data_items_count: i64,
#[prost(int64, tag = "3")]
pub test_data_items_count: i64,
#[prost(int64, tag = "4")]
pub training_annotations_count: i64,
#[prost(int64, tag = "5")]
pub validation_annotations_count: i64,
#[prost(int64, tag = "6")]
pub test_annotations_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OriginalModelInfo {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BaseModelSource {
#[prost(oneof = "base_model_source::Source", tags = "1, 2")]
pub source: ::core::option::Option<base_model_source::Source>,
}
/// Nested message and enum types in `BaseModelSource`.
pub mod base_model_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "1")]
ModelGardenSource(super::super::ModelGardenSource),
#[prost(message, tag = "2")]
GenieSource(super::super::GenieSource),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentResourcesType {
Unspecified = 0,
DedicatedResources = 1,
AutomaticResources = 2,
SharedResources = 3,
}
impl DeploymentResourcesType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DeploymentResourcesType::Unspecified => "DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED",
DeploymentResourcesType::DedicatedResources => "DEDICATED_RESOURCES",
DeploymentResourcesType::AutomaticResources => "AUTOMATIC_RESOURCES",
DeploymentResourcesType::SharedResources => "SHARED_RESOURCES",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"DEDICATED_RESOURCES" => Some(Self::DedicatedResources),
"AUTOMATIC_RESOURCES" => Some(Self::AutomaticResources),
"SHARED_RESOURCES" => Some(Self::SharedResources),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LargeModelReference {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelGardenSource {
#[prost(string, tag = "1")]
pub public_model_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenieSource {
#[prost(string, tag = "1")]
pub base_model_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictSchemata {
#[prost(string, tag = "1")]
pub instance_schema_uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub parameters_schema_uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub prediction_schema_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelContainerSpec {
#[prost(string, tag = "1")]
pub image_uri: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "4")]
pub env: ::prost::alloc::vec::Vec<EnvVar>,
#[prost(message, repeated, tag = "5")]
pub ports: ::prost::alloc::vec::Vec<Port>,
#[prost(string, tag = "6")]
pub predict_route: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub health_route: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "9")]
pub grpc_ports: ::prost::alloc::vec::Vec<Port>,
#[prost(message, optional, tag = "10")]
pub deployment_timeout: ::core::option::Option<::prost_types::Duration>,
#[prost(int64, tag = "11")]
pub shared_memory_size_mb: i64,
#[prost(message, optional, tag = "12")]
pub startup_probe: ::core::option::Option<Probe>,
#[prost(message, optional, tag = "13")]
pub health_probe: ::core::option::Option<Probe>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Port {
#[prost(int32, tag = "3")]
pub container_port: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModelSourceInfo {
#[prost(enumeration = "model_source_info::ModelSourceType", tag = "1")]
pub source_type: i32,
#[prost(bool, tag = "2")]
pub copy: bool,
}
/// Nested message and enum types in `ModelSourceInfo`.
pub mod model_source_info {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelSourceType {
Unspecified = 0,
Automl = 1,
Custom = 2,
Bqml = 3,
ModelGarden = 4,
Genie = 5,
CustomTextEmbedding = 6,
Marketplace = 7,
}
impl ModelSourceType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ModelSourceType::Unspecified => "MODEL_SOURCE_TYPE_UNSPECIFIED",
ModelSourceType::Automl => "AUTOML",
ModelSourceType::Custom => "CUSTOM",
ModelSourceType::Bqml => "BQML",
ModelSourceType::ModelGarden => "MODEL_GARDEN",
ModelSourceType::Genie => "GENIE",
ModelSourceType::CustomTextEmbedding => "CUSTOM_TEXT_EMBEDDING",
ModelSourceType::Marketplace => "MARKETPLACE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODEL_SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"AUTOML" => Some(Self::Automl),
"CUSTOM" => Some(Self::Custom),
"BQML" => Some(Self::Bqml),
"MODEL_GARDEN" => Some(Self::ModelGarden),
"GENIE" => Some(Self::Genie),
"CUSTOM_TEXT_EMBEDDING" => Some(Self::CustomTextEmbedding),
"MARKETPLACE" => Some(Self::Marketplace),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Probe {
#[prost(int32, tag = "2")]
pub period_seconds: i32,
#[prost(int32, tag = "3")]
pub timeout_seconds: i32,
#[prost(oneof = "probe::ProbeType", tags = "1")]
pub probe_type: ::core::option::Option<probe::ProbeType>,
}
/// Nested message and enum types in `Probe`.
pub mod probe {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecAction {
#[prost(string, repeated, tag = "1")]
pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ProbeType {
#[prost(message, tag = "1")]
Exec(ExecAction),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainingPipeline {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub input_data_config: ::core::option::Option<InputDataConfig>,
#[prost(string, tag = "4")]
pub training_task_definition: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub training_task_inputs: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "6")]
pub training_task_metadata: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "7")]
pub model_to_upload: ::core::option::Option<Model>,
#[prost(string, tag = "22")]
pub model_id: ::prost::alloc::string::String,
#[prost(string, tag = "21")]
pub parent_model: ::prost::alloc::string::String,
#[prost(enumeration = "PipelineState", tag = "9")]
pub state: i32,
#[prost(message, optional, tag = "10")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "11")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "12")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "13")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "14")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "15")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "18")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputDataConfig {
#[prost(string, tag = "1")]
pub dataset_id: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub annotations_filter: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub annotation_schema_uri: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub saved_query_id: ::prost::alloc::string::String,
#[prost(bool, tag = "11")]
pub persist_ml_use_assignment: bool,
#[prost(oneof = "input_data_config::Split", tags = "2, 3, 4, 5, 12")]
pub split: ::core::option::Option<input_data_config::Split>,
#[prost(oneof = "input_data_config::Destination", tags = "8, 10")]
pub destination: ::core::option::Option<input_data_config::Destination>,
}
/// Nested message and enum types in `InputDataConfig`.
pub mod input_data_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Split {
#[prost(message, tag = "2")]
FractionSplit(super::FractionSplit),
#[prost(message, tag = "3")]
FilterSplit(super::FilterSplit),
#[prost(message, tag = "4")]
PredefinedSplit(super::PredefinedSplit),
#[prost(message, tag = "5")]
TimestampSplit(super::TimestampSplit),
#[prost(message, tag = "12")]
StratifiedSplit(super::StratifiedSplit),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(message, tag = "8")]
GcsDestination(super::GcsDestination),
#[prost(message, tag = "10")]
BigqueryDestination(super::BigQueryDestination),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FractionSplit {
#[prost(double, tag = "1")]
pub training_fraction: f64,
#[prost(double, tag = "2")]
pub validation_fraction: f64,
#[prost(double, tag = "3")]
pub test_fraction: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterSplit {
#[prost(string, tag = "1")]
pub training_filter: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub validation_filter: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub test_filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredefinedSplit {
#[prost(string, tag = "1")]
pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimestampSplit {
#[prost(double, tag = "1")]
pub training_fraction: f64,
#[prost(double, tag = "2")]
pub validation_fraction: f64,
#[prost(double, tag = "3")]
pub test_fraction: f64,
#[prost(string, tag = "4")]
pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StratifiedSplit {
#[prost(double, tag = "1")]
pub training_fraction: f64,
#[prost(double, tag = "2")]
pub validation_fraction: f64,
#[prost(double, tag = "3")]
pub test_fraction: f64,
#[prost(string, tag = "4")]
pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCancelPipelineJobsOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTrainingPipelineRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub training_pipeline: ::core::option::Option<TrainingPipeline>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTrainingPipelineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrainingPipelinesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrainingPipelinesResponse {
#[prost(message, repeated, tag = "1")]
pub training_pipelines: ::prost::alloc::vec::Vec<TrainingPipeline>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTrainingPipelineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTrainingPipelineRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePipelineJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub pipeline_job: ::core::option::Option<PipelineJob>,
#[prost(string, tag = "3")]
pub pipeline_job_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPipelineJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPipelineJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPipelineJobsResponse {
#[prost(message, repeated, tag = "1")]
pub pipeline_jobs: ::prost::alloc::vec::Vec<PipelineJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePipelineJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeletePipelineJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeletePipelineJobsResponse {
#[prost(message, repeated, tag = "1")]
pub pipeline_jobs: ::prost::alloc::vec::Vec<PipelineJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelPipelineJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCancelPipelineJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCancelPipelineJobsResponse {
#[prost(message, repeated, tag = "1")]
pub pipeline_jobs: ::prost::alloc::vec::Vec<PipelineJob>,
}
/// Generated client implementations.
pub mod pipeline_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for creating and managing Vertex AI's pipelines. This includes both
/// `TrainingPipeline` resources (used for AutoML and custom training) and
/// `PipelineJob` resources (used for Vertex AI Pipelines).
#[derive(Debug, Clone)]
pub struct PipelineServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> PipelineServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> PipelineServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
PipelineServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a TrainingPipeline. A created TrainingPipeline right away will be
/// attempted to be run.
pub async fn create_training_pipeline(&mut self, request: impl tonic::IntoRequest<super::CreateTrainingPipelineRequest>) -> std::result::Result<tonic::Response<super::TrainingPipeline>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/CreateTrainingPipeline");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "CreateTrainingPipeline"));
self.inner.unary(req, path, codec).await
}
/// Gets a TrainingPipeline.
pub async fn get_training_pipeline(&mut self, request: impl tonic::IntoRequest<super::GetTrainingPipelineRequest>) -> std::result::Result<tonic::Response<super::TrainingPipeline>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/GetTrainingPipeline");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "GetTrainingPipeline"));
self.inner.unary(req, path, codec).await
}
/// Lists TrainingPipelines in a Location.
pub async fn list_training_pipelines(&mut self, request: impl tonic::IntoRequest<super::ListTrainingPipelinesRequest>) -> std::result::Result<tonic::Response<super::ListTrainingPipelinesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/ListTrainingPipelines");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "ListTrainingPipelines"));
self.inner.unary(req, path, codec).await
}
/// Deletes a TrainingPipeline.
pub async fn delete_training_pipeline(&mut self, request: impl tonic::IntoRequest<super::DeleteTrainingPipelineRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/DeleteTrainingPipeline");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "DeleteTrainingPipeline"));
self.inner.unary(req, path, codec).await
}
/// Cancels a TrainingPipeline.
/// Starts asynchronous cancellation on the TrainingPipeline. The server
/// makes a best effort to cancel the pipeline, but success is not
/// guaranteed. Clients can use
/// [PipelineService.GetTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.GetTrainingPipeline]
/// or other methods to check whether the cancellation succeeded or whether the
/// pipeline completed despite cancellation. On successful cancellation,
/// the TrainingPipeline is not deleted; instead it becomes a pipeline with
/// a
/// [TrainingPipeline.error][google.cloud.aiplatform.v1.TrainingPipeline.error]
/// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
/// corresponding to `Code.CANCELLED`, and
/// [TrainingPipeline.state][google.cloud.aiplatform.v1.TrainingPipeline.state]
/// is set to `CANCELLED`.
pub async fn cancel_training_pipeline(&mut self, request: impl tonic::IntoRequest<super::CancelTrainingPipelineRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/CancelTrainingPipeline");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "CancelTrainingPipeline"));
self.inner.unary(req, path, codec).await
}
/// Creates a PipelineJob. A PipelineJob will run immediately when created.
pub async fn create_pipeline_job(&mut self, request: impl tonic::IntoRequest<super::CreatePipelineJobRequest>) -> std::result::Result<tonic::Response<super::PipelineJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/CreatePipelineJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "CreatePipelineJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a PipelineJob.
pub async fn get_pipeline_job(&mut self, request: impl tonic::IntoRequest<super::GetPipelineJobRequest>) -> std::result::Result<tonic::Response<super::PipelineJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/GetPipelineJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "GetPipelineJob"));
self.inner.unary(req, path, codec).await
}
/// Lists PipelineJobs in a Location.
pub async fn list_pipeline_jobs(&mut self, request: impl tonic::IntoRequest<super::ListPipelineJobsRequest>) -> std::result::Result<tonic::Response<super::ListPipelineJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/ListPipelineJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "ListPipelineJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes a PipelineJob.
pub async fn delete_pipeline_job(&mut self, request: impl tonic::IntoRequest<super::DeletePipelineJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/DeletePipelineJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "DeletePipelineJob"));
self.inner.unary(req, path, codec).await
}
/// Batch deletes PipelineJobs
/// The Operation is atomic. If it fails, none of the PipelineJobs are deleted.
/// If it succeeds, all of the PipelineJobs are deleted.
pub async fn batch_delete_pipeline_jobs(&mut self, request: impl tonic::IntoRequest<super::BatchDeletePipelineJobsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/BatchDeletePipelineJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "BatchDeletePipelineJobs"));
self.inner.unary(req, path, codec).await
}
/// Cancels a PipelineJob.
/// Starts asynchronous cancellation on the PipelineJob. The server
/// makes a best effort to cancel the pipeline, but success is not
/// guaranteed. Clients can use
/// [PipelineService.GetPipelineJob][google.cloud.aiplatform.v1.PipelineService.GetPipelineJob]
/// or other methods to check whether the cancellation succeeded or whether the
/// pipeline completed despite cancellation. On successful cancellation,
/// the PipelineJob is not deleted; instead it becomes a pipeline with
/// a [PipelineJob.error][google.cloud.aiplatform.v1.PipelineJob.error] value
/// with a [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding
/// to `Code.CANCELLED`, and
/// [PipelineJob.state][google.cloud.aiplatform.v1.PipelineJob.state] is set to
/// `CANCELLED`.
pub async fn cancel_pipeline_job(&mut self, request: impl tonic::IntoRequest<super::CancelPipelineJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/CancelPipelineJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "CancelPipelineJob"));
self.inner.unary(req, path, codec).await
}
/// Batch cancel PipelineJobs.
/// Firstly the server will check if all the jobs are in non-terminal states,
/// and skip the jobs that are already terminated.
/// If the operation failed, none of the pipeline jobs are cancelled.
/// The server will poll the states of all the pipeline jobs periodically
/// to check the cancellation status.
/// This operation will return an LRO.
pub async fn batch_cancel_pipeline_jobs(&mut self, request: impl tonic::IntoRequest<super::BatchCancelPipelineJobsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PipelineService/BatchCancelPipelineJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PipelineService", "BatchCancelPipelineJobs"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schedule {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "16")]
pub max_run_count: i64,
#[prost(int64, tag = "17")]
pub started_run_count: i64,
#[prost(enumeration = "schedule::State", tag = "5")]
pub state: i32,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "19")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub next_run_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub last_pause_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub last_resume_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "11")]
pub max_concurrent_run_count: i64,
#[prost(bool, tag = "12")]
pub allow_queueing: bool,
#[prost(bool, tag = "13")]
pub catch_up: bool,
#[prost(message, optional, tag = "18")]
pub last_scheduled_run_response: ::core::option::Option<schedule::RunResponse>,
#[prost(oneof = "schedule::TimeSpecification", tags = "10")]
pub time_specification: ::core::option::Option<schedule::TimeSpecification>,
#[prost(oneof = "schedule::Request", tags = "14")]
pub request: ::core::option::Option<schedule::Request>,
}
/// Nested message and enum types in `Schedule`.
pub mod schedule {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunResponse {
#[prost(message, optional, tag = "1")]
pub scheduled_run_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "2")]
pub run_response: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Active = 1,
Paused = 2,
Completed = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Active => "ACTIVE",
State::Paused => "PAUSED",
State::Completed => "COMPLETED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ACTIVE" => Some(Self::Active),
"PAUSED" => Some(Self::Paused),
"COMPLETED" => Some(Self::Completed),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TimeSpecification {
#[prost(string, tag = "10")]
Cron(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Request {
#[prost(message, tag = "14")]
CreatePipelineJobRequest(super::CreatePipelineJobRequest),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateScheduleRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub schedule: ::core::option::Option<Schedule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScheduleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchedulesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchedulesResponse {
#[prost(message, repeated, tag = "1")]
pub schedules: ::prost::alloc::vec::Vec<Schedule>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteScheduleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseScheduleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeScheduleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub catch_up: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateScheduleRequest {
#[prost(message, optional, tag = "1")]
pub schedule: ::core::option::Option<Schedule>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod schedule_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for creating and managing Vertex AI's Schedule resources to
/// periodically launch shceudled runs to make API calls.
#[derive(Debug, Clone)]
pub struct ScheduleServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ScheduleServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ScheduleServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ScheduleServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a Schedule.
pub async fn create_schedule(&mut self, request: impl tonic::IntoRequest<super::CreateScheduleRequest>) -> std::result::Result<tonic::Response<super::Schedule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ScheduleService/CreateSchedule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ScheduleService", "CreateSchedule"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Schedule.
pub async fn delete_schedule(&mut self, request: impl tonic::IntoRequest<super::DeleteScheduleRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ScheduleService/DeleteSchedule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ScheduleService", "DeleteSchedule"));
self.inner.unary(req, path, codec).await
}
/// Gets a Schedule.
pub async fn get_schedule(&mut self, request: impl tonic::IntoRequest<super::GetScheduleRequest>) -> std::result::Result<tonic::Response<super::Schedule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ScheduleService/GetSchedule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ScheduleService", "GetSchedule"));
self.inner.unary(req, path, codec).await
}
/// Lists Schedules in a Location.
pub async fn list_schedules(&mut self, request: impl tonic::IntoRequest<super::ListSchedulesRequest>) -> std::result::Result<tonic::Response<super::ListSchedulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ScheduleService/ListSchedules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ScheduleService", "ListSchedules"));
self.inner.unary(req, path, codec).await
}
/// Pauses a Schedule. Will mark
/// [Schedule.state][google.cloud.aiplatform.v1.Schedule.state] to 'PAUSED'. If
/// the schedule is paused, no new runs will be created. Already created runs
/// will NOT be paused or canceled.
pub async fn pause_schedule(&mut self, request: impl tonic::IntoRequest<super::PauseScheduleRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ScheduleService/PauseSchedule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ScheduleService", "PauseSchedule"));
self.inner.unary(req, path, codec).await
}
/// Resumes a paused Schedule to start scheduling new runs. Will mark
/// [Schedule.state][google.cloud.aiplatform.v1.Schedule.state] to 'ACTIVE'.
/// Only paused Schedule can be resumed.
///
/// When the Schedule is resumed, new runs will be scheduled starting from the
/// next execution time after the current time based on the time_specification
/// in the Schedule. If [Schedule.catchUp][] is set up true, all
/// missed runs will be scheduled for backfill first.
pub async fn resume_schedule(&mut self, request: impl tonic::IntoRequest<super::ResumeScheduleRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ScheduleService/ResumeSchedule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ScheduleService", "ResumeSchedule"));
self.inner.unary(req, path, codec).await
}
/// Updates an active or paused Schedule.
///
/// When the Schedule is updated, new runs will be scheduled starting from the
/// updated next execution time after the update time based on the
/// time_specification in the updated Schedule. All unstarted runs before the
/// update time will be skipped while already created runs will NOT be paused
/// or canceled.
pub async fn update_schedule(&mut self, request: impl tonic::IntoRequest<super::UpdateScheduleRequest>) -> std::result::Result<tonic::Response<super::Schedule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ScheduleService/UpdateSchedule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ScheduleService", "UpdateSchedule"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
#[prost(enumeration = "Type", tag = "1")]
pub r#type: i32,
#[prost(string, tag = "7")]
pub format: ::prost::alloc::string::String,
#[prost(string, tag = "24")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub description: ::prost::alloc::string::String,
#[prost(bool, tag = "6")]
pub nullable: bool,
#[prost(message, optional, tag = "23")]
pub default: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, boxed, tag = "2")]
pub items: ::core::option::Option<::prost::alloc::boxed::Box<Schema>>,
#[prost(int64, tag = "21")]
pub min_items: i64,
#[prost(int64, tag = "22")]
pub max_items: i64,
#[prost(string, repeated, tag = "9")]
pub r#enum: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(btree_map = "string, message", tag = "3")]
pub properties: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, Schema>,
#[prost(string, repeated, tag = "5")]
pub required: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int64, tag = "14")]
pub min_properties: i64,
#[prost(int64, tag = "15")]
pub max_properties: i64,
#[prost(double, tag = "16")]
pub minimum: f64,
#[prost(double, tag = "17")]
pub maximum: f64,
#[prost(int64, tag = "18")]
pub min_length: i64,
#[prost(int64, tag = "19")]
pub max_length: i64,
#[prost(string, tag = "20")]
pub pattern: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub example: ::core::option::Option<::prost_types::Value>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
String = 1,
Number = 2,
Integer = 3,
Boolean = 4,
Array = 5,
Object = 6,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::String => "STRING",
Type::Number => "NUMBER",
Type::Integer => "INTEGER",
Type::Boolean => "BOOLEAN",
Type::Array => "ARRAY",
Type::Object => "OBJECT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"STRING" => Some(Self::String),
"NUMBER" => Some(Self::Number),
"INTEGER" => Some(Self::Integer),
"BOOLEAN" => Some(Self::Boolean),
"ARRAY" => Some(Self::Array),
"OBJECT" => Some(Self::Object),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tool {
#[prost(message, repeated, tag = "1")]
pub function_declarations: ::prost::alloc::vec::Vec<FunctionDeclaration>,
#[prost(message, optional, tag = "2")]
pub retrieval: ::core::option::Option<Retrieval>,
#[prost(message, optional, tag = "3")]
pub google_search_retrieval: ::core::option::Option<GoogleSearchRetrieval>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionDeclaration {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub parameters: ::core::option::Option<Schema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCall {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub args: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionResponse {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub response: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Retrieval {
#[deprecated]
#[prost(bool, tag = "3")]
pub disable_attribution: bool,
#[prost(oneof = "retrieval::Source", tags = "2")]
pub source: ::core::option::Option<retrieval::Source>,
}
/// Nested message and enum types in `Retrieval`.
pub mod retrieval {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
VertexAiSearch(super::VertexAiSearch),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexAiSearch {
#[prost(string, tag = "1")]
pub datastore: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleSearchRetrieval {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolConfig {
#[prost(message, optional, tag = "1")]
pub function_calling_config: ::core::option::Option<FunctionCallingConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCallingConfig {
#[prost(enumeration = "function_calling_config::Mode", tag = "1")]
pub mode: i32,
#[prost(string, repeated, tag = "2")]
pub allowed_function_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FunctionCallingConfig`.
pub mod function_calling_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Mode {
Unspecified = 0,
Auto = 1,
Any = 2,
None = 3,
}
impl Mode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Mode::Unspecified => "MODE_UNSPECIFIED",
Mode::Auto => "AUTO",
Mode::Any => "ANY",
Mode::None => "NONE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODE_UNSPECIFIED" => Some(Self::Unspecified),
"AUTO" => Some(Self::Auto),
"ANY" => Some(Self::Any),
"NONE" => Some(Self::None),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
#[prost(string, tag = "1")]
pub role: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub parts: ::prost::alloc::vec::Vec<Part>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Part {
#[prost(oneof = "part::Data", tags = "1, 2, 3, 5, 6")]
pub data: ::core::option::Option<part::Data>,
#[prost(oneof = "part::Metadata", tags = "4")]
pub metadata: ::core::option::Option<part::Metadata>,
}
/// Nested message and enum types in `Part`.
pub mod part {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Data {
#[prost(string, tag = "1")]
Text(::prost::alloc::string::String),
#[prost(message, tag = "2")]
InlineData(super::Blob),
#[prost(message, tag = "3")]
FileData(super::FileData),
#[prost(message, tag = "5")]
FunctionCall(super::FunctionCall),
#[prost(message, tag = "6")]
FunctionResponse(super::FunctionResponse),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Metadata {
#[prost(message, tag = "4")]
VideoMetadata(super::VideoMetadata),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blob {
#[prost(string, tag = "1")]
pub mime_type: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "2")]
pub data: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileData {
#[prost(string, tag = "1")]
pub mime_type: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub file_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoMetadata {
#[prost(message, optional, tag = "1")]
pub start_offset: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "2")]
pub end_offset: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerationConfig {
#[prost(float, optional, tag = "1")]
pub temperature: ::core::option::Option<f32>,
#[prost(float, optional, tag = "2")]
pub top_p: ::core::option::Option<f32>,
#[prost(float, optional, tag = "3")]
pub top_k: ::core::option::Option<f32>,
#[prost(int32, optional, tag = "4")]
pub candidate_count: ::core::option::Option<i32>,
#[prost(int32, optional, tag = "5")]
pub max_output_tokens: ::core::option::Option<i32>,
#[prost(string, repeated, tag = "6")]
pub stop_sequences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(float, optional, tag = "8")]
pub presence_penalty: ::core::option::Option<f32>,
#[prost(float, optional, tag = "9")]
pub frequency_penalty: ::core::option::Option<f32>,
#[prost(string, tag = "13")]
pub response_mime_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "16")]
pub response_schema: ::core::option::Option<Schema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetySetting {
#[prost(enumeration = "HarmCategory", tag = "1")]
pub category: i32,
#[prost(enumeration = "safety_setting::HarmBlockThreshold", tag = "2")]
pub threshold: i32,
#[prost(enumeration = "safety_setting::HarmBlockMethod", tag = "4")]
pub method: i32,
}
/// Nested message and enum types in `SafetySetting`.
pub mod safety_setting {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmBlockThreshold {
Unspecified = 0,
BlockLowAndAbove = 1,
BlockMediumAndAbove = 2,
BlockOnlyHigh = 3,
BlockNone = 4,
}
impl HarmBlockThreshold {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HarmBlockThreshold::Unspecified => "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
HarmBlockThreshold::BlockLowAndAbove => "BLOCK_LOW_AND_ABOVE",
HarmBlockThreshold::BlockMediumAndAbove => "BLOCK_MEDIUM_AND_ABOVE",
HarmBlockThreshold::BlockOnlyHigh => "BLOCK_ONLY_HIGH",
HarmBlockThreshold::BlockNone => "BLOCK_NONE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"HARM_BLOCK_THRESHOLD_UNSPECIFIED" => Some(Self::Unspecified),
"BLOCK_LOW_AND_ABOVE" => Some(Self::BlockLowAndAbove),
"BLOCK_MEDIUM_AND_ABOVE" => Some(Self::BlockMediumAndAbove),
"BLOCK_ONLY_HIGH" => Some(Self::BlockOnlyHigh),
"BLOCK_NONE" => Some(Self::BlockNone),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmBlockMethod {
Unspecified = 0,
Severity = 1,
Probability = 2,
}
impl HarmBlockMethod {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HarmBlockMethod::Unspecified => "HARM_BLOCK_METHOD_UNSPECIFIED",
HarmBlockMethod::Severity => "SEVERITY",
HarmBlockMethod::Probability => "PROBABILITY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"HARM_BLOCK_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
"SEVERITY" => Some(Self::Severity),
"PROBABILITY" => Some(Self::Probability),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetyRating {
#[prost(enumeration = "HarmCategory", tag = "1")]
pub category: i32,
#[prost(enumeration = "safety_rating::HarmProbability", tag = "2")]
pub probability: i32,
#[prost(float, tag = "5")]
pub probability_score: f32,
#[prost(enumeration = "safety_rating::HarmSeverity", tag = "6")]
pub severity: i32,
#[prost(float, tag = "7")]
pub severity_score: f32,
#[prost(bool, tag = "3")]
pub blocked: bool,
}
/// Nested message and enum types in `SafetyRating`.
pub mod safety_rating {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmProbability {
Unspecified = 0,
Negligible = 1,
Low = 2,
Medium = 3,
High = 4,
}
impl HarmProbability {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HarmProbability::Unspecified => "HARM_PROBABILITY_UNSPECIFIED",
HarmProbability::Negligible => "NEGLIGIBLE",
HarmProbability::Low => "LOW",
HarmProbability::Medium => "MEDIUM",
HarmProbability::High => "HIGH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"HARM_PROBABILITY_UNSPECIFIED" => Some(Self::Unspecified),
"NEGLIGIBLE" => Some(Self::Negligible),
"LOW" => Some(Self::Low),
"MEDIUM" => Some(Self::Medium),
"HIGH" => Some(Self::High),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmSeverity {
Unspecified = 0,
Negligible = 1,
Low = 2,
Medium = 3,
High = 4,
}
impl HarmSeverity {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HarmSeverity::Unspecified => "HARM_SEVERITY_UNSPECIFIED",
HarmSeverity::Negligible => "HARM_SEVERITY_NEGLIGIBLE",
HarmSeverity::Low => "HARM_SEVERITY_LOW",
HarmSeverity::Medium => "HARM_SEVERITY_MEDIUM",
HarmSeverity::High => "HARM_SEVERITY_HIGH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"HARM_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
"HARM_SEVERITY_NEGLIGIBLE" => Some(Self::Negligible),
"HARM_SEVERITY_LOW" => Some(Self::Low),
"HARM_SEVERITY_MEDIUM" => Some(Self::Medium),
"HARM_SEVERITY_HIGH" => Some(Self::High),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CitationMetadata {
#[prost(message, repeated, tag = "1")]
pub citations: ::prost::alloc::vec::Vec<Citation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Citation {
#[prost(int32, tag = "1")]
pub start_index: i32,
#[prost(int32, tag = "2")]
pub end_index: i32,
#[prost(string, tag = "3")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub license: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub publication_date: ::core::option::Option<super::super::super::r#type::Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Candidate {
#[prost(int32, tag = "1")]
pub index: i32,
#[prost(message, optional, tag = "2")]
pub content: ::core::option::Option<Content>,
#[prost(double, tag = "8")]
pub score: f64,
#[prost(enumeration = "candidate::FinishReason", tag = "3")]
pub finish_reason: i32,
#[prost(message, repeated, tag = "4")]
pub safety_ratings: ::prost::alloc::vec::Vec<SafetyRating>,
#[prost(string, optional, tag = "5")]
pub finish_message: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, optional, tag = "6")]
pub citation_metadata: ::core::option::Option<CitationMetadata>,
#[prost(message, optional, tag = "7")]
pub grounding_metadata: ::core::option::Option<GroundingMetadata>,
}
/// Nested message and enum types in `Candidate`.
pub mod candidate {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FinishReason {
Unspecified = 0,
Stop = 1,
MaxTokens = 2,
Safety = 3,
Recitation = 4,
Other = 5,
Blocklist = 6,
ProhibitedContent = 7,
Spii = 8,
MalformedFunctionCall = 9,
}
impl FinishReason {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FinishReason::Unspecified => "FINISH_REASON_UNSPECIFIED",
FinishReason::Stop => "STOP",
FinishReason::MaxTokens => "MAX_TOKENS",
FinishReason::Safety => "SAFETY",
FinishReason::Recitation => "RECITATION",
FinishReason::Other => "OTHER",
FinishReason::Blocklist => "BLOCKLIST",
FinishReason::ProhibitedContent => "PROHIBITED_CONTENT",
FinishReason::Spii => "SPII",
FinishReason::MalformedFunctionCall => "MALFORMED_FUNCTION_CALL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FINISH_REASON_UNSPECIFIED" => Some(Self::Unspecified),
"STOP" => Some(Self::Stop),
"MAX_TOKENS" => Some(Self::MaxTokens),
"SAFETY" => Some(Self::Safety),
"RECITATION" => Some(Self::Recitation),
"OTHER" => Some(Self::Other),
"BLOCKLIST" => Some(Self::Blocklist),
"PROHIBITED_CONTENT" => Some(Self::ProhibitedContent),
"SPII" => Some(Self::Spii),
"MALFORMED_FUNCTION_CALL" => Some(Self::MalformedFunctionCall),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
#[prost(int32, tag = "1")]
pub part_index: i32,
#[prost(int32, tag = "2")]
pub start_index: i32,
#[prost(int32, tag = "3")]
pub end_index: i32,
#[prost(string, tag = "4")]
pub text: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingChunk {
#[prost(oneof = "grounding_chunk::ChunkType", tags = "1, 2")]
pub chunk_type: ::core::option::Option<grounding_chunk::ChunkType>,
}
/// Nested message and enum types in `GroundingChunk`.
pub mod grounding_chunk {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Web {
#[prost(string, optional, tag = "1")]
pub uri: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "2")]
pub title: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrievedContext {
#[prost(string, optional, tag = "1")]
pub uri: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "2")]
pub title: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ChunkType {
#[prost(message, tag = "1")]
Web(Web),
#[prost(message, tag = "2")]
RetrievedContext(RetrievedContext),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingSupport {
#[prost(message, optional, tag = "1")]
pub segment: ::core::option::Option<Segment>,
#[prost(int32, repeated, tag = "2")]
pub grounding_chunk_indices: ::prost::alloc::vec::Vec<i32>,
#[prost(float, repeated, tag = "3")]
pub confidence_scores: ::prost::alloc::vec::Vec<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingMetadata {
#[prost(string, repeated, tag = "1")]
pub web_search_queries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "4")]
pub search_entry_point: ::core::option::Option<SearchEntryPoint>,
#[prost(message, repeated, tag = "5")]
pub grounding_chunks: ::prost::alloc::vec::Vec<GroundingChunk>,
#[prost(message, repeated, tag = "6")]
pub grounding_supports: ::prost::alloc::vec::Vec<GroundingSupport>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntryPoint {
#[prost(string, tag = "1")]
pub rendered_content: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "2")]
pub sdk_blob: ::prost::bytes::Bytes,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmCategory {
Unspecified = 0,
HateSpeech = 1,
DangerousContent = 2,
Harassment = 3,
SexuallyExplicit = 4,
}
impl HarmCategory {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HarmCategory::Unspecified => "HARM_CATEGORY_UNSPECIFIED",
HarmCategory::HateSpeech => "HARM_CATEGORY_HATE_SPEECH",
HarmCategory::DangerousContent => "HARM_CATEGORY_DANGEROUS_CONTENT",
HarmCategory::Harassment => "HARM_CATEGORY_HARASSMENT",
HarmCategory::SexuallyExplicit => "HARM_CATEGORY_SEXUALLY_EXPLICIT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"HARM_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
"HARM_CATEGORY_HATE_SPEECH" => Some(Self::HateSpeech),
"HARM_CATEGORY_DANGEROUS_CONTENT" => Some(Self::DangerousContent),
"HARM_CATEGORY_HARASSMENT" => Some(Self::Harassment),
"HARM_CATEGORY_SEXUALLY_EXPLICIT" => Some(Self::SexuallyExplicit),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoolArray {
#[prost(bool, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleArray {
#[prost(double, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int64Array {
#[prost(int64, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringArray {
#[prost(string, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tensor {
#[prost(enumeration = "tensor::DataType", tag = "1")]
pub dtype: i32,
#[prost(int64, repeated, tag = "2")]
pub shape: ::prost::alloc::vec::Vec<i64>,
#[prost(bool, repeated, tag = "3")]
pub bool_val: ::prost::alloc::vec::Vec<bool>,
#[prost(string, repeated, tag = "14")]
pub string_val: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(bytes = "bytes", repeated, tag = "15")]
pub bytes_val: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
#[prost(float, repeated, tag = "5")]
pub float_val: ::prost::alloc::vec::Vec<f32>,
#[prost(double, repeated, tag = "6")]
pub double_val: ::prost::alloc::vec::Vec<f64>,
#[prost(int32, repeated, tag = "7")]
pub int_val: ::prost::alloc::vec::Vec<i32>,
#[prost(int64, repeated, tag = "8")]
pub int64_val: ::prost::alloc::vec::Vec<i64>,
#[prost(uint32, repeated, tag = "9")]
pub uint_val: ::prost::alloc::vec::Vec<u32>,
#[prost(uint64, repeated, tag = "10")]
pub uint64_val: ::prost::alloc::vec::Vec<u64>,
#[prost(message, repeated, tag = "11")]
pub list_val: ::prost::alloc::vec::Vec<Tensor>,
#[prost(btree_map = "string, message", tag = "12")]
pub struct_val: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, Tensor>,
#[prost(bytes = "bytes", tag = "13")]
pub tensor_val: ::prost::bytes::Bytes,
}
/// Nested message and enum types in `Tensor`.
pub mod tensor {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataType {
Unspecified = 0,
Bool = 1,
String = 2,
Float = 3,
Double = 4,
Int8 = 5,
Int16 = 6,
Int32 = 7,
Int64 = 8,
Uint8 = 9,
Uint16 = 10,
Uint32 = 11,
Uint64 = 12,
}
impl DataType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DataType::Unspecified => "DATA_TYPE_UNSPECIFIED",
DataType::Bool => "BOOL",
DataType::String => "STRING",
DataType::Float => "FLOAT",
DataType::Double => "DOUBLE",
DataType::Int8 => "INT8",
DataType::Int16 => "INT16",
DataType::Int32 => "INT32",
DataType::Int64 => "INT64",
DataType::Uint8 => "UINT8",
DataType::Uint16 => "UINT16",
DataType::Uint32 => "UINT32",
DataType::Uint64 => "UINT64",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"BOOL" => Some(Self::Bool),
"STRING" => Some(Self::String),
"FLOAT" => Some(Self::Float),
"DOUBLE" => Some(Self::Double),
"INT8" => Some(Self::Int8),
"INT16" => Some(Self::Int16),
"INT32" => Some(Self::Int32),
"INT64" => Some(Self::Int64),
"UINT8" => Some(Self::Uint8),
"UINT16" => Some(Self::Uint16),
"UINT32" => Some(Self::Uint32),
"UINT64" => Some(Self::Uint64),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(message, optional, tag = "3")]
pub parameters: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictResponse {
#[prost(message, repeated, tag = "1")]
pub predictions: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(string, tag = "2")]
pub deployed_model_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub model_version_id: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub model_display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub metadata: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub http_body: ::core::option::Option<super::super::super::api::HttpBody>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamRawPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub http_body: ::core::option::Option<super::super::super::api::HttpBody>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub inputs: ::prost::alloc::vec::Vec<Tensor>,
#[prost(message, optional, tag = "3")]
pub parameters: ::core::option::Option<Tensor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectPredictResponse {
#[prost(message, repeated, tag = "1")]
pub outputs: ::prost::alloc::vec::Vec<Tensor>,
#[prost(message, optional, tag = "2")]
pub parameters: ::core::option::Option<Tensor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectRawPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub method_name: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "3")]
pub input: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectRawPredictResponse {
#[prost(bytes = "bytes", tag = "1")]
pub output: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub inputs: ::prost::alloc::vec::Vec<Tensor>,
#[prost(message, optional, tag = "3")]
pub parameters: ::core::option::Option<Tensor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectPredictResponse {
#[prost(message, repeated, tag = "1")]
pub outputs: ::prost::alloc::vec::Vec<Tensor>,
#[prost(message, optional, tag = "2")]
pub parameters: ::core::option::Option<Tensor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectRawPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub method_name: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "3")]
pub input: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectRawPredictResponse {
#[prost(bytes = "bytes", tag = "1")]
pub output: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub inputs: ::prost::alloc::vec::Vec<Tensor>,
#[prost(message, optional, tag = "3")]
pub parameters: ::core::option::Option<Tensor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingPredictResponse {
#[prost(message, repeated, tag = "1")]
pub outputs: ::prost::alloc::vec::Vec<Tensor>,
#[prost(message, optional, tag = "2")]
pub parameters: ::core::option::Option<Tensor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingRawPredictRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub method_name: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "3")]
pub input: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingRawPredictResponse {
#[prost(bytes = "bytes", tag = "1")]
pub output: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplainRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(message, optional, tag = "4")]
pub parameters: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "5")]
pub explanation_spec_override: ::core::option::Option<ExplanationSpecOverride>,
#[prost(string, tag = "3")]
pub deployed_model_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplainResponse {
#[prost(message, repeated, tag = "1")]
pub explanations: ::prost::alloc::vec::Vec<Explanation>,
#[prost(string, tag = "2")]
pub deployed_model_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub predictions: ::prost::alloc::vec::Vec<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountTokensRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub model: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(message, repeated, tag = "4")]
pub contents: ::prost::alloc::vec::Vec<Content>,
#[prost(message, optional, tag = "5")]
pub system_instruction: ::core::option::Option<Content>,
#[prost(message, repeated, tag = "6")]
pub tools: ::prost::alloc::vec::Vec<Tool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountTokensResponse {
#[prost(int32, tag = "1")]
pub total_tokens: i32,
#[prost(int32, tag = "2")]
pub total_billable_characters: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateContentRequest {
#[prost(string, tag = "5")]
pub model: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub contents: ::prost::alloc::vec::Vec<Content>,
#[prost(message, optional, tag = "8")]
pub system_instruction: ::core::option::Option<Content>,
#[prost(message, repeated, tag = "6")]
pub tools: ::prost::alloc::vec::Vec<Tool>,
#[prost(message, optional, tag = "7")]
pub tool_config: ::core::option::Option<ToolConfig>,
#[prost(message, repeated, tag = "3")]
pub safety_settings: ::prost::alloc::vec::Vec<SafetySetting>,
#[prost(message, optional, tag = "4")]
pub generation_config: ::core::option::Option<GenerationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateContentResponse {
#[prost(message, repeated, tag = "2")]
pub candidates: ::prost::alloc::vec::Vec<Candidate>,
#[prost(message, optional, tag = "3")]
pub prompt_feedback: ::core::option::Option<generate_content_response::PromptFeedback>,
#[prost(message, optional, tag = "4")]
pub usage_metadata: ::core::option::Option<generate_content_response::UsageMetadata>,
}
/// Nested message and enum types in `GenerateContentResponse`.
pub mod generate_content_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromptFeedback {
#[prost(enumeration = "prompt_feedback::BlockedReason", tag = "1")]
pub block_reason: i32,
#[prost(message, repeated, tag = "2")]
pub safety_ratings: ::prost::alloc::vec::Vec<super::SafetyRating>,
#[prost(string, tag = "3")]
pub block_reason_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PromptFeedback`.
pub mod prompt_feedback {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlockedReason {
Unspecified = 0,
Safety = 1,
Other = 2,
Blocklist = 3,
ProhibitedContent = 4,
}
impl BlockedReason {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
BlockedReason::Unspecified => "BLOCKED_REASON_UNSPECIFIED",
BlockedReason::Safety => "SAFETY",
BlockedReason::Other => "OTHER",
BlockedReason::Blocklist => "BLOCKLIST",
BlockedReason::ProhibitedContent => "PROHIBITED_CONTENT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"BLOCKED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
"SAFETY" => Some(Self::Safety),
"OTHER" => Some(Self::Other),
"BLOCKLIST" => Some(Self::Blocklist),
"PROHIBITED_CONTENT" => Some(Self::ProhibitedContent),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UsageMetadata {
#[prost(int32, tag = "1")]
pub prompt_token_count: i32,
#[prost(int32, tag = "2")]
pub candidates_token_count: i32,
#[prost(int32, tag = "3")]
pub total_token_count: i32,
}
}
/// Generated client implementations.
pub mod prediction_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for online predictions and explanations.
#[derive(Debug, Clone)]
pub struct PredictionServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> PredictionServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> PredictionServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
PredictionServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Perform an online prediction.
pub async fn predict(&mut self, request: impl tonic::IntoRequest<super::PredictRequest>) -> std::result::Result<tonic::Response<super::PredictResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/Predict");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "Predict"));
self.inner.unary(req, path, codec).await
}
/// Perform an online prediction with an arbitrary HTTP payload.
///
/// The response includes the following HTTP headers:
///
/// * `X-Vertex-AI-Endpoint-Id`: ID of the
/// [Endpoint][google.cloud.aiplatform.v1.Endpoint] that served this
/// prediction.
///
/// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's
/// [DeployedModel][google.cloud.aiplatform.v1.DeployedModel] that served this
/// prediction.
pub async fn raw_predict(&mut self, request: impl tonic::IntoRequest<super::RawPredictRequest>) -> std::result::Result<tonic::Response<super::super::super::super::api::HttpBody>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/RawPredict");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "RawPredict"));
self.inner.unary(req, path, codec).await
}
/// Perform a streaming online prediction with an arbitrary HTTP payload.
pub async fn stream_raw_predict(&mut self, request: impl tonic::IntoRequest<super::StreamRawPredictRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::super::super::super::api::HttpBody>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/StreamRawPredict");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "StreamRawPredict"));
self.inner.server_streaming(req, path, codec).await
}
/// Perform an unary online prediction request to a gRPC model server for
/// Vertex first-party products and frameworks.
pub async fn direct_predict(&mut self, request: impl tonic::IntoRequest<super::DirectPredictRequest>) -> std::result::Result<tonic::Response<super::DirectPredictResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/DirectPredict");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "DirectPredict"));
self.inner.unary(req, path, codec).await
}
/// Perform an unary online prediction request to a gRPC model server for
/// custom containers.
pub async fn direct_raw_predict(&mut self, request: impl tonic::IntoRequest<super::DirectRawPredictRequest>) -> std::result::Result<tonic::Response<super::DirectRawPredictResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/DirectRawPredict");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "DirectRawPredict"));
self.inner.unary(req, path, codec).await
}
/// Perform a streaming online prediction request to a gRPC model server for
/// Vertex first-party products and frameworks.
pub async fn stream_direct_predict(&mut self, request: impl tonic::IntoStreamingRequest<Message = super::StreamDirectPredictRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::StreamDirectPredictResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/StreamDirectPredict");
let mut req = request.into_streaming_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "StreamDirectPredict"));
self.inner.streaming(req, path, codec).await
}
/// Perform a streaming online prediction request to a gRPC model server for
/// custom containers.
pub async fn stream_direct_raw_predict(&mut self, request: impl tonic::IntoStreamingRequest<Message = super::StreamDirectRawPredictRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::StreamDirectRawPredictResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/StreamDirectRawPredict");
let mut req = request.into_streaming_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "StreamDirectRawPredict"));
self.inner.streaming(req, path, codec).await
}
/// Perform a streaming online prediction request for Vertex first-party
/// products and frameworks.
pub async fn streaming_predict(&mut self, request: impl tonic::IntoStreamingRequest<Message = super::StreamingPredictRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::StreamingPredictResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/StreamingPredict");
let mut req = request.into_streaming_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "StreamingPredict"));
self.inner.streaming(req, path, codec).await
}
/// Perform a server-side streaming online prediction request for Vertex
/// LLM streaming.
pub async fn server_streaming_predict(&mut self, request: impl tonic::IntoRequest<super::StreamingPredictRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::StreamingPredictResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/ServerStreamingPredict");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "ServerStreamingPredict"));
self.inner.server_streaming(req, path, codec).await
}
/// Perform a streaming online prediction request through gRPC.
pub async fn streaming_raw_predict(&mut self, request: impl tonic::IntoStreamingRequest<Message = super::StreamingRawPredictRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::StreamingRawPredictResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/StreamingRawPredict");
let mut req = request.into_streaming_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "StreamingRawPredict"));
self.inner.streaming(req, path, codec).await
}
/// Perform an online explanation.
///
/// If
/// [deployed_model_id][google.cloud.aiplatform.v1.ExplainRequest.deployed_model_id]
/// is specified, the corresponding DeployModel must have
/// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
/// populated. If
/// [deployed_model_id][google.cloud.aiplatform.v1.ExplainRequest.deployed_model_id]
/// is not specified, all DeployedModels must have
/// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
/// populated.
pub async fn explain(&mut self, request: impl tonic::IntoRequest<super::ExplainRequest>) -> std::result::Result<tonic::Response<super::ExplainResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/Explain");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "Explain"));
self.inner.unary(req, path, codec).await
}
/// Generate content with multimodal inputs.
pub async fn generate_content(&mut self, request: impl tonic::IntoRequest<super::GenerateContentRequest>) -> std::result::Result<tonic::Response<super::GenerateContentResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/GenerateContent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "GenerateContent"));
self.inner.unary(req, path, codec).await
}
/// Generate content with multimodal inputs with streaming support.
pub async fn stream_generate_content(&mut self, request: impl tonic::IntoRequest<super::GenerateContentRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::GenerateContentResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PredictionService/StreamGenerateContent");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PredictionService", "StreamGenerateContent"));
self.inner.server_streaming(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeTokensRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(string, tag = "3")]
pub model: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub contents: ::prost::alloc::vec::Vec<Content>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokensInfo {
#[prost(bytes = "bytes", repeated, tag = "1")]
pub tokens: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
#[prost(int64, repeated, tag = "2")]
pub token_ids: ::prost::alloc::vec::Vec<i64>,
#[prost(string, tag = "3")]
pub role: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeTokensResponse {
#[prost(message, repeated, tag = "1")]
pub tokens_info: ::prost::alloc::vec::Vec<TokensInfo>,
}
/// Generated client implementations.
pub mod llm_utility_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for LLM related utility functions.
#[derive(Debug, Clone)]
pub struct LlmUtilityServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> LlmUtilityServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> LlmUtilityServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
LlmUtilityServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Perform a token counting.
pub async fn count_tokens(&mut self, request: impl tonic::IntoRequest<super::CountTokensRequest>) -> std::result::Result<tonic::Response<super::CountTokensResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.LlmUtilityService/CountTokens");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.LlmUtilityService", "CountTokens"));
self.inner.unary(req, path, codec).await
}
/// Return a list of tokens based on the input text.
pub async fn compute_tokens(&mut self, request: impl tonic::IntoRequest<super::ComputeTokensRequest>) -> std::result::Result<tonic::Response<super::ComputeTokensResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.LlmUtilityService/ComputeTokens");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.LlmUtilityService", "ComputeTokens"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSpec {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
#[prost(string, tag = "1")]
pub artifact: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub execution: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub event_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "event::Type", tag = "4")]
pub r#type: i32,
#[prost(btree_map = "string, string", tag = "5")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Nested message and enum types in `Event`.
pub mod event {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
Input = 1,
Output = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::Input => "INPUT",
Type::Output => "OUTPUT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"INPUT" => Some(Self::Input),
"OUTPUT" => Some(Self::Output),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineageSubgraph {
#[prost(message, repeated, tag = "1")]
pub artifacts: ::prost::alloc::vec::Vec<Artifact>,
#[prost(message, repeated, tag = "2")]
pub executions: ::prost::alloc::vec::Vec<Execution>,
#[prost(message, repeated, tag = "3")]
pub events: ::prost::alloc::vec::Vec<Event>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedIndexRef {
#[prost(string, tag = "1")]
pub index_endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployed_index_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataStore {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(string, tag = "6")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub state: ::core::option::Option<metadata_store::MetadataStoreState>,
#[prost(message, optional, tag = "8")]
pub dataplex_config: ::core::option::Option<metadata_store::DataplexConfig>,
}
/// Nested message and enum types in `MetadataStore`.
pub mod metadata_store {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetadataStoreState {
#[prost(int64, tag = "1")]
pub disk_utilization_bytes: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataplexConfig {
#[prost(bool, tag = "1")]
pub enabled_pipelines_lineage: bool,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotebookIdleShutdownConfig {
#[prost(message, optional, tag = "1")]
pub idle_timeout: ::core::option::Option<::prost_types::Duration>,
#[prost(bool, tag = "2")]
pub idle_shutdown_disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavedQuery {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "12")]
pub metadata: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub annotation_filter: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub problem_type: ::prost::alloc::string::String,
#[prost(int32, tag = "10")]
pub annotation_spec_count: i32,
#[prost(string, tag = "8")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "9")]
pub support_automl_training: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureStatsAnomaly {
#[prost(double, tag = "1")]
pub score: f64,
#[prost(string, tag = "3")]
pub stats_uri: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub anomaly_uri: ::prost::alloc::string::String,
#[prost(double, tag = "5")]
pub distribution_deviation: f64,
#[prost(double, tag = "9")]
pub anomaly_detection_threshold: f64,
#[prost(message, optional, tag = "7")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobState {
Unspecified = 0,
Queued = 1,
Pending = 2,
Running = 3,
Succeeded = 4,
Failed = 5,
Cancelling = 6,
Cancelled = 7,
Paused = 8,
Expired = 9,
Updating = 10,
PartiallySucceeded = 11,
}
impl JobState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
JobState::Unspecified => "JOB_STATE_UNSPECIFIED",
JobState::Queued => "JOB_STATE_QUEUED",
JobState::Pending => "JOB_STATE_PENDING",
JobState::Running => "JOB_STATE_RUNNING",
JobState::Succeeded => "JOB_STATE_SUCCEEDED",
JobState::Failed => "JOB_STATE_FAILED",
JobState::Cancelling => "JOB_STATE_CANCELLING",
JobState::Cancelled => "JOB_STATE_CANCELLED",
JobState::Paused => "JOB_STATE_PAUSED",
JobState::Expired => "JOB_STATE_EXPIRED",
JobState::Updating => "JOB_STATE_UPDATING",
JobState::PartiallySucceeded => "JOB_STATE_PARTIALLY_SUCCEEDED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"JOB_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"JOB_STATE_QUEUED" => Some(Self::Queued),
"JOB_STATE_PENDING" => Some(Self::Pending),
"JOB_STATE_RUNNING" => Some(Self::Running),
"JOB_STATE_SUCCEEDED" => Some(Self::Succeeded),
"JOB_STATE_FAILED" => Some(Self::Failed),
"JOB_STATE_CANCELLING" => Some(Self::Cancelling),
"JOB_STATE_CANCELLED" => Some(Self::Cancelled),
"JOB_STATE_PAUSED" => Some(Self::Paused),
"JOB_STATE_EXPIRED" => Some(Self::Expired),
"JOB_STATE_UPDATING" => Some(Self::Updating),
"JOB_STATE_PARTIALLY_SUCCEEDED" => Some(Self::PartiallySucceeded),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelMonitoringObjectiveConfig {
#[prost(message, optional, tag = "1")]
pub training_dataset: ::core::option::Option<model_monitoring_objective_config::TrainingDataset>,
#[prost(message, optional, tag = "2")]
pub training_prediction_skew_detection_config: ::core::option::Option<model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig>,
#[prost(message, optional, tag = "3")]
pub prediction_drift_detection_config: ::core::option::Option<model_monitoring_objective_config::PredictionDriftDetectionConfig>,
#[prost(message, optional, tag = "5")]
pub explanation_config: ::core::option::Option<model_monitoring_objective_config::ExplanationConfig>,
}
/// Nested message and enum types in `ModelMonitoringObjectiveConfig`.
pub mod model_monitoring_objective_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainingDataset {
#[prost(string, tag = "2")]
pub data_format: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub target_field: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub logging_sampling_strategy: ::core::option::Option<super::SamplingStrategy>,
#[prost(oneof = "training_dataset::DataSource", tags = "3, 4, 5")]
pub data_source: ::core::option::Option<training_dataset::DataSource>,
}
/// Nested message and enum types in `TrainingDataset`.
pub mod training_dataset {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DataSource {
#[prost(string, tag = "3")]
Dataset(::prost::alloc::string::String),
#[prost(message, tag = "4")]
GcsSource(super::super::GcsSource),
#[prost(message, tag = "5")]
BigquerySource(super::super::BigQuerySource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainingPredictionSkewDetectionConfig {
#[prost(btree_map = "string, message", tag = "1")]
pub skew_thresholds: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::ThresholdConfig>,
#[prost(btree_map = "string, message", tag = "2")]
pub attribution_score_skew_thresholds: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::ThresholdConfig>,
#[prost(message, optional, tag = "6")]
pub default_skew_threshold: ::core::option::Option<super::ThresholdConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictionDriftDetectionConfig {
#[prost(btree_map = "string, message", tag = "1")]
pub drift_thresholds: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::ThresholdConfig>,
#[prost(btree_map = "string, message", tag = "2")]
pub attribution_score_drift_thresholds: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::ThresholdConfig>,
#[prost(message, optional, tag = "5")]
pub default_drift_threshold: ::core::option::Option<super::ThresholdConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationConfig {
#[prost(bool, tag = "1")]
pub enable_feature_attributes: bool,
#[prost(message, optional, tag = "2")]
pub explanation_baseline: ::core::option::Option<explanation_config::ExplanationBaseline>,
}
/// Nested message and enum types in `ExplanationConfig`.
pub mod explanation_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationBaseline {
#[prost(enumeration = "explanation_baseline::PredictionFormat", tag = "1")]
pub prediction_format: i32,
#[prost(oneof = "explanation_baseline::Destination", tags = "2, 3")]
pub destination: ::core::option::Option<explanation_baseline::Destination>,
}
/// Nested message and enum types in `ExplanationBaseline`.
pub mod explanation_baseline {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PredictionFormat {
Unspecified = 0,
Jsonl = 2,
Bigquery = 3,
}
impl PredictionFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PredictionFormat::Unspecified => "PREDICTION_FORMAT_UNSPECIFIED",
PredictionFormat::Jsonl => "JSONL",
PredictionFormat::Bigquery => "BIGQUERY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PREDICTION_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"JSONL" => Some(Self::Jsonl),
"BIGQUERY" => Some(Self::Bigquery),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(message, tag = "2")]
Gcs(super::super::super::GcsDestination),
#[prost(message, tag = "3")]
Bigquery(super::super::super::BigQueryDestination),
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelMonitoringAlertConfig {
#[prost(bool, tag = "2")]
pub enable_logging: bool,
#[prost(string, repeated, tag = "3")]
pub notification_channels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(oneof = "model_monitoring_alert_config::Alert", tags = "1")]
pub alert: ::core::option::Option<model_monitoring_alert_config::Alert>,
}
/// Nested message and enum types in `ModelMonitoringAlertConfig`.
pub mod model_monitoring_alert_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmailAlertConfig {
#[prost(string, repeated, tag = "1")]
pub user_emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Alert {
#[prost(message, tag = "1")]
EmailAlertConfig(EmailAlertConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThresholdConfig {
#[prost(oneof = "threshold_config::Threshold", tags = "1")]
pub threshold: ::core::option::Option<threshold_config::Threshold>,
}
/// Nested message and enum types in `ThresholdConfig`.
pub mod threshold_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Threshold {
#[prost(double, tag = "1")]
Value(f64),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SamplingStrategy {
#[prost(message, optional, tag = "1")]
pub random_sample_config: ::core::option::Option<sampling_strategy::RandomSampleConfig>,
}
/// Nested message and enum types in `SamplingStrategy`.
pub mod sampling_strategy {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RandomSampleConfig {
#[prost(double, tag = "1")]
pub sample_rate: f64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub endpoint: ::prost::alloc::string::String,
#[prost(enumeration = "JobState", tag = "4")]
pub state: i32,
#[prost(enumeration = "model_deployment_monitoring_job::MonitoringScheduleState", tag = "5")]
pub schedule_state: i32,
#[prost(message, optional, tag = "25")]
pub latest_monitoring_pipeline_metadata: ::core::option::Option<model_deployment_monitoring_job::LatestMonitoringPipelineMetadata>,
#[prost(message, repeated, tag = "6")]
pub model_deployment_monitoring_objective_configs: ::prost::alloc::vec::Vec<ModelDeploymentMonitoringObjectiveConfig>,
#[prost(message, optional, tag = "7")]
pub model_deployment_monitoring_schedule_config: ::core::option::Option<ModelDeploymentMonitoringScheduleConfig>,
#[prost(message, optional, tag = "8")]
pub logging_sampling_strategy: ::core::option::Option<SamplingStrategy>,
#[prost(message, optional, tag = "15")]
pub model_monitoring_alert_config: ::core::option::Option<ModelMonitoringAlertConfig>,
#[prost(string, tag = "9")]
pub predict_instance_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "19")]
pub sample_predict_instance: ::core::option::Option<::prost_types::Value>,
#[prost(string, tag = "16")]
pub analysis_instance_schema_uri: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "10")]
pub bigquery_tables: ::prost::alloc::vec::Vec<ModelDeploymentMonitoringBigQueryTable>,
#[prost(message, optional, tag = "17")]
pub log_ttl: ::core::option::Option<::prost_types::Duration>,
#[prost(btree_map = "string, string", tag = "11")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "12")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "13")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "14")]
pub next_schedule_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "20")]
pub stats_anomalies_base_directory: ::core::option::Option<GcsDestination>,
#[prost(message, optional, tag = "21")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(bool, tag = "22")]
pub enable_monitoring_pipeline_logs: bool,
#[prost(message, optional, tag = "23")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
}
/// Nested message and enum types in `ModelDeploymentMonitoringJob`.
pub mod model_deployment_monitoring_job {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatestMonitoringPipelineMetadata {
#[prost(message, optional, tag = "1")]
pub run_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub status: ::core::option::Option<super::super::super::super::rpc::Status>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MonitoringScheduleState {
Unspecified = 0,
Pending = 1,
Offline = 2,
Running = 3,
}
impl MonitoringScheduleState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MonitoringScheduleState::Unspecified => "MONITORING_SCHEDULE_STATE_UNSPECIFIED",
MonitoringScheduleState::Pending => "PENDING",
MonitoringScheduleState::Offline => "OFFLINE",
MonitoringScheduleState::Running => "RUNNING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MONITORING_SCHEDULE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PENDING" => Some(Self::Pending),
"OFFLINE" => Some(Self::Offline),
"RUNNING" => Some(Self::Running),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringBigQueryTable {
#[prost(enumeration = "model_deployment_monitoring_big_query_table::LogSource", tag = "1")]
pub log_source: i32,
#[prost(enumeration = "model_deployment_monitoring_big_query_table::LogType", tag = "2")]
pub log_type: i32,
#[prost(string, tag = "3")]
pub bigquery_table_path: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub request_response_logging_schema_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ModelDeploymentMonitoringBigQueryTable`.
pub mod model_deployment_monitoring_big_query_table {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogSource {
Unspecified = 0,
Training = 1,
Serving = 2,
}
impl LogSource {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LogSource::Unspecified => "LOG_SOURCE_UNSPECIFIED",
LogSource::Training => "TRAINING",
LogSource::Serving => "SERVING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOG_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
"TRAINING" => Some(Self::Training),
"SERVING" => Some(Self::Serving),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogType {
Unspecified = 0,
Predict = 1,
Explain = 2,
}
impl LogType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LogType::Unspecified => "LOG_TYPE_UNSPECIFIED",
LogType::Predict => "PREDICT",
LogType::Explain => "EXPLAIN",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"PREDICT" => Some(Self::Predict),
"EXPLAIN" => Some(Self::Explain),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringObjectiveConfig {
#[prost(string, tag = "1")]
pub deployed_model_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub objective_config: ::core::option::Option<ModelMonitoringObjectiveConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringScheduleConfig {
#[prost(message, optional, tag = "1")]
pub monitor_interval: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "2")]
pub monitor_window: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelMonitoringStatsAnomalies {
#[prost(enumeration = "ModelDeploymentMonitoringObjectiveType", tag = "1")]
pub objective: i32,
#[prost(string, tag = "2")]
pub deployed_model_id: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub anomaly_count: i32,
#[prost(message, repeated, tag = "4")]
pub feature_stats: ::prost::alloc::vec::Vec<model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies>,
}
/// Nested message and enum types in `ModelMonitoringStatsAnomalies`.
pub mod model_monitoring_stats_anomalies {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureHistoricStatsAnomalies {
#[prost(string, tag = "1")]
pub feature_display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub threshold: ::core::option::Option<super::ThresholdConfig>,
#[prost(message, optional, tag = "4")]
pub training_stats: ::core::option::Option<super::FeatureStatsAnomaly>,
#[prost(message, repeated, tag = "5")]
pub prediction_stats: ::prost::alloc::vec::Vec<super::FeatureStatsAnomaly>,
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelDeploymentMonitoringObjectiveType {
Unspecified = 0,
RawFeatureSkew = 1,
RawFeatureDrift = 2,
FeatureAttributionSkew = 3,
FeatureAttributionDrift = 4,
}
impl ModelDeploymentMonitoringObjectiveType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ModelDeploymentMonitoringObjectiveType::Unspecified => "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED",
ModelDeploymentMonitoringObjectiveType::RawFeatureSkew => "RAW_FEATURE_SKEW",
ModelDeploymentMonitoringObjectiveType::RawFeatureDrift => "RAW_FEATURE_DRIFT",
ModelDeploymentMonitoringObjectiveType::FeatureAttributionSkew => "FEATURE_ATTRIBUTION_SKEW",
ModelDeploymentMonitoringObjectiveType::FeatureAttributionDrift => "FEATURE_ATTRIBUTION_DRIFT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"RAW_FEATURE_SKEW" => Some(Self::RawFeatureSkew),
"RAW_FEATURE_DRIFT" => Some(Self::RawFeatureDrift),
"FEATURE_ATTRIBUTION_SKEW" => Some(Self::FeatureAttributionSkew),
"FEATURE_ATTRIBUTION_DRIFT" => Some(Self::FeatureAttributionDrift),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dataset {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "16")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub metadata_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub metadata: ::core::option::Option<::prost_types::Value>,
#[prost(int64, tag = "10")]
pub data_item_count: i64,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "6")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "7")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, repeated, tag = "9")]
pub saved_queries: ::prost::alloc::vec::Vec<SavedQuery>,
#[prost(message, optional, tag = "11")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(string, tag = "17")]
pub metadata_artifact: ::prost::alloc::string::String,
#[prost(string, tag = "18")]
pub model_reference: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataConfig {
#[prost(btree_map = "string, string", tag = "2")]
pub data_item_labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(btree_map = "string, string", tag = "3")]
pub annotation_labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "4")]
pub import_schema_uri: ::prost::alloc::string::String,
#[prost(oneof = "import_data_config::Source", tags = "1")]
pub source: ::core::option::Option<import_data_config::Source>,
}
/// Nested message and enum types in `ImportDataConfig`.
pub mod import_data_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "1")]
GcsSource(super::GcsSource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataConfig {
#[prost(string, tag = "2")]
pub annotations_filter: ::prost::alloc::string::String,
#[prost(string, tag = "11")]
pub saved_query_id: ::prost::alloc::string::String,
#[prost(string, tag = "12")]
pub annotation_schema_uri: ::prost::alloc::string::String,
#[prost(enumeration = "export_data_config::ExportUse", tag = "4")]
pub export_use: i32,
#[prost(oneof = "export_data_config::Destination", tags = "1")]
pub destination: ::core::option::Option<export_data_config::Destination>,
#[prost(oneof = "export_data_config::Split", tags = "5, 7")]
pub split: ::core::option::Option<export_data_config::Split>,
}
/// Nested message and enum types in `ExportDataConfig`.
pub mod export_data_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExportUse {
Unspecified = 0,
CustomCodeTraining = 6,
}
impl ExportUse {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ExportUse::Unspecified => "EXPORT_USE_UNSPECIFIED",
ExportUse::CustomCodeTraining => "CUSTOM_CODE_TRAINING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EXPORT_USE_UNSPECIFIED" => Some(Self::Unspecified),
"CUSTOM_CODE_TRAINING" => Some(Self::CustomCodeTraining),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(message, tag = "1")]
GcsDestination(super::GcsDestination),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Split {
#[prost(message, tag = "5")]
FractionSplit(super::ExportFractionSplit),
#[prost(message, tag = "7")]
FilterSplit(super::ExportFilterSplit),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportFractionSplit {
#[prost(double, tag = "1")]
pub training_fraction: f64,
#[prost(double, tag = "2")]
pub validation_fraction: f64,
#[prost(double, tag = "3")]
pub test_fraction: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFilterSplit {
#[prost(string, tag = "1")]
pub training_filter: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub validation_filter: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub test_filter: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AcceleratorType {
Unspecified = 0,
NvidiaTeslaK80 = 1,
NvidiaTeslaP100 = 2,
NvidiaTeslaV100 = 3,
NvidiaTeslaP4 = 4,
NvidiaTeslaT4 = 5,
NvidiaTeslaA100 = 8,
NvidiaA10080gb = 9,
NvidiaL4 = 11,
NvidiaH10080gb = 13,
TpuV2 = 6,
TpuV3 = 7,
TpuV4Pod = 10,
TpuV5Litepod = 12,
}
impl AcceleratorType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AcceleratorType::Unspecified => "ACCELERATOR_TYPE_UNSPECIFIED",
AcceleratorType::NvidiaTeslaK80 => "NVIDIA_TESLA_K80",
AcceleratorType::NvidiaTeslaP100 => "NVIDIA_TESLA_P100",
AcceleratorType::NvidiaTeslaV100 => "NVIDIA_TESLA_V100",
AcceleratorType::NvidiaTeslaP4 => "NVIDIA_TESLA_P4",
AcceleratorType::NvidiaTeslaT4 => "NVIDIA_TESLA_T4",
AcceleratorType::NvidiaTeslaA100 => "NVIDIA_TESLA_A100",
AcceleratorType::NvidiaA10080gb => "NVIDIA_A100_80GB",
AcceleratorType::NvidiaL4 => "NVIDIA_L4",
AcceleratorType::NvidiaH10080gb => "NVIDIA_H100_80GB",
AcceleratorType::TpuV2 => "TPU_V2",
AcceleratorType::TpuV3 => "TPU_V3",
AcceleratorType::TpuV4Pod => "TPU_V4_POD",
AcceleratorType::TpuV5Litepod => "TPU_V5_LITEPOD",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ACCELERATOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"NVIDIA_TESLA_K80" => Some(Self::NvidiaTeslaK80),
"NVIDIA_TESLA_P100" => Some(Self::NvidiaTeslaP100),
"NVIDIA_TESLA_V100" => Some(Self::NvidiaTeslaV100),
"NVIDIA_TESLA_P4" => Some(Self::NvidiaTeslaP4),
"NVIDIA_TESLA_T4" => Some(Self::NvidiaTeslaT4),
"NVIDIA_TESLA_A100" => Some(Self::NvidiaTeslaA100),
"NVIDIA_A100_80GB" => Some(Self::NvidiaA10080gb),
"NVIDIA_L4" => Some(Self::NvidiaL4),
"NVIDIA_H100_80GB" => Some(Self::NvidiaH10080gb),
"TPU_V2" => Some(Self::TpuV2),
"TPU_V3" => Some(Self::TpuV3),
"TPU_V4_POD" => Some(Self::TpuV4Pod),
"TPU_V5_LITEPOD" => Some(Self::TpuV5Litepod),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineSpec {
#[prost(string, tag = "1")]
pub machine_type: ::prost::alloc::string::String,
#[prost(enumeration = "AcceleratorType", tag = "2")]
pub accelerator_type: i32,
#[prost(int32, tag = "3")]
pub accelerator_count: i32,
#[prost(string, tag = "4")]
pub tpu_topology: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DedicatedResources {
#[prost(message, optional, tag = "1")]
pub machine_spec: ::core::option::Option<MachineSpec>,
#[prost(int32, tag = "2")]
pub min_replica_count: i32,
#[prost(int32, tag = "3")]
pub max_replica_count: i32,
#[prost(message, repeated, tag = "4")]
pub autoscaling_metric_specs: ::prost::alloc::vec::Vec<AutoscalingMetricSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutomaticResources {
#[prost(int32, tag = "1")]
pub min_replica_count: i32,
#[prost(int32, tag = "2")]
pub max_replica_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDedicatedResources {
#[prost(message, optional, tag = "1")]
pub machine_spec: ::core::option::Option<MachineSpec>,
#[prost(int32, tag = "2")]
pub starting_replica_count: i32,
#[prost(int32, tag = "3")]
pub max_replica_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourcesConsumed {
#[prost(double, tag = "1")]
pub replica_hours: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskSpec {
#[prost(string, tag = "1")]
pub boot_disk_type: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub boot_disk_size_gb: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentDiskSpec {
#[prost(string, tag = "1")]
pub disk_type: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub disk_size_gb: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfsMount {
#[prost(string, tag = "1")]
pub server: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub path: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub mount_point: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingMetricSpec {
#[prost(string, tag = "1")]
pub metric_name: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub target: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShieldedVmConfig {
#[prost(bool, tag = "1")]
pub enable_secure_boot: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentResourcePool {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub dedicated_resources: ::core::option::Option<DedicatedResources>,
#[prost(message, optional, tag = "5")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(string, tag = "6")]
pub service_account: ::prost::alloc::string::String,
#[prost(bool, tag = "7")]
pub disable_container_logging: bool,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateServiceConnectConfig {
#[prost(bool, tag = "1")]
pub enable_private_service_connect: bool,
#[prost(string, repeated, tag = "2")]
pub project_allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PscAutomatedEndpoints {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub network: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub match_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Endpoint {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub deployed_models: ::prost::alloc::vec::Vec<DeployedModel>,
#[prost(btree_map = "string, int32", tag = "5")]
pub traffic_split: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
#[prost(string, tag = "6")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "7")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "8")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "10")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(string, tag = "13")]
pub network: ::prost::alloc::string::String,
#[deprecated]
#[prost(bool, tag = "17")]
pub enable_private_service_connect: bool,
#[prost(message, optional, tag = "21")]
pub private_service_connect_config: ::core::option::Option<PrivateServiceConnectConfig>,
#[prost(string, tag = "14")]
pub model_deployment_monitoring_job: ::prost::alloc::string::String,
#[prost(message, optional, tag = "18")]
pub predict_request_response_logging_config: ::core::option::Option<PredictRequestResponseLoggingConfig>,
#[prost(bool, tag = "24")]
pub dedicated_endpoint_enabled: bool,
#[prost(string, tag = "25")]
pub dedicated_endpoint_dns: ::prost::alloc::string::String,
#[prost(bool, tag = "27")]
pub satisfies_pzs: bool,
#[prost(bool, tag = "28")]
pub satisfies_pzi: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedModel {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "18")]
pub model_version_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub explanation_spec: ::core::option::Option<ExplanationSpec>,
#[prost(bool, tag = "19")]
pub disable_explanations: bool,
#[prost(string, tag = "11")]
pub service_account: ::prost::alloc::string::String,
#[prost(bool, tag = "15")]
pub disable_container_logging: bool,
#[prost(bool, tag = "13")]
pub enable_access_logging: bool,
#[prost(message, optional, tag = "14")]
pub private_endpoints: ::core::option::Option<PrivateEndpoints>,
#[prost(oneof = "deployed_model::PredictionResources", tags = "7, 8, 17")]
pub prediction_resources: ::core::option::Option<deployed_model::PredictionResources>,
}
/// Nested message and enum types in `DeployedModel`.
pub mod deployed_model {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum PredictionResources {
#[prost(message, tag = "7")]
DedicatedResources(super::DedicatedResources),
#[prost(message, tag = "8")]
AutomaticResources(super::AutomaticResources),
#[prost(string, tag = "17")]
SharedResources(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateEndpoints {
#[prost(string, tag = "1")]
pub predict_http_uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub explain_http_uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub health_http_uri: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub service_attachment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictRequestResponseLoggingConfig {
#[prost(bool, tag = "1")]
pub enabled: bool,
#[prost(double, tag = "2")]
pub sampling_rate: f64,
#[prost(message, optional, tag = "3")]
pub bigquery_destination: ::core::option::Option<BigQueryDestination>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentResourcePoolRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub deployment_resource_pool: ::core::option::Option<DeploymentResourcePool>,
#[prost(string, tag = "3")]
pub deployment_resource_pool_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentResourcePoolOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentResourcePoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentResourcePoolsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentResourcePoolsResponse {
#[prost(message, repeated, tag = "1")]
pub deployment_resource_pools: ::prost::alloc::vec::Vec<DeploymentResourcePool>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentResourcePoolRequest {
#[prost(message, optional, tag = "1")]
pub deployment_resource_pool: ::core::option::Option<DeploymentResourcePool>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentResourcePoolOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeploymentResourcePoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDeployedModelsRequest {
#[prost(string, tag = "1")]
pub deployment_resource_pool: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDeployedModelsResponse {
#[deprecated]
#[prost(message, repeated, tag = "1")]
pub deployed_models: ::prost::alloc::vec::Vec<DeployedModel>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub deployed_model_refs: ::prost::alloc::vec::Vec<DeployedModelRef>,
#[prost(int32, tag = "4")]
pub total_deployed_model_count: i32,
#[prost(int32, tag = "5")]
pub total_endpoint_count: i32,
}
/// Generated client implementations.
pub mod deployment_resource_pool_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service that manages the DeploymentResourcePool resource.
#[derive(Debug, Clone)]
pub struct DeploymentResourcePoolServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DeploymentResourcePoolServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DeploymentResourcePoolServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DeploymentResourcePoolServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Create a DeploymentResourcePool.
pub async fn create_deployment_resource_pool(&mut self, request: impl tonic::IntoRequest<super::CreateDeploymentResourcePoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DeploymentResourcePoolService/CreateDeploymentResourcePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DeploymentResourcePoolService", "CreateDeploymentResourcePool"));
self.inner.unary(req, path, codec).await
}
/// Get a DeploymentResourcePool.
pub async fn get_deployment_resource_pool(&mut self, request: impl tonic::IntoRequest<super::GetDeploymentResourcePoolRequest>) -> std::result::Result<tonic::Response<super::DeploymentResourcePool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DeploymentResourcePoolService/GetDeploymentResourcePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DeploymentResourcePoolService", "GetDeploymentResourcePool"));
self.inner.unary(req, path, codec).await
}
/// List DeploymentResourcePools in a location.
pub async fn list_deployment_resource_pools(&mut self, request: impl tonic::IntoRequest<super::ListDeploymentResourcePoolsRequest>) -> std::result::Result<tonic::Response<super::ListDeploymentResourcePoolsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DeploymentResourcePoolService/ListDeploymentResourcePools");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DeploymentResourcePoolService", "ListDeploymentResourcePools"));
self.inner.unary(req, path, codec).await
}
/// Update a DeploymentResourcePool.
pub async fn update_deployment_resource_pool(&mut self, request: impl tonic::IntoRequest<super::UpdateDeploymentResourcePoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DeploymentResourcePoolService/UpdateDeploymentResourcePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DeploymentResourcePoolService", "UpdateDeploymentResourcePool"));
self.inner.unary(req, path, codec).await
}
/// Delete a DeploymentResourcePool.
pub async fn delete_deployment_resource_pool(&mut self, request: impl tonic::IntoRequest<super::DeleteDeploymentResourcePoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DeploymentResourcePoolService/DeleteDeploymentResourcePool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DeploymentResourcePoolService", "DeleteDeploymentResourcePool"));
self.inner.unary(req, path, codec).await
}
/// List DeployedModels that have been deployed on this DeploymentResourcePool.
pub async fn query_deployed_models(&mut self, request: impl tonic::IntoRequest<super::QueryDeployedModelsRequest>) -> std::result::Result<tonic::Response<super::QueryDeployedModelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DeploymentResourcePoolService/QueryDeployedModels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DeploymentResourcePoolService", "QueryDeployedModels"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManualBatchTuningParameters {
#[prost(int32, tag = "1")]
pub batch_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkSpec {
#[prost(bool, tag = "1")]
pub enable_internet_access: bool,
#[prost(string, tag = "2")]
pub network: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub subnetwork: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotebookEucConfig {
#[prost(bool, tag = "1")]
pub euc_disabled: bool,
#[prost(bool, tag = "2")]
pub bypass_actas_check: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookRuntimeTemplateRef {
#[prost(string, tag = "1")]
pub notebook_runtime_template: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookRuntimeTemplate {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub is_default: bool,
#[prost(message, optional, tag = "5")]
pub machine_spec: ::core::option::Option<MachineSpec>,
#[prost(message, optional, tag = "8")]
pub data_persistent_disk_spec: ::core::option::Option<PersistentDiskSpec>,
#[prost(message, optional, tag = "12")]
pub network_spec: ::core::option::Option<NetworkSpec>,
#[prost(string, tag = "13")]
pub service_account: ::prost::alloc::string::String,
#[prost(string, tag = "14")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "15")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "17")]
pub idle_shutdown_config: ::core::option::Option<NotebookIdleShutdownConfig>,
#[prost(message, optional, tag = "18")]
pub euc_config: ::core::option::Option<NotebookEucConfig>,
#[prost(message, optional, tag = "10")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "11")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "NotebookRuntimeType", tag = "19")]
pub notebook_runtime_type: i32,
#[prost(message, optional, tag = "20")]
pub shielded_vm_config: ::core::option::Option<ShieldedVmConfig>,
#[prost(string, repeated, tag = "21")]
pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "23")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookRuntime {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub runtime_user: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub notebook_runtime_template_ref: ::core::option::Option<NotebookRuntimeTemplateRef>,
#[prost(string, tag = "5")]
pub proxy_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "notebook_runtime::HealthState", tag = "8")]
pub health_state: i32,
#[prost(string, tag = "10")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "11")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "13")]
pub service_account: ::prost::alloc::string::String,
#[prost(enumeration = "notebook_runtime::RuntimeState", tag = "14")]
pub runtime_state: i32,
#[prost(bool, tag = "15")]
pub is_upgradable: bool,
#[prost(btree_map = "string, string", tag = "16")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "17")]
pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "18")]
pub version: ::prost::alloc::string::String,
#[prost(enumeration = "NotebookRuntimeType", tag = "19")]
pub notebook_runtime_type: i32,
#[prost(message, optional, tag = "23")]
pub idle_shutdown_config: ::core::option::Option<NotebookIdleShutdownConfig>,
#[prost(string, repeated, tag = "25")]
pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "28")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(bool, tag = "29")]
pub satisfies_pzs: bool,
#[prost(bool, tag = "30")]
pub satisfies_pzi: bool,
}
/// Nested message and enum types in `NotebookRuntime`.
pub mod notebook_runtime {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthState {
Unspecified = 0,
Healthy = 1,
Unhealthy = 2,
}
impl HealthState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
HealthState::Unspecified => "HEALTH_STATE_UNSPECIFIED",
HealthState::Healthy => "HEALTHY",
HealthState::Unhealthy => "UNHEALTHY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"HEALTH_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"HEALTHY" => Some(Self::Healthy),
"UNHEALTHY" => Some(Self::Unhealthy),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RuntimeState {
Unspecified = 0,
Running = 1,
BeingStarted = 2,
BeingStopped = 3,
Stopped = 4,
BeingUpgraded = 5,
Error = 100,
Invalid = 101,
}
impl RuntimeState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RuntimeState::Unspecified => "RUNTIME_STATE_UNSPECIFIED",
RuntimeState::Running => "RUNNING",
RuntimeState::BeingStarted => "BEING_STARTED",
RuntimeState::BeingStopped => "BEING_STOPPED",
RuntimeState::Stopped => "STOPPED",
RuntimeState::BeingUpgraded => "BEING_UPGRADED",
RuntimeState::Error => "ERROR",
RuntimeState::Invalid => "INVALID",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"RUNTIME_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"RUNNING" => Some(Self::Running),
"BEING_STARTED" => Some(Self::BeingStarted),
"BEING_STOPPED" => Some(Self::BeingStopped),
"STOPPED" => Some(Self::Stopped),
"BEING_UPGRADED" => Some(Self::BeingUpgraded),
"ERROR" => Some(Self::Error),
"INVALID" => Some(Self::Invalid),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotebookRuntimeType {
Unspecified = 0,
UserDefined = 1,
OneClick = 2,
}
impl NotebookRuntimeType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
NotebookRuntimeType::Unspecified => "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED",
NotebookRuntimeType::UserDefined => "USER_DEFINED",
NotebookRuntimeType::OneClick => "ONE_CLICK",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"USER_DEFINED" => Some(Self::UserDefined),
"ONE_CLICK" => Some(Self::OneClick),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnmanagedContainerModel {
#[prost(string, tag = "1")]
pub artifact_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub predict_schemata: ::core::option::Option<PredictSchemata>,
#[prost(message, optional, tag = "3")]
pub container_spec: ::core::option::Option<ModelContainerSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tensorboard {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "11")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(string, tag = "10")]
pub blob_storage_path_prefix: ::prost::alloc::string::String,
#[prost(int32, tag = "5")]
pub run_count: i32,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "8")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "9")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "12")]
pub is_default: bool,
#[prost(bool, tag = "13")]
pub satisfies_pzs: bool,
#[prost(bool, tag = "14")]
pub satisfies_pzi: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardRun {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "8")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "9")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompletionStats {
#[prost(int64, tag = "1")]
pub successful_count: i64,
#[prost(int64, tag = "2")]
pub failed_count: i64,
#[prost(int64, tag = "3")]
pub incomplete_count: i64,
#[prost(int64, tag = "5")]
pub successful_forecast_point_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelEvaluationSlice {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub slice: ::core::option::Option<model_evaluation_slice::Slice>,
#[prost(string, tag = "3")]
pub metrics_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub metrics: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "5")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub model_explanation: ::core::option::Option<ModelExplanation>,
}
/// Nested message and enum types in `ModelEvaluationSlice`.
pub mod model_evaluation_slice {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Slice {
#[prost(string, tag = "1")]
pub dimension: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub value: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub slice_spec: ::core::option::Option<slice::SliceSpec>,
}
/// Nested message and enum types in `Slice`.
pub mod slice {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SliceSpec {
#[prost(btree_map = "string, message", tag = "1")]
pub configs: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, slice_spec::SliceConfig>,
}
/// Nested message and enum types in `SliceSpec`.
pub mod slice_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SliceConfig {
#[prost(oneof = "slice_config::Kind", tags = "1, 2, 3")]
pub kind: ::core::option::Option<slice_config::Kind>,
}
/// Nested message and enum types in `SliceConfig`.
pub mod slice_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(message, tag = "1")]
Value(super::Value),
#[prost(message, tag = "2")]
Range(super::Range),
#[prost(message, tag = "3")]
AllValues(bool),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Range {
#[prost(float, tag = "1")]
pub low: f32,
#[prost(float, tag = "2")]
pub high: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
#[prost(oneof = "value::Kind", tags = "1, 2")]
pub kind: ::core::option::Option<value::Kind>,
}
/// Nested message and enum types in `Value`.
pub mod value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Kind {
#[prost(string, tag = "1")]
StringValue(::prost::alloc::string::String),
#[prost(float, tag = "2")]
FloatValue(f32),
}
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureOnlineStore {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(enumeration = "feature_online_store::State", tag = "7")]
pub state: i32,
#[prost(message, optional, tag = "10")]
pub dedicated_serving_endpoint: ::core::option::Option<feature_online_store::DedicatedServingEndpoint>,
#[prost(message, optional, tag = "13")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(oneof = "feature_online_store::StorageType", tags = "8, 12")]
pub storage_type: ::core::option::Option<feature_online_store::StorageType>,
}
/// Nested message and enum types in `FeatureOnlineStore`.
pub mod feature_online_store {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Bigtable {
#[prost(message, optional, tag = "1")]
pub auto_scaling: ::core::option::Option<bigtable::AutoScaling>,
}
/// Nested message and enum types in `Bigtable`.
pub mod bigtable {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoScaling {
#[prost(int32, tag = "1")]
pub min_node_count: i32,
#[prost(int32, tag = "2")]
pub max_node_count: i32,
#[prost(int32, tag = "3")]
pub cpu_utilization_target: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Optimized {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DedicatedServingEndpoint {
#[prost(string, tag = "2")]
pub public_endpoint_domain_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub private_service_connect_config: ::core::option::Option<super::PrivateServiceConnectConfig>,
#[prost(string, tag = "4")]
pub service_attachment: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Stable = 1,
Updating = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Stable => "STABLE",
State::Updating => "UPDATING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"STABLE" => Some(Self::Stable),
"UPDATING" => Some(Self::Updating),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum StorageType {
#[prost(message, tag = "8")]
Bigtable(Bigtable),
#[prost(message, tag = "12")]
Optimized(Optimized),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureView {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "4")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "5")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub sync_config: ::core::option::Option<feature_view::SyncConfig>,
#[prost(message, optional, tag = "15")]
pub index_config: ::core::option::Option<feature_view::IndexConfig>,
#[prost(oneof = "feature_view::Source", tags = "6, 9")]
pub source: ::core::option::Option<feature_view::Source>,
}
/// Nested message and enum types in `FeatureView`.
pub mod feature_view {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuerySource {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub entity_id_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncConfig {
#[prost(string, tag = "1")]
pub cron: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexConfig {
#[prost(string, tag = "1")]
pub embedding_column: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub filter_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "3")]
pub crowding_column: ::prost::alloc::string::String,
#[prost(int32, optional, tag = "4")]
pub embedding_dimension: ::core::option::Option<i32>,
#[prost(enumeration = "index_config::DistanceMeasureType", tag = "5")]
pub distance_measure_type: i32,
#[prost(oneof = "index_config::AlgorithmConfig", tags = "6, 7")]
pub algorithm_config: ::core::option::Option<index_config::AlgorithmConfig>,
}
/// Nested message and enum types in `IndexConfig`.
pub mod index_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BruteForceConfig {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreeAhConfig {
#[prost(int64, optional, tag = "1")]
pub leaf_node_embedding_count: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DistanceMeasureType {
Unspecified = 0,
SquaredL2Distance = 1,
CosineDistance = 2,
DotProductDistance = 3,
}
impl DistanceMeasureType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
DistanceMeasureType::Unspecified => "DISTANCE_MEASURE_TYPE_UNSPECIFIED",
DistanceMeasureType::SquaredL2Distance => "SQUARED_L2_DISTANCE",
DistanceMeasureType::CosineDistance => "COSINE_DISTANCE",
DistanceMeasureType::DotProductDistance => "DOT_PRODUCT_DISTANCE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"DISTANCE_MEASURE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"SQUARED_L2_DISTANCE" => Some(Self::SquaredL2Distance),
"COSINE_DISTANCE" => Some(Self::CosineDistance),
"DOT_PRODUCT_DISTANCE" => Some(Self::DotProductDistance),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum AlgorithmConfig {
#[prost(message, tag = "6")]
TreeAhConfig(TreeAhConfig),
#[prost(message, tag = "7")]
BruteForceConfig(BruteForceConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureRegistrySource {
#[prost(message, repeated, tag = "1")]
pub feature_groups: ::prost::alloc::vec::Vec<feature_registry_source::FeatureGroup>,
#[prost(int64, optional, tag = "2")]
pub project_number: ::core::option::Option<i64>,
}
/// Nested message and enum types in `FeatureRegistrySource`.
pub mod feature_registry_source {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureGroup {
#[prost(string, tag = "1")]
pub feature_group_id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub feature_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "6")]
BigQuerySource(BigQuerySource),
#[prost(message, tag = "9")]
FeatureRegistrySource(FeatureRegistrySource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureViewSync {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub run_time: ::core::option::Option<super::super::super::r#type::Interval>,
#[prost(message, optional, tag = "4")]
pub final_status: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "6")]
pub sync_summary: ::core::option::Option<feature_view_sync::SyncSummary>,
}
/// Nested message and enum types in `FeatureViewSync`.
pub mod feature_view_sync {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncSummary {
#[prost(int64, tag = "1")]
pub row_synced: i64,
#[prost(int64, tag = "2")]
pub total_slot: i64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureOnlineStoreRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feature_online_store: ::core::option::Option<FeatureOnlineStore>,
#[prost(string, tag = "3")]
pub feature_online_store_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureOnlineStoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureOnlineStoresRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureOnlineStoresResponse {
#[prost(message, repeated, tag = "1")]
pub feature_online_stores: ::prost::alloc::vec::Vec<FeatureOnlineStore>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureOnlineStoreRequest {
#[prost(message, optional, tag = "1")]
pub feature_online_store: ::core::option::Option<FeatureOnlineStore>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureOnlineStoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureViewRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feature_view: ::core::option::Option<FeatureView>,
#[prost(string, tag = "3")]
pub feature_view_id: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub run_sync_immediately: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureViewRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewsResponse {
#[prost(message, repeated, tag = "1")]
pub feature_views: ::prost::alloc::vec::Vec<FeatureView>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureViewRequest {
#[prost(message, optional, tag = "1")]
pub feature_view: ::core::option::Option<FeatureView>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureViewRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureOnlineStoreOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureOnlineStoreOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureViewOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureViewOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncFeatureViewRequest {
#[prost(string, tag = "1")]
pub feature_view: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncFeatureViewResponse {
#[prost(string, tag = "1")]
pub feature_view_sync: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureViewSyncRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewSyncsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewSyncsResponse {
#[prost(message, repeated, tag = "1")]
pub feature_view_syncs: ::prost::alloc::vec::Vec<FeatureViewSync>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod feature_online_store_admin_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The service that handles CRUD and List for resources for
/// FeatureOnlineStore.
#[derive(Debug, Clone)]
pub struct FeatureOnlineStoreAdminServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeatureOnlineStoreAdminServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeatureOnlineStoreAdminServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeatureOnlineStoreAdminServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new FeatureOnlineStore in a given project and location.
pub async fn create_feature_online_store(&mut self, request: impl tonic::IntoRequest<super::CreateFeatureOnlineStoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/CreateFeatureOnlineStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "CreateFeatureOnlineStore"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single FeatureOnlineStore.
pub async fn get_feature_online_store(&mut self, request: impl tonic::IntoRequest<super::GetFeatureOnlineStoreRequest>) -> std::result::Result<tonic::Response<super::FeatureOnlineStore>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/GetFeatureOnlineStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "GetFeatureOnlineStore"));
self.inner.unary(req, path, codec).await
}
/// Lists FeatureOnlineStores in a given project and location.
pub async fn list_feature_online_stores(&mut self, request: impl tonic::IntoRequest<super::ListFeatureOnlineStoresRequest>) -> std::result::Result<tonic::Response<super::ListFeatureOnlineStoresResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/ListFeatureOnlineStores");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "ListFeatureOnlineStores"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single FeatureOnlineStore.
pub async fn update_feature_online_store(&mut self, request: impl tonic::IntoRequest<super::UpdateFeatureOnlineStoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/UpdateFeatureOnlineStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "UpdateFeatureOnlineStore"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single FeatureOnlineStore. The FeatureOnlineStore must not
/// contain any FeatureViews.
pub async fn delete_feature_online_store(&mut self, request: impl tonic::IntoRequest<super::DeleteFeatureOnlineStoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/DeleteFeatureOnlineStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "DeleteFeatureOnlineStore"));
self.inner.unary(req, path, codec).await
}
/// Creates a new FeatureView in a given FeatureOnlineStore.
pub async fn create_feature_view(&mut self, request: impl tonic::IntoRequest<super::CreateFeatureViewRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/CreateFeatureView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "CreateFeatureView"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single FeatureView.
pub async fn get_feature_view(&mut self, request: impl tonic::IntoRequest<super::GetFeatureViewRequest>) -> std::result::Result<tonic::Response<super::FeatureView>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/GetFeatureView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "GetFeatureView"));
self.inner.unary(req, path, codec).await
}
/// Lists FeatureViews in a given FeatureOnlineStore.
pub async fn list_feature_views(&mut self, request: impl tonic::IntoRequest<super::ListFeatureViewsRequest>) -> std::result::Result<tonic::Response<super::ListFeatureViewsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/ListFeatureViews");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "ListFeatureViews"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single FeatureView.
pub async fn update_feature_view(&mut self, request: impl tonic::IntoRequest<super::UpdateFeatureViewRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/UpdateFeatureView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "UpdateFeatureView"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single FeatureView.
pub async fn delete_feature_view(&mut self, request: impl tonic::IntoRequest<super::DeleteFeatureViewRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/DeleteFeatureView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "DeleteFeatureView"));
self.inner.unary(req, path, codec).await
}
/// Triggers on-demand sync for the FeatureView.
pub async fn sync_feature_view(&mut self, request: impl tonic::IntoRequest<super::SyncFeatureViewRequest>) -> std::result::Result<tonic::Response<super::SyncFeatureViewResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/SyncFeatureView");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "SyncFeatureView"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single FeatureViewSync.
pub async fn get_feature_view_sync(&mut self, request: impl tonic::IntoRequest<super::GetFeatureViewSyncRequest>) -> std::result::Result<tonic::Response<super::FeatureViewSync>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/GetFeatureViewSync");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "GetFeatureViewSync"));
self.inner.unary(req, path, codec).await
}
/// Lists FeatureViewSyncs in a given FeatureView.
pub async fn list_feature_view_syncs(&mut self, request: impl tonic::IntoRequest<super::ListFeatureViewSyncsRequest>) -> std::result::Result<tonic::Response<super::ListFeatureViewSyncsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService/ListFeatureViewSyncs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService", "ListFeatureViewSyncs"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelEvaluation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub metrics_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub metrics: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, repeated, tag = "5")]
pub slice_dimensions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "6")]
pub data_item_schema_uri: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub annotation_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub model_explanation: ::core::option::Option<ModelExplanation>,
#[prost(message, repeated, tag = "9")]
pub explanation_specs: ::prost::alloc::vec::Vec<model_evaluation::ModelEvaluationExplanationSpec>,
#[prost(message, optional, tag = "11")]
pub metadata: ::core::option::Option<::prost_types::Value>,
}
/// Nested message and enum types in `ModelEvaluation`.
pub mod model_evaluation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelEvaluationExplanationSpec {
#[prost(string, tag = "1")]
pub explanation_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub explanation_spec: ::core::option::Option<super::ExplanationSpec>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookExecutionJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub execution_timeout: ::core::option::Option<::prost_types::Duration>,
#[prost(string, tag = "6")]
pub schedule_resource_name: ::prost::alloc::string::String,
#[prost(enumeration = "JobState", tag = "10")]
pub job_state: i32,
#[prost(message, optional, tag = "11")]
pub status: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "12")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "13")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "19")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(oneof = "notebook_execution_job::NotebookSource", tags = "3, 4, 17")]
pub notebook_source: ::core::option::Option<notebook_execution_job::NotebookSource>,
#[prost(oneof = "notebook_execution_job::EnvironmentSpec", tags = "14")]
pub environment_spec: ::core::option::Option<notebook_execution_job::EnvironmentSpec>,
#[prost(oneof = "notebook_execution_job::ExecutionSink", tags = "8")]
pub execution_sink: ::core::option::Option<notebook_execution_job::ExecutionSink>,
#[prost(oneof = "notebook_execution_job::ExecutionIdentity", tags = "9, 18")]
pub execution_identity: ::core::option::Option<notebook_execution_job::ExecutionIdentity>,
}
/// Nested message and enum types in `NotebookExecutionJob`.
pub mod notebook_execution_job {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataformRepositorySource {
#[prost(string, tag = "1")]
pub dataform_repository_resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub commit_sha: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsNotebookSource {
#[prost(string, tag = "1")]
pub uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub generation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectNotebookSource {
#[prost(bytes = "bytes", tag = "1")]
pub content: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum NotebookSource {
#[prost(message, tag = "3")]
DataformRepositorySource(DataformRepositorySource),
#[prost(message, tag = "4")]
GcsNotebookSource(GcsNotebookSource),
#[prost(message, tag = "17")]
DirectNotebookSource(DirectNotebookSource),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EnvironmentSpec {
#[prost(string, tag = "14")]
NotebookRuntimeTemplateResourceName(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ExecutionSink {
#[prost(string, tag = "8")]
GcsOutputUri(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ExecutionIdentity {
#[prost(string, tag = "9")]
ExecutionUser(::prost::alloc::string::String),
#[prost(string, tag = "18")]
ServiceAccount(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookRuntimeTemplateRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub notebook_runtime_template: ::core::option::Option<NotebookRuntimeTemplate>,
#[prost(string, tag = "3")]
pub notebook_runtime_template_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookRuntimeTemplateOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotebookRuntimeTemplateRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimeTemplatesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimeTemplatesResponse {
#[prost(message, repeated, tag = "1")]
pub notebook_runtime_templates: ::prost::alloc::vec::Vec<NotebookRuntimeTemplate>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotebookRuntimeTemplateRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNotebookRuntimeTemplateRequest {
#[prost(message, optional, tag = "1")]
pub notebook_runtime_template: ::core::option::Option<NotebookRuntimeTemplate>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignNotebookRuntimeRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub notebook_runtime_template: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub notebook_runtime: ::core::option::Option<NotebookRuntime>,
#[prost(string, tag = "4")]
pub notebook_runtime_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignNotebookRuntimeOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub progress_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotebookRuntimeRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimesResponse {
#[prost(message, repeated, tag = "1")]
pub notebook_runtimes: ::prost::alloc::vec::Vec<NotebookRuntime>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotebookRuntimeRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeNotebookRuntimeRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeNotebookRuntimeOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub progress_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpgradeNotebookRuntimeResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNotebookRuntimeRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNotebookRuntimeOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub progress_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartNotebookRuntimeResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookExecutionJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub notebook_execution_job: ::core::option::Option<NotebookExecutionJob>,
#[prost(string, tag = "3")]
pub notebook_execution_job_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookExecutionJobOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub progress_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotebookExecutionJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "NotebookExecutionJobView", tag = "6")]
pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookExecutionJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(enumeration = "NotebookExecutionJobView", tag = "6")]
pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookExecutionJobsResponse {
#[prost(message, repeated, tag = "1")]
pub notebook_execution_jobs: ::prost::alloc::vec::Vec<NotebookExecutionJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotebookExecutionJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotebookExecutionJobView {
Unspecified = 0,
Basic = 1,
Full = 2,
}
impl NotebookExecutionJobView {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
NotebookExecutionJobView::Unspecified => "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED",
NotebookExecutionJobView::Basic => "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC",
NotebookExecutionJobView::Full => "NOTEBOOK_EXECUTION_JOB_VIEW_FULL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
"NOTEBOOK_EXECUTION_JOB_VIEW_BASIC" => Some(Self::Basic),
"NOTEBOOK_EXECUTION_JOB_VIEW_FULL" => Some(Self::Full),
_ => None,
}
}
}
/// Generated client implementations.
pub mod notebook_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The interface for Vertex Notebook service (a.k.a. Colab on Workbench).
#[derive(Debug, Clone)]
pub struct NotebookServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> NotebookServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> NotebookServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
NotebookServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a NotebookRuntimeTemplate.
pub async fn create_notebook_runtime_template(&mut self, request: impl tonic::IntoRequest<super::CreateNotebookRuntimeTemplateRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/CreateNotebookRuntimeTemplate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "CreateNotebookRuntimeTemplate"));
self.inner.unary(req, path, codec).await
}
/// Gets a NotebookRuntimeTemplate.
pub async fn get_notebook_runtime_template(&mut self, request: impl tonic::IntoRequest<super::GetNotebookRuntimeTemplateRequest>) -> std::result::Result<tonic::Response<super::NotebookRuntimeTemplate>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/GetNotebookRuntimeTemplate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "GetNotebookRuntimeTemplate"));
self.inner.unary(req, path, codec).await
}
/// Lists NotebookRuntimeTemplates in a Location.
pub async fn list_notebook_runtime_templates(&mut self, request: impl tonic::IntoRequest<super::ListNotebookRuntimeTemplatesRequest>) -> std::result::Result<tonic::Response<super::ListNotebookRuntimeTemplatesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/ListNotebookRuntimeTemplates");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "ListNotebookRuntimeTemplates"));
self.inner.unary(req, path, codec).await
}
/// Deletes a NotebookRuntimeTemplate.
pub async fn delete_notebook_runtime_template(&mut self, request: impl tonic::IntoRequest<super::DeleteNotebookRuntimeTemplateRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/DeleteNotebookRuntimeTemplate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "DeleteNotebookRuntimeTemplate"));
self.inner.unary(req, path, codec).await
}
/// Updates a NotebookRuntimeTemplate.
pub async fn update_notebook_runtime_template(&mut self, request: impl tonic::IntoRequest<super::UpdateNotebookRuntimeTemplateRequest>) -> std::result::Result<tonic::Response<super::NotebookRuntimeTemplate>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/UpdateNotebookRuntimeTemplate");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "UpdateNotebookRuntimeTemplate"));
self.inner.unary(req, path, codec).await
}
/// Assigns a NotebookRuntime to a user for a particular Notebook file. This
/// method will either returns an existing assignment or generates a new one.
pub async fn assign_notebook_runtime(&mut self, request: impl tonic::IntoRequest<super::AssignNotebookRuntimeRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/AssignNotebookRuntime");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "AssignNotebookRuntime"));
self.inner.unary(req, path, codec).await
}
/// Gets a NotebookRuntime.
pub async fn get_notebook_runtime(&mut self, request: impl tonic::IntoRequest<super::GetNotebookRuntimeRequest>) -> std::result::Result<tonic::Response<super::NotebookRuntime>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/GetNotebookRuntime");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "GetNotebookRuntime"));
self.inner.unary(req, path, codec).await
}
/// Lists NotebookRuntimes in a Location.
pub async fn list_notebook_runtimes(&mut self, request: impl tonic::IntoRequest<super::ListNotebookRuntimesRequest>) -> std::result::Result<tonic::Response<super::ListNotebookRuntimesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/ListNotebookRuntimes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "ListNotebookRuntimes"));
self.inner.unary(req, path, codec).await
}
/// Deletes a NotebookRuntime.
pub async fn delete_notebook_runtime(&mut self, request: impl tonic::IntoRequest<super::DeleteNotebookRuntimeRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/DeleteNotebookRuntime");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "DeleteNotebookRuntime"));
self.inner.unary(req, path, codec).await
}
/// Upgrades a NotebookRuntime.
pub async fn upgrade_notebook_runtime(&mut self, request: impl tonic::IntoRequest<super::UpgradeNotebookRuntimeRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/UpgradeNotebookRuntime");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "UpgradeNotebookRuntime"));
self.inner.unary(req, path, codec).await
}
/// Starts a NotebookRuntime.
pub async fn start_notebook_runtime(&mut self, request: impl tonic::IntoRequest<super::StartNotebookRuntimeRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/StartNotebookRuntime");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "StartNotebookRuntime"));
self.inner.unary(req, path, codec).await
}
/// Creates a NotebookExecutionJob.
pub async fn create_notebook_execution_job(&mut self, request: impl tonic::IntoRequest<super::CreateNotebookExecutionJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/CreateNotebookExecutionJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "CreateNotebookExecutionJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a NotebookExecutionJob.
pub async fn get_notebook_execution_job(&mut self, request: impl tonic::IntoRequest<super::GetNotebookExecutionJobRequest>) -> std::result::Result<tonic::Response<super::NotebookExecutionJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/GetNotebookExecutionJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "GetNotebookExecutionJob"));
self.inner.unary(req, path, codec).await
}
/// Lists NotebookExecutionJobs in a Location.
pub async fn list_notebook_execution_jobs(&mut self, request: impl tonic::IntoRequest<super::ListNotebookExecutionJobsRequest>) -> std::result::Result<tonic::Response<super::ListNotebookExecutionJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/ListNotebookExecutionJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "ListNotebookExecutionJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes a NotebookExecutionJob.
pub async fn delete_notebook_execution_job(&mut self, request: impl tonic::IntoRequest<super::DeleteNotebookExecutionJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.NotebookService/DeleteNotebookExecutionJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.NotebookService", "DeleteNotebookExecutionJob"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublisherModel {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub version_id: ::prost::alloc::string::String,
#[prost(enumeration = "publisher_model::OpenSourceCategory", tag = "7")]
pub open_source_category: i32,
#[prost(message, optional, tag = "19")]
pub supported_actions: ::core::option::Option<publisher_model::CallToAction>,
#[prost(string, repeated, tag = "23")]
pub frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(enumeration = "publisher_model::LaunchStage", tag = "29")]
pub launch_stage: i32,
#[prost(enumeration = "publisher_model::VersionState", tag = "37")]
pub version_state: i32,
#[prost(string, tag = "30")]
pub publisher_model_template: ::prost::alloc::string::String,
#[prost(message, optional, tag = "31")]
pub predict_schemata: ::core::option::Option<PredictSchemata>,
}
/// Nested message and enum types in `PublisherModel`.
pub mod publisher_model {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceReference {
#[prost(oneof = "resource_reference::Reference", tags = "1, 2, 3, 4")]
pub reference: ::core::option::Option<resource_reference::Reference>,
}
/// Nested message and enum types in `ResourceReference`.
pub mod resource_reference {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Reference {
#[prost(string, tag = "1")]
Uri(::prost::alloc::string::String),
#[prost(string, tag = "2")]
ResourceName(::prost::alloc::string::String),
#[prost(string, tag = "3")]
UseCase(::prost::alloc::string::String),
#[prost(string, tag = "4")]
Description(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Documentation {
#[prost(string, tag = "1")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub content: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallToAction {
#[prost(message, optional, tag = "1")]
pub view_rest_api: ::core::option::Option<call_to_action::ViewRestApi>,
#[prost(message, optional, tag = "2")]
pub open_notebook: ::core::option::Option<call_to_action::RegionalResourceReferences>,
#[prost(message, optional, tag = "12")]
pub open_notebooks: ::core::option::Option<call_to_action::OpenNotebooks>,
#[prost(message, optional, tag = "3")]
pub create_application: ::core::option::Option<call_to_action::RegionalResourceReferences>,
#[prost(message, optional, tag = "4")]
pub open_fine_tuning_pipeline: ::core::option::Option<call_to_action::RegionalResourceReferences>,
#[prost(message, optional, tag = "13")]
pub open_fine_tuning_pipelines: ::core::option::Option<call_to_action::OpenFineTuningPipelines>,
#[prost(message, optional, tag = "5")]
pub open_prompt_tuning_pipeline: ::core::option::Option<call_to_action::RegionalResourceReferences>,
#[prost(message, optional, tag = "6")]
pub open_genie: ::core::option::Option<call_to_action::RegionalResourceReferences>,
#[prost(message, optional, tag = "7")]
pub deploy: ::core::option::Option<call_to_action::Deploy>,
#[prost(message, optional, tag = "14")]
pub deploy_gke: ::core::option::Option<call_to_action::DeployGke>,
#[prost(message, optional, tag = "8")]
pub open_generation_ai_studio: ::core::option::Option<call_to_action::RegionalResourceReferences>,
#[prost(message, optional, tag = "9")]
pub request_access: ::core::option::Option<call_to_action::RegionalResourceReferences>,
#[prost(message, optional, tag = "11")]
pub open_evaluation_pipeline: ::core::option::Option<call_to_action::RegionalResourceReferences>,
}
/// Nested message and enum types in `CallToAction`.
pub mod call_to_action {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionalResourceReferences {
#[prost(btree_map = "string, message", tag = "1")]
pub references: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::ResourceReference>,
#[prost(string, tag = "2")]
pub title: ::prost::alloc::string::String,
#[prost(string, optional, tag = "3")]
pub resource_title: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "4")]
pub resource_use_case: ::core::option::Option<::prost::alloc::string::String>,
#[prost(string, optional, tag = "5")]
pub resource_description: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewRestApi {
#[prost(message, repeated, tag = "1")]
pub documentations: ::prost::alloc::vec::Vec<super::Documentation>,
#[prost(string, tag = "2")]
pub title: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenNotebooks {
#[prost(message, repeated, tag = "1")]
pub notebooks: ::prost::alloc::vec::Vec<RegionalResourceReferences>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenFineTuningPipelines {
#[prost(message, repeated, tag = "1")]
pub fine_tuning_pipelines: ::prost::alloc::vec::Vec<RegionalResourceReferences>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deploy {
#[prost(string, tag = "1")]
pub model_display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub large_model_reference: ::core::option::Option<super::super::LargeModelReference>,
#[prost(message, optional, tag = "3")]
pub container_spec: ::core::option::Option<super::super::ModelContainerSpec>,
#[prost(string, tag = "4")]
pub artifact_uri: ::prost::alloc::string::String,
#[prost(string, optional, tag = "10")]
pub deploy_task_name: ::core::option::Option<::prost::alloc::string::String>,
#[prost(message, optional, tag = "11")]
pub deploy_metadata: ::core::option::Option<deploy::DeployMetadata>,
#[prost(string, tag = "8")]
pub title: ::prost::alloc::string::String,
#[prost(string, tag = "9")]
pub public_artifact_uri: ::prost::alloc::string::String,
#[prost(oneof = "deploy::PredictionResources", tags = "5, 6, 7")]
pub prediction_resources: ::core::option::Option<deploy::PredictionResources>,
}
/// Nested message and enum types in `Deploy`.
pub mod deploy {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployMetadata {
#[prost(btree_map = "string, string", tag = "1")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum PredictionResources {
#[prost(message, tag = "5")]
DedicatedResources(super::super::super::DedicatedResources),
#[prost(message, tag = "6")]
AutomaticResources(super::super::super::AutomaticResources),
#[prost(string, tag = "7")]
SharedResources(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployGke {
#[prost(string, repeated, tag = "1")]
pub gke_yaml_configs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OpenSourceCategory {
Unspecified = 0,
Proprietary = 1,
GoogleOwnedOssWithGoogleCheckpoint = 2,
ThirdPartyOwnedOssWithGoogleCheckpoint = 3,
GoogleOwnedOss = 4,
ThirdPartyOwnedOss = 5,
}
impl OpenSourceCategory {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OpenSourceCategory::Unspecified => "OPEN_SOURCE_CATEGORY_UNSPECIFIED",
OpenSourceCategory::Proprietary => "PROPRIETARY",
OpenSourceCategory::GoogleOwnedOssWithGoogleCheckpoint => "GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT",
OpenSourceCategory::ThirdPartyOwnedOssWithGoogleCheckpoint => "THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT",
OpenSourceCategory::GoogleOwnedOss => "GOOGLE_OWNED_OSS",
OpenSourceCategory::ThirdPartyOwnedOss => "THIRD_PARTY_OWNED_OSS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPEN_SOURCE_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
"PROPRIETARY" => Some(Self::Proprietary),
"GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" => Some(Self::GoogleOwnedOssWithGoogleCheckpoint),
"THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" => Some(Self::ThirdPartyOwnedOssWithGoogleCheckpoint),
"GOOGLE_OWNED_OSS" => Some(Self::GoogleOwnedOss),
"THIRD_PARTY_OWNED_OSS" => Some(Self::ThirdPartyOwnedOss),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LaunchStage {
Unspecified = 0,
Experimental = 1,
PrivatePreview = 2,
PublicPreview = 3,
Ga = 4,
}
impl LaunchStage {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LaunchStage::Unspecified => "LAUNCH_STAGE_UNSPECIFIED",
LaunchStage::Experimental => "EXPERIMENTAL",
LaunchStage::PrivatePreview => "PRIVATE_PREVIEW",
LaunchStage::PublicPreview => "PUBLIC_PREVIEW",
LaunchStage::Ga => "GA",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LAUNCH_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
"EXPERIMENTAL" => Some(Self::Experimental),
"PRIVATE_PREVIEW" => Some(Self::PrivatePreview),
"PUBLIC_PREVIEW" => Some(Self::PublicPreview),
"GA" => Some(Self::Ga),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VersionState {
Unspecified = 0,
Stable = 1,
Unstable = 2,
}
impl VersionState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
VersionState::Unspecified => "VERSION_STATE_UNSPECIFIED",
VersionState::Stable => "VERSION_STATE_STABLE",
VersionState::Unstable => "VERSION_STATE_UNSTABLE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VERSION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"VERSION_STATE_STABLE" => Some(Self::Stable),
"VERSION_STATE_UNSTABLE" => Some(Self::Unstable),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub metadata_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub metadata: ::core::option::Option<::prost_types::Value>,
#[prost(message, repeated, tag = "7")]
pub deployed_indexes: ::prost::alloc::vec::Vec<DeployedIndexRef>,
#[prost(string, tag = "8")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "9")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "10")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "11")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "14")]
pub index_stats: ::core::option::Option<IndexStats>,
#[prost(enumeration = "index::IndexUpdateMethod", tag = "16")]
pub index_update_method: i32,
#[prost(message, optional, tag = "17")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
/// Nested message and enum types in `Index`.
pub mod index {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexUpdateMethod {
Unspecified = 0,
BatchUpdate = 1,
StreamUpdate = 2,
}
impl IndexUpdateMethod {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
IndexUpdateMethod::Unspecified => "INDEX_UPDATE_METHOD_UNSPECIFIED",
IndexUpdateMethod::BatchUpdate => "BATCH_UPDATE",
IndexUpdateMethod::StreamUpdate => "STREAM_UPDATE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"INDEX_UPDATE_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
"BATCH_UPDATE" => Some(Self::BatchUpdate),
"STREAM_UPDATE" => Some(Self::StreamUpdate),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexDatapoint {
#[prost(string, tag = "1")]
pub datapoint_id: ::prost::alloc::string::String,
#[prost(float, repeated, packed = "false", tag = "2")]
pub feature_vector: ::prost::alloc::vec::Vec<f32>,
#[prost(message, optional, tag = "7")]
pub sparse_embedding: ::core::option::Option<index_datapoint::SparseEmbedding>,
#[prost(message, repeated, tag = "4")]
pub restricts: ::prost::alloc::vec::Vec<index_datapoint::Restriction>,
#[prost(message, repeated, tag = "6")]
pub numeric_restricts: ::prost::alloc::vec::Vec<index_datapoint::NumericRestriction>,
#[prost(message, optional, tag = "5")]
pub crowding_tag: ::core::option::Option<index_datapoint::CrowdingTag>,
}
/// Nested message and enum types in `IndexDatapoint`.
pub mod index_datapoint {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SparseEmbedding {
#[prost(float, repeated, packed = "false", tag = "1")]
pub values: ::prost::alloc::vec::Vec<f32>,
#[prost(int64, repeated, packed = "false", tag = "2")]
pub dimensions: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restriction {
#[prost(string, tag = "1")]
pub namespace: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub allow_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub deny_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NumericRestriction {
#[prost(string, tag = "1")]
pub namespace: ::prost::alloc::string::String,
#[prost(enumeration = "numeric_restriction::Operator", tag = "5")]
pub op: i32,
#[prost(oneof = "numeric_restriction::Value", tags = "2, 3, 4")]
pub value: ::core::option::Option<numeric_restriction::Value>,
}
/// Nested message and enum types in `NumericRestriction`.
pub mod numeric_restriction {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Operator {
Unspecified = 0,
Less = 1,
LessEqual = 2,
Equal = 3,
GreaterEqual = 4,
Greater = 5,
NotEqual = 6,
}
impl Operator {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Operator::Unspecified => "OPERATOR_UNSPECIFIED",
Operator::Less => "LESS",
Operator::LessEqual => "LESS_EQUAL",
Operator::Equal => "EQUAL",
Operator::GreaterEqual => "GREATER_EQUAL",
Operator::Greater => "GREATER",
Operator::NotEqual => "NOT_EQUAL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
"LESS" => Some(Self::Less),
"LESS_EQUAL" => Some(Self::LessEqual),
"EQUAL" => Some(Self::Equal),
"GREATER_EQUAL" => Some(Self::GreaterEqual),
"GREATER" => Some(Self::Greater),
"NOT_EQUAL" => Some(Self::NotEqual),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(int64, tag = "2")]
ValueInt(i64),
#[prost(float, tag = "3")]
ValueFloat(f32),
#[prost(double, tag = "4")]
ValueDouble(f64),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrowdingTag {
#[prost(string, tag = "1")]
pub crowding_attribute: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexStats {
#[prost(int64, tag = "1")]
pub vectors_count: i64,
#[prost(int64, tag = "3")]
pub sparse_vectors_count: i64,
#[prost(int32, tag = "2")]
pub shards_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindNeighborsRequest {
#[prost(string, tag = "1")]
pub index_endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployed_index_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub queries: ::prost::alloc::vec::Vec<find_neighbors_request::Query>,
#[prost(bool, tag = "4")]
pub return_full_datapoint: bool,
}
/// Nested message and enum types in `FindNeighborsRequest`.
pub mod find_neighbors_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
#[prost(message, optional, tag = "1")]
pub datapoint: ::core::option::Option<super::IndexDatapoint>,
#[prost(int32, tag = "2")]
pub neighbor_count: i32,
#[prost(int32, tag = "3")]
pub per_crowding_attribute_neighbor_count: i32,
#[prost(int32, tag = "4")]
pub approximate_neighbor_count: i32,
#[prost(double, tag = "5")]
pub fraction_leaf_nodes_to_search_override: f64,
#[prost(oneof = "query::Ranking", tags = "6")]
pub ranking: ::core::option::Option<query::Ranking>,
}
/// Nested message and enum types in `Query`.
pub mod query {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Rrf {
#[prost(float, tag = "1")]
pub alpha: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Ranking {
#[prost(message, tag = "6")]
Rrf(Rrf),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindNeighborsResponse {
#[prost(message, repeated, tag = "1")]
pub nearest_neighbors: ::prost::alloc::vec::Vec<find_neighbors_response::NearestNeighbors>,
}
/// Nested message and enum types in `FindNeighborsResponse`.
pub mod find_neighbors_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Neighbor {
#[prost(message, optional, tag = "1")]
pub datapoint: ::core::option::Option<super::IndexDatapoint>,
#[prost(double, tag = "2")]
pub distance: f64,
#[prost(double, tag = "3")]
pub sparse_distance: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NearestNeighbors {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub neighbors: ::prost::alloc::vec::Vec<Neighbor>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadIndexDatapointsRequest {
#[prost(string, tag = "1")]
pub index_endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployed_index_id: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadIndexDatapointsResponse {
#[prost(message, repeated, tag = "1")]
pub datapoints: ::prost::alloc::vec::Vec<IndexDatapoint>,
}
/// Generated client implementations.
pub mod match_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// MatchService is a Google managed service for efficient vector similarity
/// search at scale.
#[derive(Debug, Clone)]
pub struct MatchServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> MatchServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> MatchServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
MatchServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Finds the nearest neighbors of each vector within the request.
pub async fn find_neighbors(&mut self, request: impl tonic::IntoRequest<super::FindNeighborsRequest>) -> std::result::Result<tonic::Response<super::FindNeighborsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MatchService/FindNeighbors");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MatchService", "FindNeighbors"));
self.inner.unary(req, path, codec).await
}
/// Reads the datapoints/vectors of the given IDs.
/// A maximum of 1000 datapoints can be retrieved in a batch.
pub async fn read_index_datapoints(&mut self, request: impl tonic::IntoRequest<super::ReadIndexDatapointsRequest>) -> std::result::Result<tonic::Response<super::ReadIndexDatapointsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MatchService/ReadIndexDatapoints");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MatchService", "ReadIndexDatapoints"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigratableResource {
#[prost(message, optional, tag = "5")]
pub last_migrate_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(oneof = "migratable_resource::Resource", tags = "1, 2, 3, 4")]
pub resource: ::core::option::Option<migratable_resource::Resource>,
}
/// Nested message and enum types in `MigratableResource`.
pub mod migratable_resource {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MlEngineModelVersion {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomlModel {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub model_display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomlDataset {
#[prost(string, tag = "1")]
pub dataset: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub dataset_display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataLabelingDataset {
#[prost(string, tag = "1")]
pub dataset: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub dataset_display_name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub data_labeling_annotated_datasets: ::prost::alloc::vec::Vec<data_labeling_dataset::DataLabelingAnnotatedDataset>,
}
/// Nested message and enum types in `DataLabelingDataset`.
pub mod data_labeling_dataset {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataLabelingAnnotatedDataset {
#[prost(string, tag = "1")]
pub annotated_dataset: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub annotated_dataset_display_name: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Resource {
#[prost(message, tag = "1")]
MlEngineModelVersion(MlEngineModelVersion),
#[prost(message, tag = "2")]
AutomlModel(AutomlModel),
#[prost(message, tag = "3")]
AutomlDataset(AutomlDataset),
#[prost(message, tag = "4")]
DataLabelingDataset(DataLabelingDataset),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchMigratableResourcesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchMigratableResourcesResponse {
#[prost(message, repeated, tag = "1")]
pub migratable_resources: ::prost::alloc::vec::Vec<MigratableResource>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMigrateResourcesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub migrate_resource_requests: ::prost::alloc::vec::Vec<MigrateResourceRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateResourceRequest {
#[prost(oneof = "migrate_resource_request::Request", tags = "1, 2, 3, 4")]
pub request: ::core::option::Option<migrate_resource_request::Request>,
}
/// Nested message and enum types in `MigrateResourceRequest`.
pub mod migrate_resource_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateMlEngineModelVersionConfig {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub model_version: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub model_display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateAutomlModelConfig {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub model_display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateAutomlDatasetConfig {
#[prost(string, tag = "1")]
pub dataset: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub dataset_display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateDataLabelingDatasetConfig {
#[prost(string, tag = "1")]
pub dataset: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub dataset_display_name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub migrate_data_labeling_annotated_dataset_configs: ::prost::alloc::vec::Vec<migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig>,
}
/// Nested message and enum types in `MigrateDataLabelingDatasetConfig`.
pub mod migrate_data_labeling_dataset_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateDataLabelingAnnotatedDatasetConfig {
#[prost(string, tag = "1")]
pub annotated_dataset: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Request {
#[prost(message, tag = "1")]
MigrateMlEngineModelVersionConfig(MigrateMlEngineModelVersionConfig),
#[prost(message, tag = "2")]
MigrateAutomlModelConfig(MigrateAutomlModelConfig),
#[prost(message, tag = "3")]
MigrateAutomlDatasetConfig(MigrateAutomlDatasetConfig),
#[prost(message, tag = "4")]
MigrateDataLabelingDatasetConfig(MigrateDataLabelingDatasetConfig),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMigrateResourcesResponse {
#[prost(message, repeated, tag = "1")]
pub migrate_resource_responses: ::prost::alloc::vec::Vec<MigrateResourceResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateResourceResponse {
#[prost(message, optional, tag = "3")]
pub migratable_resource: ::core::option::Option<MigratableResource>,
#[prost(oneof = "migrate_resource_response::MigratedResource", tags = "1, 2")]
pub migrated_resource: ::core::option::Option<migrate_resource_response::MigratedResource>,
}
/// Nested message and enum types in `MigrateResourceResponse`.
pub mod migrate_resource_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum MigratedResource {
#[prost(string, tag = "1")]
Dataset(::prost::alloc::string::String),
#[prost(string, tag = "2")]
Model(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMigrateResourcesOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(message, repeated, tag = "2")]
pub partial_results: ::prost::alloc::vec::Vec<batch_migrate_resources_operation_metadata::PartialResult>,
}
/// Nested message and enum types in `BatchMigrateResourcesOperationMetadata`.
pub mod batch_migrate_resources_operation_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartialResult {
#[prost(message, optional, tag = "1")]
pub request: ::core::option::Option<super::MigrateResourceRequest>,
#[prost(oneof = "partial_result::Result", tags = "2, 3, 4")]
pub result: ::core::option::Option<partial_result::Result>,
}
/// Nested message and enum types in `PartialResult`.
pub mod partial_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Result {
#[prost(message, tag = "2")]
Error(super::super::super::super::super::rpc::Status),
#[prost(string, tag = "3")]
Model(::prost::alloc::string::String),
#[prost(string, tag = "4")]
Dataset(::prost::alloc::string::String),
}
}
}
/// Generated client implementations.
pub mod migration_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service that migrates resources from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
#[derive(Debug, Clone)]
pub struct MigrationServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> MigrationServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> MigrationServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
MigrationServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Searches all of the resources in automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com that can be migrated to
/// Vertex AI's given location.
pub async fn search_migratable_resources(&mut self, request: impl tonic::IntoRequest<super::SearchMigratableResourcesRequest>) -> std::result::Result<tonic::Response<super::SearchMigratableResourcesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MigrationService/SearchMigratableResources");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MigrationService", "SearchMigratableResources"));
self.inner.unary(req, path, codec).await
}
/// Batch migrates resources from ml.googleapis.com, automl.googleapis.com,
/// and datalabeling.googleapis.com to Vertex AI.
pub async fn batch_migrate_resources(&mut self, request: impl tonic::IntoRequest<super::BatchMigrateResourcesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MigrationService/BatchMigrateResources");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MigrationService", "BatchMigrateResources"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchPredictionJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "30")]
pub model_version_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "28")]
pub unmanaged_container_model: ::core::option::Option<UnmanagedContainerModel>,
#[prost(message, optional, tag = "4")]
pub input_config: ::core::option::Option<batch_prediction_job::InputConfig>,
#[prost(message, optional, tag = "27")]
pub instance_config: ::core::option::Option<batch_prediction_job::InstanceConfig>,
#[prost(message, optional, tag = "5")]
pub model_parameters: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "6")]
pub output_config: ::core::option::Option<batch_prediction_job::OutputConfig>,
#[prost(message, optional, tag = "7")]
pub dedicated_resources: ::core::option::Option<BatchDedicatedResources>,
#[prost(string, tag = "29")]
pub service_account: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub manual_batch_tuning_parameters: ::core::option::Option<ManualBatchTuningParameters>,
#[prost(bool, tag = "23")]
pub generate_explanation: bool,
#[prost(message, optional, tag = "25")]
pub explanation_spec: ::core::option::Option<ExplanationSpec>,
#[prost(message, optional, tag = "9")]
pub output_info: ::core::option::Option<batch_prediction_job::OutputInfo>,
#[prost(enumeration = "JobState", tag = "10")]
pub state: i32,
#[prost(message, optional, tag = "11")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, repeated, tag = "12")]
pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "13")]
pub resources_consumed: ::core::option::Option<ResourcesConsumed>,
#[prost(message, optional, tag = "14")]
pub completion_stats: ::core::option::Option<CompletionStats>,
#[prost(message, optional, tag = "15")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "16")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "17")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "18")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "19")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "24")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(bool, tag = "34")]
pub disable_container_logging: bool,
}
/// Nested message and enum types in `BatchPredictionJob`.
pub mod batch_prediction_job {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputConfig {
#[prost(string, tag = "1")]
pub instances_format: ::prost::alloc::string::String,
#[prost(oneof = "input_config::Source", tags = "2, 3")]
pub source: ::core::option::Option<input_config::Source>,
}
/// Nested message and enum types in `InputConfig`.
pub mod input_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
GcsSource(super::super::GcsSource),
#[prost(message, tag = "3")]
BigquerySource(super::super::BigQuerySource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceConfig {
#[prost(string, tag = "1")]
pub instance_type: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub key_field: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub included_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub excluded_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputConfig {
#[prost(string, tag = "1")]
pub predictions_format: ::prost::alloc::string::String,
#[prost(oneof = "output_config::Destination", tags = "2, 3")]
pub destination: ::core::option::Option<output_config::Destination>,
}
/// Nested message and enum types in `OutputConfig`.
pub mod output_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(message, tag = "2")]
GcsDestination(super::super::GcsDestination),
#[prost(message, tag = "3")]
BigqueryDestination(super::super::BigQueryDestination),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputInfo {
#[prost(string, tag = "4")]
pub bigquery_output_table: ::prost::alloc::string::String,
#[prost(oneof = "output_info::OutputLocation", tags = "1, 2")]
pub output_location: ::core::option::Option<output_info::OutputLocation>,
}
/// Nested message and enum types in `OutputInfo`.
pub mod output_info {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum OutputLocation {
#[prost(string, tag = "1")]
GcsOutputDirectory(::prost::alloc::string::String),
#[prost(string, tag = "2")]
BigqueryOutputDataset(::prost::alloc::string::String),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub job_spec: ::core::option::Option<CustomJobSpec>,
#[prost(enumeration = "JobState", tag = "5")]
pub state: i32,
#[prost(message, optional, tag = "6")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "10")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(btree_map = "string, string", tag = "11")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "12")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(btree_map = "string, string", tag = "16")]
pub web_access_uris: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomJobSpec {
#[prost(string, tag = "14")]
pub persistent_resource_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "1")]
pub worker_pool_specs: ::prost::alloc::vec::Vec<WorkerPoolSpec>,
#[prost(message, optional, tag = "3")]
pub scheduling: ::core::option::Option<Scheduling>,
#[prost(string, tag = "4")]
pub service_account: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub network: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "13")]
pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "6")]
pub base_output_directory: ::core::option::Option<GcsDestination>,
#[prost(string, tag = "19")]
pub protected_artifact_location_id: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub tensorboard: ::prost::alloc::string::String,
#[prost(bool, tag = "10")]
pub enable_web_access: bool,
#[prost(bool, tag = "16")]
pub enable_dashboard_access: bool,
#[prost(string, tag = "17")]
pub experiment: ::prost::alloc::string::String,
#[prost(string, tag = "18")]
pub experiment_run: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "20")]
pub models: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerPoolSpec {
#[prost(message, optional, tag = "1")]
pub machine_spec: ::core::option::Option<MachineSpec>,
#[prost(int64, tag = "2")]
pub replica_count: i64,
#[prost(message, repeated, tag = "4")]
pub nfs_mounts: ::prost::alloc::vec::Vec<NfsMount>,
#[prost(message, optional, tag = "5")]
pub disk_spec: ::core::option::Option<DiskSpec>,
#[prost(oneof = "worker_pool_spec::Task", tags = "6, 7")]
pub task: ::core::option::Option<worker_pool_spec::Task>,
}
/// Nested message and enum types in `WorkerPoolSpec`.
pub mod worker_pool_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Task {
#[prost(message, tag = "6")]
ContainerSpec(super::ContainerSpec),
#[prost(message, tag = "7")]
PythonPackageSpec(super::PythonPackageSpec),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerSpec {
#[prost(string, tag = "1")]
pub image_uri: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "4")]
pub env: ::prost::alloc::vec::Vec<EnvVar>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PythonPackageSpec {
#[prost(string, tag = "1")]
pub executor_image_uri: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub package_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "3")]
pub python_module: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "4")]
pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "5")]
pub env: ::prost::alloc::vec::Vec<EnvVar>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Scheduling {
#[prost(message, optional, tag = "1")]
pub timeout: ::core::option::Option<::prost_types::Duration>,
#[prost(bool, tag = "3")]
pub restart_job_on_worker_restart: bool,
#[prost(enumeration = "scheduling::Strategy", tag = "4")]
pub strategy: i32,
#[prost(bool, tag = "5")]
pub disable_retries: bool,
}
/// Nested message and enum types in `Scheduling`.
pub mod scheduling {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Strategy {
Unspecified = 0,
OnDemand = 1,
LowCost = 2,
}
impl Strategy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Strategy::Unspecified => "STRATEGY_UNSPECIFIED",
Strategy::OnDemand => "ON_DEMAND",
Strategy::LowCost => "LOW_COST",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
"ON_DEMAND" => Some(Self::OnDemand),
"LOW_COST" => Some(Self::LowCost),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataLabelingJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub datasets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(btree_map = "string, string", tag = "12")]
pub annotation_labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(int32, tag = "4")]
pub labeler_count: i32,
#[prost(string, tag = "5")]
pub instruction_uri: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub inputs_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub inputs: ::core::option::Option<::prost_types::Value>,
#[prost(enumeration = "JobState", tag = "8")]
pub state: i32,
#[prost(int32, tag = "13")]
pub labeling_progress: i32,
#[prost(message, optional, tag = "14")]
pub current_spend: ::core::option::Option<super::super::super::r#type::Money>,
#[prost(message, optional, tag = "9")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "10")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "22")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(btree_map = "string, string", tag = "11")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, repeated, tag = "16")]
pub specialist_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "20")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(message, optional, tag = "21")]
pub active_learning_config: ::core::option::Option<ActiveLearningConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActiveLearningConfig {
#[prost(message, optional, tag = "3")]
pub sample_config: ::core::option::Option<SampleConfig>,
#[prost(message, optional, tag = "4")]
pub training_config: ::core::option::Option<TrainingConfig>,
#[prost(oneof = "active_learning_config::HumanLabelingBudget", tags = "1, 2")]
pub human_labeling_budget: ::core::option::Option<active_learning_config::HumanLabelingBudget>,
}
/// Nested message and enum types in `ActiveLearningConfig`.
pub mod active_learning_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum HumanLabelingBudget {
#[prost(int64, tag = "1")]
MaxDataItemCount(i64),
#[prost(int32, tag = "2")]
MaxDataItemPercentage(i32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SampleConfig {
#[prost(enumeration = "sample_config::SampleStrategy", tag = "5")]
pub sample_strategy: i32,
#[prost(oneof = "sample_config::InitialBatchSampleSize", tags = "1")]
pub initial_batch_sample_size: ::core::option::Option<sample_config::InitialBatchSampleSize>,
#[prost(oneof = "sample_config::FollowingBatchSampleSize", tags = "3")]
pub following_batch_sample_size: ::core::option::Option<sample_config::FollowingBatchSampleSize>,
}
/// Nested message and enum types in `SampleConfig`.
pub mod sample_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SampleStrategy {
Unspecified = 0,
Uncertainty = 1,
}
impl SampleStrategy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
SampleStrategy::Unspecified => "SAMPLE_STRATEGY_UNSPECIFIED",
SampleStrategy::Uncertainty => "UNCERTAINTY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SAMPLE_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
"UNCERTAINTY" => Some(Self::Uncertainty),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum InitialBatchSampleSize {
#[prost(int32, tag = "1")]
InitialBatchSamplePercentage(i32),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum FollowingBatchSampleSize {
#[prost(int32, tag = "3")]
FollowingBatchSamplePercentage(i32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrainingConfig {
#[prost(int64, tag = "1")]
pub timeout_training_milli_hours: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Study {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub study_spec: ::core::option::Option<StudySpec>,
#[prost(enumeration = "study::State", tag = "4")]
pub state: i32,
#[prost(message, optional, tag = "5")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "6")]
pub inactive_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Study`.
pub mod study {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Active = 1,
Inactive = 2,
Completed = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Active => "ACTIVE",
State::Inactive => "INACTIVE",
State::Completed => "COMPLETED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ACTIVE" => Some(Self::Active),
"INACTIVE" => Some(Self::Inactive),
"COMPLETED" => Some(Self::Completed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trial {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub id: ::prost::alloc::string::String,
#[prost(enumeration = "trial::State", tag = "3")]
pub state: i32,
#[prost(message, repeated, tag = "4")]
pub parameters: ::prost::alloc::vec::Vec<trial::Parameter>,
#[prost(message, optional, tag = "5")]
pub final_measurement: ::core::option::Option<Measurement>,
#[prost(message, repeated, tag = "6")]
pub measurements: ::prost::alloc::vec::Vec<Measurement>,
#[prost(message, optional, tag = "7")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "9")]
pub client_id: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub infeasible_reason: ::prost::alloc::string::String,
#[prost(string, tag = "11")]
pub custom_job: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "12")]
pub web_access_uris: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Nested message and enum types in `Trial`.
pub mod trial {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameter {
#[prost(string, tag = "1")]
pub parameter_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub value: ::core::option::Option<::prost_types::Value>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Requested = 1,
Active = 2,
Stopping = 3,
Succeeded = 4,
Infeasible = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Requested => "REQUESTED",
State::Active => "ACTIVE",
State::Stopping => "STOPPING",
State::Succeeded => "SUCCEEDED",
State::Infeasible => "INFEASIBLE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"REQUESTED" => Some(Self::Requested),
"ACTIVE" => Some(Self::Active),
"STOPPING" => Some(Self::Stopping),
"SUCCEEDED" => Some(Self::Succeeded),
"INFEASIBLE" => Some(Self::Infeasible),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrialContext {
#[prost(string, tag = "1")]
pub description: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub parameters: ::prost::alloc::vec::Vec<trial::Parameter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StudyTimeConstraint {
#[prost(oneof = "study_time_constraint::Constraint", tags = "1, 2")]
pub constraint: ::core::option::Option<study_time_constraint::Constraint>,
}
/// Nested message and enum types in `StudyTimeConstraint`.
pub mod study_time_constraint {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Constraint {
#[prost(message, tag = "1")]
MaxDuration(::prost_types::Duration),
#[prost(message, tag = "2")]
EndTime(::prost_types::Timestamp),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StudySpec {
#[prost(message, repeated, tag = "1")]
pub metrics: ::prost::alloc::vec::Vec<study_spec::MetricSpec>,
#[prost(message, repeated, tag = "2")]
pub parameters: ::prost::alloc::vec::Vec<study_spec::ParameterSpec>,
#[prost(enumeration = "study_spec::Algorithm", tag = "3")]
pub algorithm: i32,
#[prost(enumeration = "study_spec::ObservationNoise", tag = "6")]
pub observation_noise: i32,
#[prost(enumeration = "study_spec::MeasurementSelectionType", tag = "7")]
pub measurement_selection_type: i32,
#[prost(message, optional, tag = "11")]
pub study_stopping_config: ::core::option::Option<study_spec::StudyStoppingConfig>,
#[prost(oneof = "study_spec::AutomatedStoppingSpec", tags = "4, 5, 9")]
pub automated_stopping_spec: ::core::option::Option<study_spec::AutomatedStoppingSpec>,
}
/// Nested message and enum types in `StudySpec`.
pub mod study_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricSpec {
#[prost(string, tag = "1")]
pub metric_id: ::prost::alloc::string::String,
#[prost(enumeration = "metric_spec::GoalType", tag = "2")]
pub goal: i32,
#[prost(message, optional, tag = "3")]
pub safety_config: ::core::option::Option<metric_spec::SafetyMetricConfig>,
}
/// Nested message and enum types in `MetricSpec`.
pub mod metric_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetyMetricConfig {
#[prost(double, tag = "1")]
pub safety_threshold: f64,
#[prost(double, optional, tag = "2")]
pub desired_min_safe_trials_fraction: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GoalType {
Unspecified = 0,
Maximize = 1,
Minimize = 2,
}
impl GoalType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
GoalType::Unspecified => "GOAL_TYPE_UNSPECIFIED",
GoalType::Maximize => "MAXIMIZE",
GoalType::Minimize => "MINIMIZE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"GOAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"MAXIMIZE" => Some(Self::Maximize),
"MINIMIZE" => Some(Self::Minimize),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterSpec {
#[prost(string, tag = "1")]
pub parameter_id: ::prost::alloc::string::String,
#[prost(enumeration = "parameter_spec::ScaleType", tag = "6")]
pub scale_type: i32,
#[prost(message, repeated, tag = "10")]
pub conditional_parameter_specs: ::prost::alloc::vec::Vec<parameter_spec::ConditionalParameterSpec>,
#[prost(oneof = "parameter_spec::ParameterValueSpec", tags = "2, 3, 4, 5")]
pub parameter_value_spec: ::core::option::Option<parameter_spec::ParameterValueSpec>,
}
/// Nested message and enum types in `ParameterSpec`.
pub mod parameter_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoubleValueSpec {
#[prost(double, tag = "1")]
pub min_value: f64,
#[prost(double, tag = "2")]
pub max_value: f64,
#[prost(double, optional, tag = "4")]
pub default_value: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IntegerValueSpec {
#[prost(int64, tag = "1")]
pub min_value: i64,
#[prost(int64, tag = "2")]
pub max_value: i64,
#[prost(int64, optional, tag = "4")]
pub default_value: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoricalValueSpec {
#[prost(string, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, optional, tag = "3")]
pub default_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscreteValueSpec {
#[prost(double, repeated, packed = "false", tag = "1")]
pub values: ::prost::alloc::vec::Vec<f64>,
#[prost(double, optional, tag = "3")]
pub default_value: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionalParameterSpec {
#[prost(message, optional, tag = "1")]
pub parameter_spec: ::core::option::Option<super::ParameterSpec>,
#[prost(oneof = "conditional_parameter_spec::ParentValueCondition", tags = "2, 3, 4")]
pub parent_value_condition: ::core::option::Option<conditional_parameter_spec::ParentValueCondition>,
}
/// Nested message and enum types in `ConditionalParameterSpec`.
pub mod conditional_parameter_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscreteValueCondition {
#[prost(double, repeated, packed = "false", tag = "1")]
pub values: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntValueCondition {
#[prost(int64, repeated, packed = "false", tag = "1")]
pub values: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoricalValueCondition {
#[prost(string, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ParentValueCondition {
#[prost(message, tag = "2")]
ParentDiscreteValues(DiscreteValueCondition),
#[prost(message, tag = "3")]
ParentIntValues(IntValueCondition),
#[prost(message, tag = "4")]
ParentCategoricalValues(CategoricalValueCondition),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScaleType {
Unspecified = 0,
UnitLinearScale = 1,
UnitLogScale = 2,
UnitReverseLogScale = 3,
}
impl ScaleType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ScaleType::Unspecified => "SCALE_TYPE_UNSPECIFIED",
ScaleType::UnitLinearScale => "UNIT_LINEAR_SCALE",
ScaleType::UnitLogScale => "UNIT_LOG_SCALE",
ScaleType::UnitReverseLogScale => "UNIT_REVERSE_LOG_SCALE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SCALE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"UNIT_LINEAR_SCALE" => Some(Self::UnitLinearScale),
"UNIT_LOG_SCALE" => Some(Self::UnitLogScale),
"UNIT_REVERSE_LOG_SCALE" => Some(Self::UnitReverseLogScale),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ParameterValueSpec {
#[prost(message, tag = "2")]
DoubleValueSpec(DoubleValueSpec),
#[prost(message, tag = "3")]
IntegerValueSpec(IntegerValueSpec),
#[prost(message, tag = "4")]
CategoricalValueSpec(CategoricalValueSpec),
#[prost(message, tag = "5")]
DiscreteValueSpec(DiscreteValueSpec),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DecayCurveAutomatedStoppingSpec {
#[prost(bool, tag = "1")]
pub use_elapsed_duration: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MedianAutomatedStoppingSpec {
#[prost(bool, tag = "1")]
pub use_elapsed_duration: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvexAutomatedStoppingSpec {
#[prost(int64, tag = "1")]
pub max_step_count: i64,
#[prost(int64, tag = "2")]
pub min_step_count: i64,
#[prost(int64, tag = "3")]
pub min_measurement_count: i64,
#[prost(string, tag = "4")]
pub learning_rate_parameter_name: ::prost::alloc::string::String,
#[prost(bool, tag = "5")]
pub use_elapsed_duration: bool,
#[prost(bool, optional, tag = "6")]
pub update_all_stopped_trials: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StudyStoppingConfig {
#[prost(message, optional, tag = "1")]
pub should_stop_asap: ::core::option::Option<bool>,
#[prost(message, optional, tag = "2")]
pub minimum_runtime_constraint: ::core::option::Option<super::StudyTimeConstraint>,
#[prost(message, optional, tag = "3")]
pub maximum_runtime_constraint: ::core::option::Option<super::StudyTimeConstraint>,
#[prost(message, optional, tag = "4")]
pub min_num_trials: ::core::option::Option<i32>,
#[prost(message, optional, tag = "5")]
pub max_num_trials: ::core::option::Option<i32>,
#[prost(message, optional, tag = "6")]
pub max_num_trials_no_progress: ::core::option::Option<i32>,
#[prost(message, optional, tag = "7")]
pub max_duration_no_progress: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Algorithm {
Unspecified = 0,
GridSearch = 2,
RandomSearch = 3,
}
impl Algorithm {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Algorithm::Unspecified => "ALGORITHM_UNSPECIFIED",
Algorithm::GridSearch => "GRID_SEARCH",
Algorithm::RandomSearch => "RANDOM_SEARCH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
"GRID_SEARCH" => Some(Self::GridSearch),
"RANDOM_SEARCH" => Some(Self::RandomSearch),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ObservationNoise {
Unspecified = 0,
Low = 1,
High = 2,
}
impl ObservationNoise {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ObservationNoise::Unspecified => "OBSERVATION_NOISE_UNSPECIFIED",
ObservationNoise::Low => "LOW",
ObservationNoise::High => "HIGH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OBSERVATION_NOISE_UNSPECIFIED" => Some(Self::Unspecified),
"LOW" => Some(Self::Low),
"HIGH" => Some(Self::High),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MeasurementSelectionType {
Unspecified = 0,
LastMeasurement = 1,
BestMeasurement = 2,
}
impl MeasurementSelectionType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MeasurementSelectionType::Unspecified => "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED",
MeasurementSelectionType::LastMeasurement => "LAST_MEASUREMENT",
MeasurementSelectionType::BestMeasurement => "BEST_MEASUREMENT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MEASUREMENT_SELECTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"LAST_MEASUREMENT" => Some(Self::LastMeasurement),
"BEST_MEASUREMENT" => Some(Self::BestMeasurement),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum AutomatedStoppingSpec {
#[prost(message, tag = "4")]
DecayCurveStoppingSpec(DecayCurveAutomatedStoppingSpec),
#[prost(message, tag = "5")]
MedianAutomatedStoppingSpec(MedianAutomatedStoppingSpec),
#[prost(message, tag = "9")]
ConvexAutomatedStoppingSpec(ConvexAutomatedStoppingSpec),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Measurement {
#[prost(message, optional, tag = "1")]
pub elapsed_duration: ::core::option::Option<::prost_types::Duration>,
#[prost(int64, tag = "2")]
pub step_count: i64,
#[prost(message, repeated, tag = "3")]
pub metrics: ::prost::alloc::vec::Vec<measurement::Metric>,
}
/// Nested message and enum types in `Measurement`.
pub mod measurement {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metric {
#[prost(string, tag = "1")]
pub metric_id: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub value: f64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HyperparameterTuningJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub study_spec: ::core::option::Option<StudySpec>,
#[prost(int32, tag = "5")]
pub max_trial_count: i32,
#[prost(int32, tag = "6")]
pub parallel_trial_count: i32,
#[prost(int32, tag = "7")]
pub max_failed_trial_count: i32,
#[prost(message, optional, tag = "8")]
pub trial_job_spec: ::core::option::Option<CustomJobSpec>,
#[prost(message, repeated, tag = "9")]
pub trials: ::prost::alloc::vec::Vec<Trial>,
#[prost(enumeration = "JobState", tag = "10")]
pub state: i32,
#[prost(message, optional, tag = "11")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "12")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "13")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "14")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "15")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(btree_map = "string, string", tag = "16")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "17")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub nas_job_spec: ::core::option::Option<NasJobSpec>,
#[prost(message, optional, tag = "5")]
pub nas_job_output: ::core::option::Option<NasJobOutput>,
#[prost(enumeration = "JobState", tag = "6")]
pub state: i32,
#[prost(message, optional, tag = "7")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "10")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "11")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(btree_map = "string, string", tag = "12")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "13")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[deprecated]
#[prost(bool, tag = "14")]
pub enable_restricted_image_training: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasTrialDetail {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub parameters: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub search_trial: ::core::option::Option<NasTrial>,
#[prost(message, optional, tag = "4")]
pub train_trial: ::core::option::Option<NasTrial>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasJobSpec {
#[prost(string, tag = "3")]
pub resume_nas_job_id: ::prost::alloc::string::String,
#[prost(string, tag = "1")]
pub search_space_spec: ::prost::alloc::string::String,
#[prost(oneof = "nas_job_spec::NasAlgorithmSpec", tags = "2")]
pub nas_algorithm_spec: ::core::option::Option<nas_job_spec::NasAlgorithmSpec>,
}
/// Nested message and enum types in `NasJobSpec`.
pub mod nas_job_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiTrialAlgorithmSpec {
#[prost(enumeration = "multi_trial_algorithm_spec::MultiTrialAlgorithm", tag = "1")]
pub multi_trial_algorithm: i32,
#[prost(message, optional, tag = "2")]
pub metric: ::core::option::Option<multi_trial_algorithm_spec::MetricSpec>,
#[prost(message, optional, tag = "3")]
pub search_trial_spec: ::core::option::Option<multi_trial_algorithm_spec::SearchTrialSpec>,
#[prost(message, optional, tag = "4")]
pub train_trial_spec: ::core::option::Option<multi_trial_algorithm_spec::TrainTrialSpec>,
}
/// Nested message and enum types in `MultiTrialAlgorithmSpec`.
pub mod multi_trial_algorithm_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricSpec {
#[prost(string, tag = "1")]
pub metric_id: ::prost::alloc::string::String,
#[prost(enumeration = "metric_spec::GoalType", tag = "2")]
pub goal: i32,
}
/// Nested message and enum types in `MetricSpec`.
pub mod metric_spec {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GoalType {
Unspecified = 0,
Maximize = 1,
Minimize = 2,
}
impl GoalType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
GoalType::Unspecified => "GOAL_TYPE_UNSPECIFIED",
GoalType::Maximize => "MAXIMIZE",
GoalType::Minimize => "MINIMIZE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"GOAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"MAXIMIZE" => Some(Self::Maximize),
"MINIMIZE" => Some(Self::Minimize),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTrialSpec {
#[prost(message, optional, tag = "1")]
pub search_trial_job_spec: ::core::option::Option<super::super::CustomJobSpec>,
#[prost(int32, tag = "2")]
pub max_trial_count: i32,
#[prost(int32, tag = "3")]
pub max_parallel_trial_count: i32,
#[prost(int32, tag = "4")]
pub max_failed_trial_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainTrialSpec {
#[prost(message, optional, tag = "1")]
pub train_trial_job_spec: ::core::option::Option<super::super::CustomJobSpec>,
#[prost(int32, tag = "2")]
pub max_parallel_trial_count: i32,
#[prost(int32, tag = "3")]
pub frequency: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MultiTrialAlgorithm {
Unspecified = 0,
ReinforcementLearning = 1,
GridSearch = 2,
}
impl MultiTrialAlgorithm {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MultiTrialAlgorithm::Unspecified => "MULTI_TRIAL_ALGORITHM_UNSPECIFIED",
MultiTrialAlgorithm::ReinforcementLearning => "REINFORCEMENT_LEARNING",
MultiTrialAlgorithm::GridSearch => "GRID_SEARCH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MULTI_TRIAL_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
"REINFORCEMENT_LEARNING" => Some(Self::ReinforcementLearning),
"GRID_SEARCH" => Some(Self::GridSearch),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum NasAlgorithmSpec {
#[prost(message, tag = "2")]
MultiTrialAlgorithmSpec(MultiTrialAlgorithmSpec),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasJobOutput {
#[prost(oneof = "nas_job_output::Output", tags = "1")]
pub output: ::core::option::Option<nas_job_output::Output>,
}
/// Nested message and enum types in `NasJobOutput`.
pub mod nas_job_output {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiTrialJobOutput {
#[prost(message, repeated, tag = "1")]
pub search_trials: ::prost::alloc::vec::Vec<super::NasTrial>,
#[prost(message, repeated, tag = "2")]
pub train_trials: ::prost::alloc::vec::Vec<super::NasTrial>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Output {
#[prost(message, tag = "1")]
MultiTrialJobOutput(MultiTrialJobOutput),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasTrial {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(enumeration = "nas_trial::State", tag = "2")]
pub state: i32,
#[prost(message, optional, tag = "3")]
pub final_measurement: ::core::option::Option<Measurement>,
#[prost(message, optional, tag = "4")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `NasTrial`.
pub mod nas_trial {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Requested = 1,
Active = 2,
Stopping = 3,
Succeeded = 4,
Infeasible = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Requested => "REQUESTED",
State::Active => "ACTIVE",
State::Stopping => "STOPPING",
State::Succeeded => "SUCCEEDED",
State::Infeasible => "INFEASIBLE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"REQUESTED" => Some(Self::Requested),
"ACTIVE" => Some(Self::Active),
"STOPPING" => Some(Self::Stopping),
"SUCCEEDED" => Some(Self::Succeeded),
"INFEASIBLE" => Some(Self::Infeasible),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub custom_job: ::core::option::Option<CustomJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomJobsResponse {
#[prost(message, repeated, tag = "1")]
pub custom_jobs: ::prost::alloc::vec::Vec<CustomJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelCustomJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataLabelingJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub data_labeling_job: ::core::option::Option<DataLabelingJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataLabelingJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataLabelingJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataLabelingJobsResponse {
#[prost(message, repeated, tag = "1")]
pub data_labeling_jobs: ::prost::alloc::vec::Vec<DataLabelingJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataLabelingJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelDataLabelingJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHyperparameterTuningJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub hyperparameter_tuning_job: ::core::option::Option<HyperparameterTuningJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHyperparameterTuningJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHyperparameterTuningJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHyperparameterTuningJobsResponse {
#[prost(message, repeated, tag = "1")]
pub hyperparameter_tuning_jobs: ::prost::alloc::vec::Vec<HyperparameterTuningJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHyperparameterTuningJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelHyperparameterTuningJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNasJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub nas_job: ::core::option::Option<NasJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNasJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasJobsResponse {
#[prost(message, repeated, tag = "1")]
pub nas_jobs: ::prost::alloc::vec::Vec<NasJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNasJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelNasJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNasTrialDetailRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasTrialDetailsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasTrialDetailsResponse {
#[prost(message, repeated, tag = "1")]
pub nas_trial_details: ::prost::alloc::vec::Vec<NasTrialDetail>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBatchPredictionJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub batch_prediction_job: ::core::option::Option<BatchPredictionJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBatchPredictionJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchPredictionJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchPredictionJobsResponse {
#[prost(message, repeated, tag = "1")]
pub batch_prediction_jobs: ::prost::alloc::vec::Vec<BatchPredictionJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBatchPredictionJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelBatchPredictionJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModelDeploymentMonitoringJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub model_deployment_monitoring_job: ::core::option::Option<ModelDeploymentMonitoringJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesRequest {
#[prost(string, tag = "1")]
pub model_deployment_monitoring_job: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployed_model_id: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub feature_display_name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub objectives: ::prost::alloc::vec::Vec<search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective>,
#[prost(int32, tag = "5")]
pub page_size: i32,
#[prost(string, tag = "6")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `SearchModelDeploymentMonitoringStatsAnomaliesRequest`.
pub mod search_model_deployment_monitoring_stats_anomalies_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatsAnomaliesObjective {
#[prost(enumeration = "super::ModelDeploymentMonitoringObjectiveType", tag = "1")]
pub r#type: i32,
#[prost(int32, tag = "4")]
pub top_feature_count: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesResponse {
#[prost(message, repeated, tag = "1")]
pub monitoring_stats: ::prost::alloc::vec::Vec<ModelMonitoringStatsAnomalies>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelDeploymentMonitoringJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelDeploymentMonitoringJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelDeploymentMonitoringJobsResponse {
#[prost(message, repeated, tag = "1")]
pub model_deployment_monitoring_jobs: ::prost::alloc::vec::Vec<ModelDeploymentMonitoringJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelDeploymentMonitoringJobRequest {
#[prost(message, optional, tag = "1")]
pub model_deployment_monitoring_job: ::core::option::Option<ModelDeploymentMonitoringJob>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelDeploymentMonitoringJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseModelDeploymentMonitoringJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeModelDeploymentMonitoringJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelDeploymentMonitoringJobOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
/// Generated client implementations.
pub mod job_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for creating and managing Vertex AI's jobs.
#[derive(Debug, Clone)]
pub struct JobServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> JobServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> JobServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
JobServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a CustomJob. A created CustomJob right away
/// will be attempted to be run.
pub async fn create_custom_job(&mut self, request: impl tonic::IntoRequest<super::CreateCustomJobRequest>) -> std::result::Result<tonic::Response<super::CustomJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CreateCustomJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CreateCustomJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a CustomJob.
pub async fn get_custom_job(&mut self, request: impl tonic::IntoRequest<super::GetCustomJobRequest>) -> std::result::Result<tonic::Response<super::CustomJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/GetCustomJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "GetCustomJob"));
self.inner.unary(req, path, codec).await
}
/// Lists CustomJobs in a Location.
pub async fn list_custom_jobs(&mut self, request: impl tonic::IntoRequest<super::ListCustomJobsRequest>) -> std::result::Result<tonic::Response<super::ListCustomJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ListCustomJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ListCustomJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes a CustomJob.
pub async fn delete_custom_job(&mut self, request: impl tonic::IntoRequest<super::DeleteCustomJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/DeleteCustomJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "DeleteCustomJob"));
self.inner.unary(req, path, codec).await
}
/// Cancels a CustomJob.
/// Starts asynchronous cancellation on the CustomJob. The server
/// makes a best effort to cancel the job, but success is not
/// guaranteed. Clients can use
/// [JobService.GetCustomJob][google.cloud.aiplatform.v1.JobService.GetCustomJob]
/// or other methods to check whether the cancellation succeeded or whether the
/// job completed despite cancellation. On successful cancellation,
/// the CustomJob is not deleted; instead it becomes a job with
/// a [CustomJob.error][google.cloud.aiplatform.v1.CustomJob.error] value with
/// a [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
/// `Code.CANCELLED`, and
/// [CustomJob.state][google.cloud.aiplatform.v1.CustomJob.state] is set to
/// `CANCELLED`.
pub async fn cancel_custom_job(&mut self, request: impl tonic::IntoRequest<super::CancelCustomJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CancelCustomJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CancelCustomJob"));
self.inner.unary(req, path, codec).await
}
/// Creates a DataLabelingJob.
pub async fn create_data_labeling_job(&mut self, request: impl tonic::IntoRequest<super::CreateDataLabelingJobRequest>) -> std::result::Result<tonic::Response<super::DataLabelingJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CreateDataLabelingJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CreateDataLabelingJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a DataLabelingJob.
pub async fn get_data_labeling_job(&mut self, request: impl tonic::IntoRequest<super::GetDataLabelingJobRequest>) -> std::result::Result<tonic::Response<super::DataLabelingJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/GetDataLabelingJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "GetDataLabelingJob"));
self.inner.unary(req, path, codec).await
}
/// Lists DataLabelingJobs in a Location.
pub async fn list_data_labeling_jobs(&mut self, request: impl tonic::IntoRequest<super::ListDataLabelingJobsRequest>) -> std::result::Result<tonic::Response<super::ListDataLabelingJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ListDataLabelingJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ListDataLabelingJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes a DataLabelingJob.
pub async fn delete_data_labeling_job(&mut self, request: impl tonic::IntoRequest<super::DeleteDataLabelingJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/DeleteDataLabelingJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "DeleteDataLabelingJob"));
self.inner.unary(req, path, codec).await
}
/// Cancels a DataLabelingJob. Success of cancellation is not guaranteed.
pub async fn cancel_data_labeling_job(&mut self, request: impl tonic::IntoRequest<super::CancelDataLabelingJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CancelDataLabelingJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CancelDataLabelingJob"));
self.inner.unary(req, path, codec).await
}
/// Creates a HyperparameterTuningJob
pub async fn create_hyperparameter_tuning_job(&mut self, request: impl tonic::IntoRequest<super::CreateHyperparameterTuningJobRequest>) -> std::result::Result<tonic::Response<super::HyperparameterTuningJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CreateHyperparameterTuningJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CreateHyperparameterTuningJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a HyperparameterTuningJob
pub async fn get_hyperparameter_tuning_job(&mut self, request: impl tonic::IntoRequest<super::GetHyperparameterTuningJobRequest>) -> std::result::Result<tonic::Response<super::HyperparameterTuningJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/GetHyperparameterTuningJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "GetHyperparameterTuningJob"));
self.inner.unary(req, path, codec).await
}
/// Lists HyperparameterTuningJobs in a Location.
pub async fn list_hyperparameter_tuning_jobs(&mut self, request: impl tonic::IntoRequest<super::ListHyperparameterTuningJobsRequest>) -> std::result::Result<tonic::Response<super::ListHyperparameterTuningJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ListHyperparameterTuningJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ListHyperparameterTuningJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes a HyperparameterTuningJob.
pub async fn delete_hyperparameter_tuning_job(&mut self, request: impl tonic::IntoRequest<super::DeleteHyperparameterTuningJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/DeleteHyperparameterTuningJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "DeleteHyperparameterTuningJob"));
self.inner.unary(req, path, codec).await
}
/// Cancels a HyperparameterTuningJob.
/// Starts asynchronous cancellation on the HyperparameterTuningJob. The server
/// makes a best effort to cancel the job, but success is not
/// guaranteed. Clients can use
/// [JobService.GetHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.GetHyperparameterTuningJob]
/// or other methods to check whether the cancellation succeeded or whether the
/// job completed despite cancellation. On successful cancellation,
/// the HyperparameterTuningJob is not deleted; instead it becomes a job with
/// a
/// [HyperparameterTuningJob.error][google.cloud.aiplatform.v1.HyperparameterTuningJob.error]
/// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
/// corresponding to `Code.CANCELLED`, and
/// [HyperparameterTuningJob.state][google.cloud.aiplatform.v1.HyperparameterTuningJob.state]
/// is set to `CANCELLED`.
pub async fn cancel_hyperparameter_tuning_job(&mut self, request: impl tonic::IntoRequest<super::CancelHyperparameterTuningJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CancelHyperparameterTuningJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CancelHyperparameterTuningJob"));
self.inner.unary(req, path, codec).await
}
/// Creates a NasJob
pub async fn create_nas_job(&mut self, request: impl tonic::IntoRequest<super::CreateNasJobRequest>) -> std::result::Result<tonic::Response<super::NasJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CreateNasJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CreateNasJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a NasJob
pub async fn get_nas_job(&mut self, request: impl tonic::IntoRequest<super::GetNasJobRequest>) -> std::result::Result<tonic::Response<super::NasJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/GetNasJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "GetNasJob"));
self.inner.unary(req, path, codec).await
}
/// Lists NasJobs in a Location.
pub async fn list_nas_jobs(&mut self, request: impl tonic::IntoRequest<super::ListNasJobsRequest>) -> std::result::Result<tonic::Response<super::ListNasJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ListNasJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ListNasJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes a NasJob.
pub async fn delete_nas_job(&mut self, request: impl tonic::IntoRequest<super::DeleteNasJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/DeleteNasJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "DeleteNasJob"));
self.inner.unary(req, path, codec).await
}
/// Cancels a NasJob.
/// Starts asynchronous cancellation on the NasJob. The server
/// makes a best effort to cancel the job, but success is not
/// guaranteed. Clients can use
/// [JobService.GetNasJob][google.cloud.aiplatform.v1.JobService.GetNasJob] or
/// other methods to check whether the cancellation succeeded or whether the
/// job completed despite cancellation. On successful cancellation,
/// the NasJob is not deleted; instead it becomes a job with
/// a [NasJob.error][google.cloud.aiplatform.v1.NasJob.error] value with a
/// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
/// `Code.CANCELLED`, and
/// [NasJob.state][google.cloud.aiplatform.v1.NasJob.state] is set to
/// `CANCELLED`.
pub async fn cancel_nas_job(&mut self, request: impl tonic::IntoRequest<super::CancelNasJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CancelNasJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CancelNasJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a NasTrialDetail.
pub async fn get_nas_trial_detail(&mut self, request: impl tonic::IntoRequest<super::GetNasTrialDetailRequest>) -> std::result::Result<tonic::Response<super::NasTrialDetail>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/GetNasTrialDetail");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "GetNasTrialDetail"));
self.inner.unary(req, path, codec).await
}
/// List top NasTrialDetails of a NasJob.
pub async fn list_nas_trial_details(&mut self, request: impl tonic::IntoRequest<super::ListNasTrialDetailsRequest>) -> std::result::Result<tonic::Response<super::ListNasTrialDetailsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ListNasTrialDetails");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ListNasTrialDetails"));
self.inner.unary(req, path, codec).await
}
/// Creates a BatchPredictionJob. A BatchPredictionJob once created will
/// right away be attempted to start.
pub async fn create_batch_prediction_job(&mut self, request: impl tonic::IntoRequest<super::CreateBatchPredictionJobRequest>) -> std::result::Result<tonic::Response<super::BatchPredictionJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CreateBatchPredictionJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CreateBatchPredictionJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a BatchPredictionJob
pub async fn get_batch_prediction_job(&mut self, request: impl tonic::IntoRequest<super::GetBatchPredictionJobRequest>) -> std::result::Result<tonic::Response<super::BatchPredictionJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/GetBatchPredictionJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "GetBatchPredictionJob"));
self.inner.unary(req, path, codec).await
}
/// Lists BatchPredictionJobs in a Location.
pub async fn list_batch_prediction_jobs(&mut self, request: impl tonic::IntoRequest<super::ListBatchPredictionJobsRequest>) -> std::result::Result<tonic::Response<super::ListBatchPredictionJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ListBatchPredictionJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ListBatchPredictionJobs"));
self.inner.unary(req, path, codec).await
}
/// Deletes a BatchPredictionJob. Can only be called on jobs that already
/// finished.
pub async fn delete_batch_prediction_job(&mut self, request: impl tonic::IntoRequest<super::DeleteBatchPredictionJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/DeleteBatchPredictionJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "DeleteBatchPredictionJob"));
self.inner.unary(req, path, codec).await
}
/// Cancels a BatchPredictionJob.
///
/// Starts asynchronous cancellation on the BatchPredictionJob. The server
/// makes the best effort to cancel the job, but success is not
/// guaranteed. Clients can use
/// [JobService.GetBatchPredictionJob][google.cloud.aiplatform.v1.JobService.GetBatchPredictionJob]
/// or other methods to check whether the cancellation succeeded or whether the
/// job completed despite cancellation. On a successful cancellation,
/// the BatchPredictionJob is not deleted;instead its
/// [BatchPredictionJob.state][google.cloud.aiplatform.v1.BatchPredictionJob.state]
/// is set to `CANCELLED`. Any files already outputted by the job are not
/// deleted.
pub async fn cancel_batch_prediction_job(&mut self, request: impl tonic::IntoRequest<super::CancelBatchPredictionJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CancelBatchPredictionJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CancelBatchPredictionJob"));
self.inner.unary(req, path, codec).await
}
/// Creates a ModelDeploymentMonitoringJob. It will run periodically on a
/// configured interval.
pub async fn create_model_deployment_monitoring_job(&mut self, request: impl tonic::IntoRequest<super::CreateModelDeploymentMonitoringJobRequest>) -> std::result::Result<tonic::Response<super::ModelDeploymentMonitoringJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/CreateModelDeploymentMonitoringJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "CreateModelDeploymentMonitoringJob"));
self.inner.unary(req, path, codec).await
}
/// Searches Model Monitoring Statistics generated within a given time window.
pub async fn search_model_deployment_monitoring_stats_anomalies(&mut self, request: impl tonic::IntoRequest<super::SearchModelDeploymentMonitoringStatsAnomaliesRequest>) -> std::result::Result<tonic::Response<super::SearchModelDeploymentMonitoringStatsAnomaliesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/SearchModelDeploymentMonitoringStatsAnomalies");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "SearchModelDeploymentMonitoringStatsAnomalies"));
self.inner.unary(req, path, codec).await
}
/// Gets a ModelDeploymentMonitoringJob.
pub async fn get_model_deployment_monitoring_job(&mut self, request: impl tonic::IntoRequest<super::GetModelDeploymentMonitoringJobRequest>) -> std::result::Result<tonic::Response<super::ModelDeploymentMonitoringJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/GetModelDeploymentMonitoringJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "GetModelDeploymentMonitoringJob"));
self.inner.unary(req, path, codec).await
}
/// Lists ModelDeploymentMonitoringJobs in a Location.
pub async fn list_model_deployment_monitoring_jobs(&mut self, request: impl tonic::IntoRequest<super::ListModelDeploymentMonitoringJobsRequest>) -> std::result::Result<tonic::Response<super::ListModelDeploymentMonitoringJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ListModelDeploymentMonitoringJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ListModelDeploymentMonitoringJobs"));
self.inner.unary(req, path, codec).await
}
/// Updates a ModelDeploymentMonitoringJob.
pub async fn update_model_deployment_monitoring_job(&mut self, request: impl tonic::IntoRequest<super::UpdateModelDeploymentMonitoringJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/UpdateModelDeploymentMonitoringJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "UpdateModelDeploymentMonitoringJob"));
self.inner.unary(req, path, codec).await
}
/// Deletes a ModelDeploymentMonitoringJob.
pub async fn delete_model_deployment_monitoring_job(&mut self, request: impl tonic::IntoRequest<super::DeleteModelDeploymentMonitoringJobRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/DeleteModelDeploymentMonitoringJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "DeleteModelDeploymentMonitoringJob"));
self.inner.unary(req, path, codec).await
}
/// Pauses a ModelDeploymentMonitoringJob. If the job is running, the server
/// makes a best effort to cancel the job. Will mark
/// [ModelDeploymentMonitoringJob.state][google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.state]
/// to 'PAUSED'.
pub async fn pause_model_deployment_monitoring_job(&mut self, request: impl tonic::IntoRequest<super::PauseModelDeploymentMonitoringJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/PauseModelDeploymentMonitoringJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "PauseModelDeploymentMonitoringJob"));
self.inner.unary(req, path, codec).await
}
/// Resumes a paused ModelDeploymentMonitoringJob. It will start to run from
/// next scheduled time. A deleted ModelDeploymentMonitoringJob can't be
/// resumed.
pub async fn resume_model_deployment_monitoring_job(&mut self, request: impl tonic::IntoRequest<super::ResumeModelDeploymentMonitoringJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.JobService/ResumeModelDeploymentMonitoringJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.JobService", "ResumeModelDeploymentMonitoringJob"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserActionReference {
#[prost(string, tag = "3")]
pub method: ::prost::alloc::string::String,
#[prost(oneof = "user_action_reference::Reference", tags = "1, 2")]
pub reference: ::core::option::Option<user_action_reference::Reference>,
}
/// Nested message and enum types in `UserActionReference`.
pub mod user_action_reference {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Reference {
#[prost(string, tag = "1")]
Operation(::prost::alloc::string::String),
#[prost(string, tag = "2")]
DataLabelingJob(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Annotation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub payload_schema_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub payload: ::core::option::Option<::prost_types::Value>,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "8")]
pub etag: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub annotation_source: ::core::option::Option<UserActionReference>,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub index: ::core::option::Option<Index>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(message, optional, tag = "2")]
pub nearest_neighbor_search_operation_metadata: ::core::option::Option<NearestNeighborSearchOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesResponse {
#[prost(message, repeated, tag = "1")]
pub indexes: ::prost::alloc::vec::Vec<Index>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIndexRequest {
#[prost(message, optional, tag = "1")]
pub index: ::core::option::Option<Index>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIndexOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(message, optional, tag = "2")]
pub nearest_neighbor_search_operation_metadata: ::core::option::Option<NearestNeighborSearchOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIndexRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertDatapointsRequest {
#[prost(string, tag = "1")]
pub index: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub datapoints: ::prost::alloc::vec::Vec<IndexDatapoint>,
#[prost(message, optional, tag = "3")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpsertDatapointsResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDatapointsRequest {
#[prost(string, tag = "1")]
pub index: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub datapoint_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveDatapointsResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NearestNeighborSearchOperationMetadata {
#[prost(message, repeated, tag = "1")]
pub content_validation_stats: ::prost::alloc::vec::Vec<nearest_neighbor_search_operation_metadata::ContentValidationStats>,
#[prost(int64, tag = "2")]
pub data_bytes_count: i64,
}
/// Nested message and enum types in `NearestNeighborSearchOperationMetadata`.
pub mod nearest_neighbor_search_operation_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordError {
#[prost(enumeration = "record_error::RecordErrorType", tag = "1")]
pub error_type: i32,
#[prost(string, tag = "2")]
pub error_message: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub source_gcs_uri: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub embedding_id: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub raw_record: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RecordError`.
pub mod record_error {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecordErrorType {
ErrorTypeUnspecified = 0,
EmptyLine = 1,
InvalidJsonSyntax = 2,
InvalidCsvSyntax = 3,
InvalidAvroSyntax = 4,
InvalidEmbeddingId = 5,
EmbeddingSizeMismatch = 6,
NamespaceMissing = 7,
ParsingError = 8,
DuplicateNamespace = 9,
OpInDatapoint = 10,
MultipleValues = 11,
InvalidNumericValue = 12,
InvalidEncoding = 13,
InvalidSparseDimensions = 14,
InvalidTokenValue = 15,
InvalidSparseEmbedding = 16,
InvalidEmbedding = 17,
}
impl RecordErrorType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RecordErrorType::ErrorTypeUnspecified => "ERROR_TYPE_UNSPECIFIED",
RecordErrorType::EmptyLine => "EMPTY_LINE",
RecordErrorType::InvalidJsonSyntax => "INVALID_JSON_SYNTAX",
RecordErrorType::InvalidCsvSyntax => "INVALID_CSV_SYNTAX",
RecordErrorType::InvalidAvroSyntax => "INVALID_AVRO_SYNTAX",
RecordErrorType::InvalidEmbeddingId => "INVALID_EMBEDDING_ID",
RecordErrorType::EmbeddingSizeMismatch => "EMBEDDING_SIZE_MISMATCH",
RecordErrorType::NamespaceMissing => "NAMESPACE_MISSING",
RecordErrorType::ParsingError => "PARSING_ERROR",
RecordErrorType::DuplicateNamespace => "DUPLICATE_NAMESPACE",
RecordErrorType::OpInDatapoint => "OP_IN_DATAPOINT",
RecordErrorType::MultipleValues => "MULTIPLE_VALUES",
RecordErrorType::InvalidNumericValue => "INVALID_NUMERIC_VALUE",
RecordErrorType::InvalidEncoding => "INVALID_ENCODING",
RecordErrorType::InvalidSparseDimensions => "INVALID_SPARSE_DIMENSIONS",
RecordErrorType::InvalidTokenValue => "INVALID_TOKEN_VALUE",
RecordErrorType::InvalidSparseEmbedding => "INVALID_SPARSE_EMBEDDING",
RecordErrorType::InvalidEmbedding => "INVALID_EMBEDDING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ERROR_TYPE_UNSPECIFIED" => Some(Self::ErrorTypeUnspecified),
"EMPTY_LINE" => Some(Self::EmptyLine),
"INVALID_JSON_SYNTAX" => Some(Self::InvalidJsonSyntax),
"INVALID_CSV_SYNTAX" => Some(Self::InvalidCsvSyntax),
"INVALID_AVRO_SYNTAX" => Some(Self::InvalidAvroSyntax),
"INVALID_EMBEDDING_ID" => Some(Self::InvalidEmbeddingId),
"EMBEDDING_SIZE_MISMATCH" => Some(Self::EmbeddingSizeMismatch),
"NAMESPACE_MISSING" => Some(Self::NamespaceMissing),
"PARSING_ERROR" => Some(Self::ParsingError),
"DUPLICATE_NAMESPACE" => Some(Self::DuplicateNamespace),
"OP_IN_DATAPOINT" => Some(Self::OpInDatapoint),
"MULTIPLE_VALUES" => Some(Self::MultipleValues),
"INVALID_NUMERIC_VALUE" => Some(Self::InvalidNumericValue),
"INVALID_ENCODING" => Some(Self::InvalidEncoding),
"INVALID_SPARSE_DIMENSIONS" => Some(Self::InvalidSparseDimensions),
"INVALID_TOKEN_VALUE" => Some(Self::InvalidTokenValue),
"INVALID_SPARSE_EMBEDDING" => Some(Self::InvalidSparseEmbedding),
"INVALID_EMBEDDING" => Some(Self::InvalidEmbedding),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentValidationStats {
#[prost(string, tag = "1")]
pub source_gcs_uri: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub valid_record_count: i64,
#[prost(int64, tag = "3")]
pub invalid_record_count: i64,
#[prost(message, repeated, tag = "4")]
pub partial_errors: ::prost::alloc::vec::Vec<RecordError>,
#[prost(int64, tag = "5")]
pub valid_sparse_record_count: i64,
#[prost(int64, tag = "6")]
pub invalid_sparse_record_count: i64,
}
}
/// Generated client implementations.
pub mod index_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for creating and managing Vertex AI's Index resources.
#[derive(Debug, Clone)]
pub struct IndexServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> IndexServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> IndexServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
IndexServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates an Index.
pub async fn create_index(&mut self, request: impl tonic::IntoRequest<super::CreateIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexService/CreateIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexService", "CreateIndex"));
self.inner.unary(req, path, codec).await
}
/// Gets an Index.
pub async fn get_index(&mut self, request: impl tonic::IntoRequest<super::GetIndexRequest>) -> std::result::Result<tonic::Response<super::Index>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexService/GetIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexService", "GetIndex"));
self.inner.unary(req, path, codec).await
}
/// Lists Indexes in a Location.
pub async fn list_indexes(&mut self, request: impl tonic::IntoRequest<super::ListIndexesRequest>) -> std::result::Result<tonic::Response<super::ListIndexesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexService/ListIndexes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexService", "ListIndexes"));
self.inner.unary(req, path, codec).await
}
/// Updates an Index.
pub async fn update_index(&mut self, request: impl tonic::IntoRequest<super::UpdateIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexService/UpdateIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexService", "UpdateIndex"));
self.inner.unary(req, path, codec).await
}
/// Deletes an Index.
/// An Index can only be deleted when all its
/// [DeployedIndexes][google.cloud.aiplatform.v1.Index.deployed_indexes] had
/// been undeployed.
pub async fn delete_index(&mut self, request: impl tonic::IntoRequest<super::DeleteIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexService/DeleteIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexService", "DeleteIndex"));
self.inner.unary(req, path, codec).await
}
/// Add/update Datapoints into an Index.
pub async fn upsert_datapoints(&mut self, request: impl tonic::IntoRequest<super::UpsertDatapointsRequest>) -> std::result::Result<tonic::Response<super::UpsertDatapointsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexService/UpsertDatapoints");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexService", "UpsertDatapoints"));
self.inner.unary(req, path, codec).await
}
/// Remove Datapoints from an Index.
pub async fn remove_datapoints(&mut self, request: impl tonic::IntoRequest<super::RemoveDatapointsRequest>) -> std::result::Result<tonic::Response<super::RemoveDatapointsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexService/RemoveDatapoints");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexService", "RemoveDatapoints"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexEndpoint {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub deployed_indexes: ::prost::alloc::vec::Vec<DeployedIndex>,
#[prost(string, tag = "5")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "9")]
pub network: ::prost::alloc::string::String,
#[deprecated]
#[prost(bool, tag = "10")]
pub enable_private_service_connect: bool,
#[prost(message, optional, tag = "12")]
pub private_service_connect_config: ::core::option::Option<PrivateServiceConnectConfig>,
#[prost(bool, tag = "13")]
pub public_endpoint_enabled: bool,
#[prost(string, tag = "14")]
pub public_endpoint_domain_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "15")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedIndex {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub index: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub private_endpoints: ::core::option::Option<IndexPrivateEndpoints>,
#[prost(message, optional, tag = "6")]
pub index_sync_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "7")]
pub automatic_resources: ::core::option::Option<AutomaticResources>,
#[prost(message, optional, tag = "16")]
pub dedicated_resources: ::core::option::Option<DedicatedResources>,
#[prost(bool, tag = "8")]
pub enable_access_logging: bool,
#[prost(message, optional, tag = "9")]
pub deployed_index_auth_config: ::core::option::Option<DeployedIndexAuthConfig>,
#[prost(string, repeated, tag = "10")]
pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, tag = "11")]
pub deployment_group: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedIndexAuthConfig {
#[prost(message, optional, tag = "1")]
pub auth_provider: ::core::option::Option<deployed_index_auth_config::AuthProvider>,
}
/// Nested message and enum types in `DeployedIndexAuthConfig`.
pub mod deployed_index_auth_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthProvider {
#[prost(string, repeated, tag = "1")]
pub audiences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "2")]
pub allowed_issuers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexPrivateEndpoints {
#[prost(string, tag = "1")]
pub match_grpc_address: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub service_attachment: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "3")]
pub psc_automated_endpoints: ::prost::alloc::vec::Vec<PscAutomatedEndpoints>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexEndpointRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub index_endpoint: ::core::option::Option<IndexEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexEndpointOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexEndpointRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexEndpointsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexEndpointsResponse {
#[prost(message, repeated, tag = "1")]
pub index_endpoints: ::prost::alloc::vec::Vec<IndexEndpoint>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIndexEndpointRequest {
#[prost(message, optional, tag = "1")]
pub index_endpoint: ::core::option::Option<IndexEndpoint>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIndexEndpointRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIndexRequest {
#[prost(string, tag = "1")]
pub index_endpoint: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub deployed_index: ::core::option::Option<DeployedIndex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIndexResponse {
#[prost(message, optional, tag = "1")]
pub deployed_index: ::core::option::Option<DeployedIndex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIndexOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub deployed_index_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIndexRequest {
#[prost(string, tag = "1")]
pub index_endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployed_index_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UndeployIndexResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIndexOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedIndexRequest {
#[prost(string, tag = "1")]
pub index_endpoint: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub deployed_index: ::core::option::Option<DeployedIndex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedIndexResponse {
#[prost(message, optional, tag = "1")]
pub deployed_index: ::core::option::Option<DeployedIndex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedIndexOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub deployed_index_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod index_endpoint_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for managing Vertex AI's IndexEndpoints.
#[derive(Debug, Clone)]
pub struct IndexEndpointServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> IndexEndpointServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> IndexEndpointServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
IndexEndpointServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates an IndexEndpoint.
pub async fn create_index_endpoint(&mut self, request: impl tonic::IntoRequest<super::CreateIndexEndpointRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/CreateIndexEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "CreateIndexEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Gets an IndexEndpoint.
pub async fn get_index_endpoint(&mut self, request: impl tonic::IntoRequest<super::GetIndexEndpointRequest>) -> std::result::Result<tonic::Response<super::IndexEndpoint>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/GetIndexEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "GetIndexEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Lists IndexEndpoints in a Location.
pub async fn list_index_endpoints(&mut self, request: impl tonic::IntoRequest<super::ListIndexEndpointsRequest>) -> std::result::Result<tonic::Response<super::ListIndexEndpointsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/ListIndexEndpoints");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "ListIndexEndpoints"));
self.inner.unary(req, path, codec).await
}
/// Updates an IndexEndpoint.
pub async fn update_index_endpoint(&mut self, request: impl tonic::IntoRequest<super::UpdateIndexEndpointRequest>) -> std::result::Result<tonic::Response<super::IndexEndpoint>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/UpdateIndexEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "UpdateIndexEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Deletes an IndexEndpoint.
pub async fn delete_index_endpoint(&mut self, request: impl tonic::IntoRequest<super::DeleteIndexEndpointRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/DeleteIndexEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "DeleteIndexEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Deploys an Index into this IndexEndpoint, creating a DeployedIndex within
/// it.
/// Only non-empty Indexes can be deployed.
pub async fn deploy_index(&mut self, request: impl tonic::IntoRequest<super::DeployIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/DeployIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "DeployIndex"));
self.inner.unary(req, path, codec).await
}
/// Undeploys an Index from an IndexEndpoint, removing a DeployedIndex from it,
/// and freeing all resources it's using.
pub async fn undeploy_index(&mut self, request: impl tonic::IntoRequest<super::UndeployIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/UndeployIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "UndeployIndex"));
self.inner.unary(req, path, codec).await
}
/// Update an existing DeployedIndex under an IndexEndpoint.
pub async fn mutate_deployed_index(&mut self, request: impl tonic::IntoRequest<super::MutateDeployedIndexRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.IndexEndpointService/MutateDeployedIndex");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.IndexEndpointService", "MutateDeployedIndex"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureGroup {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "4")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "5")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "6")]
pub description: ::prost::alloc::string::String,
#[prost(oneof = "feature_group::Source", tags = "7")]
pub source: ::core::option::Option<feature_group::Source>,
}
/// Nested message and enum types in `FeatureGroup`.
pub mod feature_group {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuery {
#[prost(message, optional, tag = "1")]
pub big_query_source: ::core::option::Option<super::BigQuerySource>,
#[prost(string, repeated, tag = "2")]
pub entity_id_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "7")]
BigQuery(BigQuery),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardTimeSeries {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(enumeration = "tensorboard_time_series::ValueType", tag = "4")]
pub value_type: i32,
#[prost(message, optional, tag = "5")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "7")]
pub etag: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub plugin_name: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "9")]
pub plugin_data: ::prost::bytes::Bytes,
#[prost(message, optional, tag = "10")]
pub metadata: ::core::option::Option<tensorboard_time_series::Metadata>,
}
/// Nested message and enum types in `TensorboardTimeSeries`.
pub mod tensorboard_time_series {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Metadata {
#[prost(int64, tag = "1")]
pub max_step: i64,
#[prost(message, optional, tag = "2")]
pub max_wall_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "3")]
pub max_blob_sequence_length: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValueType {
Unspecified = 0,
Scalar = 1,
Tensor = 2,
BlobSequence = 3,
}
impl ValueType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ValueType::Unspecified => "VALUE_TYPE_UNSPECIFIED",
ValueType::Scalar => "SCALAR",
ValueType::Tensor => "TENSOR",
ValueType::BlobSequence => "BLOB_SEQUENCE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"SCALAR" => Some(Self::Scalar),
"TENSOR" => Some(Self::Tensor),
"BLOB_SEQUENCE" => Some(Self::BlobSequence),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdMatcher {
#[prost(string, repeated, tag = "1")]
pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureSelector {
#[prost(message, optional, tag = "1")]
pub id_matcher: ::core::option::Option<IdMatcher>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecialistPool {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub specialist_managers_count: i32,
#[prost(string, repeated, tag = "4")]
pub specialist_manager_emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "5")]
pub pending_data_labeling_jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "7")]
pub specialist_worker_emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteFeatureValuesRequest {
#[prost(string, tag = "1")]
pub entity_type: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub payloads: ::prost::alloc::vec::Vec<WriteFeatureValuesPayload>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteFeatureValuesPayload {
#[prost(string, tag = "1")]
pub entity_id: ::prost::alloc::string::String,
#[prost(btree_map = "string, message", tag = "2")]
pub feature_values: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, FeatureValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteFeatureValuesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadFeatureValuesRequest {
#[prost(string, tag = "1")]
pub entity_type: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub entity_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub feature_selector: ::core::option::Option<FeatureSelector>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadFeatureValuesResponse {
#[prost(message, optional, tag = "1")]
pub header: ::core::option::Option<read_feature_values_response::Header>,
#[prost(message, optional, tag = "2")]
pub entity_view: ::core::option::Option<read_feature_values_response::EntityView>,
}
/// Nested message and enum types in `ReadFeatureValuesResponse`.
pub mod read_feature_values_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureDescriptor {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
#[prost(string, tag = "1")]
pub entity_type: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub feature_descriptors: ::prost::alloc::vec::Vec<FeatureDescriptor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityView {
#[prost(string, tag = "1")]
pub entity_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub data: ::prost::alloc::vec::Vec<entity_view::Data>,
}
/// Nested message and enum types in `EntityView`.
pub mod entity_view {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
#[prost(oneof = "data::Data", tags = "1, 2")]
pub data: ::core::option::Option<data::Data>,
}
/// Nested message and enum types in `Data`.
pub mod data {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Data {
#[prost(message, tag = "1")]
Value(super::super::super::FeatureValue),
#[prost(message, tag = "2")]
Values(super::super::super::FeatureValueList),
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingReadFeatureValuesRequest {
#[prost(string, tag = "1")]
pub entity_type: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub entity_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub feature_selector: ::core::option::Option<FeatureSelector>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureValue {
#[prost(message, optional, tag = "14")]
pub metadata: ::core::option::Option<feature_value::Metadata>,
#[prost(oneof = "feature_value::Value", tags = "1, 2, 5, 6, 7, 8, 11, 12, 13, 15")]
pub value: ::core::option::Option<feature_value::Value>,
}
/// Nested message and enum types in `FeatureValue`.
pub mod feature_value {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Metadata {
#[prost(message, optional, tag = "1")]
pub generate_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(bool, tag = "1")]
BoolValue(bool),
#[prost(double, tag = "2")]
DoubleValue(f64),
#[prost(int64, tag = "5")]
Int64Value(i64),
#[prost(string, tag = "6")]
StringValue(::prost::alloc::string::String),
#[prost(message, tag = "7")]
BoolArrayValue(super::BoolArray),
#[prost(message, tag = "8")]
DoubleArrayValue(super::DoubleArray),
#[prost(message, tag = "11")]
Int64ArrayValue(super::Int64Array),
#[prost(message, tag = "12")]
StringArrayValue(super::StringArray),
#[prost(bytes, tag = "13")]
BytesValue(::prost::bytes::Bytes),
#[prost(message, tag = "15")]
StructValue(super::StructValue),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructValue {
#[prost(message, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<StructFieldValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructFieldValue {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub value: ::core::option::Option<FeatureValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureValueList {
#[prost(message, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<FeatureValue>,
}
/// Generated client implementations.
pub mod featurestore_online_serving_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for serving online feature values.
#[derive(Debug, Clone)]
pub struct FeaturestoreOnlineServingServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeaturestoreOnlineServingServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeaturestoreOnlineServingServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeaturestoreOnlineServingServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Reads Feature values of a specific entity of an EntityType. For reading
/// feature values of multiple entities of an EntityType, please use
/// StreamingReadFeatureValues.
pub async fn read_feature_values(&mut self, request: impl tonic::IntoRequest<super::ReadFeatureValuesRequest>) -> std::result::Result<tonic::Response<super::ReadFeatureValuesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreOnlineServingService/ReadFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreOnlineServingService", "ReadFeatureValues"));
self.inner.unary(req, path, codec).await
}
/// Reads Feature values for multiple entities. Depending on their size, data
/// for different entities may be broken
/// up across multiple responses.
pub async fn streaming_read_feature_values(&mut self, request: impl tonic::IntoRequest<super::StreamingReadFeatureValuesRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::ReadFeatureValuesResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreOnlineServingService/StreamingReadFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreOnlineServingService", "StreamingReadFeatureValues"));
self.inner.server_streaming(req, path, codec).await
}
/// Writes Feature values of one or more entities of an EntityType.
///
/// The Feature values are merged into existing entities if any. The Feature
/// values to be written must have timestamp within the online storage
/// retention.
pub async fn write_feature_values(&mut self, request: impl tonic::IntoRequest<super::WriteFeatureValuesRequest>) -> std::result::Result<tonic::Response<super::WriteFeatureValuesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreOnlineServingService/WriteFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreOnlineServingService", "WriteFeatureValues"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSchema {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub schema_version: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub schema: ::prost::alloc::string::String,
#[prost(enumeration = "metadata_schema::MetadataSchemaType", tag = "4")]
pub schema_type: i32,
#[prost(message, optional, tag = "5")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "6")]
pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MetadataSchema`.
pub mod metadata_schema {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetadataSchemaType {
Unspecified = 0,
ArtifactType = 1,
ExecutionType = 2,
ContextType = 3,
}
impl MetadataSchemaType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
MetadataSchemaType::Unspecified => "METADATA_SCHEMA_TYPE_UNSPECIFIED",
MetadataSchemaType::ArtifactType => "ARTIFACT_TYPE",
MetadataSchemaType::ExecutionType => "EXECUTION_TYPE",
MetadataSchemaType::ContextType => "CONTEXT_TYPE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"METADATA_SCHEMA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"ARTIFACT_TYPE" => Some(Self::ArtifactType),
"EXECUTION_TYPE" => Some(Self::ExecutionType),
"CONTEXT_TYPE" => Some(Self::ContextType),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataStoreRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub metadata_store: ::core::option::Option<MetadataStore>,
#[prost(string, tag = "3")]
pub metadata_store_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataStoreOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataStoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataStoresRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataStoresResponse {
#[prost(message, repeated, tag = "1")]
pub metadata_stores: ::prost::alloc::vec::Vec<MetadataStore>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMetadataStoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[deprecated]
#[prost(bool, tag = "2")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMetadataStoreOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArtifactRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub artifact: ::core::option::Option<Artifact>,
#[prost(string, tag = "3")]
pub artifact_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetArtifactRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArtifactsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArtifactsResponse {
#[prost(message, repeated, tag = "1")]
pub artifacts: ::prost::alloc::vec::Vec<Artifact>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateArtifactRequest {
#[prost(message, optional, tag = "1")]
pub artifact: ::core::option::Option<Artifact>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(bool, tag = "3")]
pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteArtifactRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeArtifactsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeArtifactsResponse {
#[prost(int64, tag = "1")]
pub purge_count: i64,
#[prost(string, repeated, tag = "2")]
pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeArtifactsMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContextRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub context: ::core::option::Option<Context>,
#[prost(string, tag = "3")]
pub context_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContextRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsResponse {
#[prost(message, repeated, tag = "1")]
pub contexts: ::prost::alloc::vec::Vec<Context>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContextRequest {
#[prost(message, optional, tag = "1")]
pub context: ::core::option::Option<Context>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(bool, tag = "3")]
pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContextRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub force: bool,
#[prost(string, tag = "3")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeContextsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeContextsResponse {
#[prost(int64, tag = "1")]
pub purge_count: i64,
#[prost(string, repeated, tag = "2")]
pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeContextsMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddContextArtifactsAndExecutionsRequest {
#[prost(string, tag = "1")]
pub context: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub artifacts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub executions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddContextArtifactsAndExecutionsResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddContextChildrenRequest {
#[prost(string, tag = "1")]
pub context: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub child_contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddContextChildrenResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveContextChildrenRequest {
#[prost(string, tag = "1")]
pub context: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub child_contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveContextChildrenResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryContextLineageSubgraphRequest {
#[prost(string, tag = "1")]
pub context: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExecutionRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub execution: ::core::option::Option<Execution>,
#[prost(string, tag = "3")]
pub execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExecutionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExecutionsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExecutionsResponse {
#[prost(message, repeated, tag = "1")]
pub executions: ::prost::alloc::vec::Vec<Execution>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExecutionRequest {
#[prost(message, optional, tag = "1")]
pub execution: ::core::option::Option<Execution>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(bool, tag = "3")]
pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExecutionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeExecutionsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeExecutionsResponse {
#[prost(int64, tag = "1")]
pub purge_count: i64,
#[prost(string, repeated, tag = "2")]
pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeExecutionsMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddExecutionEventsRequest {
#[prost(string, tag = "1")]
pub execution: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub events: ::prost::alloc::vec::Vec<Event>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddExecutionEventsResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryExecutionInputsAndOutputsRequest {
#[prost(string, tag = "1")]
pub execution: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataSchemaRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub metadata_schema: ::core::option::Option<MetadataSchema>,
#[prost(string, tag = "3")]
pub metadata_schema_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataSchemaRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataSchemasRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataSchemasResponse {
#[prost(message, repeated, tag = "1")]
pub metadata_schemas: ::prost::alloc::vec::Vec<MetadataSchema>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryArtifactLineageSubgraphRequest {
#[prost(string, tag = "1")]
pub artifact: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub max_hops: i32,
#[prost(string, tag = "3")]
pub filter: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod metadata_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service for reading and writing metadata entries.
#[derive(Debug, Clone)]
pub struct MetadataServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> MetadataServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> MetadataServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
MetadataServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Initializes a MetadataStore, including allocation of resources.
pub async fn create_metadata_store(&mut self, request: impl tonic::IntoRequest<super::CreateMetadataStoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/CreateMetadataStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "CreateMetadataStore"));
self.inner.unary(req, path, codec).await
}
/// Retrieves a specific MetadataStore.
pub async fn get_metadata_store(&mut self, request: impl tonic::IntoRequest<super::GetMetadataStoreRequest>) -> std::result::Result<tonic::Response<super::MetadataStore>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/GetMetadataStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "GetMetadataStore"));
self.inner.unary(req, path, codec).await
}
/// Lists MetadataStores for a Location.
pub async fn list_metadata_stores(&mut self, request: impl tonic::IntoRequest<super::ListMetadataStoresRequest>) -> std::result::Result<tonic::Response<super::ListMetadataStoresResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/ListMetadataStores");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "ListMetadataStores"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single MetadataStore and all its child resources (Artifacts,
/// Executions, and Contexts).
pub async fn delete_metadata_store(&mut self, request: impl tonic::IntoRequest<super::DeleteMetadataStoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/DeleteMetadataStore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "DeleteMetadataStore"));
self.inner.unary(req, path, codec).await
}
/// Creates an Artifact associated with a MetadataStore.
pub async fn create_artifact(&mut self, request: impl tonic::IntoRequest<super::CreateArtifactRequest>) -> std::result::Result<tonic::Response<super::Artifact>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/CreateArtifact");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "CreateArtifact"));
self.inner.unary(req, path, codec).await
}
/// Retrieves a specific Artifact.
pub async fn get_artifact(&mut self, request: impl tonic::IntoRequest<super::GetArtifactRequest>) -> std::result::Result<tonic::Response<super::Artifact>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/GetArtifact");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "GetArtifact"));
self.inner.unary(req, path, codec).await
}
/// Lists Artifacts in the MetadataStore.
pub async fn list_artifacts(&mut self, request: impl tonic::IntoRequest<super::ListArtifactsRequest>) -> std::result::Result<tonic::Response<super::ListArtifactsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/ListArtifacts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "ListArtifacts"));
self.inner.unary(req, path, codec).await
}
/// Updates a stored Artifact.
pub async fn update_artifact(&mut self, request: impl tonic::IntoRequest<super::UpdateArtifactRequest>) -> std::result::Result<tonic::Response<super::Artifact>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/UpdateArtifact");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "UpdateArtifact"));
self.inner.unary(req, path, codec).await
}
/// Deletes an Artifact.
pub async fn delete_artifact(&mut self, request: impl tonic::IntoRequest<super::DeleteArtifactRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/DeleteArtifact");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "DeleteArtifact"));
self.inner.unary(req, path, codec).await
}
/// Purges Artifacts.
pub async fn purge_artifacts(&mut self, request: impl tonic::IntoRequest<super::PurgeArtifactsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/PurgeArtifacts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "PurgeArtifacts"));
self.inner.unary(req, path, codec).await
}
/// Creates a Context associated with a MetadataStore.
pub async fn create_context(&mut self, request: impl tonic::IntoRequest<super::CreateContextRequest>) -> std::result::Result<tonic::Response<super::Context>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/CreateContext");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "CreateContext"));
self.inner.unary(req, path, codec).await
}
/// Retrieves a specific Context.
pub async fn get_context(&mut self, request: impl tonic::IntoRequest<super::GetContextRequest>) -> std::result::Result<tonic::Response<super::Context>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/GetContext");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "GetContext"));
self.inner.unary(req, path, codec).await
}
/// Lists Contexts on the MetadataStore.
pub async fn list_contexts(&mut self, request: impl tonic::IntoRequest<super::ListContextsRequest>) -> std::result::Result<tonic::Response<super::ListContextsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/ListContexts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "ListContexts"));
self.inner.unary(req, path, codec).await
}
/// Updates a stored Context.
pub async fn update_context(&mut self, request: impl tonic::IntoRequest<super::UpdateContextRequest>) -> std::result::Result<tonic::Response<super::Context>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/UpdateContext");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "UpdateContext"));
self.inner.unary(req, path, codec).await
}
/// Deletes a stored Context.
pub async fn delete_context(&mut self, request: impl tonic::IntoRequest<super::DeleteContextRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/DeleteContext");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "DeleteContext"));
self.inner.unary(req, path, codec).await
}
/// Purges Contexts.
pub async fn purge_contexts(&mut self, request: impl tonic::IntoRequest<super::PurgeContextsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/PurgeContexts");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "PurgeContexts"));
self.inner.unary(req, path, codec).await
}
/// Adds a set of Artifacts and Executions to a Context. If any of the
/// Artifacts or Executions have already been added to a Context, they are
/// simply skipped.
pub async fn add_context_artifacts_and_executions(&mut self, request: impl tonic::IntoRequest<super::AddContextArtifactsAndExecutionsRequest>) -> std::result::Result<tonic::Response<super::AddContextArtifactsAndExecutionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/AddContextArtifactsAndExecutions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "AddContextArtifactsAndExecutions"));
self.inner.unary(req, path, codec).await
}
/// Adds a set of Contexts as children to a parent Context. If any of the
/// child Contexts have already been added to the parent Context, they are
/// simply skipped. If this call would create a cycle or cause any Context to
/// have more than 10 parents, the request will fail with an INVALID_ARGUMENT
/// error.
pub async fn add_context_children(&mut self, request: impl tonic::IntoRequest<super::AddContextChildrenRequest>) -> std::result::Result<tonic::Response<super::AddContextChildrenResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/AddContextChildren");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "AddContextChildren"));
self.inner.unary(req, path, codec).await
}
/// Remove a set of children contexts from a parent Context. If any of the
/// child Contexts were NOT added to the parent Context, they are
/// simply skipped.
pub async fn remove_context_children(&mut self, request: impl tonic::IntoRequest<super::RemoveContextChildrenRequest>) -> std::result::Result<tonic::Response<super::RemoveContextChildrenResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/RemoveContextChildren");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "RemoveContextChildren"));
self.inner.unary(req, path, codec).await
}
/// Retrieves Artifacts and Executions within the specified Context, connected
/// by Event edges and returned as a LineageSubgraph.
pub async fn query_context_lineage_subgraph(&mut self, request: impl tonic::IntoRequest<super::QueryContextLineageSubgraphRequest>) -> std::result::Result<tonic::Response<super::LineageSubgraph>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/QueryContextLineageSubgraph");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "QueryContextLineageSubgraph"));
self.inner.unary(req, path, codec).await
}
/// Creates an Execution associated with a MetadataStore.
pub async fn create_execution(&mut self, request: impl tonic::IntoRequest<super::CreateExecutionRequest>) -> std::result::Result<tonic::Response<super::Execution>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/CreateExecution");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "CreateExecution"));
self.inner.unary(req, path, codec).await
}
/// Retrieves a specific Execution.
pub async fn get_execution(&mut self, request: impl tonic::IntoRequest<super::GetExecutionRequest>) -> std::result::Result<tonic::Response<super::Execution>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/GetExecution");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "GetExecution"));
self.inner.unary(req, path, codec).await
}
/// Lists Executions in the MetadataStore.
pub async fn list_executions(&mut self, request: impl tonic::IntoRequest<super::ListExecutionsRequest>) -> std::result::Result<tonic::Response<super::ListExecutionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/ListExecutions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "ListExecutions"));
self.inner.unary(req, path, codec).await
}
/// Updates a stored Execution.
pub async fn update_execution(&mut self, request: impl tonic::IntoRequest<super::UpdateExecutionRequest>) -> std::result::Result<tonic::Response<super::Execution>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/UpdateExecution");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "UpdateExecution"));
self.inner.unary(req, path, codec).await
}
/// Deletes an Execution.
pub async fn delete_execution(&mut self, request: impl tonic::IntoRequest<super::DeleteExecutionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/DeleteExecution");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "DeleteExecution"));
self.inner.unary(req, path, codec).await
}
/// Purges Executions.
pub async fn purge_executions(&mut self, request: impl tonic::IntoRequest<super::PurgeExecutionsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/PurgeExecutions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "PurgeExecutions"));
self.inner.unary(req, path, codec).await
}
/// Adds Events to the specified Execution. An Event indicates whether an
/// Artifact was used as an input or output for an Execution. If an Event
/// already exists between the Execution and the Artifact, the Event is
/// skipped.
pub async fn add_execution_events(&mut self, request: impl tonic::IntoRequest<super::AddExecutionEventsRequest>) -> std::result::Result<tonic::Response<super::AddExecutionEventsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/AddExecutionEvents");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "AddExecutionEvents"));
self.inner.unary(req, path, codec).await
}
/// Obtains the set of input and output Artifacts for this Execution, in the
/// form of LineageSubgraph that also contains the Execution and connecting
/// Events.
pub async fn query_execution_inputs_and_outputs(&mut self, request: impl tonic::IntoRequest<super::QueryExecutionInputsAndOutputsRequest>) -> std::result::Result<tonic::Response<super::LineageSubgraph>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/QueryExecutionInputsAndOutputs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "QueryExecutionInputsAndOutputs"));
self.inner.unary(req, path, codec).await
}
/// Creates a MetadataSchema.
pub async fn create_metadata_schema(&mut self, request: impl tonic::IntoRequest<super::CreateMetadataSchemaRequest>) -> std::result::Result<tonic::Response<super::MetadataSchema>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/CreateMetadataSchema");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "CreateMetadataSchema"));
self.inner.unary(req, path, codec).await
}
/// Retrieves a specific MetadataSchema.
pub async fn get_metadata_schema(&mut self, request: impl tonic::IntoRequest<super::GetMetadataSchemaRequest>) -> std::result::Result<tonic::Response<super::MetadataSchema>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/GetMetadataSchema");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "GetMetadataSchema"));
self.inner.unary(req, path, codec).await
}
/// Lists MetadataSchemas.
pub async fn list_metadata_schemas(&mut self, request: impl tonic::IntoRequest<super::ListMetadataSchemasRequest>) -> std::result::Result<tonic::Response<super::ListMetadataSchemasResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/ListMetadataSchemas");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "ListMetadataSchemas"));
self.inner.unary(req, path, codec).await
}
/// Retrieves lineage of an Artifact represented through Artifacts and
/// Executions connected by Event edges and returned as a LineageSubgraph.
pub async fn query_artifact_lineage_subgraph(&mut self, request: impl tonic::IntoRequest<super::QueryArtifactLineageSubgraphRequest>) -> std::result::Result<tonic::Response<super::LineageSubgraph>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.MetadataService/QueryArtifactLineageSubgraph");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.MetadataService", "QueryArtifactLineageSubgraph"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublisherModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub language_code: ::prost::alloc::string::String,
#[prost(enumeration = "PublisherModelView", tag = "3")]
pub view: i32,
#[prost(bool, tag = "5")]
pub is_hugging_face_model: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PublisherModelView {
Unspecified = 0,
Basic = 1,
Full = 2,
PublisherModelVersionViewBasic = 3,
}
impl PublisherModelView {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PublisherModelView::Unspecified => "PUBLISHER_MODEL_VIEW_UNSPECIFIED",
PublisherModelView::Basic => "PUBLISHER_MODEL_VIEW_BASIC",
PublisherModelView::Full => "PUBLISHER_MODEL_VIEW_FULL",
PublisherModelView::PublisherModelVersionViewBasic => "PUBLISHER_MODEL_VERSION_VIEW_BASIC",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PUBLISHER_MODEL_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
"PUBLISHER_MODEL_VIEW_BASIC" => Some(Self::Basic),
"PUBLISHER_MODEL_VIEW_FULL" => Some(Self::Full),
"PUBLISHER_MODEL_VERSION_VIEW_BASIC" => Some(Self::PublisherModelVersionViewBasic),
_ => None,
}
}
}
/// Generated client implementations.
pub mod model_garden_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The interface of Model Garden Service.
#[derive(Debug, Clone)]
pub struct ModelGardenServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ModelGardenServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ModelGardenServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ModelGardenServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets a Model Garden publisher model.
pub async fn get_publisher_model(&mut self, request: impl tonic::IntoRequest<super::GetPublisherModelRequest>) -> std::result::Result<tonic::Response<super::PublisherModel>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelGardenService/GetPublisherModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelGardenService", "GetPublisherModel"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatasetVersion {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "3")]
pub etag: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub big_query_dataset_name: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub metadata: ::core::option::Option<::prost_types::Value>,
#[prost(string, tag = "9")]
pub model_reference: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEndpointRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub endpoint: ::core::option::Option<Endpoint>,
#[prost(string, tag = "4")]
pub endpoint_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEndpointOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEndpointRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEndpointsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEndpointsResponse {
#[prost(message, repeated, tag = "1")]
pub endpoints: ::prost::alloc::vec::Vec<Endpoint>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEndpointRequest {
#[prost(message, optional, tag = "1")]
pub endpoint: ::core::option::Option<Endpoint>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEndpointRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployModelRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub deployed_model: ::core::option::Option<DeployedModel>,
#[prost(btree_map = "string, int32", tag = "3")]
pub traffic_split: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployModelResponse {
#[prost(message, optional, tag = "1")]
pub deployed_model: ::core::option::Option<DeployedModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployModelOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployModelRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployed_model_id: ::prost::alloc::string::String,
#[prost(btree_map = "string, int32", tag = "3")]
pub traffic_split: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UndeployModelResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployModelOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedModelRequest {
#[prost(string, tag = "1")]
pub endpoint: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub deployed_model: ::core::option::Option<DeployedModel>,
#[prost(message, optional, tag = "4")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedModelResponse {
#[prost(message, optional, tag = "1")]
pub deployed_model: ::core::option::Option<DeployedModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedModelOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
/// Generated client implementations.
pub mod endpoint_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for managing Vertex AI's Endpoints.
#[derive(Debug, Clone)]
pub struct EndpointServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> EndpointServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> EndpointServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
EndpointServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates an Endpoint.
pub async fn create_endpoint(&mut self, request: impl tonic::IntoRequest<super::CreateEndpointRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/CreateEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "CreateEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Gets an Endpoint.
pub async fn get_endpoint(&mut self, request: impl tonic::IntoRequest<super::GetEndpointRequest>) -> std::result::Result<tonic::Response<super::Endpoint>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/GetEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "GetEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Lists Endpoints in a Location.
pub async fn list_endpoints(&mut self, request: impl tonic::IntoRequest<super::ListEndpointsRequest>) -> std::result::Result<tonic::Response<super::ListEndpointsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/ListEndpoints");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "ListEndpoints"));
self.inner.unary(req, path, codec).await
}
/// Updates an Endpoint.
pub async fn update_endpoint(&mut self, request: impl tonic::IntoRequest<super::UpdateEndpointRequest>) -> std::result::Result<tonic::Response<super::Endpoint>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/UpdateEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "UpdateEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Deletes an Endpoint.
pub async fn delete_endpoint(&mut self, request: impl tonic::IntoRequest<super::DeleteEndpointRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/DeleteEndpoint");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "DeleteEndpoint"));
self.inner.unary(req, path, codec).await
}
/// Deploys a Model into this Endpoint, creating a DeployedModel within it.
pub async fn deploy_model(&mut self, request: impl tonic::IntoRequest<super::DeployModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/DeployModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "DeployModel"));
self.inner.unary(req, path, codec).await
}
/// Undeploys a Model from an Endpoint, removing a DeployedModel from it, and
/// freeing all resources it's using.
pub async fn undeploy_model(&mut self, request: impl tonic::IntoRequest<super::UndeployModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/UndeployModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "UndeployModel"));
self.inner.unary(req, path, codec).await
}
/// Updates an existing deployed model. Updatable fields include
/// `min_replica_count`, `max_replica_count`, `autoscaling_metric_specs`,
/// `disable_container_logging` (v1 only), and `enable_container_logging`
/// (v1beta1 only).
pub async fn mutate_deployed_model(&mut self, request: impl tonic::IntoRequest<super::MutateDeployedModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.EndpointService/MutateDeployedModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.EndpointService", "MutateDeployedModel"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesData {
#[prost(string, tag = "1")]
pub tensorboard_time_series_id: ::prost::alloc::string::String,
#[prost(enumeration = "tensorboard_time_series::ValueType", tag = "2")]
pub value_type: i32,
#[prost(message, repeated, tag = "3")]
pub values: ::prost::alloc::vec::Vec<TimeSeriesDataPoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesDataPoint {
#[prost(message, optional, tag = "1")]
pub wall_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int64, tag = "2")]
pub step: i64,
#[prost(oneof = "time_series_data_point::Value", tags = "3, 4, 5")]
pub value: ::core::option::Option<time_series_data_point::Value>,
}
/// Nested message and enum types in `TimeSeriesDataPoint`.
pub mod time_series_data_point {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(message, tag = "3")]
Scalar(super::Scalar),
#[prost(message, tag = "4")]
Tensor(super::TensorboardTensor),
#[prost(message, tag = "5")]
Blobs(super::TensorboardBlobSequence),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Scalar {
#[prost(double, tag = "1")]
pub value: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardTensor {
#[prost(bytes = "bytes", tag = "1")]
pub value: ::prost::bytes::Bytes,
#[prost(int32, tag = "2")]
pub version_number: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardBlobSequence {
#[prost(message, repeated, tag = "1")]
pub values: ::prost::alloc::vec::Vec<TensorboardBlob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardBlob {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "2")]
pub data: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardExperiment {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub etag: ::prost::alloc::string::String,
#[prost(string, tag = "8")]
pub source: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub tensorboard: ::core::option::Option<Tensorboard>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardsResponse {
#[prost(message, repeated, tag = "1")]
pub tensorboards: ::prost::alloc::vec::Vec<Tensorboard>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub tensorboard: ::core::option::Option<Tensorboard>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardUsageRequest {
#[prost(string, tag = "1")]
pub tensorboard: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardUsageResponse {
#[prost(btree_map = "string, message", tag = "1")]
pub monthly_usage_data: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, read_tensorboard_usage_response::PerMonthUsageData>,
}
/// Nested message and enum types in `ReadTensorboardUsageResponse`.
pub mod read_tensorboard_usage_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerUserUsageData {
#[prost(string, tag = "1")]
pub username: ::prost::alloc::string::String,
#[prost(int64, tag = "2")]
pub view_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerMonthUsageData {
#[prost(message, repeated, tag = "1")]
pub user_usage_data: ::prost::alloc::vec::Vec<PerUserUsageData>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardSizeRequest {
#[prost(string, tag = "1")]
pub tensorboard: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadTensorboardSizeResponse {
#[prost(int64, tag = "1")]
pub storage_size_byte: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardExperimentRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub tensorboard_experiment: ::core::option::Option<TensorboardExperiment>,
#[prost(string, tag = "3")]
pub tensorboard_experiment_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardExperimentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardExperimentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardExperimentsResponse {
#[prost(message, repeated, tag = "1")]
pub tensorboard_experiments: ::prost::alloc::vec::Vec<TensorboardExperiment>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardExperimentRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub tensorboard_experiment: ::core::option::Option<TensorboardExperiment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardExperimentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardRunsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub requests: ::prost::alloc::vec::Vec<CreateTensorboardRunRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardRunsResponse {
#[prost(message, repeated, tag = "1")]
pub tensorboard_runs: ::prost::alloc::vec::Vec<TensorboardRun>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardRunRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub tensorboard_run: ::core::option::Option<TensorboardRun>,
#[prost(string, tag = "3")]
pub tensorboard_run_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardRunRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardBlobDataRequest {
#[prost(string, tag = "1")]
pub time_series: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub blob_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardBlobDataResponse {
#[prost(message, repeated, tag = "1")]
pub blobs: ::prost::alloc::vec::Vec<TensorboardBlob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardRunsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardRunsResponse {
#[prost(message, repeated, tag = "1")]
pub tensorboard_runs: ::prost::alloc::vec::Vec<TensorboardRun>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardRunRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub tensorboard_run: ::core::option::Option<TensorboardRun>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardRunRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardTimeSeriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub requests: ::prost::alloc::vec::Vec<CreateTensorboardTimeSeriesRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardTimeSeriesResponse {
#[prost(message, repeated, tag = "1")]
pub tensorboard_time_series: ::prost::alloc::vec::Vec<TensorboardTimeSeries>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardTimeSeriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub tensorboard_time_series_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub tensorboard_time_series: ::core::option::Option<TensorboardTimeSeries>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardTimeSeriesRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardTimeSeriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardTimeSeriesResponse {
#[prost(message, repeated, tag = "1")]
pub tensorboard_time_series: ::prost::alloc::vec::Vec<TensorboardTimeSeries>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardTimeSeriesRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub tensorboard_time_series: ::core::option::Option<TensorboardTimeSeries>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardTimeSeriesRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadTensorboardTimeSeriesDataRequest {
#[prost(string, tag = "1")]
pub tensorboard: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub time_series: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadTensorboardTimeSeriesDataResponse {
#[prost(message, repeated, tag = "1")]
pub time_series_data: ::prost::alloc::vec::Vec<TimeSeriesData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardTimeSeriesDataRequest {
#[prost(string, tag = "1")]
pub tensorboard_time_series: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub max_data_points: i32,
#[prost(string, tag = "3")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardTimeSeriesDataResponse {
#[prost(message, optional, tag = "1")]
pub time_series_data: ::core::option::Option<TimeSeriesData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteTensorboardExperimentDataRequest {
#[prost(string, tag = "1")]
pub tensorboard_experiment: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub write_run_data_requests: ::prost::alloc::vec::Vec<WriteTensorboardRunDataRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteTensorboardExperimentDataResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteTensorboardRunDataRequest {
#[prost(string, tag = "1")]
pub tensorboard_run: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub time_series_data: ::prost::alloc::vec::Vec<TimeSeriesData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteTensorboardRunDataResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportTensorboardTimeSeriesDataRequest {
#[prost(string, tag = "1")]
pub tensorboard_time_series: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportTensorboardTimeSeriesDataResponse {
#[prost(message, repeated, tag = "1")]
pub time_series_data_points: ::prost::alloc::vec::Vec<TimeSeriesDataPoint>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
/// Generated client implementations.
pub mod tensorboard_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// TensorboardService
#[derive(Debug, Clone)]
pub struct TensorboardServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> TensorboardServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> TensorboardServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
TensorboardServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a Tensorboard.
pub async fn create_tensorboard(&mut self, request: impl tonic::IntoRequest<super::CreateTensorboardRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/CreateTensorboard");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "CreateTensorboard"));
self.inner.unary(req, path, codec).await
}
/// Gets a Tensorboard.
pub async fn get_tensorboard(&mut self, request: impl tonic::IntoRequest<super::GetTensorboardRequest>) -> std::result::Result<tonic::Response<super::Tensorboard>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/GetTensorboard");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "GetTensorboard"));
self.inner.unary(req, path, codec).await
}
/// Updates a Tensorboard.
pub async fn update_tensorboard(&mut self, request: impl tonic::IntoRequest<super::UpdateTensorboardRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/UpdateTensorboard");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "UpdateTensorboard"));
self.inner.unary(req, path, codec).await
}
/// Lists Tensorboards in a Location.
pub async fn list_tensorboards(&mut self, request: impl tonic::IntoRequest<super::ListTensorboardsRequest>) -> std::result::Result<tonic::Response<super::ListTensorboardsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ListTensorboards");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ListTensorboards"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Tensorboard.
pub async fn delete_tensorboard(&mut self, request: impl tonic::IntoRequest<super::DeleteTensorboardRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/DeleteTensorboard");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "DeleteTensorboard"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of monthly active users for a given TensorBoard instance.
pub async fn read_tensorboard_usage(&mut self, request: impl tonic::IntoRequest<super::ReadTensorboardUsageRequest>) -> std::result::Result<tonic::Response<super::ReadTensorboardUsageResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ReadTensorboardUsage");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ReadTensorboardUsage"));
self.inner.unary(req, path, codec).await
}
/// Returns the storage size for a given TensorBoard instance.
pub async fn read_tensorboard_size(&mut self, request: impl tonic::IntoRequest<super::ReadTensorboardSizeRequest>) -> std::result::Result<tonic::Response<super::ReadTensorboardSizeResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ReadTensorboardSize");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ReadTensorboardSize"));
self.inner.unary(req, path, codec).await
}
/// Creates a TensorboardExperiment.
pub async fn create_tensorboard_experiment(&mut self, request: impl tonic::IntoRequest<super::CreateTensorboardExperimentRequest>) -> std::result::Result<tonic::Response<super::TensorboardExperiment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/CreateTensorboardExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "CreateTensorboardExperiment"));
self.inner.unary(req, path, codec).await
}
/// Gets a TensorboardExperiment.
pub async fn get_tensorboard_experiment(&mut self, request: impl tonic::IntoRequest<super::GetTensorboardExperimentRequest>) -> std::result::Result<tonic::Response<super::TensorboardExperiment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/GetTensorboardExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "GetTensorboardExperiment"));
self.inner.unary(req, path, codec).await
}
/// Updates a TensorboardExperiment.
pub async fn update_tensorboard_experiment(&mut self, request: impl tonic::IntoRequest<super::UpdateTensorboardExperimentRequest>) -> std::result::Result<tonic::Response<super::TensorboardExperiment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/UpdateTensorboardExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "UpdateTensorboardExperiment"));
self.inner.unary(req, path, codec).await
}
/// Lists TensorboardExperiments in a Location.
pub async fn list_tensorboard_experiments(&mut self, request: impl tonic::IntoRequest<super::ListTensorboardExperimentsRequest>) -> std::result::Result<tonic::Response<super::ListTensorboardExperimentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ListTensorboardExperiments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ListTensorboardExperiments"));
self.inner.unary(req, path, codec).await
}
/// Deletes a TensorboardExperiment.
pub async fn delete_tensorboard_experiment(&mut self, request: impl tonic::IntoRequest<super::DeleteTensorboardExperimentRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/DeleteTensorboardExperiment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "DeleteTensorboardExperiment"));
self.inner.unary(req, path, codec).await
}
/// Creates a TensorboardRun.
pub async fn create_tensorboard_run(&mut self, request: impl tonic::IntoRequest<super::CreateTensorboardRunRequest>) -> std::result::Result<tonic::Response<super::TensorboardRun>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/CreateTensorboardRun");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "CreateTensorboardRun"));
self.inner.unary(req, path, codec).await
}
/// Batch create TensorboardRuns.
pub async fn batch_create_tensorboard_runs(&mut self, request: impl tonic::IntoRequest<super::BatchCreateTensorboardRunsRequest>) -> std::result::Result<tonic::Response<super::BatchCreateTensorboardRunsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/BatchCreateTensorboardRuns");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "BatchCreateTensorboardRuns"));
self.inner.unary(req, path, codec).await
}
/// Gets a TensorboardRun.
pub async fn get_tensorboard_run(&mut self, request: impl tonic::IntoRequest<super::GetTensorboardRunRequest>) -> std::result::Result<tonic::Response<super::TensorboardRun>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/GetTensorboardRun");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "GetTensorboardRun"));
self.inner.unary(req, path, codec).await
}
/// Updates a TensorboardRun.
pub async fn update_tensorboard_run(&mut self, request: impl tonic::IntoRequest<super::UpdateTensorboardRunRequest>) -> std::result::Result<tonic::Response<super::TensorboardRun>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/UpdateTensorboardRun");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "UpdateTensorboardRun"));
self.inner.unary(req, path, codec).await
}
/// Lists TensorboardRuns in a Location.
pub async fn list_tensorboard_runs(&mut self, request: impl tonic::IntoRequest<super::ListTensorboardRunsRequest>) -> std::result::Result<tonic::Response<super::ListTensorboardRunsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ListTensorboardRuns");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ListTensorboardRuns"));
self.inner.unary(req, path, codec).await
}
/// Deletes a TensorboardRun.
pub async fn delete_tensorboard_run(&mut self, request: impl tonic::IntoRequest<super::DeleteTensorboardRunRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/DeleteTensorboardRun");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "DeleteTensorboardRun"));
self.inner.unary(req, path, codec).await
}
/// Batch create TensorboardTimeSeries that belong to a TensorboardExperiment.
pub async fn batch_create_tensorboard_time_series(&mut self, request: impl tonic::IntoRequest<super::BatchCreateTensorboardTimeSeriesRequest>) -> std::result::Result<tonic::Response<super::BatchCreateTensorboardTimeSeriesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/BatchCreateTensorboardTimeSeries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "BatchCreateTensorboardTimeSeries"));
self.inner.unary(req, path, codec).await
}
/// Creates a TensorboardTimeSeries.
pub async fn create_tensorboard_time_series(&mut self, request: impl tonic::IntoRequest<super::CreateTensorboardTimeSeriesRequest>) -> std::result::Result<tonic::Response<super::TensorboardTimeSeries>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/CreateTensorboardTimeSeries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "CreateTensorboardTimeSeries"));
self.inner.unary(req, path, codec).await
}
/// Gets a TensorboardTimeSeries.
pub async fn get_tensorboard_time_series(&mut self, request: impl tonic::IntoRequest<super::GetTensorboardTimeSeriesRequest>) -> std::result::Result<tonic::Response<super::TensorboardTimeSeries>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/GetTensorboardTimeSeries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "GetTensorboardTimeSeries"));
self.inner.unary(req, path, codec).await
}
/// Updates a TensorboardTimeSeries.
pub async fn update_tensorboard_time_series(&mut self, request: impl tonic::IntoRequest<super::UpdateTensorboardTimeSeriesRequest>) -> std::result::Result<tonic::Response<super::TensorboardTimeSeries>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/UpdateTensorboardTimeSeries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "UpdateTensorboardTimeSeries"));
self.inner.unary(req, path, codec).await
}
/// Lists TensorboardTimeSeries in a Location.
pub async fn list_tensorboard_time_series(&mut self, request: impl tonic::IntoRequest<super::ListTensorboardTimeSeriesRequest>) -> std::result::Result<tonic::Response<super::ListTensorboardTimeSeriesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ListTensorboardTimeSeries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ListTensorboardTimeSeries"));
self.inner.unary(req, path, codec).await
}
/// Deletes a TensorboardTimeSeries.
pub async fn delete_tensorboard_time_series(&mut self, request: impl tonic::IntoRequest<super::DeleteTensorboardTimeSeriesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/DeleteTensorboardTimeSeries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "DeleteTensorboardTimeSeries"));
self.inner.unary(req, path, codec).await
}
/// Reads multiple TensorboardTimeSeries' data. The data point number limit is
/// 1000 for scalars, 100 for tensors and blob references. If the number of
/// data points stored is less than the limit, all data is returned.
/// Otherwise, the number limit of data points is randomly selected from
/// this time series and returned.
pub async fn batch_read_tensorboard_time_series_data(&mut self, request: impl tonic::IntoRequest<super::BatchReadTensorboardTimeSeriesDataRequest>) -> std::result::Result<tonic::Response<super::BatchReadTensorboardTimeSeriesDataResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/BatchReadTensorboardTimeSeriesData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "BatchReadTensorboardTimeSeriesData"));
self.inner.unary(req, path, codec).await
}
/// Reads a TensorboardTimeSeries' data. By default, if the number of data
/// points stored is less than 1000, all data is returned. Otherwise, 1000
/// data points is randomly selected from this time series and returned.
/// This value can be changed by changing max_data_points, which can't be
/// greater than 10k.
pub async fn read_tensorboard_time_series_data(&mut self, request: impl tonic::IntoRequest<super::ReadTensorboardTimeSeriesDataRequest>) -> std::result::Result<tonic::Response<super::ReadTensorboardTimeSeriesDataResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ReadTensorboardTimeSeriesData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ReadTensorboardTimeSeriesData"));
self.inner.unary(req, path, codec).await
}
/// Gets bytes of TensorboardBlobs.
/// This is to allow reading blob data stored in consumer project's Cloud
/// Storage bucket without users having to obtain Cloud Storage access
/// permission.
pub async fn read_tensorboard_blob_data(&mut self, request: impl tonic::IntoRequest<super::ReadTensorboardBlobDataRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::ReadTensorboardBlobDataResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ReadTensorboardBlobData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ReadTensorboardBlobData"));
self.inner.server_streaming(req, path, codec).await
}
/// Write time series data points of multiple TensorboardTimeSeries in multiple
/// TensorboardRun's. If any data fail to be ingested, an error is returned.
pub async fn write_tensorboard_experiment_data(&mut self, request: impl tonic::IntoRequest<super::WriteTensorboardExperimentDataRequest>) -> std::result::Result<tonic::Response<super::WriteTensorboardExperimentDataResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/WriteTensorboardExperimentData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "WriteTensorboardExperimentData"));
self.inner.unary(req, path, codec).await
}
/// Write time series data points into multiple TensorboardTimeSeries under
/// a TensorboardRun. If any data fail to be ingested, an error is returned.
pub async fn write_tensorboard_run_data(&mut self, request: impl tonic::IntoRequest<super::WriteTensorboardRunDataRequest>) -> std::result::Result<tonic::Response<super::WriteTensorboardRunDataResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/WriteTensorboardRunData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "WriteTensorboardRunData"));
self.inner.unary(req, path, codec).await
}
/// Exports a TensorboardTimeSeries' data. Data is returned in paginated
/// responses.
pub async fn export_tensorboard_time_series_data(&mut self, request: impl tonic::IntoRequest<super::ExportTensorboardTimeSeriesDataRequest>) -> std::result::Result<tonic::Response<super::ExportTensorboardTimeSeriesDataResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.TensorboardService/ExportTensorboardTimeSeriesData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.TensorboardService", "ExportTensorboardTimeSeriesData"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeaturestoreMonitoringConfig {
#[prost(message, optional, tag = "1")]
pub snapshot_analysis: ::core::option::Option<featurestore_monitoring_config::SnapshotAnalysis>,
#[prost(message, optional, tag = "2")]
pub import_features_analysis: ::core::option::Option<featurestore_monitoring_config::ImportFeaturesAnalysis>,
#[prost(message, optional, tag = "3")]
pub numerical_threshold_config: ::core::option::Option<featurestore_monitoring_config::ThresholdConfig>,
#[prost(message, optional, tag = "4")]
pub categorical_threshold_config: ::core::option::Option<featurestore_monitoring_config::ThresholdConfig>,
}
/// Nested message and enum types in `FeaturestoreMonitoringConfig`.
pub mod featurestore_monitoring_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnapshotAnalysis {
#[prost(bool, tag = "1")]
pub disabled: bool,
#[prost(int32, tag = "3")]
pub monitoring_interval_days: i32,
#[prost(int32, tag = "4")]
pub staleness_days: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportFeaturesAnalysis {
#[prost(enumeration = "import_features_analysis::State", tag = "1")]
pub state: i32,
#[prost(enumeration = "import_features_analysis::Baseline", tag = "2")]
pub anomaly_detection_baseline: i32,
}
/// Nested message and enum types in `ImportFeaturesAnalysis`.
pub mod import_features_analysis {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Default = 1,
Enabled = 2,
Disabled = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Default => "DEFAULT",
State::Enabled => "ENABLED",
State::Disabled => "DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"DEFAULT" => Some(Self::Default),
"ENABLED" => Some(Self::Enabled),
"DISABLED" => Some(Self::Disabled),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Baseline {
Unspecified = 0,
LatestStats = 1,
MostRecentSnapshotStats = 2,
PreviousImportFeaturesStats = 3,
}
impl Baseline {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Baseline::Unspecified => "BASELINE_UNSPECIFIED",
Baseline::LatestStats => "LATEST_STATS",
Baseline::MostRecentSnapshotStats => "MOST_RECENT_SNAPSHOT_STATS",
Baseline::PreviousImportFeaturesStats => "PREVIOUS_IMPORT_FEATURES_STATS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"BASELINE_UNSPECIFIED" => Some(Self::Unspecified),
"LATEST_STATS" => Some(Self::LatestStats),
"MOST_RECENT_SNAPSHOT_STATS" => Some(Self::MostRecentSnapshotStats),
"PREVIOUS_IMPORT_FEATURES_STATS" => Some(Self::PreviousImportFeaturesStats),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThresholdConfig {
#[prost(oneof = "threshold_config::Threshold", tags = "1")]
pub threshold: ::core::option::Option<threshold_config::Threshold>,
}
/// Nested message and enum types in `ThresholdConfig`.
pub mod threshold_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Threshold {
#[prost(double, tag = "1")]
Value(f64),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityType {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub etag: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub monitoring_config: ::core::option::Option<FeaturestoreMonitoringConfig>,
#[prost(int32, tag = "10")]
pub offline_storage_ttl_days: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Feature {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
#[prost(enumeration = "feature::ValueType", tag = "3")]
pub value_type: i32,
#[prost(message, optional, tag = "4")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "12")]
pub disable_monitoring: bool,
#[prost(message, repeated, tag = "11")]
pub monitoring_stats_anomalies: ::prost::alloc::vec::Vec<feature::MonitoringStatsAnomaly>,
#[prost(string, tag = "106")]
pub version_column_name: ::prost::alloc::string::String,
#[prost(string, tag = "107")]
pub point_of_contact: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Feature`.
pub mod feature {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonitoringStatsAnomaly {
#[prost(enumeration = "monitoring_stats_anomaly::Objective", tag = "1")]
pub objective: i32,
#[prost(message, optional, tag = "2")]
pub feature_stats_anomaly: ::core::option::Option<super::FeatureStatsAnomaly>,
}
/// Nested message and enum types in `MonitoringStatsAnomaly`.
pub mod monitoring_stats_anomaly {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Objective {
Unspecified = 0,
ImportFeatureAnalysis = 1,
SnapshotAnalysis = 2,
}
impl Objective {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Objective::Unspecified => "OBJECTIVE_UNSPECIFIED",
Objective::ImportFeatureAnalysis => "IMPORT_FEATURE_ANALYSIS",
Objective::SnapshotAnalysis => "SNAPSHOT_ANALYSIS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OBJECTIVE_UNSPECIFIED" => Some(Self::Unspecified),
"IMPORT_FEATURE_ANALYSIS" => Some(Self::ImportFeatureAnalysis),
"SNAPSHOT_ANALYSIS" => Some(Self::SnapshotAnalysis),
_ => None,
}
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValueType {
Unspecified = 0,
Bool = 1,
BoolArray = 2,
Double = 3,
DoubleArray = 4,
Int64 = 9,
Int64Array = 10,
String = 11,
StringArray = 12,
Bytes = 13,
Struct = 14,
}
impl ValueType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ValueType::Unspecified => "VALUE_TYPE_UNSPECIFIED",
ValueType::Bool => "BOOL",
ValueType::BoolArray => "BOOL_ARRAY",
ValueType::Double => "DOUBLE",
ValueType::DoubleArray => "DOUBLE_ARRAY",
ValueType::Int64 => "INT64",
ValueType::Int64Array => "INT64_ARRAY",
ValueType::String => "STRING",
ValueType::StringArray => "STRING_ARRAY",
ValueType::Bytes => "BYTES",
ValueType::Struct => "STRUCT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"BOOL" => Some(Self::Bool),
"BOOL_ARRAY" => Some(Self::BoolArray),
"DOUBLE" => Some(Self::Double),
"DOUBLE_ARRAY" => Some(Self::DoubleArray),
"INT64" => Some(Self::Int64),
"INT64_ARRAY" => Some(Self::Int64Array),
"STRING" => Some(Self::String),
"STRING_ARRAY" => Some(Self::StringArray),
"BYTES" => Some(Self::Bytes),
"STRUCT" => Some(Self::Struct),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Featurestore {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub etag: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "7")]
pub online_serving_config: ::core::option::Option<featurestore::OnlineServingConfig>,
#[prost(enumeration = "featurestore::State", tag = "8")]
pub state: i32,
#[prost(int32, tag = "13")]
pub online_storage_ttl_days: i32,
#[prost(message, optional, tag = "10")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
/// Nested message and enum types in `Featurestore`.
pub mod featurestore {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OnlineServingConfig {
#[prost(int32, tag = "2")]
pub fixed_node_count: i32,
#[prost(message, optional, tag = "4")]
pub scaling: ::core::option::Option<online_serving_config::Scaling>,
}
/// Nested message and enum types in `OnlineServingConfig`.
pub mod online_serving_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Scaling {
#[prost(int32, tag = "1")]
pub min_node_count: i32,
#[prost(int32, tag = "2")]
pub max_node_count: i32,
#[prost(int32, tag = "3")]
pub cpu_utilization_target: i32,
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Stable = 1,
Updating = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Stable => "STABLE",
State::Updating => "UPDATING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"STABLE" => Some(Self::Stable),
"UPDATING" => Some(Self::Updating),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeaturestoreRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub featurestore: ::core::option::Option<Featurestore>,
#[prost(string, tag = "3")]
pub featurestore_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeaturestoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturestoresRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturestoresResponse {
#[prost(message, repeated, tag = "1")]
pub featurestores: ::prost::alloc::vec::Vec<Featurestore>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeaturestoreRequest {
#[prost(message, optional, tag = "1")]
pub featurestore: ::core::option::Option<Featurestore>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeaturestoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportFeatureValuesRequest {
#[prost(string, tag = "1")]
pub entity_type: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub entity_id_field: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "8")]
pub feature_specs: ::prost::alloc::vec::Vec<import_feature_values_request::FeatureSpec>,
#[prost(bool, tag = "9")]
pub disable_online_serving: bool,
#[prost(int32, tag = "11")]
pub worker_count: i32,
#[prost(bool, tag = "12")]
pub disable_ingestion_analysis: bool,
#[prost(oneof = "import_feature_values_request::Source", tags = "2, 3, 4")]
pub source: ::core::option::Option<import_feature_values_request::Source>,
#[prost(oneof = "import_feature_values_request::FeatureTimeSource", tags = "6, 7")]
pub feature_time_source: ::core::option::Option<import_feature_values_request::FeatureTimeSource>,
}
/// Nested message and enum types in `ImportFeatureValuesRequest`.
pub mod import_feature_values_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureSpec {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub source_field: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Source {
#[prost(message, tag = "2")]
AvroSource(super::AvroSource),
#[prost(message, tag = "3")]
BigquerySource(super::BigQuerySource),
#[prost(message, tag = "4")]
CsvSource(super::CsvSource),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum FeatureTimeSource {
#[prost(string, tag = "6")]
FeatureTimeField(::prost::alloc::string::String),
#[prost(message, tag = "7")]
FeatureTime(::prost_types::Timestamp),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportFeatureValuesResponse {
#[prost(int64, tag = "1")]
pub imported_entity_count: i64,
#[prost(int64, tag = "2")]
pub imported_feature_value_count: i64,
#[prost(int64, tag = "6")]
pub invalid_row_count: i64,
#[prost(int64, tag = "4")]
pub timestamp_outside_retention_rows_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadFeatureValuesRequest {
#[prost(string, tag = "1")]
pub featurestore: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub destination: ::core::option::Option<FeatureValueDestination>,
#[prost(message, repeated, tag = "8")]
pub pass_through_fields: ::prost::alloc::vec::Vec<batch_read_feature_values_request::PassThroughField>,
#[prost(message, repeated, tag = "7")]
pub entity_type_specs: ::prost::alloc::vec::Vec<batch_read_feature_values_request::EntityTypeSpec>,
#[prost(message, optional, tag = "11")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(oneof = "batch_read_feature_values_request::ReadOption", tags = "3, 5")]
pub read_option: ::core::option::Option<batch_read_feature_values_request::ReadOption>,
}
/// Nested message and enum types in `BatchReadFeatureValuesRequest`.
pub mod batch_read_feature_values_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PassThroughField {
#[prost(string, tag = "1")]
pub field_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityTypeSpec {
#[prost(string, tag = "1")]
pub entity_type_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feature_selector: ::core::option::Option<super::FeatureSelector>,
#[prost(message, repeated, tag = "3")]
pub settings: ::prost::alloc::vec::Vec<super::DestinationFeatureSetting>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum ReadOption {
#[prost(message, tag = "3")]
CsvReadInstances(super::CsvSource),
#[prost(message, tag = "5")]
BigqueryReadInstances(super::BigQuerySource),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFeatureValuesRequest {
#[prost(string, tag = "1")]
pub entity_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub destination: ::core::option::Option<FeatureValueDestination>,
#[prost(message, optional, tag = "5")]
pub feature_selector: ::core::option::Option<FeatureSelector>,
#[prost(message, repeated, tag = "6")]
pub settings: ::prost::alloc::vec::Vec<DestinationFeatureSetting>,
#[prost(oneof = "export_feature_values_request::Mode", tags = "3, 7")]
pub mode: ::core::option::Option<export_feature_values_request::Mode>,
}
/// Nested message and enum types in `ExportFeatureValuesRequest`.
pub mod export_feature_values_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnapshotExport {
#[prost(message, optional, tag = "1")]
pub snapshot_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FullExport {
#[prost(message, optional, tag = "2")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "1")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Mode {
#[prost(message, tag = "3")]
SnapshotExport(SnapshotExport),
#[prost(message, tag = "7")]
FullExport(FullExport),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestinationFeatureSetting {
#[prost(string, tag = "1")]
pub feature_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub destination_field: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureValueDestination {
#[prost(oneof = "feature_value_destination::Destination", tags = "1, 2, 3")]
pub destination: ::core::option::Option<feature_value_destination::Destination>,
}
/// Nested message and enum types in `FeatureValueDestination`.
pub mod feature_value_destination {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Destination {
#[prost(message, tag = "1")]
BigqueryDestination(super::BigQueryDestination),
#[prost(message, tag = "2")]
TfrecordDestination(super::TfRecordDestination),
#[prost(message, tag = "3")]
CsvDestination(super::CsvDestination),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportFeatureValuesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchReadFeatureValuesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntityTypeRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub entity_type: ::core::option::Option<EntityType>,
#[prost(string, tag = "3")]
pub entity_type_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntityTypeRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntityTypesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntityTypesResponse {
#[prost(message, repeated, tag = "1")]
pub entity_types: ::prost::alloc::vec::Vec<EntityType>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntityTypeRequest {
#[prost(message, optional, tag = "1")]
pub entity_type: ::core::option::Option<EntityType>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntityTypeRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feature: ::core::option::Option<Feature>,
#[prost(string, tag = "3")]
pub feature_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateFeaturesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub requests: ::prost::alloc::vec::Vec<CreateFeatureRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateFeaturesResponse {
#[prost(message, repeated, tag = "1")]
pub features: ::prost::alloc::vec::Vec<Feature>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(int32, tag = "7")]
pub latest_stats_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturesResponse {
#[prost(message, repeated, tag = "1")]
pub features: ::prost::alloc::vec::Vec<Feature>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchFeaturesRequest {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub query: ::prost::alloc::string::String,
#[prost(int32, tag = "4")]
pub page_size: i32,
#[prost(string, tag = "5")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchFeaturesResponse {
#[prost(message, repeated, tag = "1")]
pub features: ::prost::alloc::vec::Vec<Feature>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureRequest {
#[prost(message, optional, tag = "1")]
pub feature: ::core::option::Option<Feature>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeaturestoreOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeaturestoreOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportFeatureValuesOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(int64, tag = "2")]
pub imported_entity_count: i64,
#[prost(int64, tag = "3")]
pub imported_feature_value_count: i64,
#[prost(string, repeated, tag = "4")]
pub source_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(int64, tag = "6")]
pub invalid_row_count: i64,
#[prost(int64, tag = "7")]
pub timestamp_outside_retention_rows_count: i64,
#[prost(int64, repeated, tag = "8")]
pub blocking_operation_ids: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFeatureValuesOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadFeatureValuesOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureValuesOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntityTypeOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateFeaturesOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureValuesRequest {
#[prost(string, tag = "1")]
pub entity_type: ::prost::alloc::string::String,
#[prost(oneof = "delete_feature_values_request::DeleteOption", tags = "2, 3")]
pub delete_option: ::core::option::Option<delete_feature_values_request::DeleteOption>,
}
/// Nested message and enum types in `DeleteFeatureValuesRequest`.
pub mod delete_feature_values_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectEntity {
#[prost(message, optional, tag = "1")]
pub entity_id_selector: ::core::option::Option<super::EntityIdSelector>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectTimeRangeAndFeature {
#[prost(message, optional, tag = "1")]
pub time_range: ::core::option::Option<super::super::super::super::r#type::Interval>,
#[prost(message, optional, tag = "2")]
pub feature_selector: ::core::option::Option<super::FeatureSelector>,
#[prost(bool, tag = "3")]
pub skip_online_storage_delete: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DeleteOption {
#[prost(message, tag = "2")]
SelectEntity(SelectEntity),
#[prost(message, tag = "3")]
SelectTimeRangeAndFeature(SelectTimeRangeAndFeature),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteFeatureValuesResponse {
#[prost(oneof = "delete_feature_values_response::Response", tags = "1, 2")]
pub response: ::core::option::Option<delete_feature_values_response::Response>,
}
/// Nested message and enum types in `DeleteFeatureValuesResponse`.
pub mod delete_feature_values_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectEntity {
#[prost(int64, tag = "1")]
pub offline_storage_deleted_entity_row_count: i64,
#[prost(int64, tag = "2")]
pub online_storage_deleted_entity_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectTimeRangeAndFeature {
#[prost(int64, tag = "1")]
pub impacted_feature_count: i64,
#[prost(int64, tag = "2")]
pub offline_storage_modified_entity_row_count: i64,
#[prost(int64, tag = "3")]
pub online_storage_modified_entity_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Response {
#[prost(message, tag = "1")]
SelectEntity(SelectEntity),
#[prost(message, tag = "2")]
SelectTimeRangeAndFeature(SelectTimeRangeAndFeature),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityIdSelector {
#[prost(string, tag = "5")]
pub entity_id_field: ::prost::alloc::string::String,
#[prost(oneof = "entity_id_selector::EntityIdsSource", tags = "3")]
pub entity_ids_source: ::core::option::Option<entity_id_selector::EntityIdsSource>,
}
/// Nested message and enum types in `EntityIdSelector`.
pub mod entity_id_selector {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EntityIdsSource {
#[prost(message, tag = "3")]
CsvSource(super::CsvSource),
}
}
/// Generated client implementations.
pub mod featurestore_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The service that handles CRUD and List for resources for Featurestore.
#[derive(Debug, Clone)]
pub struct FeaturestoreServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeaturestoreServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeaturestoreServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeaturestoreServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new Featurestore in a given project and location.
pub async fn create_featurestore(&mut self, request: impl tonic::IntoRequest<super::CreateFeaturestoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/CreateFeaturestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "CreateFeaturestore"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single Featurestore.
pub async fn get_featurestore(&mut self, request: impl tonic::IntoRequest<super::GetFeaturestoreRequest>) -> std::result::Result<tonic::Response<super::Featurestore>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/GetFeaturestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "GetFeaturestore"));
self.inner.unary(req, path, codec).await
}
/// Lists Featurestores in a given project and location.
pub async fn list_featurestores(&mut self, request: impl tonic::IntoRequest<super::ListFeaturestoresRequest>) -> std::result::Result<tonic::Response<super::ListFeaturestoresResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/ListFeaturestores");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "ListFeaturestores"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single Featurestore.
pub async fn update_featurestore(&mut self, request: impl tonic::IntoRequest<super::UpdateFeaturestoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/UpdateFeaturestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "UpdateFeaturestore"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single Featurestore. The Featurestore must not contain any
/// EntityTypes or `force` must be set to true for the request to succeed.
pub async fn delete_featurestore(&mut self, request: impl tonic::IntoRequest<super::DeleteFeaturestoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/DeleteFeaturestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "DeleteFeaturestore"));
self.inner.unary(req, path, codec).await
}
/// Creates a new EntityType in a given Featurestore.
pub async fn create_entity_type(&mut self, request: impl tonic::IntoRequest<super::CreateEntityTypeRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/CreateEntityType");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "CreateEntityType"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single EntityType.
pub async fn get_entity_type(&mut self, request: impl tonic::IntoRequest<super::GetEntityTypeRequest>) -> std::result::Result<tonic::Response<super::EntityType>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/GetEntityType");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "GetEntityType"));
self.inner.unary(req, path, codec).await
}
/// Lists EntityTypes in a given Featurestore.
pub async fn list_entity_types(&mut self, request: impl tonic::IntoRequest<super::ListEntityTypesRequest>) -> std::result::Result<tonic::Response<super::ListEntityTypesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/ListEntityTypes");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "ListEntityTypes"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single EntityType.
pub async fn update_entity_type(&mut self, request: impl tonic::IntoRequest<super::UpdateEntityTypeRequest>) -> std::result::Result<tonic::Response<super::EntityType>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/UpdateEntityType");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "UpdateEntityType"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single EntityType. The EntityType must not have any Features
/// or `force` must be set to true for the request to succeed.
pub async fn delete_entity_type(&mut self, request: impl tonic::IntoRequest<super::DeleteEntityTypeRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/DeleteEntityType");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "DeleteEntityType"));
self.inner.unary(req, path, codec).await
}
/// Creates a new Feature in a given EntityType.
pub async fn create_feature(&mut self, request: impl tonic::IntoRequest<super::CreateFeatureRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/CreateFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "CreateFeature"));
self.inner.unary(req, path, codec).await
}
/// Creates a batch of Features in a given EntityType.
pub async fn batch_create_features(&mut self, request: impl tonic::IntoRequest<super::BatchCreateFeaturesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/BatchCreateFeatures");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "BatchCreateFeatures"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single Feature.
pub async fn get_feature(&mut self, request: impl tonic::IntoRequest<super::GetFeatureRequest>) -> std::result::Result<tonic::Response<super::Feature>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/GetFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "GetFeature"));
self.inner.unary(req, path, codec).await
}
/// Lists Features in a given EntityType.
pub async fn list_features(&mut self, request: impl tonic::IntoRequest<super::ListFeaturesRequest>) -> std::result::Result<tonic::Response<super::ListFeaturesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/ListFeatures");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "ListFeatures"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single Feature.
pub async fn update_feature(&mut self, request: impl tonic::IntoRequest<super::UpdateFeatureRequest>) -> std::result::Result<tonic::Response<super::Feature>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/UpdateFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "UpdateFeature"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single Feature.
pub async fn delete_feature(&mut self, request: impl tonic::IntoRequest<super::DeleteFeatureRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/DeleteFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "DeleteFeature"));
self.inner.unary(req, path, codec).await
}
/// Imports Feature values into the Featurestore from a source storage.
///
/// The progress of the import is tracked by the returned operation. The
/// imported features are guaranteed to be visible to subsequent read
/// operations after the operation is marked as successfully done.
///
/// If an import operation fails, the Feature values returned from
/// reads and exports may be inconsistent. If consistency is
/// required, the caller must retry the same import request again and wait till
/// the new operation returned is marked as successfully done.
///
/// There are also scenarios where the caller can cause inconsistency.
///
///  - Source data for import contains multiple distinct Feature values for
///    the same entity ID and timestamp.
///  - Source is modified during an import. This includes adding, updating, or
///  removing source data and/or metadata. Examples of updating metadata
///  include but are not limited to changing storage location, storage class,
///  or retention policy.
///  - Online serving cluster is under-provisioned.
pub async fn import_feature_values(&mut self, request: impl tonic::IntoRequest<super::ImportFeatureValuesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/ImportFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "ImportFeatureValues"));
self.inner.unary(req, path, codec).await
}
/// Batch reads Feature values from a Featurestore.
///
/// This API enables batch reading Feature values, where each read
/// instance in the batch may read Feature values of entities from one or
/// more EntityTypes. Point-in-time correctness is guaranteed for Feature
/// values of each read instance as of each instance's read timestamp.
pub async fn batch_read_feature_values(&mut self, request: impl tonic::IntoRequest<super::BatchReadFeatureValuesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/BatchReadFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "BatchReadFeatureValues"));
self.inner.unary(req, path, codec).await
}
/// Exports Feature values from all the entities of a target EntityType.
pub async fn export_feature_values(&mut self, request: impl tonic::IntoRequest<super::ExportFeatureValuesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/ExportFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "ExportFeatureValues"));
self.inner.unary(req, path, codec).await
}
/// Delete Feature values from Featurestore.
///
/// The progress of the deletion is tracked by the returned operation. The
/// deleted feature values are guaranteed to be invisible to subsequent read
/// operations after the operation is marked as successfully done.
///
/// If a delete feature values operation fails, the feature values
/// returned from reads and exports may be inconsistent. If consistency is
/// required, the caller must retry the same delete request again and wait till
/// the new operation returned is marked as successfully done.
pub async fn delete_feature_values(&mut self, request: impl tonic::IntoRequest<super::DeleteFeatureValuesRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/DeleteFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "DeleteFeatureValues"));
self.inner.unary(req, path, codec).await
}
/// Searches Features matching a query in a given project.
pub async fn search_features(&mut self, request: impl tonic::IntoRequest<super::SearchFeaturesRequest>) -> std::result::Result<tonic::Response<super::SearchFeaturesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeaturestoreService/SearchFeatures");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeaturestoreService", "SearchFeatures"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureGroupRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub feature_group: ::core::option::Option<FeatureGroup>,
#[prost(string, tag = "3")]
pub feature_group_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureGroupRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureGroupsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureGroupsResponse {
#[prost(message, repeated, tag = "1")]
pub feature_groups: ::prost::alloc::vec::Vec<FeatureGroup>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureGroupRequest {
#[prost(message, optional, tag = "1")]
pub feature_group: ::core::option::Option<FeatureGroup>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureGroupRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureGroupOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureGroupOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRegistryFeatureOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
/// Generated client implementations.
pub mod feature_registry_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The service that handles CRUD and List for resources for
/// FeatureRegistry.
#[derive(Debug, Clone)]
pub struct FeatureRegistryServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeatureRegistryServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeatureRegistryServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeatureRegistryServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new FeatureGroup in a given project and location.
pub async fn create_feature_group(&mut self, request: impl tonic::IntoRequest<super::CreateFeatureGroupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/CreateFeatureGroup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "CreateFeatureGroup"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single FeatureGroup.
pub async fn get_feature_group(&mut self, request: impl tonic::IntoRequest<super::GetFeatureGroupRequest>) -> std::result::Result<tonic::Response<super::FeatureGroup>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/GetFeatureGroup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "GetFeatureGroup"));
self.inner.unary(req, path, codec).await
}
/// Lists FeatureGroups in a given project and location.
pub async fn list_feature_groups(&mut self, request: impl tonic::IntoRequest<super::ListFeatureGroupsRequest>) -> std::result::Result<tonic::Response<super::ListFeatureGroupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/ListFeatureGroups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "ListFeatureGroups"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single FeatureGroup.
pub async fn update_feature_group(&mut self, request: impl tonic::IntoRequest<super::UpdateFeatureGroupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/UpdateFeatureGroup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "UpdateFeatureGroup"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single FeatureGroup.
pub async fn delete_feature_group(&mut self, request: impl tonic::IntoRequest<super::DeleteFeatureGroupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/DeleteFeatureGroup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "DeleteFeatureGroup"));
self.inner.unary(req, path, codec).await
}
/// Creates a new Feature in a given FeatureGroup.
pub async fn create_feature(&mut self, request: impl tonic::IntoRequest<super::CreateFeatureRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/CreateFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "CreateFeature"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single Feature.
pub async fn get_feature(&mut self, request: impl tonic::IntoRequest<super::GetFeatureRequest>) -> std::result::Result<tonic::Response<super::Feature>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/GetFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "GetFeature"));
self.inner.unary(req, path, codec).await
}
/// Lists Features in a given FeatureGroup.
pub async fn list_features(&mut self, request: impl tonic::IntoRequest<super::ListFeaturesRequest>) -> std::result::Result<tonic::Response<super::ListFeaturesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/ListFeatures");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "ListFeatures"));
self.inner.unary(req, path, codec).await
}
/// Updates the parameters of a single Feature.
pub async fn update_feature(&mut self, request: impl tonic::IntoRequest<super::UpdateFeatureRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/UpdateFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "UpdateFeature"));
self.inner.unary(req, path, codec).await
}
/// Deletes a single Feature.
pub async fn delete_feature(&mut self, request: impl tonic::IntoRequest<super::DeleteFeatureRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureRegistryService/DeleteFeature");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureRegistryService", "DeleteFeature"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStudyRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStudyRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub study: ::core::option::Option<Study>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStudiesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStudiesResponse {
#[prost(message, repeated, tag = "1")]
pub studies: ::prost::alloc::vec::Vec<Study>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStudyRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupStudyRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTrialsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub suggestion_count: i32,
#[prost(string, tag = "3")]
pub client_id: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub contexts: ::prost::alloc::vec::Vec<TrialContext>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTrialsResponse {
#[prost(message, repeated, tag = "1")]
pub trials: ::prost::alloc::vec::Vec<Trial>,
#[prost(enumeration = "study::State", tag = "2")]
pub study_state: i32,
#[prost(message, optional, tag = "3")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTrialsMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub client_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTrialRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub trial: ::core::option::Option<Trial>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTrialRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrialsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub page_token: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrialsResponse {
#[prost(message, repeated, tag = "1")]
pub trials: ::prost::alloc::vec::Vec<Trial>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddTrialMeasurementRequest {
#[prost(string, tag = "1")]
pub trial_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub measurement: ::core::option::Option<Measurement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteTrialRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub final_measurement: ::core::option::Option<Measurement>,
#[prost(bool, tag = "3")]
pub trial_infeasible: bool,
#[prost(string, tag = "4")]
pub infeasible_reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTrialRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckTrialEarlyStoppingStateRequest {
#[prost(string, tag = "1")]
pub trial_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckTrialEarlyStoppingStateResponse {
#[prost(bool, tag = "1")]
pub should_stop: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckTrialEarlyStoppingStateMetatdata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub study: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub trial: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopTrialRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOptimalTrialsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOptimalTrialsResponse {
#[prost(message, repeated, tag = "1")]
pub optimal_trials: ::prost::alloc::vec::Vec<Trial>,
}
/// Generated client implementations.
pub mod vizier_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Vertex AI Vizier API.
///
/// Vertex AI Vizier is a service to solve blackbox optimization problems,
/// such as tuning machine learning hyperparameters and searching over deep
/// learning architectures.
#[derive(Debug, Clone)]
pub struct VizierServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> VizierServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> VizierServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
VizierServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a Study. A resource name will be generated after creation of the
/// Study.
pub async fn create_study(&mut self, request: impl tonic::IntoRequest<super::CreateStudyRequest>) -> std::result::Result<tonic::Response<super::Study>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/CreateStudy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "CreateStudy"));
self.inner.unary(req, path, codec).await
}
/// Gets a Study by name.
pub async fn get_study(&mut self, request: impl tonic::IntoRequest<super::GetStudyRequest>) -> std::result::Result<tonic::Response<super::Study>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/GetStudy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "GetStudy"));
self.inner.unary(req, path, codec).await
}
/// Lists all the studies in a region for an associated project.
pub async fn list_studies(&mut self, request: impl tonic::IntoRequest<super::ListStudiesRequest>) -> std::result::Result<tonic::Response<super::ListStudiesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/ListStudies");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "ListStudies"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Study.
pub async fn delete_study(&mut self, request: impl tonic::IntoRequest<super::DeleteStudyRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/DeleteStudy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "DeleteStudy"));
self.inner.unary(req, path, codec).await
}
/// Looks a study up using the user-defined display_name field instead of the
/// fully qualified resource name.
pub async fn lookup_study(&mut self, request: impl tonic::IntoRequest<super::LookupStudyRequest>) -> std::result::Result<tonic::Response<super::Study>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/LookupStudy");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "LookupStudy"));
self.inner.unary(req, path, codec).await
}
/// Adds one or more Trials to a Study, with parameter values
/// suggested by Vertex AI Vizier. Returns a long-running
/// operation associated with the generation of Trial suggestions.
/// When this long-running operation succeeds, it will contain
/// a
/// [SuggestTrialsResponse][google.cloud.aiplatform.v1.SuggestTrialsResponse].
pub async fn suggest_trials(&mut self, request: impl tonic::IntoRequest<super::SuggestTrialsRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/SuggestTrials");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "SuggestTrials"));
self.inner.unary(req, path, codec).await
}
/// Adds a user provided Trial to a Study.
pub async fn create_trial(&mut self, request: impl tonic::IntoRequest<super::CreateTrialRequest>) -> std::result::Result<tonic::Response<super::Trial>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/CreateTrial");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "CreateTrial"));
self.inner.unary(req, path, codec).await
}
/// Gets a Trial.
pub async fn get_trial(&mut self, request: impl tonic::IntoRequest<super::GetTrialRequest>) -> std::result::Result<tonic::Response<super::Trial>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/GetTrial");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "GetTrial"));
self.inner.unary(req, path, codec).await
}
/// Lists the Trials associated with a Study.
pub async fn list_trials(&mut self, request: impl tonic::IntoRequest<super::ListTrialsRequest>) -> std::result::Result<tonic::Response<super::ListTrialsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/ListTrials");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "ListTrials"));
self.inner.unary(req, path, codec).await
}
/// Adds a measurement of the objective metrics to a Trial. This measurement
/// is assumed to have been taken before the Trial is complete.
pub async fn add_trial_measurement(&mut self, request: impl tonic::IntoRequest<super::AddTrialMeasurementRequest>) -> std::result::Result<tonic::Response<super::Trial>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/AddTrialMeasurement");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "AddTrialMeasurement"));
self.inner.unary(req, path, codec).await
}
/// Marks a Trial as complete.
pub async fn complete_trial(&mut self, request: impl tonic::IntoRequest<super::CompleteTrialRequest>) -> std::result::Result<tonic::Response<super::Trial>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/CompleteTrial");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "CompleteTrial"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Trial.
pub async fn delete_trial(&mut self, request: impl tonic::IntoRequest<super::DeleteTrialRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/DeleteTrial");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "DeleteTrial"));
self.inner.unary(req, path, codec).await
}
/// Checks  whether a Trial should stop or not. Returns a
/// long-running operation. When the operation is successful,
/// it will contain a
/// [CheckTrialEarlyStoppingStateResponse][google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateResponse].
pub async fn check_trial_early_stopping_state(&mut self, request: impl tonic::IntoRequest<super::CheckTrialEarlyStoppingStateRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/CheckTrialEarlyStoppingState");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "CheckTrialEarlyStoppingState"));
self.inner.unary(req, path, codec).await
}
/// Stops a Trial.
pub async fn stop_trial(&mut self, request: impl tonic::IntoRequest<super::StopTrialRequest>) -> std::result::Result<tonic::Response<super::Trial>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/StopTrial");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "StopTrial"));
self.inner.unary(req, path, codec).await
}
/// Lists the pareto-optimal Trials for multi-objective Study or the
/// optimal Trials for single-objective Study. The definition of
/// pareto-optimal can be checked in wiki page.
/// https://en.wikipedia.org/wiki/Pareto_efficiency
pub async fn list_optimal_trials(&mut self, request: impl tonic::IntoRequest<super::ListOptimalTrialsRequest>) -> std::result::Result<tonic::Response<super::ListOptimalTrialsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.VizierService/ListOptimalTrials");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.VizierService", "ListOptimalTrials"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentResource {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub resource_pools: ::prost::alloc::vec::Vec<ResourcePool>,
#[prost(enumeration = "persistent_resource::State", tag = "5")]
pub state: i32,
#[prost(message, optional, tag = "6")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(message, optional, tag = "7")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "10")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "11")]
pub network: ::prost::alloc::string::String,
#[prost(message, optional, tag = "12")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(message, optional, tag = "13")]
pub resource_runtime_spec: ::core::option::Option<ResourceRuntimeSpec>,
#[prost(message, optional, tag = "14")]
pub resource_runtime: ::core::option::Option<ResourceRuntime>,
#[prost(string, repeated, tag = "15")]
pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PersistentResource`.
pub mod persistent_resource {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Provisioning = 1,
Running = 3,
Stopping = 4,
Error = 5,
Rebooting = 6,
Updating = 7,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Provisioning => "PROVISIONING",
State::Running => "RUNNING",
State::Stopping => "STOPPING",
State::Error => "ERROR",
State::Rebooting => "REBOOTING",
State::Updating => "UPDATING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"PROVISIONING" => Some(Self::Provisioning),
"RUNNING" => Some(Self::Running),
"STOPPING" => Some(Self::Stopping),
"ERROR" => Some(Self::Error),
"REBOOTING" => Some(Self::Rebooting),
"UPDATING" => Some(Self::Updating),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePool {
#[prost(string, tag = "1")]
pub id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub machine_spec: ::core::option::Option<MachineSpec>,
#[prost(int64, optional, tag = "3")]
pub replica_count: ::core::option::Option<i64>,
#[prost(message, optional, tag = "4")]
pub disk_spec: ::core::option::Option<DiskSpec>,
#[prost(int64, tag = "6")]
pub used_replica_count: i64,
#[prost(message, optional, tag = "7")]
pub autoscaling_spec: ::core::option::Option<resource_pool::AutoscalingSpec>,
}
/// Nested message and enum types in `ResourcePool`.
pub mod resource_pool {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoscalingSpec {
#[prost(int64, optional, tag = "1")]
pub min_replica_count: ::core::option::Option<i64>,
#[prost(int64, optional, tag = "2")]
pub max_replica_count: ::core::option::Option<i64>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceRuntimeSpec {
#[prost(message, optional, tag = "2")]
pub service_account_spec: ::core::option::Option<ServiceAccountSpec>,
#[prost(message, optional, tag = "1")]
pub ray_spec: ::core::option::Option<RaySpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaySpec {
#[prost(string, tag = "1")]
pub image_uri: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "6")]
pub resource_pool_images: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "7")]
pub head_node_resource_pool_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub ray_metric_spec: ::core::option::Option<RayMetricSpec>,
#[prost(message, optional, tag = "10")]
pub ray_logs_spec: ::core::option::Option<RayLogsSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceRuntime {
#[prost(btree_map = "string, string", tag = "1")]
pub access_uris: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccountSpec {
#[prost(bool, tag = "1")]
pub enable_custom_service_account: bool,
#[prost(string, tag = "2")]
pub service_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RayMetricSpec {
#[prost(bool, tag = "1")]
pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RayLogsSpec {
#[prost(bool, tag = "1")]
pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub tuned_model_display_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
#[prost(enumeration = "JobState", tag = "6")]
pub state: i32,
#[prost(message, optional, tag = "7")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "10")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "11")]
pub error: ::core::option::Option<super::super::super::rpc::Status>,
#[prost(btree_map = "string, string", tag = "12")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "13")]
pub experiment: ::prost::alloc::string::String,
#[prost(message, optional, tag = "14")]
pub tuned_model: ::core::option::Option<TunedModel>,
#[prost(message, optional, tag = "15")]
pub tuning_data_stats: ::core::option::Option<TuningDataStats>,
#[prost(message, optional, tag = "16")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(oneof = "tuning_job::SourceModel", tags = "4")]
pub source_model: ::core::option::Option<tuning_job::SourceModel>,
#[prost(oneof = "tuning_job::TuningSpec", tags = "5")]
pub tuning_spec: ::core::option::Option<tuning_job::TuningSpec>,
}
/// Nested message and enum types in `TuningJob`.
pub mod tuning_job {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum SourceModel {
#[prost(string, tag = "4")]
BaseModel(::prost::alloc::string::String),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TuningSpec {
#[prost(message, tag = "5")]
SupervisedTuningSpec(super::SupervisedTuningSpec),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TunedModel {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub endpoint: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisedTuningDatasetDistribution {
#[prost(int64, tag = "1")]
pub sum: i64,
#[prost(int64, tag = "9")]
pub billable_sum: i64,
#[prost(double, tag = "2")]
pub min: f64,
#[prost(double, tag = "3")]
pub max: f64,
#[prost(double, tag = "4")]
pub mean: f64,
#[prost(double, tag = "5")]
pub median: f64,
#[prost(double, tag = "6")]
pub p5: f64,
#[prost(double, tag = "7")]
pub p95: f64,
#[prost(message, repeated, tag = "8")]
pub buckets: ::prost::alloc::vec::Vec<supervised_tuning_dataset_distribution::DatasetBucket>,
}
/// Nested message and enum types in `SupervisedTuningDatasetDistribution`.
pub mod supervised_tuning_dataset_distribution {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatasetBucket {
#[prost(double, tag = "1")]
pub count: f64,
#[prost(double, tag = "2")]
pub left: f64,
#[prost(double, tag = "3")]
pub right: f64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisedTuningDataStats {
#[prost(int64, tag = "1")]
pub tuning_dataset_example_count: i64,
#[prost(int64, tag = "2")]
pub total_tuning_character_count: i64,
#[deprecated]
#[prost(int64, tag = "3")]
pub total_billable_character_count: i64,
#[prost(int64, tag = "9")]
pub total_billable_token_count: i64,
#[prost(int64, tag = "4")]
pub tuning_step_count: i64,
#[prost(message, optional, tag = "5")]
pub user_input_token_distribution: ::core::option::Option<SupervisedTuningDatasetDistribution>,
#[prost(message, optional, tag = "6")]
pub user_output_token_distribution: ::core::option::Option<SupervisedTuningDatasetDistribution>,
#[prost(message, optional, tag = "7")]
pub user_message_per_example_distribution: ::core::option::Option<SupervisedTuningDatasetDistribution>,
#[prost(message, repeated, tag = "8")]
pub user_dataset_examples: ::prost::alloc::vec::Vec<Content>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningDataStats {
#[prost(oneof = "tuning_data_stats::TuningDataStats", tags = "1")]
pub tuning_data_stats: ::core::option::Option<tuning_data_stats::TuningDataStats>,
}
/// Nested message and enum types in `TuningDataStats`.
pub mod tuning_data_stats {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum TuningDataStats {
#[prost(message, tag = "1")]
SupervisedTuningDataStats(super::SupervisedTuningDataStats),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SupervisedHyperParameters {
#[prost(int64, tag = "1")]
pub epoch_count: i64,
#[prost(double, tag = "2")]
pub learning_rate_multiplier: f64,
#[prost(enumeration = "supervised_hyper_parameters::AdapterSize", tag = "3")]
pub adapter_size: i32,
}
/// Nested message and enum types in `SupervisedHyperParameters`.
pub mod supervised_hyper_parameters {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdapterSize {
Unspecified = 0,
One = 1,
Four = 2,
Eight = 3,
Sixteen = 4,
}
impl AdapterSize {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AdapterSize::Unspecified => "ADAPTER_SIZE_UNSPECIFIED",
AdapterSize::One => "ADAPTER_SIZE_ONE",
AdapterSize::Four => "ADAPTER_SIZE_FOUR",
AdapterSize::Eight => "ADAPTER_SIZE_EIGHT",
AdapterSize::Sixteen => "ADAPTER_SIZE_SIXTEEN",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ADAPTER_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
"ADAPTER_SIZE_ONE" => Some(Self::One),
"ADAPTER_SIZE_FOUR" => Some(Self::Four),
"ADAPTER_SIZE_EIGHT" => Some(Self::Eight),
"ADAPTER_SIZE_SIXTEEN" => Some(Self::Sixteen),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisedTuningSpec {
#[prost(string, tag = "1")]
pub training_dataset_uri: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub validation_dataset_uri: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub hyper_parameters: ::core::option::Option<SupervisedHyperParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTuningJobRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub tuning_job: ::core::option::Option<TuningJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTuningJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTuningJobsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTuningJobsResponse {
#[prost(message, repeated, tag = "1")]
pub tuning_jobs: ::prost::alloc::vec::Vec<TuningJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTuningJobRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod gen_ai_tuning_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for creating and managing GenAI Tuning Jobs.
#[derive(Debug, Clone)]
pub struct GenAiTuningServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> GenAiTuningServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> GenAiTuningServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
GenAiTuningServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a TuningJob. A created TuningJob right away will be attempted to
/// be run.
pub async fn create_tuning_job(&mut self, request: impl tonic::IntoRequest<super::CreateTuningJobRequest>) -> std::result::Result<tonic::Response<super::TuningJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.GenAiTuningService/CreateTuningJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.GenAiTuningService", "CreateTuningJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a TuningJob.
pub async fn get_tuning_job(&mut self, request: impl tonic::IntoRequest<super::GetTuningJobRequest>) -> std::result::Result<tonic::Response<super::TuningJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.GenAiTuningService/GetTuningJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.GenAiTuningService", "GetTuningJob"));
self.inner.unary(req, path, codec).await
}
/// Lists TuningJobs in a Location.
pub async fn list_tuning_jobs(&mut self, request: impl tonic::IntoRequest<super::ListTuningJobsRequest>) -> std::result::Result<tonic::Response<super::ListTuningJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.GenAiTuningService/ListTuningJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.GenAiTuningService", "ListTuningJobs"));
self.inner.unary(req, path, codec).await
}
/// Cancels a TuningJob.
/// Starts asynchronous cancellation on the TuningJob. The server makes a best
/// effort to cancel the job, but success is not guaranteed. Clients can use
/// [GenAiTuningService.GetTuningJob][google.cloud.aiplatform.v1.GenAiTuningService.GetTuningJob]
/// or other methods to check whether the cancellation succeeded or whether the
/// job completed despite cancellation. On successful cancellation, the
/// TuningJob is not deleted; instead it becomes a job with a
/// [TuningJob.error][google.cloud.aiplatform.v1.TuningJob.error] value with a
/// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
/// `Code.CANCELLED`, and
/// [TuningJob.state][google.cloud.aiplatform.v1.TuningJob.state] is set to
/// `CANCELLED`.
pub async fn cancel_tuning_job(&mut self, request: impl tonic::IntoRequest<super::CancelTuningJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.GenAiTuningService/CancelTuningJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.GenAiTuningService", "CancelTuningJob"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePersistentResourceRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub persistent_resource: ::core::option::Option<PersistentResource>,
#[prost(string, tag = "3")]
pub persistent_resource_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePersistentResourceOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub progress_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePersistentResourceOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub progress_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootPersistentResourceOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub progress_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPersistentResourceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPersistentResourcesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPersistentResourcesResponse {
#[prost(message, repeated, tag = "1")]
pub persistent_resources: ::prost::alloc::vec::Vec<PersistentResource>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePersistentResourceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePersistentResourceRequest {
#[prost(message, optional, tag = "1")]
pub persistent_resource: ::core::option::Option<PersistentResource>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootPersistentResourceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod persistent_resource_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for managing Vertex AI's machine learning PersistentResource.
#[derive(Debug, Clone)]
pub struct PersistentResourceServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> PersistentResourceServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> PersistentResourceServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
PersistentResourceServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a PersistentResource.
pub async fn create_persistent_resource(&mut self, request: impl tonic::IntoRequest<super::CreatePersistentResourceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PersistentResourceService/CreatePersistentResource");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PersistentResourceService", "CreatePersistentResource"));
self.inner.unary(req, path, codec).await
}
/// Gets a PersistentResource.
pub async fn get_persistent_resource(&mut self, request: impl tonic::IntoRequest<super::GetPersistentResourceRequest>) -> std::result::Result<tonic::Response<super::PersistentResource>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PersistentResourceService/GetPersistentResource");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PersistentResourceService", "GetPersistentResource"));
self.inner.unary(req, path, codec).await
}
/// Lists PersistentResources in a Location.
pub async fn list_persistent_resources(&mut self, request: impl tonic::IntoRequest<super::ListPersistentResourcesRequest>) -> std::result::Result<tonic::Response<super::ListPersistentResourcesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PersistentResourceService/ListPersistentResources");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PersistentResourceService", "ListPersistentResources"));
self.inner.unary(req, path, codec).await
}
/// Deletes a PersistentResource.
pub async fn delete_persistent_resource(&mut self, request: impl tonic::IntoRequest<super::DeletePersistentResourceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PersistentResourceService/DeletePersistentResource");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PersistentResourceService", "DeletePersistentResource"));
self.inner.unary(req, path, codec).await
}
/// Updates a PersistentResource.
pub async fn update_persistent_resource(&mut self, request: impl tonic::IntoRequest<super::UpdatePersistentResourceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PersistentResourceService/UpdatePersistentResource");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PersistentResourceService", "UpdatePersistentResource"));
self.inner.unary(req, path, codec).await
}
/// Reboots a PersistentResource.
pub async fn reboot_persistent_resource(&mut self, request: impl tonic::IntoRequest<super::RebootPersistentResourceRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.PersistentResourceService/RebootPersistentResource");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.PersistentResourceService", "RebootPersistentResource"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecialistPoolRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub specialist_pool: ::core::option::Option<SpecialistPool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecialistPoolOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecialistPoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecialistPoolsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecialistPoolsResponse {
#[prost(message, repeated, tag = "1")]
pub specialist_pools: ::prost::alloc::vec::Vec<SpecialistPool>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSpecialistPoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecialistPoolRequest {
#[prost(message, optional, tag = "1")]
pub specialist_pool: ::core::option::Option<SpecialistPool>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecialistPoolOperationMetadata {
#[prost(string, tag = "1")]
pub specialist_pool: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
/// Generated client implementations.
pub mod specialist_pool_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for creating and managing Customer SpecialistPools.
/// When customers start Data Labeling jobs, they can reuse/create Specialist
/// Pools to bring their own Specialists to label the data.
/// Customers can add/remove Managers for the Specialist Pool on Cloud console,
/// then Managers will get email notifications to manage Specialists and tasks on
/// CrowdCompute console.
#[derive(Debug, Clone)]
pub struct SpecialistPoolServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SpecialistPoolServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SpecialistPoolServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SpecialistPoolServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a SpecialistPool.
pub async fn create_specialist_pool(&mut self, request: impl tonic::IntoRequest<super::CreateSpecialistPoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.SpecialistPoolService/CreateSpecialistPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.SpecialistPoolService", "CreateSpecialistPool"));
self.inner.unary(req, path, codec).await
}
/// Gets a SpecialistPool.
pub async fn get_specialist_pool(&mut self, request: impl tonic::IntoRequest<super::GetSpecialistPoolRequest>) -> std::result::Result<tonic::Response<super::SpecialistPool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.SpecialistPoolService/GetSpecialistPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.SpecialistPoolService", "GetSpecialistPool"));
self.inner.unary(req, path, codec).await
}
/// Lists SpecialistPools in a Location.
pub async fn list_specialist_pools(&mut self, request: impl tonic::IntoRequest<super::ListSpecialistPoolsRequest>) -> std::result::Result<tonic::Response<super::ListSpecialistPoolsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.SpecialistPoolService/ListSpecialistPools");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.SpecialistPoolService", "ListSpecialistPools"));
self.inner.unary(req, path, codec).await
}
/// Deletes a SpecialistPool as well as all Specialists in the pool.
pub async fn delete_specialist_pool(&mut self, request: impl tonic::IntoRequest<super::DeleteSpecialistPoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.SpecialistPoolService/DeleteSpecialistPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.SpecialistPoolService", "DeleteSpecialistPool"));
self.inner.unary(req, path, codec).await
}
/// Updates a SpecialistPool.
pub async fn update_specialist_pool(&mut self, request: impl tonic::IntoRequest<super::UpdateSpecialistPoolRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.SpecialistPoolService/UpdateSpecialistPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.SpecialistPoolService", "UpdateSpecialistPool"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureViewDataKey {
#[prost(oneof = "feature_view_data_key::KeyOneof", tags = "1, 2")]
pub key_oneof: ::core::option::Option<feature_view_data_key::KeyOneof>,
}
/// Nested message and enum types in `FeatureViewDataKey`.
pub mod feature_view_data_key {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompositeKey {
#[prost(string, repeated, tag = "1")]
pub parts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum KeyOneof {
#[prost(string, tag = "1")]
Key(::prost::alloc::string::String),
#[prost(message, tag = "2")]
CompositeKey(CompositeKey),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFeatureValuesRequest {
#[prost(string, tag = "1")]
pub feature_view: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub data_key: ::core::option::Option<FeatureViewDataKey>,
#[prost(enumeration = "FeatureViewDataFormat", tag = "7")]
pub data_format: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFeatureValuesResponse {
#[prost(message, optional, tag = "4")]
pub data_key: ::core::option::Option<FeatureViewDataKey>,
#[prost(oneof = "fetch_feature_values_response::Format", tags = "3, 2")]
pub format: ::core::option::Option<fetch_feature_values_response::Format>,
}
/// Nested message and enum types in `FetchFeatureValuesResponse`.
pub mod fetch_feature_values_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureNameValuePairList {
#[prost(message, repeated, tag = "1")]
pub features: ::prost::alloc::vec::Vec<feature_name_value_pair_list::FeatureNameValuePair>,
}
/// Nested message and enum types in `FeatureNameValuePairList`.
pub mod feature_name_value_pair_list {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureNameValuePair {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(oneof = "feature_name_value_pair::Data", tags = "2")]
pub data: ::core::option::Option<feature_name_value_pair::Data>,
}
/// Nested message and enum types in `FeatureNameValuePair`.
pub mod feature_name_value_pair {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Data {
#[prost(message, tag = "2")]
Value(super::super::super::FeatureValue),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Format {
#[prost(message, tag = "3")]
KeyValues(FeatureNameValuePairList),
#[prost(message, tag = "2")]
ProtoStruct(::prost_types::Struct),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NearestNeighborQuery {
#[prost(int32, tag = "3")]
pub neighbor_count: i32,
#[prost(message, repeated, tag = "4")]
pub string_filters: ::prost::alloc::vec::Vec<nearest_neighbor_query::StringFilter>,
#[prost(message, repeated, tag = "8")]
pub numeric_filters: ::prost::alloc::vec::Vec<nearest_neighbor_query::NumericFilter>,
#[prost(int32, tag = "5")]
pub per_crowding_attribute_neighbor_count: i32,
#[prost(message, optional, tag = "7")]
pub parameters: ::core::option::Option<nearest_neighbor_query::Parameters>,
#[prost(oneof = "nearest_neighbor_query::Instance", tags = "1, 2")]
pub instance: ::core::option::Option<nearest_neighbor_query::Instance>,
}
/// Nested message and enum types in `NearestNeighborQuery`.
pub mod nearest_neighbor_query {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Embedding {
#[prost(float, repeated, packed = "false", tag = "1")]
pub value: ::prost::alloc::vec::Vec<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringFilter {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub allow_tokens: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "3")]
pub deny_tokens: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NumericFilter {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "numeric_filter::Operator", optional, tag = "5")]
pub op: ::core::option::Option<i32>,
#[prost(oneof = "numeric_filter::Value", tags = "2, 3, 4")]
pub value: ::core::option::Option<numeric_filter::Value>,
}
/// Nested message and enum types in `NumericFilter`.
pub mod numeric_filter {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Operator {
Unspecified = 0,
Less = 1,
LessEqual = 2,
Equal = 3,
GreaterEqual = 4,
Greater = 5,
NotEqual = 6,
}
impl Operator {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Operator::Unspecified => "OPERATOR_UNSPECIFIED",
Operator::Less => "LESS",
Operator::LessEqual => "LESS_EQUAL",
Operator::Equal => "EQUAL",
Operator::GreaterEqual => "GREATER_EQUAL",
Operator::Greater => "GREATER",
Operator::NotEqual => "NOT_EQUAL",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
"LESS" => Some(Self::Less),
"LESS_EQUAL" => Some(Self::LessEqual),
"EQUAL" => Some(Self::Equal),
"GREATER_EQUAL" => Some(Self::GreaterEqual),
"GREATER" => Some(Self::Greater),
"NOT_EQUAL" => Some(Self::NotEqual),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Value {
#[prost(int64, tag = "2")]
ValueInt(i64),
#[prost(float, tag = "3")]
ValueFloat(f32),
#[prost(double, tag = "4")]
ValueDouble(f64),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Parameters {
#[prost(int32, tag = "1")]
pub approximate_neighbor_candidates: i32,
#[prost(double, tag = "2")]
pub leaf_nodes_search_fraction: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Instance {
#[prost(string, tag = "1")]
EntityId(::prost::alloc::string::String),
#[prost(message, tag = "2")]
Embedding(Embedding),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchNearestEntitiesRequest {
#[prost(string, tag = "1")]
pub feature_view: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub query: ::core::option::Option<NearestNeighborQuery>,
#[prost(bool, tag = "3")]
pub return_full_entity: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NearestNeighbors {
#[prost(message, repeated, tag = "1")]
pub neighbors: ::prost::alloc::vec::Vec<nearest_neighbors::Neighbor>,
}
/// Nested message and enum types in `NearestNeighbors`.
pub mod nearest_neighbors {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Neighbor {
#[prost(string, tag = "1")]
pub entity_id: ::prost::alloc::string::String,
#[prost(double, tag = "2")]
pub distance: f64,
#[prost(message, optional, tag = "3")]
pub entity_key_values: ::core::option::Option<super::FetchFeatureValuesResponse>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchNearestEntitiesResponse {
#[prost(message, optional, tag = "1")]
pub nearest_neighbors: ::core::option::Option<NearestNeighbors>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FeatureViewDataFormat {
Unspecified = 0,
KeyValue = 1,
ProtoStruct = 2,
}
impl FeatureViewDataFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FeatureViewDataFormat::Unspecified => "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED",
FeatureViewDataFormat::KeyValue => "KEY_VALUE",
FeatureViewDataFormat::ProtoStruct => "PROTO_STRUCT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"KEY_VALUE" => Some(Self::KeyValue),
"PROTO_STRUCT" => Some(Self::ProtoStruct),
_ => None,
}
}
}
/// Generated client implementations.
pub mod feature_online_store_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for fetching feature values from the online store.
#[derive(Debug, Clone)]
pub struct FeatureOnlineStoreServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> FeatureOnlineStoreServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> FeatureOnlineStoreServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
FeatureOnlineStoreServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Fetch feature values under a FeatureView.
pub async fn fetch_feature_values(&mut self, request: impl tonic::IntoRequest<super::FetchFeatureValuesRequest>) -> std::result::Result<tonic::Response<super::FetchFeatureValuesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreService/FetchFeatureValues");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreService", "FetchFeatureValues"));
self.inner.unary(req, path, codec).await
}
/// Search the nearest entities under a FeatureView.
/// Search only works for indexable feature view; if a feature view isn't
/// indexable, returns Invalid argument response.
pub async fn search_nearest_entities(&mut self, request: impl tonic::IntoRequest<super::SearchNearestEntitiesRequest>) -> std::result::Result<tonic::Response<super::SearchNearestEntitiesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.FeatureOnlineStoreService/SearchNearestEntities");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.FeatureOnlineStoreService", "SearchNearestEntities"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModelRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub parent_model: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub model_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub model: ::core::option::Option<Model>,
#[prost(string, tag = "6")]
pub service_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModelOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModelResponse {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub model_version_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsResponse {
#[prost(message, repeated, tag = "1")]
pub models: ::prost::alloc::vec::Vec<Model>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelVersionsRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelVersionsResponse {
#[prost(message, repeated, tag = "1")]
pub models: ::prost::alloc::vec::Vec<Model>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelRequest {
#[prost(message, optional, tag = "1")]
pub model: ::core::option::Option<Model>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExplanationDatasetRequest {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub examples: ::core::option::Option<Examples>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExplanationDatasetOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelVersionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeVersionAliasesRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub version_aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportModelRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub output_config: ::core::option::Option<export_model_request::OutputConfig>,
}
/// Nested message and enum types in `ExportModelRequest`.
pub mod export_model_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputConfig {
#[prost(string, tag = "1")]
pub export_format_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub artifact_destination: ::core::option::Option<super::GcsDestination>,
#[prost(message, optional, tag = "4")]
pub image_destination: ::core::option::Option<super::ContainerRegistryDestination>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportModelOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(message, optional, tag = "2")]
pub output_info: ::core::option::Option<export_model_operation_metadata::OutputInfo>,
}
/// Nested message and enum types in `ExportModelOperationMetadata`.
pub mod export_model_operation_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputInfo {
#[prost(string, tag = "2")]
pub artifact_output_uri: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub image_output_uri: ::prost::alloc::string::String,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateExplanationDatasetResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportModelResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyModelRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub source_model: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub encryption_spec: ::core::option::Option<EncryptionSpec>,
#[prost(oneof = "copy_model_request::DestinationModel", tags = "4, 5")]
pub destination_model: ::core::option::Option<copy_model_request::DestinationModel>,
}
/// Nested message and enum types in `CopyModelRequest`.
pub mod copy_model_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DestinationModel {
#[prost(string, tag = "4")]
ModelId(::prost::alloc::string::String),
#[prost(string, tag = "5")]
ParentModel(::prost::alloc::string::String),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyModelOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyModelResponse {
#[prost(string, tag = "1")]
pub model: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub model_version_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportModelEvaluationRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub model_evaluation: ::core::option::Option<ModelEvaluation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchImportModelEvaluationSlicesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub model_evaluation_slices: ::prost::alloc::vec::Vec<ModelEvaluationSlice>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchImportModelEvaluationSlicesResponse {
#[prost(string, repeated, tag = "1")]
pub imported_model_evaluation_slices: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchImportEvaluatedAnnotationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub evaluated_annotations: ::prost::alloc::vec::Vec<EvaluatedAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchImportEvaluatedAnnotationsResponse {
#[prost(int32, tag = "1")]
pub imported_evaluated_annotations_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelEvaluationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationsResponse {
#[prost(message, repeated, tag = "1")]
pub model_evaluations: ::prost::alloc::vec::Vec<ModelEvaluation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelEvaluationSliceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationSlicesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationSlicesResponse {
#[prost(message, repeated, tag = "1")]
pub model_evaluation_slices: ::prost::alloc::vec::Vec<ModelEvaluationSlice>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod model_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for managing Vertex AI's machine learning Models.
#[derive(Debug, Clone)]
pub struct ModelServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> ModelServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> ModelServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
ModelServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Uploads a Model artifact into Vertex AI.
pub async fn upload_model(&mut self, request: impl tonic::IntoRequest<super::UploadModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/UploadModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "UploadModel"));
self.inner.unary(req, path, codec).await
}
/// Gets a Model.
pub async fn get_model(&mut self, request: impl tonic::IntoRequest<super::GetModelRequest>) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/GetModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "GetModel"));
self.inner.unary(req, path, codec).await
}
/// Lists Models in a Location.
pub async fn list_models(&mut self, request: impl tonic::IntoRequest<super::ListModelsRequest>) -> std::result::Result<tonic::Response<super::ListModelsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/ListModels");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "ListModels"));
self.inner.unary(req, path, codec).await
}
/// Lists versions of the specified model.
pub async fn list_model_versions(&mut self, request: impl tonic::IntoRequest<super::ListModelVersionsRequest>) -> std::result::Result<tonic::Response<super::ListModelVersionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/ListModelVersions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "ListModelVersions"));
self.inner.unary(req, path, codec).await
}
/// Updates a Model.
pub async fn update_model(&mut self, request: impl tonic::IntoRequest<super::UpdateModelRequest>) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/UpdateModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "UpdateModel"));
self.inner.unary(req, path, codec).await
}
/// Incrementally update the dataset used for an examples model.
pub async fn update_explanation_dataset(&mut self, request: impl tonic::IntoRequest<super::UpdateExplanationDatasetRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/UpdateExplanationDataset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "UpdateExplanationDataset"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Model.
///
/// A model cannot be deleted if any
/// [Endpoint][google.cloud.aiplatform.v1.Endpoint] resource has a
/// [DeployedModel][google.cloud.aiplatform.v1.DeployedModel] based on the
/// model in its
/// [deployed_models][google.cloud.aiplatform.v1.Endpoint.deployed_models]
/// field.
pub async fn delete_model(&mut self, request: impl tonic::IntoRequest<super::DeleteModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/DeleteModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "DeleteModel"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Model version.
///
/// Model version can only be deleted if there are no
/// [DeployedModels][google.cloud.aiplatform.v1.DeployedModel] created from it.
/// Deleting the only version in the Model is not allowed. Use
/// [DeleteModel][google.cloud.aiplatform.v1.ModelService.DeleteModel] for
/// deleting the Model instead.
pub async fn delete_model_version(&mut self, request: impl tonic::IntoRequest<super::DeleteModelVersionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/DeleteModelVersion");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "DeleteModelVersion"));
self.inner.unary(req, path, codec).await
}
/// Merges a set of aliases for a Model version.
pub async fn merge_version_aliases(&mut self, request: impl tonic::IntoRequest<super::MergeVersionAliasesRequest>) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/MergeVersionAliases");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "MergeVersionAliases"));
self.inner.unary(req, path, codec).await
}
/// Exports a trained, exportable Model to a location specified by the
/// user. A Model is considered to be exportable if it has at least one
/// [supported export
/// format][google.cloud.aiplatform.v1.Model.supported_export_formats].
pub async fn export_model(&mut self, request: impl tonic::IntoRequest<super::ExportModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/ExportModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "ExportModel"));
self.inner.unary(req, path, codec).await
}
/// Copies an already existing Vertex AI Model into the specified Location.
/// The source Model must exist in the same Project.
/// When copying custom Models, the users themselves are responsible for
/// [Model.metadata][google.cloud.aiplatform.v1.Model.metadata] content to be
/// region-agnostic, as well as making sure that any resources (e.g. files) it
/// depends on remain accessible.
pub async fn copy_model(&mut self, request: impl tonic::IntoRequest<super::CopyModelRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/CopyModel");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "CopyModel"));
self.inner.unary(req, path, codec).await
}
/// Imports an externally generated ModelEvaluation.
pub async fn import_model_evaluation(&mut self, request: impl tonic::IntoRequest<super::ImportModelEvaluationRequest>) -> std::result::Result<tonic::Response<super::ModelEvaluation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/ImportModelEvaluation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "ImportModelEvaluation"));
self.inner.unary(req, path, codec).await
}
/// Imports a list of externally generated ModelEvaluationSlice.
pub async fn batch_import_model_evaluation_slices(&mut self, request: impl tonic::IntoRequest<super::BatchImportModelEvaluationSlicesRequest>) -> std::result::Result<tonic::Response<super::BatchImportModelEvaluationSlicesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/BatchImportModelEvaluationSlices");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "BatchImportModelEvaluationSlices"));
self.inner.unary(req, path, codec).await
}
/// Imports a list of externally generated EvaluatedAnnotations.
pub async fn batch_import_evaluated_annotations(&mut self, request: impl tonic::IntoRequest<super::BatchImportEvaluatedAnnotationsRequest>) -> std::result::Result<tonic::Response<super::BatchImportEvaluatedAnnotationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/BatchImportEvaluatedAnnotations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "BatchImportEvaluatedAnnotations"));
self.inner.unary(req, path, codec).await
}
/// Gets a ModelEvaluation.
pub async fn get_model_evaluation(&mut self, request: impl tonic::IntoRequest<super::GetModelEvaluationRequest>) -> std::result::Result<tonic::Response<super::ModelEvaluation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/GetModelEvaluation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "GetModelEvaluation"));
self.inner.unary(req, path, codec).await
}
/// Lists ModelEvaluations in a Model.
pub async fn list_model_evaluations(&mut self, request: impl tonic::IntoRequest<super::ListModelEvaluationsRequest>) -> std::result::Result<tonic::Response<super::ListModelEvaluationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/ListModelEvaluations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "ListModelEvaluations"));
self.inner.unary(req, path, codec).await
}
/// Gets a ModelEvaluationSlice.
pub async fn get_model_evaluation_slice(&mut self, request: impl tonic::IntoRequest<super::GetModelEvaluationSliceRequest>) -> std::result::Result<tonic::Response<super::ModelEvaluationSlice>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/GetModelEvaluationSlice");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "GetModelEvaluationSlice"));
self.inner.unary(req, path, codec).await
}
/// Lists ModelEvaluationSlices in a ModelEvaluation.
pub async fn list_model_evaluation_slices(&mut self, request: impl tonic::IntoRequest<super::ListModelEvaluationSlicesRequest>) -> std::result::Result<tonic::Response<super::ListModelEvaluationSlicesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.ModelService/ListModelEvaluationSlices");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.ModelService", "ListModelEvaluationSlices"));
self.inner.unary(req, path, codec).await
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataItem {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(btree_map = "string, string", tag = "3")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "4")]
pub payload: ::core::option::Option<::prost_types::Value>,
#[prost(string, tag = "7")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub dataset: ::core::option::Option<Dataset>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatasetRequest {
#[prost(message, optional, tag = "1")]
pub dataset: ::core::option::Option<Dataset>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatasetVersionRequest {
#[prost(message, optional, tag = "1")]
pub dataset_version: ::core::option::Option<DatasetVersion>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsResponse {
#[prost(message, repeated, tag = "1")]
pub datasets: ::prost::alloc::vec::Vec<Dataset>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "2")]
pub import_configs: ::prost::alloc::vec::Vec<ImportDataConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportDataResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub export_config: ::core::option::Option<ExportDataConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataResponse {
#[prost(string, repeated, tag = "1")]
pub exported_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "2")]
pub data_stats: ::core::option::Option<model::DataStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
#[prost(string, tag = "2")]
pub gcs_output_directory: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetVersionRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub dataset_version: ::core::option::Option<DatasetVersion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetVersionOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetVersionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetVersionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetVersionsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetVersionsResponse {
#[prost(message, repeated, tag = "1")]
pub dataset_versions: ::prost::alloc::vec::Vec<DatasetVersion>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreDatasetVersionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreDatasetVersionOperationMetadata {
#[prost(message, optional, tag = "1")]
pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataItemsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataItemsResponse {
#[prost(message, repeated, tag = "1")]
pub data_items: ::prost::alloc::vec::Vec<DataItem>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDataItemsRequest {
#[prost(string, tag = "1")]
pub dataset: ::prost::alloc::string::String,
#[deprecated]
#[prost(string, tag = "2")]
pub saved_query: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub data_labeling_job: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub data_item_filter: ::prost::alloc::string::String,
#[deprecated]
#[prost(string, tag = "5")]
pub annotations_filter: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "11")]
pub annotation_filters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "6")]
pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(int32, tag = "7")]
pub annotations_limit: i32,
#[prost(int32, tag = "8")]
pub page_size: i32,
#[deprecated]
#[prost(string, tag = "9")]
pub order_by: ::prost::alloc::string::String,
#[prost(string, tag = "10")]
pub page_token: ::prost::alloc::string::String,
#[prost(oneof = "search_data_items_request::Order", tags = "12, 13")]
pub order: ::core::option::Option<search_data_items_request::Order>,
}
/// Nested message and enum types in `SearchDataItemsRequest`.
pub mod search_data_items_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderByAnnotation {
#[prost(string, tag = "1")]
pub saved_query: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Order {
#[prost(string, tag = "12")]
OrderByDataItem(::prost::alloc::string::String),
#[prost(message, tag = "13")]
OrderByAnnotation(OrderByAnnotation),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDataItemsResponse {
#[prost(message, repeated, tag = "1")]
pub data_item_views: ::prost::alloc::vec::Vec<DataItemView>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataItemView {
#[prost(message, optional, tag = "1")]
pub data_item: ::core::option::Option<DataItem>,
#[prost(message, repeated, tag = "2")]
pub annotations: ::prost::alloc::vec::Vec<Annotation>,
#[prost(bool, tag = "3")]
pub has_truncated_annotations: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSavedQueriesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSavedQueriesResponse {
#[prost(message, repeated, tag = "1")]
pub saved_queries: ::prost::alloc::vec::Vec<SavedQuery>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSavedQueryRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnnotationSpecRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
#[prost(message, optional, tag = "5")]
pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(string, tag = "6")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsResponse {
#[prost(message, repeated, tag = "1")]
pub annotations: ::prost::alloc::vec::Vec<Annotation>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod dataset_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// The service that manages Vertex AI Dataset and its child resources.
#[derive(Debug, Clone)]
pub struct DatasetServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> DatasetServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> DatasetServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
DatasetServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a Dataset.
pub async fn create_dataset(&mut self, request: impl tonic::IntoRequest<super::CreateDatasetRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/CreateDataset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "CreateDataset"));
self.inner.unary(req, path, codec).await
}
/// Gets a Dataset.
pub async fn get_dataset(&mut self, request: impl tonic::IntoRequest<super::GetDatasetRequest>) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/GetDataset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "GetDataset"));
self.inner.unary(req, path, codec).await
}
/// Updates a Dataset.
pub async fn update_dataset(&mut self, request: impl tonic::IntoRequest<super::UpdateDatasetRequest>) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/UpdateDataset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "UpdateDataset"));
self.inner.unary(req, path, codec).await
}
/// Lists Datasets in a Location.
pub async fn list_datasets(&mut self, request: impl tonic::IntoRequest<super::ListDatasetsRequest>) -> std::result::Result<tonic::Response<super::ListDatasetsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/ListDatasets");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "ListDatasets"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Dataset.
pub async fn delete_dataset(&mut self, request: impl tonic::IntoRequest<super::DeleteDatasetRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/DeleteDataset");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "DeleteDataset"));
self.inner.unary(req, path, codec).await
}
/// Imports data into a Dataset.
pub async fn import_data(&mut self, request: impl tonic::IntoRequest<super::ImportDataRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/ImportData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "ImportData"));
self.inner.unary(req, path, codec).await
}
/// Exports data from a Dataset.
pub async fn export_data(&mut self, request: impl tonic::IntoRequest<super::ExportDataRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/ExportData");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "ExportData"));
self.inner.unary(req, path, codec).await
}
/// Create a version from a Dataset.
pub async fn create_dataset_version(&mut self, request: impl tonic::IntoRequest<super::CreateDatasetVersionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/CreateDatasetVersion");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "CreateDatasetVersion"));
self.inner.unary(req, path, codec).await
}
/// Updates a DatasetVersion.
pub async fn update_dataset_version(&mut self, request: impl tonic::IntoRequest<super::UpdateDatasetVersionRequest>) -> std::result::Result<tonic::Response<super::DatasetVersion>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/UpdateDatasetVersion");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "UpdateDatasetVersion"));
self.inner.unary(req, path, codec).await
}
/// Deletes a Dataset version.
pub async fn delete_dataset_version(&mut self, request: impl tonic::IntoRequest<super::DeleteDatasetVersionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/DeleteDatasetVersion");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "DeleteDatasetVersion"));
self.inner.unary(req, path, codec).await
}
/// Gets a Dataset version.
pub async fn get_dataset_version(&mut self, request: impl tonic::IntoRequest<super::GetDatasetVersionRequest>) -> std::result::Result<tonic::Response<super::DatasetVersion>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/GetDatasetVersion");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "GetDatasetVersion"));
self.inner.unary(req, path, codec).await
}
/// Lists DatasetVersions in a Dataset.
pub async fn list_dataset_versions(&mut self, request: impl tonic::IntoRequest<super::ListDatasetVersionsRequest>) -> std::result::Result<tonic::Response<super::ListDatasetVersionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/ListDatasetVersions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "ListDatasetVersions"));
self.inner.unary(req, path, codec).await
}
/// Restores a dataset version.
pub async fn restore_dataset_version(&mut self, request: impl tonic::IntoRequest<super::RestoreDatasetVersionRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/RestoreDatasetVersion");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "RestoreDatasetVersion"));
self.inner.unary(req, path, codec).await
}
/// Lists DataItems in a Dataset.
pub async fn list_data_items(&mut self, request: impl tonic::IntoRequest<super::ListDataItemsRequest>) -> std::result::Result<tonic::Response<super::ListDataItemsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/ListDataItems");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "ListDataItems"));
self.inner.unary(req, path, codec).await
}
/// Searches DataItems in a Dataset.
pub async fn search_data_items(&mut self, request: impl tonic::IntoRequest<super::SearchDataItemsRequest>) -> std::result::Result<tonic::Response<super::SearchDataItemsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/SearchDataItems");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "SearchDataItems"));
self.inner.unary(req, path, codec).await
}
/// Lists SavedQueries in a Dataset.
pub async fn list_saved_queries(&mut self, request: impl tonic::IntoRequest<super::ListSavedQueriesRequest>) -> std::result::Result<tonic::Response<super::ListSavedQueriesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/ListSavedQueries");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "ListSavedQueries"));
self.inner.unary(req, path, codec).await
}
/// Deletes a SavedQuery.
pub async fn delete_saved_query(&mut self, request: impl tonic::IntoRequest<super::DeleteSavedQueryRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/DeleteSavedQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "DeleteSavedQuery"));
self.inner.unary(req, path, codec).await
}
/// Gets an AnnotationSpec.
pub async fn get_annotation_spec(&mut self, request: impl tonic::IntoRequest<super::GetAnnotationSpecRequest>) -> std::result::Result<tonic::Response<super::AnnotationSpec>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/GetAnnotationSpec");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "GetAnnotationSpec"));
self.inner.unary(req, path, codec).await
}
/// Lists Annotations belongs to a dataitem
pub async fn list_annotations(&mut self, request: impl tonic::IntoRequest<super::ListAnnotationsRequest>) -> std::result::Result<tonic::Response<super::ListAnnotationsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.aiplatform.v1.DatasetService/ListAnnotations");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.aiplatform.v1.DatasetService", "ListAnnotations"));
self.inner.unary(req, path, codec).await
}
}
}
