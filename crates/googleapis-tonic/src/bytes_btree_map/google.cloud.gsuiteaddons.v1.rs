// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAuthorizationRequest {
#[prost(string, tag = "2")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Authorization {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub service_account_email: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub oauth_client_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub deployment_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub deployment: ::core::option::Option<Deployment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplaceDeploymentRequest {
#[prost(message, optional, tag = "2")]
pub deployment: ::core::option::Option<Deployment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
#[prost(message, repeated, tag = "1")]
pub deployments: ::prost::alloc::vec::Vec<Deployment>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeploymentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallDeploymentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UninstallDeploymentRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstallStatusRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallStatus {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub installed: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deployment {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub oauth_scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub add_ons: ::core::option::Option<AddOns>,
#[prost(string, tag = "5")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddOns {
#[prost(message, optional, tag = "1")]
pub common: ::core::option::Option<super::super::super::apps::script::r#type::CommonAddOnManifest>,
#[prost(message, optional, tag = "2")]
pub gmail: ::core::option::Option<super::super::super::apps::script::r#type::gmail::GmailAddOnManifest>,
#[prost(message, optional, tag = "5")]
pub drive: ::core::option::Option<super::super::super::apps::script::r#type::drive::DriveAddOnManifest>,
#[prost(message, optional, tag = "6")]
pub calendar: ::core::option::Option<super::super::super::apps::script::r#type::calendar::CalendarAddOnManifest>,
#[prost(message, optional, tag = "7")]
pub docs: ::core::option::Option<super::super::super::apps::script::r#type::docs::DocsAddOnManifest>,
#[prost(message, optional, tag = "8")]
pub sheets: ::core::option::Option<super::super::super::apps::script::r#type::sheets::SheetsAddOnManifest>,
#[prost(message, optional, tag = "10")]
pub slides: ::core::option::Option<super::super::super::apps::script::r#type::slides::SlidesAddOnManifest>,
#[prost(message, optional, tag = "15")]
pub http_options: ::core::option::Option<super::super::super::apps::script::r#type::HttpOptions>,
}
/// Generated client implementations.
pub mod g_suite_add_ons_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// A service for managing Google Workspace Add-ons deployments.
///
/// A Google Workspace Add-on is a third-party embedded component that can be
/// installed in Google Workspace Applications like Gmail, Calendar, Drive, and
/// the Google Docs, Sheets, and Slides editors. Google Workspace Add-ons can
/// display UI cards, receive contextual information from the host application,
/// and perform actions in the host application (See:
/// https://developers.google.com/gsuite/add-ons/overview for more information).
///
/// A Google Workspace Add-on deployment resource specifies metadata about the
/// add-on, including a specification of the entry points in the host application
/// that trigger add-on executions (see:
/// https://developers.google.com/gsuite/add-ons/concepts/gsuite-manifests).
/// Add-on deployments defined via the Google Workspace Add-ons API define their
/// entrypoints using HTTPS URLs (See:
/// https://developers.google.com/gsuite/add-ons/guides/alternate-runtimes),
///
/// A Google Workspace Add-on deployment can be installed in developer mode,
/// which allows an add-on developer to test the experience an end-user would see
/// when installing and running the add-on in their G Suite applications.  When
/// running in developer mode, more detailed error messages are exposed in the
/// add-on UI to aid in debugging.
///
/// A Google Workspace Add-on deployment can be published to Google Workspace
/// Marketplace, which allows other Google Workspace users to discover and
/// install the add-on.  See:
/// https://developers.google.com/gsuite/add-ons/how-tos/publish-add-on-overview
/// for details.
#[derive(Debug, Clone)]
pub struct GSuiteAddOnsClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> GSuiteAddOnsClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> GSuiteAddOnsClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
GSuiteAddOnsClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Gets the authorization information for deployments in a given project.
pub async fn get_authorization(&mut self, request: impl tonic::IntoRequest<super::GetAuthorizationRequest>) -> std::result::Result<tonic::Response<super::Authorization>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/GetAuthorization");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "GetAuthorization"));
self.inner.unary(req, path, codec).await
}
/// Creates a deployment with the specified name and configuration.
pub async fn create_deployment(&mut self, request: impl tonic::IntoRequest<super::CreateDeploymentRequest>) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/CreateDeployment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "CreateDeployment"));
self.inner.unary(req, path, codec).await
}
/// Creates or replaces a deployment with the specified name.
pub async fn replace_deployment(&mut self, request: impl tonic::IntoRequest<super::ReplaceDeploymentRequest>) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/ReplaceDeployment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "ReplaceDeployment"));
self.inner.unary(req, path, codec).await
}
/// Gets the deployment with the specified name.
pub async fn get_deployment(&mut self, request: impl tonic::IntoRequest<super::GetDeploymentRequest>) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/GetDeployment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "GetDeployment"));
self.inner.unary(req, path, codec).await
}
/// Lists all deployments in a particular project.
pub async fn list_deployments(&mut self, request: impl tonic::IntoRequest<super::ListDeploymentsRequest>) -> std::result::Result<tonic::Response<super::ListDeploymentsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/ListDeployments");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "ListDeployments"));
self.inner.unary(req, path, codec).await
}
/// Deletes the deployment with the given name.
pub async fn delete_deployment(&mut self, request: impl tonic::IntoRequest<super::DeleteDeploymentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/DeleteDeployment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "DeleteDeployment"));
self.inner.unary(req, path, codec).await
}
/// Installs a deployment in developer mode.
/// See:
/// https://developers.google.com/gsuite/add-ons/how-tos/testing-gsuite-addons.
pub async fn install_deployment(&mut self, request: impl tonic::IntoRequest<super::InstallDeploymentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/InstallDeployment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "InstallDeployment"));
self.inner.unary(req, path, codec).await
}
/// Uninstalls a developer mode deployment.
/// See:
/// https://developers.google.com/gsuite/add-ons/how-tos/testing-gsuite-addons.
pub async fn uninstall_deployment(&mut self, request: impl tonic::IntoRequest<super::UninstallDeploymentRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/UninstallDeployment");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "UninstallDeployment"));
self.inner.unary(req, path, codec).await
}
/// Fetches the install status of a developer mode deployment.
pub async fn get_install_status(&mut self, request: impl tonic::IntoRequest<super::GetInstallStatusRequest>) -> std::result::Result<tonic::Response<super::InstallStatus>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gsuiteaddons.v1.GSuiteAddOns/GetInstallStatus");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gsuiteaddons.v1.GSuiteAddOns", "GetInstallStatus"));
self.inner.unary(req, path, codec).await
}
}
}
