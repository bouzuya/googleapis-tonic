// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vertex {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedVertex {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoundingPoly {
    #[prost(message, repeated, tag = "1")]
    pub vertices: ::prost::alloc::vec::Vec<Vertex>,
    #[prost(message, repeated, tag = "2")]
    pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
    #[prost(float, tag = "3")]
    pub z: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Product {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub product_category: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub product_labels: ::prost::alloc::vec::Vec<product::KeyValue>,
}
/// Nested message and enum types in `Product`.
pub mod product {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyValue {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductSet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub index_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub index_error: ::core::option::Option<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceImage {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub bounding_polys: ::prost::alloc::vec::Vec<BoundingPoly>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub product: ::core::option::Option<Product>,
    #[prost(string, tag = "3")]
    pub product_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsResponse {
    #[prost(message, repeated, tag = "1")]
    pub products: ::prost::alloc::vec::Vec<Product>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductRequest {
    #[prost(message, optional, tag = "1")]
    pub product: ::core::option::Option<Product>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteProductRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductSetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub product_set: ::core::option::Option<ProductSet>,
    #[prost(string, tag = "3")]
    pub product_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub product_sets: ::prost::alloc::vec::Vec<ProductSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductSetRequest {
    #[prost(message, optional, tag = "1")]
    pub product_set: ::core::option::Option<ProductSet>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteProductSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReferenceImageRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub reference_image: ::core::option::Option<ReferenceImage>,
    #[prost(string, tag = "3")]
    pub reference_image_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReferenceImagesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReferenceImagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub reference_images: ::prost::alloc::vec::Vec<ReferenceImage>,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReferenceImageRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReferenceImageRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddProductToProductSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub product: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductFromProductSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub product: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsInProductSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsInProductSetResponse {
    #[prost(message, repeated, tag = "1")]
    pub products: ::prost::alloc::vec::Vec<Product>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportProductSetsGcsSource {
    #[prost(string, tag = "1")]
    pub csv_file_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportProductSetsInputConfig {
    #[prost(oneof = "import_product_sets_input_config::Source", tags = "1")]
    pub source: ::core::option::Option<import_product_sets_input_config::Source>,
}
/// Nested message and enum types in `ImportProductSetsInputConfig`.
pub mod import_product_sets_input_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        GcsSource(super::ImportProductSetsGcsSource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportProductSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input_config: ::core::option::Option<ImportProductSetsInputConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportProductSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub reference_images: ::prost::alloc::vec::Vec<ReferenceImage>,
    #[prost(message, repeated, tag = "2")]
    pub statuses: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchOperationMetadata {
    #[prost(enumeration = "batch_operation_metadata::State", tag = "1")]
    pub state: i32,
    #[prost(message, optional, tag = "2")]
    pub submit_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `BatchOperationMetadata`.
pub mod batch_operation_metadata {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Processing = 1,
        Successful = 2,
        Failed = 3,
        Cancelled = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Processing => "PROCESSING",
                State::Successful => "SUCCESSFUL",
                State::Failed => "FAILED",
                State::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROCESSING" => Some(Self::Processing),
                "SUCCESSFUL" => Some(Self::Successful),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductSetPurgeConfig {
    #[prost(string, tag = "1")]
    pub product_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeProductsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub force: bool,
    #[prost(oneof = "purge_products_request::Target", tags = "2, 3")]
    pub target: ::core::option::Option<purge_products_request::Target>,
}
/// Nested message and enum types in `PurgeProductsRequest`.
pub mod purge_products_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(message, tag = "2")]
        ProductSetPurgeConfig(super::ProductSetPurgeConfig),
        #[prost(bool, tag = "3")]
        DeleteOrphanProducts(bool),
    }
}
/// Generated client implementations.
pub mod product_search_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Manages Products and ProductSets of reference images for use in product
    /// search. It uses the following resource model:
    ///
    /// - The API has a collection of
    /// [ProductSet][google.cloud.vision.v1p4beta1.ProductSet] resources, named
    /// `projects/*/locations/*/productSets/*`, which acts as a way to put different
    /// products into groups to limit identification.
    ///
    /// In parallel,
    ///
    /// - The API has a collection of
    /// [Product][google.cloud.vision.v1p4beta1.Product] resources, named
    ///   `projects/*/locations/*/products/*`
    ///
    /// - Each [Product][google.cloud.vision.v1p4beta1.Product] has a collection of
    /// [ReferenceImage][google.cloud.vision.v1p4beta1.ReferenceImage] resources,
    /// named
    ///   `projects/*/locations/*/products/*/referenceImages/*`
    #[derive(Debug, Clone)]
    pub struct ProductSearchClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ProductSearchClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProductSearchClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ProductSearchClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates and returns a new ProductSet resource.
        ///
        /// Possible errors:
        ///
        /// * Returns INVALID_ARGUMENT if display_name is missing, or is longer than
        ///   4096 characters.
        pub async fn create_product_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProductSetRequest>,
        ) -> std::result::Result<tonic::Response<super::ProductSet>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/CreateProductSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "CreateProductSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists ProductSets in an unspecified order.
        ///
        /// Possible errors:
        ///
        /// * Returns INVALID_ARGUMENT if page_size is greater than 100, or less
        ///   than 1.
        pub async fn list_product_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProductSetsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListProductSetsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/ListProductSets",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "ListProductSets",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets information associated with a ProductSet.
        ///
        /// Possible errors:
        ///
        /// * Returns NOT_FOUND if the ProductSet does not exist.
        pub async fn get_product_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProductSetRequest>,
        ) -> std::result::Result<tonic::Response<super::ProductSet>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/GetProductSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "GetProductSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Makes changes to a ProductSet resource.
        /// Only display_name can be updated currently.
        ///
        /// Possible errors:
        ///
        /// * Returns NOT_FOUND if the ProductSet does not exist.
        /// * Returns INVALID_ARGUMENT if display_name is present in update_mask but
        ///   missing from the request or longer than 4096 characters.
        pub async fn update_product_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateProductSetRequest>,
        ) -> std::result::Result<tonic::Response<super::ProductSet>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/UpdateProductSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "UpdateProductSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes a ProductSet. Products and ReferenceImages in the
        /// ProductSet are not deleted.
        ///
        /// The actual image files are not deleted from Google Cloud Storage.
        pub async fn delete_product_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteProductSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/DeleteProductSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "DeleteProductSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates and returns a new product resource.
        ///
        /// Possible errors:
        ///
        /// * Returns INVALID_ARGUMENT if display_name is missing or longer than 4096
        ///   characters.
        /// * Returns INVALID_ARGUMENT if description is longer than 4096 characters.
        /// * Returns INVALID_ARGUMENT if product_category is missing or invalid.
        pub async fn create_product(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProductRequest>,
        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/CreateProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "CreateProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists products in an unspecified order.
        ///
        /// Possible errors:
        ///
        /// * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
        pub async fn list_products(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProductsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListProductsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/ListProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "ListProducts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets information associated with a Product.
        ///
        /// Possible errors:
        ///
        /// * Returns NOT_FOUND if the Product does not exist.
        pub async fn get_product(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProductRequest>,
        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/GetProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "GetProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Makes changes to a Product resource.
        /// Only the `display_name`, `description`, and `labels` fields can be updated
        /// right now.
        ///
        /// If labels are updated, the change will not be reflected in queries until
        /// the next index time.
        ///
        /// Possible errors:
        ///
        /// * Returns NOT_FOUND if the Product does not exist.
        /// * Returns INVALID_ARGUMENT if display_name is present in update_mask but is
        ///   missing from the request or longer than 4096 characters.
        /// * Returns INVALID_ARGUMENT if description is present in update_mask but is
        ///   longer than 4096 characters.
        /// * Returns INVALID_ARGUMENT if product_category is present in update_mask.
        pub async fn update_product(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateProductRequest>,
        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/UpdateProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "UpdateProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes a product and its reference images.
        ///
        /// Metadata of the product and all its images will be deleted right away, but
        /// search queries against ProductSets containing the product may still work
        /// until all related caches are refreshed.
        pub async fn delete_product(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteProductRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/DeleteProduct",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "DeleteProduct",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates and returns a new ReferenceImage resource.
        ///
        /// The `bounding_poly` field is optional. If `bounding_poly` is not specified,
        /// the system will try to detect regions of interest in the image that are
        /// compatible with the product_category on the parent product. If it is
        /// specified, detection is ALWAYS skipped. The system converts polygons into
        /// non-rotated rectangles.
        ///
        /// Note that the pipeline will resize the image if the image resolution is too
        /// large to process (above 50MP).
        ///
        /// Possible errors:
        ///
        /// * Returns INVALID_ARGUMENT if the image_uri is missing or longer than 4096
        ///   characters.
        /// * Returns INVALID_ARGUMENT if the product does not exist.
        /// * Returns INVALID_ARGUMENT if bounding_poly is not provided, and nothing
        ///   compatible with the parent product's product_category is detected.
        /// * Returns INVALID_ARGUMENT if bounding_poly contains more than 10 polygons.
        pub async fn create_reference_image(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReferenceImageRequest>,
        ) -> std::result::Result<tonic::Response<super::ReferenceImage>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/CreateReferenceImage",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "CreateReferenceImage",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes a reference image.
        ///
        /// The image metadata will be deleted right away, but search queries
        /// against ProductSets containing the image may still work until all related
        /// caches are refreshed.
        ///
        /// The actual image files are not deleted from Google Cloud Storage.
        pub async fn delete_reference_image(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReferenceImageRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/DeleteReferenceImage",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "DeleteReferenceImage",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists reference images.
        ///
        /// Possible errors:
        ///
        /// * Returns NOT_FOUND if the parent product does not exist.
        /// * Returns INVALID_ARGUMENT if the page_size is greater than 100, or less
        ///   than 1.
        pub async fn list_reference_images(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReferenceImagesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListReferenceImagesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/ListReferenceImages",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "ListReferenceImages",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets information associated with a ReferenceImage.
        ///
        /// Possible errors:
        ///
        /// * Returns NOT_FOUND if the specified image does not exist.
        pub async fn get_reference_image(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReferenceImageRequest>,
        ) -> std::result::Result<tonic::Response<super::ReferenceImage>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/GetReferenceImage",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "GetReferenceImage",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Adds a Product to the specified ProductSet. If the Product is already
        /// present, no change is made.
        ///
        /// One Product can be added to at most 100 ProductSets.
        ///
        /// Possible errors:
        ///
        /// * Returns NOT_FOUND if the Product or the ProductSet doesn't exist.
        pub async fn add_product_to_product_set(
            &mut self,
            request: impl tonic::IntoRequest<super::AddProductToProductSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/AddProductToProductSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "AddProductToProductSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Removes a Product from the specified ProductSet.
        pub async fn remove_product_from_product_set(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveProductFromProductSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/RemoveProductFromProductSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "RemoveProductFromProductSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Products in a ProductSet, in an unspecified order. If the
        /// ProductSet does not exist, the products field of the response will be
        /// empty.
        ///
        /// Possible errors:
        ///
        /// * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
        pub async fn list_products_in_product_set(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProductsInProductSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProductsInProductSetResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/ListProductsInProductSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "ListProductsInProductSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Asynchronous API that imports a list of reference images to specified
        /// product sets based on a list of image information.
        ///
        /// The [google.longrunning.Operation][google.longrunning.Operation] API can be
        /// used to keep track of the progress and results of the request.
        /// `Operation.metadata` contains `BatchOperationMetadata`. (progress)
        /// `Operation.response` contains `ImportProductSetsResponse`. (results)
        ///
        /// The input source of this method is a csv file on Google Cloud Storage.
        /// For the format of the csv file please see
        /// [ImportProductSetsGcsSource.csv_file_uri][google.cloud.vision.v1p4beta1.ImportProductSetsGcsSource.csv_file_uri].
        pub async fn import_product_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportProductSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/ImportProductSets",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "ImportProductSets",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Asynchronous API to delete all Products in a ProductSet or all Products
        /// that are in no ProductSet.
        ///
        /// If a Product is a member of the specified ProductSet in addition to other
        /// ProductSets, the Product will still be deleted.
        ///
        /// It is recommended to not delete the specified ProductSet until after this
        /// operation has completed. It is also recommended to not add any of the
        /// Products involved in the batch delete to a new ProductSet while this
        /// operation is running because those Products may still end up deleted.
        ///
        /// It's not possible to undo the PurgeProducts operation. Therefore, it is
        /// recommended to keep the csv files used in ImportProductSets (if that was
        /// how you originally built the Product Set) before starting PurgeProducts, in
        /// case you need to re-import the data after deletion.
        ///
        /// If the plan is to purge all of the Products from a ProductSet and then
        /// re-use the empty ProductSet to re-import new Products into the empty
        /// ProductSet, you must wait until the PurgeProducts operation has finished
        /// for that ProductSet.
        ///
        /// The [google.longrunning.Operation][google.longrunning.Operation] API can be
        /// used to keep track of the progress and results of the request.
        /// `Operation.metadata` contains `BatchOperationMetadata`. (progress)
        pub async fn purge_products(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeProductsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ProductSearch/PurgeProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ProductSearch",
                "PurgeProducts",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductSearchParams {
    #[prost(message, optional, tag = "9")]
    pub bounding_poly: ::core::option::Option<BoundingPoly>,
    #[prost(string, tag = "6")]
    pub product_set: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub product_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductSearchResults {
    #[prost(message, optional, tag = "2")]
    pub index_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "5")]
    pub results: ::prost::alloc::vec::Vec<product_search_results::Result>,
    #[prost(message, repeated, tag = "6")]
    pub product_grouped_results: ::prost::alloc::vec::Vec<product_search_results::GroupedResult>,
}
/// Nested message and enum types in `ProductSearchResults`.
pub mod product_search_results {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(message, optional, tag = "1")]
        pub product: ::core::option::Option<super::Product>,
        #[prost(float, tag = "2")]
        pub score: f32,
        #[prost(string, tag = "3")]
        pub image: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ObjectAnnotation {
        #[prost(string, tag = "1")]
        pub mid: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub language_code: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        #[prost(float, tag = "4")]
        pub score: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupedResult {
        #[prost(message, optional, tag = "1")]
        pub bounding_poly: ::core::option::Option<super::BoundingPoly>,
        #[prost(message, repeated, tag = "2")]
        pub results: ::prost::alloc::vec::Vec<Result>,
        #[prost(message, repeated, tag = "3")]
        pub object_annotations: ::prost::alloc::vec::Vec<ObjectAnnotation>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaceRecognitionParams {
    #[prost(string, repeated, tag = "1")]
    pub celebrity_set: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Celebrity {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaceRecognitionResult {
    #[prost(message, optional, tag = "1")]
    pub celebrity: ::core::option::Option<Celebrity>,
    #[prost(float, tag = "2")]
    pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextAnnotation {
    #[prost(message, repeated, tag = "1")]
    pub pages: ::prost::alloc::vec::Vec<Page>,
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TextAnnotation`.
pub mod text_annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetectedLanguage {
        #[prost(string, tag = "1")]
        pub language_code: ::prost::alloc::string::String,
        #[prost(float, tag = "2")]
        pub confidence: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DetectedBreak {
        #[prost(enumeration = "detected_break::BreakType", tag = "1")]
        pub r#type: i32,
        #[prost(bool, tag = "2")]
        pub is_prefix: bool,
    }
    /// Nested message and enum types in `DetectedBreak`.
    pub mod detected_break {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum BreakType {
            Unknown = 0,
            Space = 1,
            SureSpace = 2,
            EolSureSpace = 3,
            Hyphen = 4,
            LineBreak = 5,
        }
        impl BreakType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    BreakType::Unknown => "UNKNOWN",
                    BreakType::Space => "SPACE",
                    BreakType::SureSpace => "SURE_SPACE",
                    BreakType::EolSureSpace => "EOL_SURE_SPACE",
                    BreakType::Hyphen => "HYPHEN",
                    BreakType::LineBreak => "LINE_BREAK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "SPACE" => Some(Self::Space),
                    "SURE_SPACE" => Some(Self::SureSpace),
                    "EOL_SURE_SPACE" => Some(Self::EolSureSpace),
                    "HYPHEN" => Some(Self::Hyphen),
                    "LINE_BREAK" => Some(Self::LineBreak),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextProperty {
        #[prost(message, repeated, tag = "1")]
        pub detected_languages: ::prost::alloc::vec::Vec<DetectedLanguage>,
        #[prost(message, optional, tag = "2")]
        pub detected_break: ::core::option::Option<DetectedBreak>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Page {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<text_annotation::TextProperty>,
    #[prost(int32, tag = "2")]
    pub width: i32,
    #[prost(int32, tag = "3")]
    pub height: i32,
    #[prost(message, repeated, tag = "4")]
    pub blocks: ::prost::alloc::vec::Vec<Block>,
    #[prost(float, tag = "5")]
    pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<text_annotation::TextProperty>,
    #[prost(message, optional, tag = "2")]
    pub bounding_box: ::core::option::Option<BoundingPoly>,
    #[prost(message, repeated, tag = "3")]
    pub paragraphs: ::prost::alloc::vec::Vec<Paragraph>,
    #[prost(enumeration = "block::BlockType", tag = "4")]
    pub block_type: i32,
    #[prost(float, tag = "5")]
    pub confidence: f32,
}
/// Nested message and enum types in `Block`.
pub mod block {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum BlockType {
        Unknown = 0,
        Text = 1,
        Table = 2,
        Picture = 3,
        Ruler = 4,
        Barcode = 5,
    }
    impl BlockType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BlockType::Unknown => "UNKNOWN",
                BlockType::Text => "TEXT",
                BlockType::Table => "TABLE",
                BlockType::Picture => "PICTURE",
                BlockType::Ruler => "RULER",
                BlockType::Barcode => "BARCODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT" => Some(Self::Text),
                "TABLE" => Some(Self::Table),
                "PICTURE" => Some(Self::Picture),
                "RULER" => Some(Self::Ruler),
                "BARCODE" => Some(Self::Barcode),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Paragraph {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<text_annotation::TextProperty>,
    #[prost(message, optional, tag = "2")]
    pub bounding_box: ::core::option::Option<BoundingPoly>,
    #[prost(message, repeated, tag = "3")]
    pub words: ::prost::alloc::vec::Vec<Word>,
    #[prost(float, tag = "4")]
    pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Word {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<text_annotation::TextProperty>,
    #[prost(message, optional, tag = "2")]
    pub bounding_box: ::core::option::Option<BoundingPoly>,
    #[prost(message, repeated, tag = "3")]
    pub symbols: ::prost::alloc::vec::Vec<Symbol>,
    #[prost(float, tag = "4")]
    pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Symbol {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<text_annotation::TextProperty>,
    #[prost(message, optional, tag = "2")]
    pub bounding_box: ::core::option::Option<BoundingPoly>,
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebDetection {
    #[prost(message, repeated, tag = "1")]
    pub web_entities: ::prost::alloc::vec::Vec<web_detection::WebEntity>,
    #[prost(message, repeated, tag = "2")]
    pub full_matching_images: ::prost::alloc::vec::Vec<web_detection::WebImage>,
    #[prost(message, repeated, tag = "3")]
    pub partial_matching_images: ::prost::alloc::vec::Vec<web_detection::WebImage>,
    #[prost(message, repeated, tag = "4")]
    pub pages_with_matching_images: ::prost::alloc::vec::Vec<web_detection::WebPage>,
    #[prost(message, repeated, tag = "6")]
    pub visually_similar_images: ::prost::alloc::vec::Vec<web_detection::WebImage>,
    #[prost(message, repeated, tag = "8")]
    pub best_guess_labels: ::prost::alloc::vec::Vec<web_detection::WebLabel>,
}
/// Nested message and enum types in `WebDetection`.
pub mod web_detection {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WebEntity {
        #[prost(string, tag = "1")]
        pub entity_id: ::prost::alloc::string::String,
        #[prost(float, tag = "2")]
        pub score: f32,
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WebImage {
        #[prost(string, tag = "1")]
        pub url: ::prost::alloc::string::String,
        #[prost(float, tag = "2")]
        pub score: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WebPage {
        #[prost(string, tag = "1")]
        pub url: ::prost::alloc::string::String,
        #[prost(float, tag = "2")]
        pub score: f32,
        #[prost(string, tag = "3")]
        pub page_title: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub full_matching_images: ::prost::alloc::vec::Vec<WebImage>,
        #[prost(message, repeated, tag = "5")]
        pub partial_matching_images: ::prost::alloc::vec::Vec<WebImage>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WebLabel {
        #[prost(string, tag = "1")]
        pub label: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub language_code: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Feature {
    #[prost(enumeration = "feature::Type", tag = "1")]
    pub r#type: i32,
    #[prost(int32, tag = "2")]
    pub max_results: i32,
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Feature`.
pub mod feature {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        FaceDetection = 1,
        LandmarkDetection = 2,
        LogoDetection = 3,
        LabelDetection = 4,
        TextDetection = 5,
        DocumentTextDetection = 11,
        SafeSearchDetection = 6,
        ImageProperties = 7,
        CropHints = 9,
        WebDetection = 10,
        ProductSearch = 12,
        ObjectLocalization = 19,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::FaceDetection => "FACE_DETECTION",
                Type::LandmarkDetection => "LANDMARK_DETECTION",
                Type::LogoDetection => "LOGO_DETECTION",
                Type::LabelDetection => "LABEL_DETECTION",
                Type::TextDetection => "TEXT_DETECTION",
                Type::DocumentTextDetection => "DOCUMENT_TEXT_DETECTION",
                Type::SafeSearchDetection => "SAFE_SEARCH_DETECTION",
                Type::ImageProperties => "IMAGE_PROPERTIES",
                Type::CropHints => "CROP_HINTS",
                Type::WebDetection => "WEB_DETECTION",
                Type::ProductSearch => "PRODUCT_SEARCH",
                Type::ObjectLocalization => "OBJECT_LOCALIZATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FACE_DETECTION" => Some(Self::FaceDetection),
                "LANDMARK_DETECTION" => Some(Self::LandmarkDetection),
                "LOGO_DETECTION" => Some(Self::LogoDetection),
                "LABEL_DETECTION" => Some(Self::LabelDetection),
                "TEXT_DETECTION" => Some(Self::TextDetection),
                "DOCUMENT_TEXT_DETECTION" => Some(Self::DocumentTextDetection),
                "SAFE_SEARCH_DETECTION" => Some(Self::SafeSearchDetection),
                "IMAGE_PROPERTIES" => Some(Self::ImageProperties),
                "CROP_HINTS" => Some(Self::CropHints),
                "WEB_DETECTION" => Some(Self::WebDetection),
                "PRODUCT_SEARCH" => Some(Self::ProductSearch),
                "OBJECT_LOCALIZATION" => Some(Self::ObjectLocalization),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSource {
    #[prost(string, tag = "1")]
    pub gcs_image_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub image_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(bytes = "bytes", tag = "1")]
    pub content: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub source: ::core::option::Option<ImageSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaceAnnotation {
    #[prost(message, optional, tag = "1")]
    pub bounding_poly: ::core::option::Option<BoundingPoly>,
    #[prost(message, optional, tag = "2")]
    pub fd_bounding_poly: ::core::option::Option<BoundingPoly>,
    #[prost(message, repeated, tag = "3")]
    pub landmarks: ::prost::alloc::vec::Vec<face_annotation::Landmark>,
    #[prost(float, tag = "4")]
    pub roll_angle: f32,
    #[prost(float, tag = "5")]
    pub pan_angle: f32,
    #[prost(float, tag = "6")]
    pub tilt_angle: f32,
    #[prost(float, tag = "7")]
    pub detection_confidence: f32,
    #[prost(float, tag = "8")]
    pub landmarking_confidence: f32,
    #[prost(enumeration = "Likelihood", tag = "9")]
    pub joy_likelihood: i32,
    #[prost(enumeration = "Likelihood", tag = "10")]
    pub sorrow_likelihood: i32,
    #[prost(enumeration = "Likelihood", tag = "11")]
    pub anger_likelihood: i32,
    #[prost(enumeration = "Likelihood", tag = "12")]
    pub surprise_likelihood: i32,
    #[prost(enumeration = "Likelihood", tag = "13")]
    pub under_exposed_likelihood: i32,
    #[prost(enumeration = "Likelihood", tag = "14")]
    pub blurred_likelihood: i32,
    #[prost(enumeration = "Likelihood", tag = "15")]
    pub headwear_likelihood: i32,
    #[prost(message, repeated, tag = "16")]
    pub recognition_result: ::prost::alloc::vec::Vec<FaceRecognitionResult>,
}
/// Nested message and enum types in `FaceAnnotation`.
pub mod face_annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Landmark {
        #[prost(enumeration = "landmark::Type", tag = "3")]
        pub r#type: i32,
        #[prost(message, optional, tag = "4")]
        pub position: ::core::option::Option<super::Position>,
    }
    /// Nested message and enum types in `Landmark`.
    pub mod landmark {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Type {
            UnknownLandmark = 0,
            LeftEye = 1,
            RightEye = 2,
            LeftOfLeftEyebrow = 3,
            RightOfLeftEyebrow = 4,
            LeftOfRightEyebrow = 5,
            RightOfRightEyebrow = 6,
            MidpointBetweenEyes = 7,
            NoseTip = 8,
            UpperLip = 9,
            LowerLip = 10,
            MouthLeft = 11,
            MouthRight = 12,
            MouthCenter = 13,
            NoseBottomRight = 14,
            NoseBottomLeft = 15,
            NoseBottomCenter = 16,
            LeftEyeTopBoundary = 17,
            LeftEyeRightCorner = 18,
            LeftEyeBottomBoundary = 19,
            LeftEyeLeftCorner = 20,
            RightEyeTopBoundary = 21,
            RightEyeRightCorner = 22,
            RightEyeBottomBoundary = 23,
            RightEyeLeftCorner = 24,
            LeftEyebrowUpperMidpoint = 25,
            RightEyebrowUpperMidpoint = 26,
            LeftEarTragion = 27,
            RightEarTragion = 28,
            LeftEyePupil = 29,
            RightEyePupil = 30,
            ForeheadGlabella = 31,
            ChinGnathion = 32,
            ChinLeftGonion = 33,
            ChinRightGonion = 34,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::UnknownLandmark => "UNKNOWN_LANDMARK",
                    Type::LeftEye => "LEFT_EYE",
                    Type::RightEye => "RIGHT_EYE",
                    Type::LeftOfLeftEyebrow => "LEFT_OF_LEFT_EYEBROW",
                    Type::RightOfLeftEyebrow => "RIGHT_OF_LEFT_EYEBROW",
                    Type::LeftOfRightEyebrow => "LEFT_OF_RIGHT_EYEBROW",
                    Type::RightOfRightEyebrow => "RIGHT_OF_RIGHT_EYEBROW",
                    Type::MidpointBetweenEyes => "MIDPOINT_BETWEEN_EYES",
                    Type::NoseTip => "NOSE_TIP",
                    Type::UpperLip => "UPPER_LIP",
                    Type::LowerLip => "LOWER_LIP",
                    Type::MouthLeft => "MOUTH_LEFT",
                    Type::MouthRight => "MOUTH_RIGHT",
                    Type::MouthCenter => "MOUTH_CENTER",
                    Type::NoseBottomRight => "NOSE_BOTTOM_RIGHT",
                    Type::NoseBottomLeft => "NOSE_BOTTOM_LEFT",
                    Type::NoseBottomCenter => "NOSE_BOTTOM_CENTER",
                    Type::LeftEyeTopBoundary => "LEFT_EYE_TOP_BOUNDARY",
                    Type::LeftEyeRightCorner => "LEFT_EYE_RIGHT_CORNER",
                    Type::LeftEyeBottomBoundary => "LEFT_EYE_BOTTOM_BOUNDARY",
                    Type::LeftEyeLeftCorner => "LEFT_EYE_LEFT_CORNER",
                    Type::RightEyeTopBoundary => "RIGHT_EYE_TOP_BOUNDARY",
                    Type::RightEyeRightCorner => "RIGHT_EYE_RIGHT_CORNER",
                    Type::RightEyeBottomBoundary => "RIGHT_EYE_BOTTOM_BOUNDARY",
                    Type::RightEyeLeftCorner => "RIGHT_EYE_LEFT_CORNER",
                    Type::LeftEyebrowUpperMidpoint => "LEFT_EYEBROW_UPPER_MIDPOINT",
                    Type::RightEyebrowUpperMidpoint => "RIGHT_EYEBROW_UPPER_MIDPOINT",
                    Type::LeftEarTragion => "LEFT_EAR_TRAGION",
                    Type::RightEarTragion => "RIGHT_EAR_TRAGION",
                    Type::LeftEyePupil => "LEFT_EYE_PUPIL",
                    Type::RightEyePupil => "RIGHT_EYE_PUPIL",
                    Type::ForeheadGlabella => "FOREHEAD_GLABELLA",
                    Type::ChinGnathion => "CHIN_GNATHION",
                    Type::ChinLeftGonion => "CHIN_LEFT_GONION",
                    Type::ChinRightGonion => "CHIN_RIGHT_GONION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN_LANDMARK" => Some(Self::UnknownLandmark),
                    "LEFT_EYE" => Some(Self::LeftEye),
                    "RIGHT_EYE" => Some(Self::RightEye),
                    "LEFT_OF_LEFT_EYEBROW" => Some(Self::LeftOfLeftEyebrow),
                    "RIGHT_OF_LEFT_EYEBROW" => Some(Self::RightOfLeftEyebrow),
                    "LEFT_OF_RIGHT_EYEBROW" => Some(Self::LeftOfRightEyebrow),
                    "RIGHT_OF_RIGHT_EYEBROW" => Some(Self::RightOfRightEyebrow),
                    "MIDPOINT_BETWEEN_EYES" => Some(Self::MidpointBetweenEyes),
                    "NOSE_TIP" => Some(Self::NoseTip),
                    "UPPER_LIP" => Some(Self::UpperLip),
                    "LOWER_LIP" => Some(Self::LowerLip),
                    "MOUTH_LEFT" => Some(Self::MouthLeft),
                    "MOUTH_RIGHT" => Some(Self::MouthRight),
                    "MOUTH_CENTER" => Some(Self::MouthCenter),
                    "NOSE_BOTTOM_RIGHT" => Some(Self::NoseBottomRight),
                    "NOSE_BOTTOM_LEFT" => Some(Self::NoseBottomLeft),
                    "NOSE_BOTTOM_CENTER" => Some(Self::NoseBottomCenter),
                    "LEFT_EYE_TOP_BOUNDARY" => Some(Self::LeftEyeTopBoundary),
                    "LEFT_EYE_RIGHT_CORNER" => Some(Self::LeftEyeRightCorner),
                    "LEFT_EYE_BOTTOM_BOUNDARY" => Some(Self::LeftEyeBottomBoundary),
                    "LEFT_EYE_LEFT_CORNER" => Some(Self::LeftEyeLeftCorner),
                    "RIGHT_EYE_TOP_BOUNDARY" => Some(Self::RightEyeTopBoundary),
                    "RIGHT_EYE_RIGHT_CORNER" => Some(Self::RightEyeRightCorner),
                    "RIGHT_EYE_BOTTOM_BOUNDARY" => Some(Self::RightEyeBottomBoundary),
                    "RIGHT_EYE_LEFT_CORNER" => Some(Self::RightEyeLeftCorner),
                    "LEFT_EYEBROW_UPPER_MIDPOINT" => Some(Self::LeftEyebrowUpperMidpoint),
                    "RIGHT_EYEBROW_UPPER_MIDPOINT" => Some(Self::RightEyebrowUpperMidpoint),
                    "LEFT_EAR_TRAGION" => Some(Self::LeftEarTragion),
                    "RIGHT_EAR_TRAGION" => Some(Self::RightEarTragion),
                    "LEFT_EYE_PUPIL" => Some(Self::LeftEyePupil),
                    "RIGHT_EYE_PUPIL" => Some(Self::RightEyePupil),
                    "FOREHEAD_GLABELLA" => Some(Self::ForeheadGlabella),
                    "CHIN_GNATHION" => Some(Self::ChinGnathion),
                    "CHIN_LEFT_GONION" => Some(Self::ChinLeftGonion),
                    "CHIN_RIGHT_GONION" => Some(Self::ChinRightGonion),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationInfo {
    #[prost(message, optional, tag = "1")]
    pub lat_lng: ::core::option::Option<super::super::super::r#type::LatLng>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub uint64_value: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityAnnotation {
    #[prost(string, tag = "1")]
    pub mid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub locale: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub score: f32,
    #[deprecated]
    #[prost(float, tag = "5")]
    pub confidence: f32,
    #[prost(float, tag = "6")]
    pub topicality: f32,
    #[prost(message, optional, tag = "7")]
    pub bounding_poly: ::core::option::Option<BoundingPoly>,
    #[prost(message, repeated, tag = "8")]
    pub locations: ::prost::alloc::vec::Vec<LocationInfo>,
    #[prost(message, repeated, tag = "9")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizedObjectAnnotation {
    #[prost(string, tag = "1")]
    pub mid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub score: f32,
    #[prost(message, optional, tag = "5")]
    pub bounding_poly: ::core::option::Option<BoundingPoly>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafeSearchAnnotation {
    #[prost(enumeration = "Likelihood", tag = "1")]
    pub adult: i32,
    #[prost(enumeration = "Likelihood", tag = "2")]
    pub spoof: i32,
    #[prost(enumeration = "Likelihood", tag = "3")]
    pub medical: i32,
    #[prost(enumeration = "Likelihood", tag = "4")]
    pub violence: i32,
    #[prost(enumeration = "Likelihood", tag = "9")]
    pub racy: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LatLongRect {
    #[prost(message, optional, tag = "1")]
    pub min_lat_lng: ::core::option::Option<super::super::super::r#type::LatLng>,
    #[prost(message, optional, tag = "2")]
    pub max_lat_lng: ::core::option::Option<super::super::super::r#type::LatLng>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ColorInfo {
    #[prost(message, optional, tag = "1")]
    pub color: ::core::option::Option<super::super::super::r#type::Color>,
    #[prost(float, tag = "2")]
    pub score: f32,
    #[prost(float, tag = "3")]
    pub pixel_fraction: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DominantColorsAnnotation {
    #[prost(message, repeated, tag = "1")]
    pub colors: ::prost::alloc::vec::Vec<ColorInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageProperties {
    #[prost(message, optional, tag = "1")]
    pub dominant_colors: ::core::option::Option<DominantColorsAnnotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CropHint {
    #[prost(message, optional, tag = "1")]
    pub bounding_poly: ::core::option::Option<BoundingPoly>,
    #[prost(float, tag = "2")]
    pub confidence: f32,
    #[prost(float, tag = "3")]
    pub importance_fraction: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CropHintsAnnotation {
    #[prost(message, repeated, tag = "1")]
    pub crop_hints: ::prost::alloc::vec::Vec<CropHint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CropHintsParams {
    #[prost(float, repeated, tag = "1")]
    pub aspect_ratios: ::prost::alloc::vec::Vec<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebDetectionParams {
    #[prost(bool, tag = "2")]
    pub include_geo_results: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextDetectionParams {
    #[prost(bool, tag = "9")]
    pub enable_text_detection_confidence_score: bool,
    #[prost(string, repeated, tag = "11")]
    pub advanced_ocr_options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageContext {
    #[prost(message, optional, tag = "1")]
    pub lat_long_rect: ::core::option::Option<LatLongRect>,
    #[prost(string, repeated, tag = "2")]
    pub language_hints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub crop_hints_params: ::core::option::Option<CropHintsParams>,
    #[prost(message, optional, tag = "10")]
    pub face_recognition_params: ::core::option::Option<FaceRecognitionParams>,
    #[prost(message, optional, tag = "5")]
    pub product_search_params: ::core::option::Option<ProductSearchParams>,
    #[prost(message, optional, tag = "6")]
    pub web_detection_params: ::core::option::Option<WebDetectionParams>,
    #[prost(message, optional, tag = "12")]
    pub text_detection_params: ::core::option::Option<TextDetectionParams>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotateImageRequest {
    #[prost(message, optional, tag = "1")]
    pub image: ::core::option::Option<Image>,
    #[prost(message, repeated, tag = "2")]
    pub features: ::prost::alloc::vec::Vec<Feature>,
    #[prost(message, optional, tag = "3")]
    pub image_context: ::core::option::Option<ImageContext>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageAnnotationContext {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_number: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotateImageResponse {
    #[prost(message, repeated, tag = "1")]
    pub face_annotations: ::prost::alloc::vec::Vec<FaceAnnotation>,
    #[prost(message, repeated, tag = "2")]
    pub landmark_annotations: ::prost::alloc::vec::Vec<EntityAnnotation>,
    #[prost(message, repeated, tag = "3")]
    pub logo_annotations: ::prost::alloc::vec::Vec<EntityAnnotation>,
    #[prost(message, repeated, tag = "4")]
    pub label_annotations: ::prost::alloc::vec::Vec<EntityAnnotation>,
    #[prost(message, repeated, tag = "22")]
    pub localized_object_annotations: ::prost::alloc::vec::Vec<LocalizedObjectAnnotation>,
    #[prost(message, repeated, tag = "5")]
    pub text_annotations: ::prost::alloc::vec::Vec<EntityAnnotation>,
    #[prost(message, optional, tag = "12")]
    pub full_text_annotation: ::core::option::Option<TextAnnotation>,
    #[prost(message, optional, tag = "6")]
    pub safe_search_annotation: ::core::option::Option<SafeSearchAnnotation>,
    #[prost(message, optional, tag = "8")]
    pub image_properties_annotation: ::core::option::Option<ImageProperties>,
    #[prost(message, optional, tag = "11")]
    pub crop_hints_annotation: ::core::option::Option<CropHintsAnnotation>,
    #[prost(message, optional, tag = "13")]
    pub web_detection: ::core::option::Option<WebDetection>,
    #[prost(message, optional, tag = "14")]
    pub product_search_results: ::core::option::Option<ProductSearchResults>,
    #[prost(message, optional, tag = "9")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "21")]
    pub context: ::core::option::Option<ImageAnnotationContext>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchAnnotateImagesRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<AnnotateImageRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchAnnotateImagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<AnnotateImageResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotateFileRequest {
    #[prost(message, optional, tag = "1")]
    pub input_config: ::core::option::Option<InputConfig>,
    #[prost(message, repeated, tag = "2")]
    pub features: ::prost::alloc::vec::Vec<Feature>,
    #[prost(message, optional, tag = "3")]
    pub image_context: ::core::option::Option<ImageContext>,
    #[prost(int32, repeated, tag = "4")]
    pub pages: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotateFileResponse {
    #[prost(message, optional, tag = "1")]
    pub input_config: ::core::option::Option<InputConfig>,
    #[prost(message, repeated, tag = "2")]
    pub responses: ::prost::alloc::vec::Vec<AnnotateImageResponse>,
    #[prost(int32, tag = "3")]
    pub total_pages: i32,
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchAnnotateFilesRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<AnnotateFileRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchAnnotateFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<AnnotateFileResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsyncAnnotateFileRequest {
    #[prost(message, optional, tag = "1")]
    pub input_config: ::core::option::Option<InputConfig>,
    #[prost(message, repeated, tag = "2")]
    pub features: ::prost::alloc::vec::Vec<Feature>,
    #[prost(message, optional, tag = "3")]
    pub image_context: ::core::option::Option<ImageContext>,
    #[prost(message, optional, tag = "4")]
    pub output_config: ::core::option::Option<OutputConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsyncAnnotateFileResponse {
    #[prost(message, optional, tag = "1")]
    pub output_config: ::core::option::Option<OutputConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsyncBatchAnnotateImagesRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<AnnotateImageRequest>,
    #[prost(message, optional, tag = "2")]
    pub output_config: ::core::option::Option<OutputConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsyncBatchAnnotateImagesResponse {
    #[prost(message, optional, tag = "1")]
    pub output_config: ::core::option::Option<OutputConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsyncBatchAnnotateFilesRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<AsyncAnnotateFileRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsyncBatchAnnotateFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<AsyncAnnotateFileResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputConfig {
    #[prost(message, optional, tag = "1")]
    pub gcs_source: ::core::option::Option<GcsSource>,
    #[prost(bytes = "bytes", tag = "3")]
    pub content: ::prost::bytes::Bytes,
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputConfig {
    #[prost(message, optional, tag = "1")]
    pub gcs_destination: ::core::option::Option<GcsDestination>,
    #[prost(int32, tag = "2")]
    pub batch_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsDestination {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(enumeration = "operation_metadata::State", tag = "1")]
    pub state: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `OperationMetadata`.
pub mod operation_metadata {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Created = 1,
        Running = 2,
        Done = 3,
        Cancelled = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Created => "CREATED",
                State::Running => "RUNNING",
                State::Done => "DONE",
                State::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATED" => Some(Self::Created),
                "RUNNING" => Some(Self::Running),
                "DONE" => Some(Self::Done),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Likelihood {
    Unknown = 0,
    VeryUnlikely = 1,
    Unlikely = 2,
    Possible = 3,
    Likely = 4,
    VeryLikely = 5,
}
impl Likelihood {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Likelihood::Unknown => "UNKNOWN",
            Likelihood::VeryUnlikely => "VERY_UNLIKELY",
            Likelihood::Unlikely => "UNLIKELY",
            Likelihood::Possible => "POSSIBLE",
            Likelihood::Likely => "LIKELY",
            Likelihood::VeryLikely => "VERY_LIKELY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "VERY_UNLIKELY" => Some(Self::VeryUnlikely),
            "UNLIKELY" => Some(Self::Unlikely),
            "POSSIBLE" => Some(Self::Possible),
            "LIKELY" => Some(Self::Likely),
            "VERY_LIKELY" => Some(Self::VeryLikely),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod image_annotator_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Service that performs Google Cloud Vision API detection tasks over client
    /// images, such as face, landmark, logo, label, and text detection. The
    /// ImageAnnotator service returns detected entities from the images.
    #[derive(Debug, Clone)]
    pub struct ImageAnnotatorClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ImageAnnotatorClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ImageAnnotatorClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ImageAnnotatorClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Run image detection and annotation for a batch of images.
        pub async fn batch_annotate_images(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchAnnotateImagesRequest>,
        ) -> std::result::Result<tonic::Response<super::BatchAnnotateImagesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ImageAnnotator/BatchAnnotateImages",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ImageAnnotator",
                "BatchAnnotateImages",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Service that performs image detection and annotation for a batch of files.
        /// Now only "application/pdf", "image/tiff" and "image/gif" are supported.
        ///
        /// This service will extract at most 5 (customers can specify which 5 in
        /// AnnotateFileRequest.pages) frames (gif) or pages (pdf or tiff) from each
        /// file provided and perform detection and annotation for each image
        /// extracted.
        pub async fn batch_annotate_files(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchAnnotateFilesRequest>,
        ) -> std::result::Result<tonic::Response<super::BatchAnnotateFilesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ImageAnnotator/BatchAnnotateFiles",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ImageAnnotator",
                "BatchAnnotateFiles",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Run asynchronous image detection and annotation for a list of images.
        ///
        /// Progress and results can be retrieved through the
        /// `google.longrunning.Operations` interface.
        /// `Operation.metadata` contains `OperationMetadata` (metadata).
        /// `Operation.response` contains `AsyncBatchAnnotateImagesResponse` (results).
        ///
        /// This service will write image annotation outputs to json files in customer
        /// GCS bucket, each json file containing BatchAnnotateImagesResponse proto.
        pub async fn async_batch_annotate_images(
            &mut self,
            request: impl tonic::IntoRequest<super::AsyncBatchAnnotateImagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ImageAnnotator/AsyncBatchAnnotateImages",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ImageAnnotator",
                "AsyncBatchAnnotateImages",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Run asynchronous image detection and annotation for a list of generic
        /// files, such as PDF files, which may contain multiple pages and multiple
        /// images per page. Progress and results can be retrieved through the
        /// `google.longrunning.Operations` interface.
        /// `Operation.metadata` contains `OperationMetadata` (metadata).
        /// `Operation.response` contains `AsyncBatchAnnotateFilesResponse` (results).
        pub async fn async_batch_annotate_files(
            &mut self,
            request: impl tonic::IntoRequest<super::AsyncBatchAnnotateFilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vision.v1p4beta1.ImageAnnotator/AsyncBatchAnnotateFiles",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.vision.v1p4beta1.ImageAnnotator",
                "AsyncBatchAnnotateFiles",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
