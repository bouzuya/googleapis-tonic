// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypedValue {
    #[prost(oneof = "typed_value::Value", tags = "1, 2, 3, 4, 5")]
    pub value: ::core::option::Option<typed_value::Value>,
}
/// Nested message and enum types in `TypedValue`.
pub mod typed_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(bool, tag = "1")]
        BoolValue(bool),
        #[prost(int64, tag = "2")]
        Int64Value(i64),
        #[prost(double, tag = "3")]
        DoubleValue(f64),
        #[prost(string, tag = "4")]
        StringValue(::prost::alloc::string::String),
        #[prost(message, tag = "5")]
        DistributionValue(super::super::super::api::Distribution),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeInterval {
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aggregation {
    #[prost(message, optional, tag = "1")]
    pub alignment_period: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "aggregation::Aligner", tag = "2")]
    pub per_series_aligner: i32,
    #[prost(enumeration = "aggregation::Reducer", tag = "4")]
    pub cross_series_reducer: i32,
    #[prost(string, repeated, tag = "5")]
    pub group_by_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Aggregation`.
pub mod aggregation {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Aligner {
        AlignNone = 0,
        AlignDelta = 1,
        AlignRate = 2,
        AlignInterpolate = 3,
        AlignNextOlder = 4,
        AlignMin = 10,
        AlignMax = 11,
        AlignMean = 12,
        AlignCount = 13,
        AlignSum = 14,
        AlignStddev = 15,
        AlignCountTrue = 16,
        AlignCountFalse = 24,
        AlignFractionTrue = 17,
        AlignPercentile99 = 18,
        AlignPercentile95 = 19,
        AlignPercentile50 = 20,
        AlignPercentile05 = 21,
        AlignPercentChange = 23,
    }
    impl Aligner {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Aligner::AlignNone => "ALIGN_NONE",
                Aligner::AlignDelta => "ALIGN_DELTA",
                Aligner::AlignRate => "ALIGN_RATE",
                Aligner::AlignInterpolate => "ALIGN_INTERPOLATE",
                Aligner::AlignNextOlder => "ALIGN_NEXT_OLDER",
                Aligner::AlignMin => "ALIGN_MIN",
                Aligner::AlignMax => "ALIGN_MAX",
                Aligner::AlignMean => "ALIGN_MEAN",
                Aligner::AlignCount => "ALIGN_COUNT",
                Aligner::AlignSum => "ALIGN_SUM",
                Aligner::AlignStddev => "ALIGN_STDDEV",
                Aligner::AlignCountTrue => "ALIGN_COUNT_TRUE",
                Aligner::AlignCountFalse => "ALIGN_COUNT_FALSE",
                Aligner::AlignFractionTrue => "ALIGN_FRACTION_TRUE",
                Aligner::AlignPercentile99 => "ALIGN_PERCENTILE_99",
                Aligner::AlignPercentile95 => "ALIGN_PERCENTILE_95",
                Aligner::AlignPercentile50 => "ALIGN_PERCENTILE_50",
                Aligner::AlignPercentile05 => "ALIGN_PERCENTILE_05",
                Aligner::AlignPercentChange => "ALIGN_PERCENT_CHANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALIGN_NONE" => Some(Self::AlignNone),
                "ALIGN_DELTA" => Some(Self::AlignDelta),
                "ALIGN_RATE" => Some(Self::AlignRate),
                "ALIGN_INTERPOLATE" => Some(Self::AlignInterpolate),
                "ALIGN_NEXT_OLDER" => Some(Self::AlignNextOlder),
                "ALIGN_MIN" => Some(Self::AlignMin),
                "ALIGN_MAX" => Some(Self::AlignMax),
                "ALIGN_MEAN" => Some(Self::AlignMean),
                "ALIGN_COUNT" => Some(Self::AlignCount),
                "ALIGN_SUM" => Some(Self::AlignSum),
                "ALIGN_STDDEV" => Some(Self::AlignStddev),
                "ALIGN_COUNT_TRUE" => Some(Self::AlignCountTrue),
                "ALIGN_COUNT_FALSE" => Some(Self::AlignCountFalse),
                "ALIGN_FRACTION_TRUE" => Some(Self::AlignFractionTrue),
                "ALIGN_PERCENTILE_99" => Some(Self::AlignPercentile99),
                "ALIGN_PERCENTILE_95" => Some(Self::AlignPercentile95),
                "ALIGN_PERCENTILE_50" => Some(Self::AlignPercentile50),
                "ALIGN_PERCENTILE_05" => Some(Self::AlignPercentile05),
                "ALIGN_PERCENT_CHANGE" => Some(Self::AlignPercentChange),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Reducer {
        ReduceNone = 0,
        ReduceMean = 1,
        ReduceMin = 2,
        ReduceMax = 3,
        ReduceSum = 4,
        ReduceStddev = 5,
        ReduceCount = 6,
        ReduceCountTrue = 7,
        ReduceCountFalse = 15,
        ReduceFractionTrue = 8,
        ReducePercentile99 = 9,
        ReducePercentile95 = 10,
        ReducePercentile50 = 11,
        ReducePercentile05 = 12,
    }
    impl Reducer {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reducer::ReduceNone => "REDUCE_NONE",
                Reducer::ReduceMean => "REDUCE_MEAN",
                Reducer::ReduceMin => "REDUCE_MIN",
                Reducer::ReduceMax => "REDUCE_MAX",
                Reducer::ReduceSum => "REDUCE_SUM",
                Reducer::ReduceStddev => "REDUCE_STDDEV",
                Reducer::ReduceCount => "REDUCE_COUNT",
                Reducer::ReduceCountTrue => "REDUCE_COUNT_TRUE",
                Reducer::ReduceCountFalse => "REDUCE_COUNT_FALSE",
                Reducer::ReduceFractionTrue => "REDUCE_FRACTION_TRUE",
                Reducer::ReducePercentile99 => "REDUCE_PERCENTILE_99",
                Reducer::ReducePercentile95 => "REDUCE_PERCENTILE_95",
                Reducer::ReducePercentile50 => "REDUCE_PERCENTILE_50",
                Reducer::ReducePercentile05 => "REDUCE_PERCENTILE_05",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REDUCE_NONE" => Some(Self::ReduceNone),
                "REDUCE_MEAN" => Some(Self::ReduceMean),
                "REDUCE_MIN" => Some(Self::ReduceMin),
                "REDUCE_MAX" => Some(Self::ReduceMax),
                "REDUCE_SUM" => Some(Self::ReduceSum),
                "REDUCE_STDDEV" => Some(Self::ReduceStddev),
                "REDUCE_COUNT" => Some(Self::ReduceCount),
                "REDUCE_COUNT_TRUE" => Some(Self::ReduceCountTrue),
                "REDUCE_COUNT_FALSE" => Some(Self::ReduceCountFalse),
                "REDUCE_FRACTION_TRUE" => Some(Self::ReduceFractionTrue),
                "REDUCE_PERCENTILE_99" => Some(Self::ReducePercentile99),
                "REDUCE_PERCENTILE_95" => Some(Self::ReducePercentile95),
                "REDUCE_PERCENTILE_50" => Some(Self::ReducePercentile50),
                "REDUCE_PERCENTILE_05" => Some(Self::ReducePercentile05),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComparisonType {
    ComparisonUnspecified = 0,
    ComparisonGt = 1,
    ComparisonGe = 2,
    ComparisonLt = 3,
    ComparisonLe = 4,
    ComparisonEq = 5,
    ComparisonNe = 6,
}
impl ComparisonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ComparisonType::ComparisonUnspecified => "COMPARISON_UNSPECIFIED",
            ComparisonType::ComparisonGt => "COMPARISON_GT",
            ComparisonType::ComparisonGe => "COMPARISON_GE",
            ComparisonType::ComparisonLt => "COMPARISON_LT",
            ComparisonType::ComparisonLe => "COMPARISON_LE",
            ComparisonType::ComparisonEq => "COMPARISON_EQ",
            ComparisonType::ComparisonNe => "COMPARISON_NE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPARISON_UNSPECIFIED" => Some(Self::ComparisonUnspecified),
            "COMPARISON_GT" => Some(Self::ComparisonGt),
            "COMPARISON_GE" => Some(Self::ComparisonGe),
            "COMPARISON_LT" => Some(Self::ComparisonLt),
            "COMPARISON_LE" => Some(Self::ComparisonLe),
            "COMPARISON_EQ" => Some(Self::ComparisonEq),
            "COMPARISON_NE" => Some(Self::ComparisonNe),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServiceTier {
    Unspecified = 0,
    Basic = 1,
    Premium = 2,
}
impl ServiceTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ServiceTier::Unspecified => "SERVICE_TIER_UNSPECIFIED",
            ServiceTier::Basic => "SERVICE_TIER_BASIC",
            ServiceTier::Premium => "SERVICE_TIER_PREMIUM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVICE_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "SERVICE_TIER_BASIC" => Some(Self::Basic),
            "SERVICE_TIER_PREMIUM" => Some(Self::Premium),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<TimeInterval>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<TypedValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
    #[prost(message, optional, tag = "1")]
    pub metric: ::core::option::Option<super::super::api::Metric>,
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<super::super::api::MonitoredResource>,
    #[prost(message, optional, tag = "7")]
    pub metadata: ::core::option::Option<super::super::api::MonitoredResourceMetadata>,
    #[prost(
        enumeration = "super::super::api::metric_descriptor::MetricKind",
        tag = "3"
    )]
    pub metric_kind: i32,
    #[prost(
        enumeration = "super::super::api::metric_descriptor::ValueType",
        tag = "4"
    )]
    pub value_type: i32,
    #[prost(message, repeated, tag = "5")]
    pub points: ::prost::alloc::vec::Vec<Point>,
    #[prost(string, tag = "8")]
    pub unit: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesDescriptor {
    #[prost(message, repeated, tag = "1")]
    pub label_descriptors: ::prost::alloc::vec::Vec<super::super::api::LabelDescriptor>,
    #[prost(message, repeated, tag = "5")]
    pub point_descriptors: ::prost::alloc::vec::Vec<time_series_descriptor::ValueDescriptor>,
}
/// Nested message and enum types in `TimeSeriesDescriptor`.
pub mod time_series_descriptor {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValueDescriptor {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(
            enumeration = "super::super::super::api::metric_descriptor::ValueType",
            tag = "2"
        )]
        pub value_type: i32,
        #[prost(
            enumeration = "super::super::super::api::metric_descriptor::MetricKind",
            tag = "3"
        )]
        pub metric_kind: i32,
        #[prost(string, tag = "4")]
        pub unit: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesData {
    #[prost(message, repeated, tag = "1")]
    pub label_values: ::prost::alloc::vec::Vec<LabelValue>,
    #[prost(message, repeated, tag = "2")]
    pub point_data: ::prost::alloc::vec::Vec<time_series_data::PointData>,
}
/// Nested message and enum types in `TimeSeriesData`.
pub mod time_series_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PointData {
        #[prost(message, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<super::TypedValue>,
        #[prost(message, optional, tag = "2")]
        pub time_interval: ::core::option::Option<super::TimeInterval>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelValue {
    #[prost(oneof = "label_value::Value", tags = "1, 2, 3")]
    pub value: ::core::option::Option<label_value::Value>,
}
/// Nested message and enum types in `LabelValue`.
pub mod label_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(bool, tag = "1")]
        BoolValue(bool),
        #[prost(int64, tag = "2")]
        Int64Value(i64),
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryError {
    #[prost(message, optional, tag = "1")]
    pub locator: ::core::option::Option<TextLocator>,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextLocator {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub start_position: ::core::option::Option<text_locator::Position>,
    #[prost(message, optional, tag = "3")]
    pub end_position: ::core::option::Option<text_locator::Position>,
    #[prost(message, optional, boxed, tag = "4")]
    pub nested_locator: ::core::option::Option<::prost::alloc::boxed::Box<TextLocator>>,
    #[prost(string, tag = "5")]
    pub nesting_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TextLocator`.
pub mod text_locator {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Position {
        #[prost(int32, tag = "1")]
        pub line: i32,
        #[prost(int32, tag = "2")]
        pub column: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMonitoredResourceDescriptorsRequest {
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMonitoredResourceDescriptorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub resource_descriptors:
        ::prost::alloc::vec::Vec<super::super::api::MonitoredResourceDescriptor>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMonitoredResourceDescriptorRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetricDescriptorsRequest {
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetricDescriptorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub metric_descriptors: ::prost::alloc::vec::Vec<super::super::api::MetricDescriptor>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricDescriptorRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetricDescriptorRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metric_descriptor: ::core::option::Option<super::super::api::MetricDescriptor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMetricDescriptorRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTimeSeriesRequest {
    #[prost(string, tag = "10")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub interval: ::core::option::Option<TimeInterval>,
    #[prost(message, optional, tag = "5")]
    pub aggregation: ::core::option::Option<Aggregation>,
    #[prost(message, optional, tag = "11")]
    pub secondary_aggregation: ::core::option::Option<Aggregation>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(enumeration = "list_time_series_request::TimeSeriesView", tag = "7")]
    pub view: i32,
    #[prost(int32, tag = "8")]
    pub page_size: i32,
    #[prost(string, tag = "9")]
    pub page_token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ListTimeSeriesRequest`.
pub mod list_time_series_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TimeSeriesView {
        Full = 0,
        Headers = 1,
    }
    impl TimeSeriesView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TimeSeriesView::Full => "FULL",
                TimeSeriesView::Headers => "HEADERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FULL" => Some(Self::Full),
                "HEADERS" => Some(Self::Headers),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTimeSeriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub time_series: ::prost::alloc::vec::Vec<TimeSeries>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub execution_errors: ::prost::alloc::vec::Vec<super::super::rpc::Status>,
    #[prost(string, tag = "5")]
    pub unit: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTimeSeriesRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub time_series: ::prost::alloc::vec::Vec<TimeSeries>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTimeSeriesError {
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub time_series: ::core::option::Option<TimeSeries>,
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTimeSeriesSummary {
    #[prost(int32, tag = "1")]
    pub total_point_count: i32,
    #[prost(int32, tag = "2")]
    pub success_point_count: i32,
    #[prost(message, repeated, tag = "3")]
    pub errors: ::prost::alloc::vec::Vec<create_time_series_summary::Error>,
}
/// Nested message and enum types in `CreateTimeSeriesSummary`.
pub mod create_time_series_summary {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Error {
        #[prost(message, optional, tag = "1")]
        pub status: ::core::option::Option<super::super::super::rpc::Status>,
        #[prost(int32, tag = "2")]
        pub point_count: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTimeSeriesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub query: ::prost::alloc::string::String,
    #[prost(int32, tag = "9")]
    pub page_size: i32,
    #[prost(string, tag = "10")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTimeSeriesResponse {
    #[prost(message, optional, tag = "8")]
    pub time_series_descriptor: ::core::option::Option<TimeSeriesDescriptor>,
    #[prost(message, repeated, tag = "9")]
    pub time_series_data: ::prost::alloc::vec::Vec<TimeSeriesData>,
    #[prost(string, tag = "10")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryErrorList {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<QueryError>,
    #[prost(string, tag = "2")]
    pub error_summary: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod metric_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Manages metric descriptors, monitored resource descriptors, and
    /// time series data.
    #[derive(Debug, Clone)]
    pub struct MetricServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MetricServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MetricServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            MetricServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists monitored resource descriptors that match a filter.
        pub async fn list_monitored_resource_descriptors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMonitoredResourceDescriptorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMonitoredResourceDescriptorsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/ListMonitoredResourceDescriptors",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "ListMonitoredResourceDescriptors",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single monitored resource descriptor.
        pub async fn get_monitored_resource_descriptor(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMonitoredResourceDescriptorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::api::MonitoredResourceDescriptor>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/GetMonitoredResourceDescriptor",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "GetMonitoredResourceDescriptor",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists metric descriptors that match a filter.
        pub async fn list_metric_descriptors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMetricDescriptorsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListMetricDescriptorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/ListMetricDescriptors",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "ListMetricDescriptors",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single metric descriptor.
        pub async fn get_metric_descriptor(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMetricDescriptorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::api::MetricDescriptor>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/GetMetricDescriptor",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "GetMetricDescriptor",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new metric descriptor.
        /// The creation is executed asynchronously.
        /// User-created metric descriptors define
        /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics).
        /// The metric descriptor is updated if it already exists,
        /// except that metric labels are never removed.
        pub async fn create_metric_descriptor(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMetricDescriptorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::api::MetricDescriptor>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/CreateMetricDescriptor",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "CreateMetricDescriptor",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a metric descriptor. Only user-created
        /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics) can be
        /// deleted.
        pub async fn delete_metric_descriptor(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMetricDescriptorRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/DeleteMetricDescriptor",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "DeleteMetricDescriptor",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists time series that match a filter.
        pub async fn list_time_series(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTimeSeriesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListTimeSeriesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/ListTimeSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "ListTimeSeries",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates or adds data to one or more time series.
        /// The response is empty if all time series in the request were written.
        /// If any time series could not be written, a corresponding failure message is
        /// included in the error response.
        /// This method does not support
        /// [resource locations constraint of an organization
        /// policy](https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy).
        pub async fn create_time_series(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTimeSeriesRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/CreateTimeSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "CreateTimeSeries",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates or adds data to one or more service time series. A service time
        /// series is a time series for a metric from a Google Cloud service. The
        /// response is empty if all time series in the request were written. If any
        /// time series could not be written, a corresponding failure message is
        /// included in the error response. This endpoint rejects writes to
        /// user-defined metrics.
        /// This method is only for use by Google Cloud services. Use
        /// [projects.timeSeries.create][google.monitoring.v3.MetricService.CreateTimeSeries]
        /// instead.
        pub async fn create_service_time_series(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTimeSeriesRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.MetricService/CreateServiceTimeSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.MetricService",
                "CreateServiceTimeSeries",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod query_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The QueryService API is used to manage time series data in Cloud
    /// Monitoring. Time series data is a collection of data points that describes
    /// the time-varying values of a metric.
    #[derive(Debug, Clone)]
    pub struct QueryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> QueryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            QueryServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Queries time series using Monitoring Query Language.
        pub async fn query_time_series(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryTimeSeriesRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryTimeSeriesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.QueryService/QueryTimeSeries",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.QueryService",
                "QueryTimeSeries",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub parent_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub is_cluster: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutationRecord {
    #[prost(message, optional, tag = "1")]
    pub mutate_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub mutated_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationChannelDescriptor {
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub labels: ::prost::alloc::vec::Vec<super::super::api::LabelDescriptor>,
    #[deprecated]
    #[prost(enumeration = "ServiceTier", repeated, packed = "false", tag = "5")]
    pub supported_tiers: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "super::super::api::LaunchStage", tag = "7")]
    pub launch_stage: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationChannel {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "5")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(btree_map = "string, string", tag = "8")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "notification_channel::VerificationStatus", tag = "9")]
    pub verification_status: i32,
    #[prost(message, optional, tag = "11")]
    pub enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "12")]
    pub creation_record: ::core::option::Option<MutationRecord>,
    #[prost(message, repeated, tag = "13")]
    pub mutation_records: ::prost::alloc::vec::Vec<MutationRecord>,
}
/// Nested message and enum types in `NotificationChannel`.
pub mod notification_channel {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum VerificationStatus {
        Unspecified = 0,
        Unverified = 1,
        Verified = 2,
    }
    impl VerificationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VerificationStatus::Unspecified => "VERIFICATION_STATUS_UNSPECIFIED",
                VerificationStatus::Unverified => "UNVERIFIED",
                VerificationStatus::Verified => "VERIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERIFICATION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "UNVERIFIED" => Some(Self::Unverified),
                "VERIFIED" => Some(Self::Verified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlertPolicy {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub documentation: ::core::option::Option<alert_policy::Documentation>,
    #[prost(btree_map = "string, string", tag = "16")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "12")]
    pub conditions: ::prost::alloc::vec::Vec<alert_policy::Condition>,
    #[prost(enumeration = "alert_policy::ConditionCombinerType", tag = "6")]
    pub combiner: i32,
    #[prost(message, optional, tag = "17")]
    pub enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "18")]
    pub validity: ::core::option::Option<super::super::rpc::Status>,
    #[prost(string, repeated, tag = "14")]
    pub notification_channels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "10")]
    pub creation_record: ::core::option::Option<MutationRecord>,
    #[prost(message, optional, tag = "11")]
    pub mutation_record: ::core::option::Option<MutationRecord>,
    #[prost(message, optional, tag = "21")]
    pub alert_strategy: ::core::option::Option<alert_policy::AlertStrategy>,
    #[prost(enumeration = "alert_policy::Severity", tag = "22")]
    pub severity: i32,
}
/// Nested message and enum types in `AlertPolicy`.
pub mod alert_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Documentation {
        #[prost(string, tag = "1")]
        pub content: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub mime_type: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub subject: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub links: ::prost::alloc::vec::Vec<documentation::Link>,
    }
    /// Nested message and enum types in `Documentation`.
    pub mod documentation {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Link {
            #[prost(string, tag = "1")]
            pub display_name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub url: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Condition {
        #[prost(string, tag = "12")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(oneof = "condition::Condition", tags = "1, 2, 20, 19, 21")]
        pub condition: ::core::option::Option<condition::Condition>,
    }
    /// Nested message and enum types in `Condition`.
    pub mod condition {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Trigger {
            #[prost(oneof = "trigger::Type", tags = "1, 2")]
            pub r#type: ::core::option::Option<trigger::Type>,
        }
        /// Nested message and enum types in `Trigger`.
        pub mod trigger {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
            pub enum Type {
                #[prost(int32, tag = "1")]
                Count(i32),
                #[prost(double, tag = "2")]
                Percent(f64),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MetricThreshold {
            #[prost(string, tag = "2")]
            pub filter: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "8")]
            pub aggregations: ::prost::alloc::vec::Vec<super::super::Aggregation>,
            #[prost(string, tag = "9")]
            pub denominator_filter: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "10")]
            pub denominator_aggregations: ::prost::alloc::vec::Vec<super::super::Aggregation>,
            #[prost(message, optional, tag = "12")]
            pub forecast_options: ::core::option::Option<metric_threshold::ForecastOptions>,
            #[prost(enumeration = "super::super::ComparisonType", tag = "4")]
            pub comparison: i32,
            #[prost(double, tag = "5")]
            pub threshold_value: f64,
            #[prost(message, optional, tag = "6")]
            pub duration: ::core::option::Option<::prost_types::Duration>,
            #[prost(message, optional, tag = "7")]
            pub trigger: ::core::option::Option<Trigger>,
            #[prost(enumeration = "EvaluationMissingData", tag = "11")]
            pub evaluation_missing_data: i32,
        }
        /// Nested message and enum types in `MetricThreshold`.
        pub mod metric_threshold {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct ForecastOptions {
                #[prost(message, optional, tag = "1")]
                pub forecast_horizon: ::core::option::Option<::prost_types::Duration>,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MetricAbsence {
            #[prost(string, tag = "1")]
            pub filter: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "5")]
            pub aggregations: ::prost::alloc::vec::Vec<super::super::Aggregation>,
            #[prost(message, optional, tag = "2")]
            pub duration: ::core::option::Option<::prost_types::Duration>,
            #[prost(message, optional, tag = "3")]
            pub trigger: ::core::option::Option<Trigger>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LogMatch {
            #[prost(string, tag = "1")]
            pub filter: ::prost::alloc::string::String,
            #[prost(btree_map = "string, string", tag = "2")]
            pub label_extractors: ::prost::alloc::collections::BTreeMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MonitoringQueryLanguageCondition {
            #[prost(string, tag = "1")]
            pub query: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub duration: ::core::option::Option<::prost_types::Duration>,
            #[prost(message, optional, tag = "3")]
            pub trigger: ::core::option::Option<Trigger>,
            #[prost(enumeration = "EvaluationMissingData", tag = "4")]
            pub evaluation_missing_data: i32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PrometheusQueryLanguageCondition {
            #[prost(string, tag = "1")]
            pub query: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub duration: ::core::option::Option<::prost_types::Duration>,
            #[prost(message, optional, tag = "3")]
            pub evaluation_interval: ::core::option::Option<::prost_types::Duration>,
            #[prost(btree_map = "string, string", tag = "4")]
            pub labels: ::prost::alloc::collections::BTreeMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
            #[prost(string, tag = "5")]
            pub rule_group: ::prost::alloc::string::String,
            #[prost(string, tag = "6")]
            pub alert_rule: ::prost::alloc::string::String,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum EvaluationMissingData {
            Unspecified = 0,
            Inactive = 1,
            Active = 2,
            NoOp = 3,
        }
        impl EvaluationMissingData {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    EvaluationMissingData::Unspecified => "EVALUATION_MISSING_DATA_UNSPECIFIED",
                    EvaluationMissingData::Inactive => "EVALUATION_MISSING_DATA_INACTIVE",
                    EvaluationMissingData::Active => "EVALUATION_MISSING_DATA_ACTIVE",
                    EvaluationMissingData::NoOp => "EVALUATION_MISSING_DATA_NO_OP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "EVALUATION_MISSING_DATA_UNSPECIFIED" => Some(Self::Unspecified),
                    "EVALUATION_MISSING_DATA_INACTIVE" => Some(Self::Inactive),
                    "EVALUATION_MISSING_DATA_ACTIVE" => Some(Self::Active),
                    "EVALUATION_MISSING_DATA_NO_OP" => Some(Self::NoOp),
                    _ => None,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Condition {
            #[prost(message, tag = "1")]
            ConditionThreshold(MetricThreshold),
            #[prost(message, tag = "2")]
            ConditionAbsent(MetricAbsence),
            #[prost(message, tag = "20")]
            ConditionMatchedLog(LogMatch),
            #[prost(message, tag = "19")]
            ConditionMonitoringQueryLanguage(MonitoringQueryLanguageCondition),
            #[prost(message, tag = "21")]
            ConditionPrometheusQueryLanguage(PrometheusQueryLanguageCondition),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AlertStrategy {
        #[prost(message, optional, tag = "1")]
        pub notification_rate_limit: ::core::option::Option<alert_strategy::NotificationRateLimit>,
        #[prost(message, optional, tag = "3")]
        pub auto_close: ::core::option::Option<::prost_types::Duration>,
        #[prost(message, repeated, tag = "4")]
        pub notification_channel_strategy:
            ::prost::alloc::vec::Vec<alert_strategy::NotificationChannelStrategy>,
    }
    /// Nested message and enum types in `AlertStrategy`.
    pub mod alert_strategy {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NotificationRateLimit {
            #[prost(message, optional, tag = "1")]
            pub period: ::core::option::Option<::prost_types::Duration>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct NotificationChannelStrategy {
            #[prost(string, repeated, tag = "1")]
            pub notification_channel_names:
                ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "2")]
            pub renotify_interval: ::core::option::Option<::prost_types::Duration>,
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ConditionCombinerType {
        CombineUnspecified = 0,
        And = 1,
        Or = 2,
        AndWithMatchingResource = 3,
    }
    impl ConditionCombinerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConditionCombinerType::CombineUnspecified => "COMBINE_UNSPECIFIED",
                ConditionCombinerType::And => "AND",
                ConditionCombinerType::Or => "OR",
                ConditionCombinerType::AndWithMatchingResource => "AND_WITH_MATCHING_RESOURCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMBINE_UNSPECIFIED" => Some(Self::CombineUnspecified),
                "AND" => Some(Self::And),
                "OR" => Some(Self::Or),
                "AND_WITH_MATCHING_RESOURCE" => Some(Self::AndWithMatchingResource),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Severity {
        Unspecified = 0,
        Critical = 1,
        Error = 2,
        Warning = 3,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Severity::Unspecified => "SEVERITY_UNSPECIFIED",
                Severity::Critical => "CRITICAL",
                Severity::Error => "ERROR",
                Severity::Warning => "WARNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "CRITICAL" => Some(Self::Critical),
                "ERROR" => Some(Self::Error),
                "WARNING" => Some(Self::Warning),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAlertPolicyRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub alert_policy: ::core::option::Option<AlertPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAlertPolicyRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAlertPoliciesRequest {
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAlertPoliciesResponse {
    #[prost(message, repeated, tag = "3")]
    pub alert_policies: ::prost::alloc::vec::Vec<AlertPolicy>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAlertPolicyRequest {
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "3")]
    pub alert_policy: ::core::option::Option<AlertPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAlertPolicyRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod alert_policy_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The AlertPolicyService API is used to manage (list, create, delete,
    /// edit) alert policies in Cloud Monitoring. An alerting policy is
    /// a description of the conditions under which some aspect of your
    /// system is considered to be "unhealthy" and the ways to notify
    /// people or services about this state. In addition to using this API, alert
    /// policies can also be managed through
    /// [Cloud Monitoring](https://cloud.google.com/monitoring/docs/),
    /// which can be reached by clicking the "Monitoring" tab in
    /// [Cloud console](https://console.cloud.google.com/).
    #[derive(Debug, Clone)]
    pub struct AlertPolicyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AlertPolicyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AlertPolicyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AlertPolicyServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists the existing alerting policies for the workspace.
        pub async fn list_alert_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAlertPoliciesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListAlertPoliciesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.AlertPolicyService/ListAlertPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.AlertPolicyService",
                "ListAlertPolicies",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single alerting policy.
        pub async fn get_alert_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAlertPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::AlertPolicy>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.AlertPolicyService/GetAlertPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.AlertPolicyService",
                "GetAlertPolicy",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new alerting policy.
        ///
        /// Design your application to single-thread API calls that modify the state of
        /// alerting policies in a single project. This includes calls to
        /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
        pub async fn create_alert_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAlertPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::AlertPolicy>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.AlertPolicyService/CreateAlertPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.AlertPolicyService",
                "CreateAlertPolicy",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an alerting policy.
        ///
        /// Design your application to single-thread API calls that modify the state of
        /// alerting policies in a single project. This includes calls to
        /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
        pub async fn delete_alert_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAlertPolicyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.AlertPolicyService/DeleteAlertPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.AlertPolicyService",
                "DeleteAlertPolicy",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an alerting policy. You can either replace the entire policy with
        /// a new one or replace only certain fields in the current alerting policy by
        /// specifying the fields to be updated via `updateMask`. Returns the
        /// updated alerting policy.
        ///
        /// Design your application to single-thread API calls that modify the state of
        /// alerting policies in a single project. This includes calls to
        /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
        pub async fn update_alert_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAlertPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::AlertPolicy>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.AlertPolicyService/UpdateAlertPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.AlertPolicyService",
                "UpdateAlertPolicy",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanContext {
    #[prost(string, tag = "1")]
    pub span_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternalChecker {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub gcp_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub peer_project_id: ::prost::alloc::string::String,
    #[prost(enumeration = "internal_checker::State", tag = "7")]
    pub state: i32,
}
/// Nested message and enum types in `InternalChecker`.
pub mod internal_checker {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Running = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Creating => "CREATING",
                State::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyntheticMonitorTarget {
    #[prost(oneof = "synthetic_monitor_target::Target", tags = "1")]
    pub target: ::core::option::Option<synthetic_monitor_target::Target>,
}
/// Nested message and enum types in `SyntheticMonitorTarget`.
pub mod synthetic_monitor_target {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudFunctionV2Target {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub cloud_run_revision: ::core::option::Option<super::super::super::api::MonitoredResource>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(message, tag = "1")]
        CloudFunctionV2(CloudFunctionV2Target),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UptimeCheckConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub period: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "8")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, repeated, tag = "9")]
    pub content_matchers: ::prost::alloc::vec::Vec<uptime_check_config::ContentMatcher>,
    #[prost(enumeration = "uptime_check_config::CheckerType", tag = "17")]
    pub checker_type: i32,
    #[prost(enumeration = "UptimeCheckRegion", repeated, tag = "10")]
    pub selected_regions: ::prost::alloc::vec::Vec<i32>,
    #[deprecated]
    #[prost(bool, tag = "15")]
    pub is_internal: bool,
    #[deprecated]
    #[prost(message, repeated, tag = "14")]
    pub internal_checkers: ::prost::alloc::vec::Vec<InternalChecker>,
    #[prost(btree_map = "string, string", tag = "20")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "uptime_check_config::Resource", tags = "3, 4, 21")]
    pub resource: ::core::option::Option<uptime_check_config::Resource>,
    #[prost(oneof = "uptime_check_config::CheckRequestType", tags = "5, 6")]
    pub check_request_type: ::core::option::Option<uptime_check_config::CheckRequestType>,
}
/// Nested message and enum types in `UptimeCheckConfig`.
pub mod uptime_check_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceGroup {
        #[prost(string, tag = "1")]
        pub group_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::GroupResourceType", tag = "2")]
        pub resource_type: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PingConfig {
        #[prost(int32, tag = "1")]
        pub pings_count: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HttpCheck {
        #[prost(enumeration = "http_check::RequestMethod", tag = "8")]
        pub request_method: i32,
        #[prost(bool, tag = "1")]
        pub use_ssl: bool,
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
        #[prost(int32, tag = "3")]
        pub port: i32,
        #[prost(message, optional, tag = "4")]
        pub auth_info: ::core::option::Option<http_check::BasicAuthentication>,
        #[prost(bool, tag = "5")]
        pub mask_headers: bool,
        #[prost(btree_map = "string, string", tag = "6")]
        pub headers: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(enumeration = "http_check::ContentType", tag = "9")]
        pub content_type: i32,
        #[prost(string, tag = "13")]
        pub custom_content_type: ::prost::alloc::string::String,
        #[prost(bool, tag = "7")]
        pub validate_ssl: bool,
        #[prost(bytes = "bytes", tag = "10")]
        pub body: ::prost::bytes::Bytes,
        #[prost(message, repeated, tag = "11")]
        pub accepted_response_status_codes:
            ::prost::alloc::vec::Vec<http_check::ResponseStatusCode>,
        #[prost(message, optional, tag = "12")]
        pub ping_config: ::core::option::Option<PingConfig>,
        #[prost(oneof = "http_check::AuthMethod", tags = "14")]
        pub auth_method: ::core::option::Option<http_check::AuthMethod>,
    }
    /// Nested message and enum types in `HttpCheck`.
    pub mod http_check {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BasicAuthentication {
            #[prost(string, tag = "1")]
            pub username: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub password: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ResponseStatusCode {
            #[prost(oneof = "response_status_code::StatusCode", tags = "1, 2")]
            pub status_code: ::core::option::Option<response_status_code::StatusCode>,
        }
        /// Nested message and enum types in `ResponseStatusCode`.
        pub mod response_status_code {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum StatusClass {
                Unspecified = 0,
                StatusClass1xx = 100,
                StatusClass2xx = 200,
                StatusClass3xx = 300,
                StatusClass4xx = 400,
                StatusClass5xx = 500,
                Any = 1000,
            }
            impl StatusClass {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        StatusClass::Unspecified => "STATUS_CLASS_UNSPECIFIED",
                        StatusClass::StatusClass1xx => "STATUS_CLASS_1XX",
                        StatusClass::StatusClass2xx => "STATUS_CLASS_2XX",
                        StatusClass::StatusClass3xx => "STATUS_CLASS_3XX",
                        StatusClass::StatusClass4xx => "STATUS_CLASS_4XX",
                        StatusClass::StatusClass5xx => "STATUS_CLASS_5XX",
                        StatusClass::Any => "STATUS_CLASS_ANY",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATUS_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
                        "STATUS_CLASS_1XX" => Some(Self::StatusClass1xx),
                        "STATUS_CLASS_2XX" => Some(Self::StatusClass2xx),
                        "STATUS_CLASS_3XX" => Some(Self::StatusClass3xx),
                        "STATUS_CLASS_4XX" => Some(Self::StatusClass4xx),
                        "STATUS_CLASS_5XX" => Some(Self::StatusClass5xx),
                        "STATUS_CLASS_ANY" => Some(Self::Any),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
            pub enum StatusCode {
                #[prost(int32, tag = "1")]
                StatusValue(i32),
                #[prost(enumeration = "StatusClass", tag = "2")]
                StatusClass(i32),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ServiceAgentAuthentication {
            #[prost(
                enumeration = "service_agent_authentication::ServiceAgentAuthenticationType",
                tag = "1"
            )]
            pub r#type: i32,
        }
        /// Nested message and enum types in `ServiceAgentAuthentication`.
        pub mod service_agent_authentication {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum ServiceAgentAuthenticationType {
                Unspecified = 0,
                OidcToken = 1,
            }
            impl ServiceAgentAuthenticationType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        ServiceAgentAuthenticationType::Unspecified => {
                            "SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED"
                        }
                        ServiceAgentAuthenticationType::OidcToken => "OIDC_TOKEN",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "OIDC_TOKEN" => Some(Self::OidcToken),
                        _ => None,
                    }
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum RequestMethod {
            MethodUnspecified = 0,
            Get = 1,
            Post = 2,
        }
        impl RequestMethod {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    RequestMethod::MethodUnspecified => "METHOD_UNSPECIFIED",
                    RequestMethod::Get => "GET",
                    RequestMethod::Post => "POST",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "METHOD_UNSPECIFIED" => Some(Self::MethodUnspecified),
                    "GET" => Some(Self::Get),
                    "POST" => Some(Self::Post),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum ContentType {
            TypeUnspecified = 0,
            UrlEncoded = 1,
            UserProvided = 2,
        }
        impl ContentType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ContentType::TypeUnspecified => "TYPE_UNSPECIFIED",
                    ContentType::UrlEncoded => "URL_ENCODED",
                    ContentType::UserProvided => "USER_PROVIDED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::TypeUnspecified),
                    "URL_ENCODED" => Some(Self::UrlEncoded),
                    "USER_PROVIDED" => Some(Self::UserProvided),
                    _ => None,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum AuthMethod {
            #[prost(message, tag = "14")]
            ServiceAgentAuthentication(ServiceAgentAuthentication),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TcpCheck {
        #[prost(int32, tag = "1")]
        pub port: i32,
        #[prost(message, optional, tag = "2")]
        pub ping_config: ::core::option::Option<PingConfig>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContentMatcher {
        #[prost(string, tag = "1")]
        pub content: ::prost::alloc::string::String,
        #[prost(enumeration = "content_matcher::ContentMatcherOption", tag = "2")]
        pub matcher: i32,
        #[prost(oneof = "content_matcher::AdditionalMatcherInfo", tags = "3")]
        pub additional_matcher_info: ::core::option::Option<content_matcher::AdditionalMatcherInfo>,
    }
    /// Nested message and enum types in `ContentMatcher`.
    pub mod content_matcher {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonPathMatcher {
            #[prost(string, tag = "1")]
            pub json_path: ::prost::alloc::string::String,
            #[prost(enumeration = "json_path_matcher::JsonPathMatcherOption", tag = "2")]
            pub json_matcher: i32,
        }
        /// Nested message and enum types in `JsonPathMatcher`.
        pub mod json_path_matcher {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum JsonPathMatcherOption {
                Unspecified = 0,
                ExactMatch = 1,
                RegexMatch = 2,
            }
            impl JsonPathMatcherOption {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        JsonPathMatcherOption::Unspecified => {
                            "JSON_PATH_MATCHER_OPTION_UNSPECIFIED"
                        }
                        JsonPathMatcherOption::ExactMatch => "EXACT_MATCH",
                        JsonPathMatcherOption::RegexMatch => "REGEX_MATCH",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "JSON_PATH_MATCHER_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                        "EXACT_MATCH" => Some(Self::ExactMatch),
                        "REGEX_MATCH" => Some(Self::RegexMatch),
                        _ => None,
                    }
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum ContentMatcherOption {
            Unspecified = 0,
            ContainsString = 1,
            NotContainsString = 2,
            MatchesRegex = 3,
            NotMatchesRegex = 4,
            MatchesJsonPath = 5,
            NotMatchesJsonPath = 6,
        }
        impl ContentMatcherOption {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ContentMatcherOption::Unspecified => "CONTENT_MATCHER_OPTION_UNSPECIFIED",
                    ContentMatcherOption::ContainsString => "CONTAINS_STRING",
                    ContentMatcherOption::NotContainsString => "NOT_CONTAINS_STRING",
                    ContentMatcherOption::MatchesRegex => "MATCHES_REGEX",
                    ContentMatcherOption::NotMatchesRegex => "NOT_MATCHES_REGEX",
                    ContentMatcherOption::MatchesJsonPath => "MATCHES_JSON_PATH",
                    ContentMatcherOption::NotMatchesJsonPath => "NOT_MATCHES_JSON_PATH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONTENT_MATCHER_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                    "CONTAINS_STRING" => Some(Self::ContainsString),
                    "NOT_CONTAINS_STRING" => Some(Self::NotContainsString),
                    "MATCHES_REGEX" => Some(Self::MatchesRegex),
                    "NOT_MATCHES_REGEX" => Some(Self::NotMatchesRegex),
                    "MATCHES_JSON_PATH" => Some(Self::MatchesJsonPath),
                    "NOT_MATCHES_JSON_PATH" => Some(Self::NotMatchesJsonPath),
                    _ => None,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum AdditionalMatcherInfo {
            #[prost(message, tag = "3")]
            JsonPathMatcher(JsonPathMatcher),
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CheckerType {
        Unspecified = 0,
        StaticIpCheckers = 1,
        VpcCheckers = 3,
    }
    impl CheckerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CheckerType::Unspecified => "CHECKER_TYPE_UNSPECIFIED",
                CheckerType::StaticIpCheckers => "STATIC_IP_CHECKERS",
                CheckerType::VpcCheckers => "VPC_CHECKERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHECKER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STATIC_IP_CHECKERS" => Some(Self::StaticIpCheckers),
                "VPC_CHECKERS" => Some(Self::VpcCheckers),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Resource {
        #[prost(message, tag = "3")]
        MonitoredResource(super::super::super::api::MonitoredResource),
        #[prost(message, tag = "4")]
        ResourceGroup(ResourceGroup),
        #[prost(message, tag = "21")]
        SyntheticMonitor(super::SyntheticMonitorTarget),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CheckRequestType {
        #[prost(message, tag = "5")]
        HttpCheck(HttpCheck),
        #[prost(message, tag = "6")]
        TcpCheck(TcpCheck),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UptimeCheckIp {
    #[prost(enumeration = "UptimeCheckRegion", tag = "1")]
    pub region: i32,
    #[prost(string, tag = "2")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ip_address: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UptimeCheckRegion {
    RegionUnspecified = 0,
    Usa = 1,
    Europe = 2,
    SouthAmerica = 3,
    AsiaPacific = 4,
    UsaOregon = 5,
    UsaIowa = 6,
    UsaVirginia = 7,
}
impl UptimeCheckRegion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UptimeCheckRegion::RegionUnspecified => "REGION_UNSPECIFIED",
            UptimeCheckRegion::Usa => "USA",
            UptimeCheckRegion::Europe => "EUROPE",
            UptimeCheckRegion::SouthAmerica => "SOUTH_AMERICA",
            UptimeCheckRegion::AsiaPacific => "ASIA_PACIFIC",
            UptimeCheckRegion::UsaOregon => "USA_OREGON",
            UptimeCheckRegion::UsaIowa => "USA_IOWA",
            UptimeCheckRegion::UsaVirginia => "USA_VIRGINIA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REGION_UNSPECIFIED" => Some(Self::RegionUnspecified),
            "USA" => Some(Self::Usa),
            "EUROPE" => Some(Self::Europe),
            "SOUTH_AMERICA" => Some(Self::SouthAmerica),
            "ASIA_PACIFIC" => Some(Self::AsiaPacific),
            "USA_OREGON" => Some(Self::UsaOregon),
            "USA_IOWA" => Some(Self::UsaIowa),
            "USA_VIRGINIA" => Some(Self::UsaVirginia),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupResourceType {
    ResourceTypeUnspecified = 0,
    Instance = 1,
    AwsElbLoadBalancer = 2,
}
impl GroupResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GroupResourceType::ResourceTypeUnspecified => "RESOURCE_TYPE_UNSPECIFIED",
            GroupResourceType::Instance => "INSTANCE",
            GroupResourceType::AwsElbLoadBalancer => "AWS_ELB_LOAD_BALANCER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_TYPE_UNSPECIFIED" => Some(Self::ResourceTypeUnspecified),
            "INSTANCE" => Some(Self::Instance),
            "AWS_ELB_LOAD_BALANCER" => Some(Self::AwsElbLoadBalancer),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUptimeCheckConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUptimeCheckConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub uptime_check_configs: ::prost::alloc::vec::Vec<UptimeCheckConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUptimeCheckConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUptimeCheckConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub uptime_check_config: ::core::option::Option<UptimeCheckConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUptimeCheckConfigRequest {
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "3")]
    pub uptime_check_config: ::core::option::Option<UptimeCheckConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUptimeCheckConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUptimeCheckIpsRequest {
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUptimeCheckIpsResponse {
    #[prost(message, repeated, tag = "1")]
    pub uptime_check_ips: ::prost::alloc::vec::Vec<UptimeCheckIp>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod uptime_check_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The UptimeCheckService API is used to manage (list, create, delete, edit)
    /// Uptime check configurations in the Cloud Monitoring product. An Uptime
    /// check is a piece of configuration that determines which resources and
    /// services to monitor for availability. These configurations can also be
    /// configured interactively by navigating to the [Cloud console]
    /// (https://console.cloud.google.com), selecting the appropriate project,
    /// clicking on "Monitoring" on the left-hand side to navigate to Cloud
    /// Monitoring, and then clicking on "Uptime".
    #[derive(Debug, Clone)]
    pub struct UptimeCheckServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> UptimeCheckServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UptimeCheckServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            UptimeCheckServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists the existing valid Uptime check configurations for the project
        /// (leaving out any invalid configurations).
        pub async fn list_uptime_check_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUptimeCheckConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUptimeCheckConfigsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.UptimeCheckService/ListUptimeCheckConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.UptimeCheckService",
                "ListUptimeCheckConfigs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single Uptime check configuration.
        pub async fn get_uptime_check_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUptimeCheckConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::UptimeCheckConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.UptimeCheckService/GetUptimeCheckConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.UptimeCheckService",
                "GetUptimeCheckConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Uptime check configuration.
        pub async fn create_uptime_check_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUptimeCheckConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::UptimeCheckConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.UptimeCheckService/CreateUptimeCheckConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.UptimeCheckService",
                "CreateUptimeCheckConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an Uptime check configuration. You can either replace the entire
        /// configuration with a new one or replace only certain fields in the current
        /// configuration by specifying the fields to be updated via `updateMask`.
        /// Returns the updated configuration.
        pub async fn update_uptime_check_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUptimeCheckConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::UptimeCheckConfig>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.UptimeCheckService/UpdateUptimeCheckConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.UptimeCheckService",
                "UpdateUptimeCheckConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an Uptime check configuration. Note that this method will fail
        /// if the Uptime check configuration is referenced by an alert policy or
        /// other dependent configs that would be rendered invalid by the deletion.
        pub async fn delete_uptime_check_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUptimeCheckConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.UptimeCheckService/DeleteUptimeCheckConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.UptimeCheckService",
                "DeleteUptimeCheckConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of IP addresses that checkers run from
        pub async fn list_uptime_check_ips(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUptimeCheckIpsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListUptimeCheckIpsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.UptimeCheckService/ListUptimeCheckIps",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.UptimeCheckService",
                "ListUptimeCheckIps",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snooze {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub criteria: ::core::option::Option<snooze::Criteria>,
    #[prost(message, optional, tag = "4")]
    pub interval: ::core::option::Option<TimeInterval>,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Snooze`.
pub mod snooze {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Criteria {
        #[prost(string, repeated, tag = "1")]
        pub policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsRequest {
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(oneof = "list_groups_request::Filter", tags = "2, 3, 4")]
    pub filter: ::core::option::Option<list_groups_request::Filter>,
}
/// Nested message and enum types in `ListGroupsRequest`.
pub mod list_groups_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        #[prost(string, tag = "2")]
        ChildrenOfGroup(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        AncestorsOfGroup(::prost::alloc::string::String),
        #[prost(string, tag = "4")]
        DescendantsOfGroup(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub group: ::prost::alloc::vec::Vec<Group>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGroupRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupRequest {
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub group: ::core::option::Option<Group>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGroupRequest {
    #[prost(message, optional, tag = "2")]
    pub group: ::core::option::Option<Group>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub recursive: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupMembersRequest {
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub interval: ::core::option::Option<TimeInterval>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupMembersResponse {
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<super::super::api::MonitoredResource>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod group_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The Group API lets you inspect and manage your
    /// [groups](#google.monitoring.v3.Group).
    ///
    /// A group is a named filter that is used to identify
    /// a collection of monitored resources. Groups are typically used to
    /// mirror the physical and/or logical topology of the environment.
    /// Because group membership is computed dynamically, monitored
    /// resources that are started in the future are automatically placed
    /// in matching groups. By using a group to name monitored resources in,
    /// for example, an alert policy, the target of that alert policy is
    /// updated automatically as monitored resources are added and removed
    /// from the infrastructure.
    #[derive(Debug, Clone)]
    pub struct GroupServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GroupServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GroupServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            GroupServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists the existing groups.
        pub async fn list_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListGroupsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.GroupService/ListGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.GroupService",
                "ListGroups",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single group.
        pub async fn get_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Group>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/google.monitoring.v3.GroupService/GetGroup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.GroupService",
                "GetGroup",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new group.
        pub async fn create_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Group>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.GroupService/CreateGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.GroupService",
                "CreateGroup",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing group.
        /// You can change any group attributes except `name`.
        pub async fn update_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Group>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.GroupService/UpdateGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.GroupService",
                "UpdateGroup",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an existing group.
        pub async fn delete_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGroupRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.GroupService/DeleteGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.GroupService",
                "DeleteGroup",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the monitored resources that are members of a group.
        pub async fn list_group_members(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGroupMembersRequest>,
        ) -> std::result::Result<tonic::Response<super::ListGroupMembersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.GroupService/ListGroupMembers",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.GroupService",
                "ListGroupMembers",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DroppedLabels {
    #[prost(btree_map = "string, string", tag = "1")]
    pub label: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "19")]
    pub basic_service: ::core::option::Option<service::BasicService>,
    #[prost(message, optional, tag = "13")]
    pub telemetry: ::core::option::Option<service::Telemetry>,
    #[prost(btree_map = "string, string", tag = "14")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(
        oneof = "service::Identifier",
        tags = "6, 7, 8, 9, 10, 11, 12, 15, 16, 17"
    )]
    pub identifier: ::core::option::Option<service::Identifier>,
}
/// Nested message and enum types in `Service`.
pub mod service {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Custom {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppEngine {
        #[prost(string, tag = "1")]
        pub module_id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudEndpoints {
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusterIstio {
        #[prost(string, tag = "1")]
        pub location: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub cluster_name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub service_namespace: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub service_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MeshIstio {
        #[prost(string, tag = "1")]
        pub mesh_uid: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub service_namespace: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub service_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IstioCanonicalService {
        #[prost(string, tag = "1")]
        pub mesh_uid: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub canonical_service_namespace: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub canonical_service: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudRun {
        #[prost(string, tag = "1")]
        pub service_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub location: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GkeNamespace {
        #[prost(string, tag = "1")]
        pub project_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub location: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub cluster_name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub namespace_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GkeWorkload {
        #[prost(string, tag = "1")]
        pub project_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub location: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub cluster_name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub namespace_name: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub top_level_controller_type: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub top_level_controller_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GkeService {
        #[prost(string, tag = "1")]
        pub project_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub location: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub cluster_name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub namespace_name: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub service_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BasicService {
        #[prost(string, tag = "1")]
        pub service_type: ::prost::alloc::string::String,
        #[prost(btree_map = "string, string", tag = "2")]
        pub service_labels: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Telemetry {
        #[prost(string, tag = "1")]
        pub resource_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        #[prost(message, tag = "6")]
        Custom(Custom),
        #[prost(message, tag = "7")]
        AppEngine(AppEngine),
        #[prost(message, tag = "8")]
        CloudEndpoints(CloudEndpoints),
        #[prost(message, tag = "9")]
        ClusterIstio(ClusterIstio),
        #[prost(message, tag = "10")]
        MeshIstio(MeshIstio),
        #[prost(message, tag = "11")]
        IstioCanonicalService(IstioCanonicalService),
        #[prost(message, tag = "12")]
        CloudRun(CloudRun),
        #[prost(message, tag = "15")]
        GkeNamespace(GkeNamespace),
        #[prost(message, tag = "16")]
        GkeWorkload(GkeWorkload),
        #[prost(message, tag = "17")]
        GkeService(GkeService),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceLevelObjective {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub service_level_indicator: ::core::option::Option<ServiceLevelIndicator>,
    #[prost(double, tag = "4")]
    pub goal: f64,
    #[prost(btree_map = "string, string", tag = "12")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "service_level_objective::Period", tags = "5, 6")]
    pub period: ::core::option::Option<service_level_objective::Period>,
}
/// Nested message and enum types in `ServiceLevelObjective`.
pub mod service_level_objective {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum View {
        Unspecified = 0,
        Full = 2,
        Explicit = 1,
    }
    impl View {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                View::Unspecified => "VIEW_UNSPECIFIED",
                View::Full => "FULL",
                View::Explicit => "EXPLICIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL" => Some(Self::Full),
                "EXPLICIT" => Some(Self::Explicit),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Period {
        #[prost(message, tag = "5")]
        RollingPeriod(::prost_types::Duration),
        #[prost(enumeration = "super::super::super::r#type::CalendarPeriod", tag = "6")]
        CalendarPeriod(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceLevelIndicator {
    #[prost(oneof = "service_level_indicator::Type", tags = "4, 1, 2")]
    pub r#type: ::core::option::Option<service_level_indicator::Type>,
}
/// Nested message and enum types in `ServiceLevelIndicator`.
pub mod service_level_indicator {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "4")]
        BasicSli(super::BasicSli),
        #[prost(message, tag = "1")]
        RequestBased(super::RequestBasedSli),
        #[prost(message, tag = "2")]
        WindowsBased(super::WindowsBasedSli),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BasicSli {
    #[prost(string, repeated, tag = "7")]
    pub method: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub location: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "9")]
    pub version: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "basic_sli::SliCriteria", tags = "2, 3")]
    pub sli_criteria: ::core::option::Option<basic_sli::SliCriteria>,
}
/// Nested message and enum types in `BasicSli`.
pub mod basic_sli {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AvailabilityCriteria {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LatencyCriteria {
        #[prost(message, optional, tag = "3")]
        pub threshold: ::core::option::Option<::prost_types::Duration>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum SliCriteria {
        #[prost(message, tag = "2")]
        Availability(AvailabilityCriteria),
        #[prost(message, tag = "3")]
        Latency(LatencyCriteria),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Range {
    #[prost(double, tag = "1")]
    pub min: f64,
    #[prost(double, tag = "2")]
    pub max: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestBasedSli {
    #[prost(oneof = "request_based_sli::Method", tags = "1, 3")]
    pub method: ::core::option::Option<request_based_sli::Method>,
}
/// Nested message and enum types in `RequestBasedSli`.
pub mod request_based_sli {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Method {
        #[prost(message, tag = "1")]
        GoodTotalRatio(super::TimeSeriesRatio),
        #[prost(message, tag = "3")]
        DistributionCut(super::DistributionCut),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesRatio {
    #[prost(string, tag = "4")]
    pub good_service_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub bad_service_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub total_service_filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistributionCut {
    #[prost(string, tag = "4")]
    pub distribution_filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub range: ::core::option::Option<Range>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowsBasedSli {
    #[prost(message, optional, tag = "4")]
    pub window_period: ::core::option::Option<::prost_types::Duration>,
    #[prost(oneof = "windows_based_sli::WindowCriterion", tags = "5, 2, 6, 7")]
    pub window_criterion: ::core::option::Option<windows_based_sli::WindowCriterion>,
}
/// Nested message and enum types in `WindowsBasedSli`.
pub mod windows_based_sli {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerformanceThreshold {
        #[prost(double, tag = "2")]
        pub threshold: f64,
        #[prost(oneof = "performance_threshold::Type", tags = "1, 3")]
        pub r#type: ::core::option::Option<performance_threshold::Type>,
    }
    /// Nested message and enum types in `PerformanceThreshold`.
    pub mod performance_threshold {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Type {
            #[prost(message, tag = "1")]
            Performance(super::super::RequestBasedSli),
            #[prost(message, tag = "3")]
            BasicSliPerformance(super::super::BasicSli),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetricRange {
        #[prost(string, tag = "1")]
        pub time_series: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub range: ::core::option::Option<super::Range>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WindowCriterion {
        #[prost(string, tag = "5")]
        GoodBadMetricFilter(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        GoodTotalRatioThreshold(PerformanceThreshold),
        #[prost(message, tag = "6")]
        MetricMeanInRange(MetricRange),
        #[prost(message, tag = "7")]
        MetricSumInRange(MetricRange),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationChannelDescriptorsRequest {
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationChannelDescriptorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub channel_descriptors: ::prost::alloc::vec::Vec<NotificationChannelDescriptor>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotificationChannelDescriptorRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotificationChannelRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub notification_channel: ::core::option::Option<NotificationChannel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationChannelsRequest {
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationChannelsResponse {
    #[prost(message, repeated, tag = "3")]
    pub notification_channels: ::prost::alloc::vec::Vec<NotificationChannel>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotificationChannelRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNotificationChannelRequest {
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "3")]
    pub notification_channel: ::core::option::Option<NotificationChannel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotificationChannelRequest {
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendNotificationChannelVerificationCodeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotificationChannelVerificationCodeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotificationChannelVerificationCodeResponse {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyNotificationChannelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod notification_channel_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The Notification Channel API provides access to configuration that
    /// controls how messages related to incidents are sent.
    #[derive(Debug, Clone)]
    pub struct NotificationChannelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NotificationChannelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NotificationChannelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            NotificationChannelServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists the descriptors for supported channel types. The use of descriptors
        /// makes it possible for new channel types to be dynamically added.
        pub async fn list_notification_channel_descriptors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNotificationChannelDescriptorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNotificationChannelDescriptorsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.monitoring.v3.NotificationChannelService/ListNotificationChannelDescriptors");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "ListNotificationChannelDescriptors",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single channel descriptor. The descriptor indicates which fields
        /// are expected / permitted for a notification channel of the given type.
        pub async fn get_notification_channel_descriptor(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNotificationChannelDescriptorRequest>,
        ) -> std::result::Result<tonic::Response<super::NotificationChannelDescriptor>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.NotificationChannelService/GetNotificationChannelDescriptor",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "GetNotificationChannelDescriptor",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the notification channels that have been created for the project.
        /// To list the types of notification channels that are supported, use
        /// the `ListNotificationChannelDescriptors` method.
        pub async fn list_notification_channels(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNotificationChannelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNotificationChannelsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.NotificationChannelService/ListNotificationChannels",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "ListNotificationChannels",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single notification channel. The channel includes the relevant
        /// configuration details with which the channel was created. However, the
        /// response may truncate or omit passwords, API keys, or other private key
        /// matter and thus the response may not be 100% identical to the information
        /// that was supplied in the call to the create method.
        pub async fn get_notification_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNotificationChannelRequest>,
        ) -> std::result::Result<tonic::Response<super::NotificationChannel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.NotificationChannelService/GetNotificationChannel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "GetNotificationChannel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new notification channel, representing a single notification
        /// endpoint such as an email address, SMS number, or PagerDuty service.
        ///
        /// Design your application to single-thread API calls that modify the state of
        /// notification channels in a single project. This includes calls to
        /// CreateNotificationChannel, DeleteNotificationChannel and
        /// UpdateNotificationChannel.
        pub async fn create_notification_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNotificationChannelRequest>,
        ) -> std::result::Result<tonic::Response<super::NotificationChannel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.NotificationChannelService/CreateNotificationChannel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "CreateNotificationChannel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a notification channel. Fields not specified in the field mask
        /// remain unchanged.
        ///
        /// Design your application to single-thread API calls that modify the state of
        /// notification channels in a single project. This includes calls to
        /// CreateNotificationChannel, DeleteNotificationChannel and
        /// UpdateNotificationChannel.
        pub async fn update_notification_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNotificationChannelRequest>,
        ) -> std::result::Result<tonic::Response<super::NotificationChannel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.NotificationChannelService/UpdateNotificationChannel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "UpdateNotificationChannel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a notification channel.
        ///
        /// Design your application to single-thread API calls that modify the state of
        /// notification channels in a single project. This includes calls to
        /// CreateNotificationChannel, DeleteNotificationChannel and
        /// UpdateNotificationChannel.
        pub async fn delete_notification_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNotificationChannelRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.NotificationChannelService/DeleteNotificationChannel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "DeleteNotificationChannel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Causes a verification code to be delivered to the channel. The code
        /// can then be supplied in `VerifyNotificationChannel` to verify the channel.
        pub async fn send_notification_channel_verification_code(
            &mut self,
            request: impl tonic::IntoRequest<super::SendNotificationChannelVerificationCodeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.monitoring.v3.NotificationChannelService/SendNotificationChannelVerificationCode");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "SendNotificationChannelVerificationCode",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Requests a verification code for an already verified channel that can then
        /// be used in a call to VerifyNotificationChannel() on a different channel
        /// with an equivalent identity in the same or in a different project. This
        /// makes it possible to copy a channel between projects without requiring
        /// manual reverification of the channel. If the channel is not in the
        /// verified state, this method will fail (in other words, this may only be
        /// used if the SendNotificationChannelVerificationCode and
        /// VerifyNotificationChannel paths have already been used to put the given
        /// channel into the verified state).
        ///
        /// There is no guarantee that the verification codes returned by this method
        /// will be of a similar structure or form as the ones that are delivered
        /// to the channel via SendNotificationChannelVerificationCode; while
        /// VerifyNotificationChannel() will recognize both the codes delivered via
        /// SendNotificationChannelVerificationCode() and returned from
        /// GetNotificationChannelVerificationCode(), it is typically the case that
        /// the verification codes delivered via
        /// SendNotificationChannelVerificationCode() will be shorter and also
        /// have a shorter expiration (e.g. codes such as "G-123456") whereas
        /// GetVerificationCode() will typically return a much longer, websafe base
        /// 64 encoded string that has a longer expiration time.
        pub async fn get_notification_channel_verification_code(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNotificationChannelVerificationCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNotificationChannelVerificationCodeResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/google.monitoring.v3.NotificationChannelService/GetNotificationChannelVerificationCode");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "GetNotificationChannelVerificationCode",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Verifies a `NotificationChannel` by proving receipt of the code
        /// delivered to the channel as a result of calling
        /// `SendNotificationChannelVerificationCode`.
        pub async fn verify_notification_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifyNotificationChannelRequest>,
        ) -> std::result::Result<tonic::Response<super::NotificationChannel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.NotificationChannelService/VerifyNotificationChannel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.NotificationChannelService",
                "VerifyNotificationChannel",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSnoozeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub snooze: ::core::option::Option<Snooze>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnoozesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnoozesResponse {
    #[prost(message, repeated, tag = "1")]
    pub snoozes: ::prost::alloc::vec::Vec<Snooze>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSnoozeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSnoozeRequest {
    #[prost(message, optional, tag = "1")]
    pub snooze: ::core::option::Option<Snooze>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod snooze_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The SnoozeService API is used to temporarily prevent an alert policy from
    /// generating alerts. A Snooze is a description of the criteria under which one
    /// or more alert policies should not fire alerts for the specified duration.
    #[derive(Debug, Clone)]
    pub struct SnoozeServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SnoozeServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SnoozeServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            SnoozeServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a `Snooze` that will prevent alerts, which match the provided
        /// criteria, from being opened. The `Snooze` applies for a specific time
        /// interval.
        pub async fn create_snooze(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSnoozeRequest>,
        ) -> std::result::Result<tonic::Response<super::Snooze>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.SnoozeService/CreateSnooze",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.SnoozeService",
                "CreateSnooze",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the `Snooze`s associated with a project. Can optionally pass in
        /// `filter`, which specifies predicates to match `Snooze`s.
        pub async fn list_snoozes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSnoozesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListSnoozesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.SnoozeService/ListSnoozes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.SnoozeService",
                "ListSnoozes",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a `Snooze` by `name`.
        pub async fn get_snooze(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSnoozeRequest>,
        ) -> std::result::Result<tonic::Response<super::Snooze>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.SnoozeService/GetSnooze",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.SnoozeService",
                "GetSnooze",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `Snooze`, identified by its `name`, with the parameters in the
        /// given `Snooze` object.
        pub async fn update_snooze(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSnoozeRequest>,
        ) -> std::result::Result<tonic::Response<super::Snooze>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.SnoozeService/UpdateSnooze",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.SnoozeService",
                "UpdateSnooze",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub service_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub service: ::core::option::Option<Service>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServicesResponse {
    #[prost(message, repeated, tag = "1")]
    pub services: ::prost::alloc::vec::Vec<Service>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceRequest {
    #[prost(message, optional, tag = "1")]
    pub service: ::core::option::Option<Service>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServiceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceLevelObjectiveRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub service_level_objective_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub service_level_objective: ::core::option::Option<ServiceLevelObjective>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceLevelObjectiveRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "service_level_objective::View", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServiceLevelObjectivesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "service_level_objective::View", tag = "5")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServiceLevelObjectivesResponse {
    #[prost(message, repeated, tag = "1")]
    pub service_level_objectives: ::prost::alloc::vec::Vec<ServiceLevelObjective>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceLevelObjectiveRequest {
    #[prost(message, optional, tag = "1")]
    pub service_level_objective: ::core::option::Option<ServiceLevelObjective>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServiceLevelObjectiveRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod service_monitoring_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The Cloud Monitoring Service-Oriented Monitoring API has endpoints for
    /// managing and querying aspects of a Metrics Scope's services. These include
    /// the `Service`'s monitored resources, its Service-Level Objectives, and a
    /// taxonomy of categorized Health Metrics.
    #[derive(Debug, Clone)]
    pub struct ServiceMonitoringServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ServiceMonitoringServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ServiceMonitoringServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            ServiceMonitoringServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a `Service`.
        pub async fn create_service(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Service>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/CreateService",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "CreateService",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get the named `Service`.
        pub async fn get_service(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Service>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/GetService",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "GetService",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List `Service`s for this Metrics Scope.
        pub async fn list_services(
            &mut self,
            request: impl tonic::IntoRequest<super::ListServicesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListServicesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/ListServices",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "ListServices",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Update this `Service`.
        pub async fn update_service(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Service>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/UpdateService",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "UpdateService",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Soft delete this `Service`.
        pub async fn delete_service(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServiceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/DeleteService",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "DeleteService",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Create a `ServiceLevelObjective` for the given `Service`.
        pub async fn create_service_level_objective(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateServiceLevelObjectiveRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceLevelObjective>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/CreateServiceLevelObjective",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "CreateServiceLevelObjective",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get a `ServiceLevelObjective` by name.
        pub async fn get_service_level_objective(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceLevelObjectiveRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceLevelObjective>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/GetServiceLevelObjective",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "GetServiceLevelObjective",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List the `ServiceLevelObjective`s for the given `Service`.
        pub async fn list_service_level_objectives(
            &mut self,
            request: impl tonic::IntoRequest<super::ListServiceLevelObjectivesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListServiceLevelObjectivesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/ListServiceLevelObjectives",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "ListServiceLevelObjectives",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Update the given `ServiceLevelObjective`.
        pub async fn update_service_level_objective(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServiceLevelObjectiveRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceLevelObjective>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/UpdateServiceLevelObjective",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "UpdateServiceLevelObjective",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Delete the given `ServiceLevelObjective`.
        pub async fn delete_service_level_objective(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServiceLevelObjectiveRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.v3.ServiceMonitoringService/DeleteServiceLevelObjective",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.monitoring.v3.ServiceMonitoringService",
                "DeleteServiceLevelObjective",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
