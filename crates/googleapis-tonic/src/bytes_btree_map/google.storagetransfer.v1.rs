// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleServiceAccount {
#[prost(string, tag = "1")]
pub account_email: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub subject_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsAccessKey {
#[prost(string, tag = "1")]
pub access_key_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub secret_access_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AzureCredentials {
#[prost(string, tag = "2")]
pub sas_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectConditions {
#[prost(message, optional, tag = "1")]
pub min_time_elapsed_since_last_modification: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "2")]
pub max_time_elapsed_since_last_modification: ::core::option::Option<::prost_types::Duration>,
#[prost(string, repeated, tag = "3")]
pub include_prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(string, repeated, tag = "4")]
pub exclude_prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "5")]
pub last_modified_since: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub last_modified_before: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsData {
#[prost(string, tag = "1")]
pub bucket_name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsS3Data {
#[prost(string, tag = "1")]
pub bucket_name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub aws_access_key: ::core::option::Option<AwsAccessKey>,
#[prost(string, tag = "3")]
pub path: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub role_arn: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub credentials_secret: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AzureBlobStorageData {
#[prost(string, tag = "1")]
pub storage_account: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub azure_credentials: ::core::option::Option<AzureCredentials>,
#[prost(string, tag = "4")]
pub container: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub path: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub credentials_secret: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpData {
#[prost(string, tag = "1")]
pub list_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PosixFilesystem {
#[prost(string, tag = "1")]
pub root_directory: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsS3CompatibleData {
#[prost(string, tag = "1")]
pub bucket_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub path: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub endpoint: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub region: ::prost::alloc::string::String,
#[prost(oneof = "aws_s3_compatible_data::DataProvider", tags = "4")]
pub data_provider: ::core::option::Option<aws_s3_compatible_data::DataProvider>,
}
/// Nested message and enum types in `AwsS3CompatibleData`.
pub mod aws_s3_compatible_data {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum DataProvider {
#[prost(message, tag = "4")]
S3Metadata(super::S3CompatibleMetadata),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct S3CompatibleMetadata {
#[prost(enumeration = "s3_compatible_metadata::AuthMethod", tag = "1")]
pub auth_method: i32,
#[prost(enumeration = "s3_compatible_metadata::RequestModel", tag = "2")]
pub request_model: i32,
#[prost(enumeration = "s3_compatible_metadata::NetworkProtocol", tag = "3")]
pub protocol: i32,
#[prost(enumeration = "s3_compatible_metadata::ListApi", tag = "4")]
pub list_api: i32,
}
/// Nested message and enum types in `S3CompatibleMetadata`.
pub mod s3_compatible_metadata {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthMethod {
Unspecified = 0,
AwsSignatureV4 = 1,
AwsSignatureV2 = 2,
}
impl AuthMethod {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
AuthMethod::Unspecified => "AUTH_METHOD_UNSPECIFIED",
AuthMethod::AwsSignatureV4 => "AUTH_METHOD_AWS_SIGNATURE_V4",
AuthMethod::AwsSignatureV2 => "AUTH_METHOD_AWS_SIGNATURE_V2",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"AUTH_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
"AUTH_METHOD_AWS_SIGNATURE_V4" => Some(Self::AwsSignatureV4),
"AUTH_METHOD_AWS_SIGNATURE_V2" => Some(Self::AwsSignatureV2),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RequestModel {
Unspecified = 0,
VirtualHostedStyle = 1,
PathStyle = 2,
}
impl RequestModel {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
RequestModel::Unspecified => "REQUEST_MODEL_UNSPECIFIED",
RequestModel::VirtualHostedStyle => "REQUEST_MODEL_VIRTUAL_HOSTED_STYLE",
RequestModel::PathStyle => "REQUEST_MODEL_PATH_STYLE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"REQUEST_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
"REQUEST_MODEL_VIRTUAL_HOSTED_STYLE" => Some(Self::VirtualHostedStyle),
"REQUEST_MODEL_PATH_STYLE" => Some(Self::PathStyle),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkProtocol {
Unspecified = 0,
Https = 1,
Http = 2,
}
impl NetworkProtocol {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
NetworkProtocol::Unspecified => "NETWORK_PROTOCOL_UNSPECIFIED",
NetworkProtocol::Https => "NETWORK_PROTOCOL_HTTPS",
NetworkProtocol::Http => "NETWORK_PROTOCOL_HTTP",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NETWORK_PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
"NETWORK_PROTOCOL_HTTPS" => Some(Self::Https),
"NETWORK_PROTOCOL_HTTP" => Some(Self::Http),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ListApi {
Unspecified = 0,
ListObjectsV2 = 1,
ListObjects = 2,
}
impl ListApi {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ListApi::Unspecified => "LIST_API_UNSPECIFIED",
ListApi::ListObjectsV2 => "LIST_OBJECTS_V2",
ListApi::ListObjects => "LIST_OBJECTS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LIST_API_UNSPECIFIED" => Some(Self::Unspecified),
"LIST_OBJECTS_V2" => Some(Self::ListObjectsV2),
"LIST_OBJECTS" => Some(Self::ListObjects),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentPool {
#[prost(string, tag = "2")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "agent_pool::State", tag = "4")]
pub state: i32,
#[prost(message, optional, tag = "5")]
pub bandwidth_limit: ::core::option::Option<agent_pool::BandwidthLimit>,
}
/// Nested message and enum types in `AgentPool`.
pub mod agent_pool {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BandwidthLimit {
#[prost(int64, tag = "1")]
pub limit_mbps: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Created = 2,
Deleting = 3,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Created => "CREATED",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"CREATED" => Some(Self::Created),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransferOptions {
#[prost(bool, tag = "1")]
pub overwrite_objects_already_existing_in_sink: bool,
#[prost(bool, tag = "2")]
pub delete_objects_unique_in_sink: bool,
#[prost(bool, tag = "3")]
pub delete_objects_from_source_after_transfer: bool,
#[prost(enumeration = "transfer_options::OverwriteWhen", tag = "4")]
pub overwrite_when: i32,
#[prost(message, optional, tag = "5")]
pub metadata_options: ::core::option::Option<MetadataOptions>,
}
/// Nested message and enum types in `TransferOptions`.
pub mod transfer_options {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OverwriteWhen {
Unspecified = 0,
Different = 1,
Never = 2,
Always = 3,
}
impl OverwriteWhen {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OverwriteWhen::Unspecified => "OVERWRITE_WHEN_UNSPECIFIED",
OverwriteWhen::Different => "DIFFERENT",
OverwriteWhen::Never => "NEVER",
OverwriteWhen::Always => "ALWAYS",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OVERWRITE_WHEN_UNSPECIFIED" => Some(Self::Unspecified),
"DIFFERENT" => Some(Self::Different),
"NEVER" => Some(Self::Never),
"ALWAYS" => Some(Self::Always),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferSpec {
#[prost(message, optional, tag = "5")]
pub object_conditions: ::core::option::Option<ObjectConditions>,
#[prost(message, optional, tag = "6")]
pub transfer_options: ::core::option::Option<TransferOptions>,
#[prost(message, optional, tag = "15")]
pub transfer_manifest: ::core::option::Option<TransferManifest>,
#[prost(string, tag = "17")]
pub source_agent_pool_name: ::prost::alloc::string::String,
#[prost(string, tag = "18")]
pub sink_agent_pool_name: ::prost::alloc::string::String,
#[prost(oneof = "transfer_spec::DataSink", tags = "4, 13")]
pub data_sink: ::core::option::Option<transfer_spec::DataSink>,
#[prost(oneof = "transfer_spec::DataSource", tags = "1, 2, 3, 14, 8, 19")]
pub data_source: ::core::option::Option<transfer_spec::DataSource>,
#[prost(oneof = "transfer_spec::IntermediateDataLocation", tags = "16")]
pub intermediate_data_location: ::core::option::Option<transfer_spec::IntermediateDataLocation>,
}
/// Nested message and enum types in `TransferSpec`.
pub mod transfer_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DataSink {
#[prost(message, tag = "4")]
GcsDataSink(super::GcsData),
#[prost(message, tag = "13")]
PosixDataSink(super::PosixFilesystem),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum DataSource {
#[prost(message, tag = "1")]
GcsDataSource(super::GcsData),
#[prost(message, tag = "2")]
AwsS3DataSource(super::AwsS3Data),
#[prost(message, tag = "3")]
HttpDataSource(super::HttpData),
#[prost(message, tag = "14")]
PosixDataSource(super::PosixFilesystem),
#[prost(message, tag = "8")]
AzureBlobStorageDataSource(super::AzureBlobStorageData),
#[prost(message, tag = "19")]
AwsS3CompatibleDataSource(super::AwsS3CompatibleData),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum IntermediateDataLocation {
#[prost(message, tag = "16")]
GcsIntermediateDataLocation(super::GcsData),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetadataOptions {
#[prost(enumeration = "metadata_options::Symlink", tag = "1")]
pub symlink: i32,
#[prost(enumeration = "metadata_options::Mode", tag = "2")]
pub mode: i32,
#[prost(enumeration = "metadata_options::Gid", tag = "3")]
pub gid: i32,
#[prost(enumeration = "metadata_options::Uid", tag = "4")]
pub uid: i32,
#[prost(enumeration = "metadata_options::Acl", tag = "5")]
pub acl: i32,
#[prost(enumeration = "metadata_options::StorageClass", tag = "6")]
pub storage_class: i32,
#[prost(enumeration = "metadata_options::TemporaryHold", tag = "7")]
pub temporary_hold: i32,
#[prost(enumeration = "metadata_options::KmsKey", tag = "8")]
pub kms_key: i32,
#[prost(enumeration = "metadata_options::TimeCreated", tag = "9")]
pub time_created: i32,
}
/// Nested message and enum types in `MetadataOptions`.
pub mod metadata_options {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Symlink {
Unspecified = 0,
Skip = 1,
Preserve = 2,
}
impl Symlink {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Symlink::Unspecified => "SYMLINK_UNSPECIFIED",
Symlink::Skip => "SYMLINK_SKIP",
Symlink::Preserve => "SYMLINK_PRESERVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SYMLINK_UNSPECIFIED" => Some(Self::Unspecified),
"SYMLINK_SKIP" => Some(Self::Skip),
"SYMLINK_PRESERVE" => Some(Self::Preserve),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Mode {
Unspecified = 0,
Skip = 1,
Preserve = 2,
}
impl Mode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Mode::Unspecified => "MODE_UNSPECIFIED",
Mode::Skip => "MODE_SKIP",
Mode::Preserve => "MODE_PRESERVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"MODE_UNSPECIFIED" => Some(Self::Unspecified),
"MODE_SKIP" => Some(Self::Skip),
"MODE_PRESERVE" => Some(Self::Preserve),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Gid {
Unspecified = 0,
Skip = 1,
Number = 2,
}
impl Gid {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Gid::Unspecified => "GID_UNSPECIFIED",
Gid::Skip => "GID_SKIP",
Gid::Number => "GID_NUMBER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"GID_UNSPECIFIED" => Some(Self::Unspecified),
"GID_SKIP" => Some(Self::Skip),
"GID_NUMBER" => Some(Self::Number),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Uid {
Unspecified = 0,
Skip = 1,
Number = 2,
}
impl Uid {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Uid::Unspecified => "UID_UNSPECIFIED",
Uid::Skip => "UID_SKIP",
Uid::Number => "UID_NUMBER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"UID_UNSPECIFIED" => Some(Self::Unspecified),
"UID_SKIP" => Some(Self::Skip),
"UID_NUMBER" => Some(Self::Number),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Acl {
Unspecified = 0,
DestinationBucketDefault = 1,
Preserve = 2,
}
impl Acl {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Acl::Unspecified => "ACL_UNSPECIFIED",
Acl::DestinationBucketDefault => "ACL_DESTINATION_BUCKET_DEFAULT",
Acl::Preserve => "ACL_PRESERVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ACL_UNSPECIFIED" => Some(Self::Unspecified),
"ACL_DESTINATION_BUCKET_DEFAULT" => Some(Self::DestinationBucketDefault),
"ACL_PRESERVE" => Some(Self::Preserve),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageClass {
Unspecified = 0,
DestinationBucketDefault = 1,
Preserve = 2,
Standard = 3,
Nearline = 4,
Coldline = 5,
Archive = 6,
}
impl StorageClass {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
StorageClass::Unspecified => "STORAGE_CLASS_UNSPECIFIED",
StorageClass::DestinationBucketDefault => "STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT",
StorageClass::Preserve => "STORAGE_CLASS_PRESERVE",
StorageClass::Standard => "STORAGE_CLASS_STANDARD",
StorageClass::Nearline => "STORAGE_CLASS_NEARLINE",
StorageClass::Coldline => "STORAGE_CLASS_COLDLINE",
StorageClass::Archive => "STORAGE_CLASS_ARCHIVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STORAGE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
"STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT" => Some(Self::DestinationBucketDefault),
"STORAGE_CLASS_PRESERVE" => Some(Self::Preserve),
"STORAGE_CLASS_STANDARD" => Some(Self::Standard),
"STORAGE_CLASS_NEARLINE" => Some(Self::Nearline),
"STORAGE_CLASS_COLDLINE" => Some(Self::Coldline),
"STORAGE_CLASS_ARCHIVE" => Some(Self::Archive),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TemporaryHold {
Unspecified = 0,
Skip = 1,
Preserve = 2,
}
impl TemporaryHold {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TemporaryHold::Unspecified => "TEMPORARY_HOLD_UNSPECIFIED",
TemporaryHold::Skip => "TEMPORARY_HOLD_SKIP",
TemporaryHold::Preserve => "TEMPORARY_HOLD_PRESERVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TEMPORARY_HOLD_UNSPECIFIED" => Some(Self::Unspecified),
"TEMPORARY_HOLD_SKIP" => Some(Self::Skip),
"TEMPORARY_HOLD_PRESERVE" => Some(Self::Preserve),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KmsKey {
Unspecified = 0,
DestinationBucketDefault = 1,
Preserve = 2,
}
impl KmsKey {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
KmsKey::Unspecified => "KMS_KEY_UNSPECIFIED",
KmsKey::DestinationBucketDefault => "KMS_KEY_DESTINATION_BUCKET_DEFAULT",
KmsKey::Preserve => "KMS_KEY_PRESERVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"KMS_KEY_UNSPECIFIED" => Some(Self::Unspecified),
"KMS_KEY_DESTINATION_BUCKET_DEFAULT" => Some(Self::DestinationBucketDefault),
"KMS_KEY_PRESERVE" => Some(Self::Preserve),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeCreated {
Unspecified = 0,
Skip = 1,
PreserveAsCustomTime = 2,
}
impl TimeCreated {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TimeCreated::Unspecified => "TIME_CREATED_UNSPECIFIED",
TimeCreated::Skip => "TIME_CREATED_SKIP",
TimeCreated::PreserveAsCustomTime => "TIME_CREATED_PRESERVE_AS_CUSTOM_TIME",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TIME_CREATED_UNSPECIFIED" => Some(Self::Unspecified),
"TIME_CREATED_SKIP" => Some(Self::Skip),
"TIME_CREATED_PRESERVE_AS_CUSTOM_TIME" => Some(Self::PreserveAsCustomTime),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferManifest {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Schedule {
#[prost(message, optional, tag = "1")]
pub schedule_start_date: ::core::option::Option<super::super::r#type::Date>,
#[prost(message, optional, tag = "2")]
pub schedule_end_date: ::core::option::Option<super::super::r#type::Date>,
#[prost(message, optional, tag = "3")]
pub start_time_of_day: ::core::option::Option<super::super::r#type::TimeOfDay>,
#[prost(message, optional, tag = "4")]
pub end_time_of_day: ::core::option::Option<super::super::r#type::TimeOfDay>,
#[prost(message, optional, tag = "5")]
pub repeat_interval: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventStream {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub event_stream_start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "3")]
pub event_stream_expiration_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferJob {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub project_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub transfer_spec: ::core::option::Option<TransferSpec>,
#[prost(message, optional, tag = "11")]
pub notification_config: ::core::option::Option<NotificationConfig>,
#[prost(message, optional, tag = "14")]
pub logging_config: ::core::option::Option<LoggingConfig>,
#[prost(message, optional, tag = "5")]
pub schedule: ::core::option::Option<Schedule>,
#[prost(message, optional, tag = "15")]
pub event_stream: ::core::option::Option<EventStream>,
#[prost(enumeration = "transfer_job::Status", tag = "6")]
pub status: i32,
#[prost(message, optional, tag = "7")]
pub creation_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "8")]
pub last_modification_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "9")]
pub deletion_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "12")]
pub latest_operation_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TransferJob`.
pub mod transfer_job {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
Unspecified = 0,
Enabled = 1,
Disabled = 2,
Deleted = 3,
}
impl Status {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Status::Unspecified => "STATUS_UNSPECIFIED",
Status::Enabled => "ENABLED",
Status::Disabled => "DISABLED",
Status::Deleted => "DELETED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATUS_UNSPECIFIED" => Some(Self::Unspecified),
"ENABLED" => Some(Self::Enabled),
"DISABLED" => Some(Self::Disabled),
"DELETED" => Some(Self::Deleted),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorLogEntry {
#[prost(string, tag = "1")]
pub url: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub error_details: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorSummary {
#[prost(enumeration = "super::super::rpc::Code", tag = "1")]
pub error_code: i32,
#[prost(int64, tag = "2")]
pub error_count: i64,
#[prost(message, repeated, tag = "3")]
pub error_log_entries: ::prost::alloc::vec::Vec<ErrorLogEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransferCounters {
#[prost(int64, tag = "1")]
pub objects_found_from_source: i64,
#[prost(int64, tag = "2")]
pub bytes_found_from_source: i64,
#[prost(int64, tag = "3")]
pub objects_found_only_from_sink: i64,
#[prost(int64, tag = "4")]
pub bytes_found_only_from_sink: i64,
#[prost(int64, tag = "5")]
pub objects_from_source_skipped_by_sync: i64,
#[prost(int64, tag = "6")]
pub bytes_from_source_skipped_by_sync: i64,
#[prost(int64, tag = "7")]
pub objects_copied_to_sink: i64,
#[prost(int64, tag = "8")]
pub bytes_copied_to_sink: i64,
#[prost(int64, tag = "9")]
pub objects_deleted_from_source: i64,
#[prost(int64, tag = "10")]
pub bytes_deleted_from_source: i64,
#[prost(int64, tag = "11")]
pub objects_deleted_from_sink: i64,
#[prost(int64, tag = "12")]
pub bytes_deleted_from_sink: i64,
#[prost(int64, tag = "13")]
pub objects_from_source_failed: i64,
#[prost(int64, tag = "14")]
pub bytes_from_source_failed: i64,
#[prost(int64, tag = "15")]
pub objects_failed_to_delete_from_sink: i64,
#[prost(int64, tag = "16")]
pub bytes_failed_to_delete_from_sink: i64,
#[prost(int64, tag = "17")]
pub directories_found_from_source: i64,
#[prost(int64, tag = "18")]
pub directories_failed_to_list_from_source: i64,
#[prost(int64, tag = "19")]
pub directories_successfully_listed_from_source: i64,
#[prost(int64, tag = "22")]
pub intermediate_objects_cleaned_up: i64,
#[prost(int64, tag = "23")]
pub intermediate_objects_failed_cleaned_up: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationConfig {
#[prost(string, tag = "1")]
pub pubsub_topic: ::prost::alloc::string::String,
#[prost(enumeration = "notification_config::EventType", repeated, tag = "2")]
pub event_types: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "notification_config::PayloadFormat", tag = "3")]
pub payload_format: i32,
}
/// Nested message and enum types in `NotificationConfig`.
pub mod notification_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
Unspecified = 0,
TransferOperationSuccess = 1,
TransferOperationFailed = 2,
TransferOperationAborted = 3,
}
impl EventType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EventType::Unspecified => "EVENT_TYPE_UNSPECIFIED",
EventType::TransferOperationSuccess => "TRANSFER_OPERATION_SUCCESS",
EventType::TransferOperationFailed => "TRANSFER_OPERATION_FAILED",
EventType::TransferOperationAborted => "TRANSFER_OPERATION_ABORTED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"TRANSFER_OPERATION_SUCCESS" => Some(Self::TransferOperationSuccess),
"TRANSFER_OPERATION_FAILED" => Some(Self::TransferOperationFailed),
"TRANSFER_OPERATION_ABORTED" => Some(Self::TransferOperationAborted),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PayloadFormat {
Unspecified = 0,
None = 1,
Json = 2,
}
impl PayloadFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
PayloadFormat::Unspecified => "PAYLOAD_FORMAT_UNSPECIFIED",
PayloadFormat::None => "NONE",
PayloadFormat::Json => "JSON",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PAYLOAD_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"NONE" => Some(Self::None),
"JSON" => Some(Self::Json),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggingConfig {
#[prost(enumeration = "logging_config::LoggableAction", repeated, tag = "1")]
pub log_actions: ::prost::alloc::vec::Vec<i32>,
#[prost(enumeration = "logging_config::LoggableActionState", repeated, tag = "2")]
pub log_action_states: ::prost::alloc::vec::Vec<i32>,
#[prost(bool, tag = "3")]
pub enable_onprem_gcs_transfer_logs: bool,
}
/// Nested message and enum types in `LoggingConfig`.
pub mod logging_config {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoggableAction {
Unspecified = 0,
Find = 1,
Delete = 2,
Copy = 3,
}
impl LoggableAction {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LoggableAction::Unspecified => "LOGGABLE_ACTION_UNSPECIFIED",
LoggableAction::Find => "FIND",
LoggableAction::Delete => "DELETE",
LoggableAction::Copy => "COPY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOGGABLE_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
"FIND" => Some(Self::Find),
"DELETE" => Some(Self::Delete),
"COPY" => Some(Self::Copy),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoggableActionState {
Unspecified = 0,
Succeeded = 1,
Failed = 2,
}
impl LoggableActionState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LoggableActionState::Unspecified => "LOGGABLE_ACTION_STATE_UNSPECIFIED",
LoggableActionState::Succeeded => "SUCCEEDED",
LoggableActionState::Failed => "FAILED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOGGABLE_ACTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferOperation {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub project_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub transfer_spec: ::core::option::Option<TransferSpec>,
#[prost(message, optional, tag = "10")]
pub notification_config: ::core::option::Option<NotificationConfig>,
#[prost(message, optional, tag = "12")]
pub logging_config: ::core::option::Option<LoggingConfig>,
#[prost(message, optional, tag = "4")]
pub start_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "transfer_operation::Status", tag = "6")]
pub status: i32,
#[prost(message, optional, tag = "7")]
pub counters: ::core::option::Option<TransferCounters>,
#[prost(message, repeated, tag = "8")]
pub error_breakdowns: ::prost::alloc::vec::Vec<ErrorSummary>,
#[prost(string, tag = "9")]
pub transfer_job_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TransferOperation`.
pub mod transfer_operation {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
Unspecified = 0,
InProgress = 1,
Paused = 2,
Success = 3,
Failed = 4,
Aborted = 5,
Queued = 6,
Suspending = 7,
}
impl Status {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Status::Unspecified => "STATUS_UNSPECIFIED",
Status::InProgress => "IN_PROGRESS",
Status::Paused => "PAUSED",
Status::Success => "SUCCESS",
Status::Failed => "FAILED",
Status::Aborted => "ABORTED",
Status::Queued => "QUEUED",
Status::Suspending => "SUSPENDING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATUS_UNSPECIFIED" => Some(Self::Unspecified),
"IN_PROGRESS" => Some(Self::InProgress),
"PAUSED" => Some(Self::Paused),
"SUCCESS" => Some(Self::Success),
"FAILED" => Some(Self::Failed),
"ABORTED" => Some(Self::Aborted),
"QUEUED" => Some(Self::Queued),
"SUSPENDING" => Some(Self::Suspending),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGoogleServiceAccountRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTransferJobRequest {
#[prost(message, optional, tag = "1")]
pub transfer_job: ::core::option::Option<TransferJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTransferJobRequest {
#[prost(string, tag = "1")]
pub job_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub project_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub transfer_job: ::core::option::Option<TransferJob>,
#[prost(message, optional, tag = "4")]
pub update_transfer_job_field_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransferJobRequest {
#[prost(string, tag = "1")]
pub job_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub project_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTransferJobRequest {
#[prost(string, tag = "1")]
pub job_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub project_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransferJobsRequest {
#[prost(string, tag = "1")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "4")]
pub page_size: i32,
#[prost(string, tag = "5")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransferJobsResponse {
#[prost(message, repeated, tag = "1")]
pub transfer_jobs: ::prost::alloc::vec::Vec<TransferJob>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseTransferOperationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeTransferOperationRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunTransferJobRequest {
#[prost(string, tag = "1")]
pub job_name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub project_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAgentPoolRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub agent_pool: ::core::option::Option<AgentPool>,
#[prost(string, tag = "3")]
pub agent_pool_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAgentPoolRequest {
#[prost(message, optional, tag = "1")]
pub agent_pool: ::core::option::Option<AgentPool>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentPoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAgentPoolRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAgentPoolsRequest {
#[prost(string, tag = "1")]
pub project_id: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub filter: ::prost::alloc::string::String,
#[prost(int32, tag = "3")]
pub page_size: i32,
#[prost(string, tag = "4")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAgentPoolsResponse {
#[prost(message, repeated, tag = "1")]
pub agent_pools: ::prost::alloc::vec::Vec<AgentPool>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod storage_transfer_service_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Storage Transfer Service and its protos.
/// Transfers data between between Google Cloud Storage buckets or from a data
/// source external to Google to a Cloud Storage bucket.
#[derive(Debug, Clone)]
pub struct StorageTransferServiceClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> StorageTransferServiceClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> StorageTransferServiceClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
StorageTransferServiceClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns the Google service account that is used by Storage Transfer
/// Service to access buckets in the project where transfers
/// run or in other projects. Each Google service account is associated
/// with one Google Cloud project. Users
/// should add this service account to the Google Cloud Storage bucket
/// ACLs to grant access to Storage Transfer Service. This service
/// account is created and owned by Storage Transfer Service and can
/// only be used by Storage Transfer Service.
pub async fn get_google_service_account(&mut self, request: impl tonic::IntoRequest<super::GetGoogleServiceAccountRequest>) -> std::result::Result<tonic::Response<super::GoogleServiceAccount>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/GetGoogleServiceAccount");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "GetGoogleServiceAccount"));
self.inner.unary(req, path, codec).await
}
/// Creates a transfer job that runs periodically.
pub async fn create_transfer_job(&mut self, request: impl tonic::IntoRequest<super::CreateTransferJobRequest>) -> std::result::Result<tonic::Response<super::TransferJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/CreateTransferJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "CreateTransferJob"));
self.inner.unary(req, path, codec).await
}
/// Updates a transfer job. Updating a job's transfer spec does not affect
/// transfer operations that are running already.
///
/// **Note:** The job's [status][google.storagetransfer.v1.TransferJob.status]
/// field can be modified using this RPC (for example, to set a job's status to
/// [DELETED][google.storagetransfer.v1.TransferJob.Status.DELETED],
/// [DISABLED][google.storagetransfer.v1.TransferJob.Status.DISABLED], or
/// [ENABLED][google.storagetransfer.v1.TransferJob.Status.ENABLED]).
pub async fn update_transfer_job(&mut self, request: impl tonic::IntoRequest<super::UpdateTransferJobRequest>) -> std::result::Result<tonic::Response<super::TransferJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/UpdateTransferJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "UpdateTransferJob"));
self.inner.unary(req, path, codec).await
}
/// Gets a transfer job.
pub async fn get_transfer_job(&mut self, request: impl tonic::IntoRequest<super::GetTransferJobRequest>) -> std::result::Result<tonic::Response<super::TransferJob>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/GetTransferJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "GetTransferJob"));
self.inner.unary(req, path, codec).await
}
/// Lists transfer jobs.
pub async fn list_transfer_jobs(&mut self, request: impl tonic::IntoRequest<super::ListTransferJobsRequest>) -> std::result::Result<tonic::Response<super::ListTransferJobsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/ListTransferJobs");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "ListTransferJobs"));
self.inner.unary(req, path, codec).await
}
/// Pauses a transfer operation.
pub async fn pause_transfer_operation(&mut self, request: impl tonic::IntoRequest<super::PauseTransferOperationRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/PauseTransferOperation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "PauseTransferOperation"));
self.inner.unary(req, path, codec).await
}
/// Resumes a transfer operation that is paused.
pub async fn resume_transfer_operation(&mut self, request: impl tonic::IntoRequest<super::ResumeTransferOperationRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/ResumeTransferOperation");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "ResumeTransferOperation"));
self.inner.unary(req, path, codec).await
}
/// Starts a new operation for the specified transfer job.
/// A `TransferJob` has a maximum of one active `TransferOperation`. If this
/// method is called while a `TransferOperation` is active, an error is
/// returned.
pub async fn run_transfer_job(&mut self, request: impl tonic::IntoRequest<super::RunTransferJobRequest>) -> std::result::Result<tonic::Response<super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/RunTransferJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "RunTransferJob"));
self.inner.unary(req, path, codec).await
}
/// Deletes a transfer job. Deleting a transfer job sets its status to
/// [DELETED][google.storagetransfer.v1.TransferJob.Status.DELETED].
pub async fn delete_transfer_job(&mut self, request: impl tonic::IntoRequest<super::DeleteTransferJobRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/DeleteTransferJob");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "DeleteTransferJob"));
self.inner.unary(req, path, codec).await
}
/// Creates an agent pool resource.
pub async fn create_agent_pool(&mut self, request: impl tonic::IntoRequest<super::CreateAgentPoolRequest>) -> std::result::Result<tonic::Response<super::AgentPool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/CreateAgentPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "CreateAgentPool"));
self.inner.unary(req, path, codec).await
}
/// Updates an existing agent pool resource.
pub async fn update_agent_pool(&mut self, request: impl tonic::IntoRequest<super::UpdateAgentPoolRequest>) -> std::result::Result<tonic::Response<super::AgentPool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/UpdateAgentPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "UpdateAgentPool"));
self.inner.unary(req, path, codec).await
}
/// Gets an agent pool.
pub async fn get_agent_pool(&mut self, request: impl tonic::IntoRequest<super::GetAgentPoolRequest>) -> std::result::Result<tonic::Response<super::AgentPool>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/GetAgentPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "GetAgentPool"));
self.inner.unary(req, path, codec).await
}
/// Lists agent pools.
pub async fn list_agent_pools(&mut self, request: impl tonic::IntoRequest<super::ListAgentPoolsRequest>) -> std::result::Result<tonic::Response<super::ListAgentPoolsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/ListAgentPools");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "ListAgentPools"));
self.inner.unary(req, path, codec).await
}
/// Deletes an agent pool.
pub async fn delete_agent_pool(&mut self, request: impl tonic::IntoRequest<super::DeleteAgentPoolRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.storagetransfer.v1.StorageTransferService/DeleteAgentPool");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.storagetransfer.v1.StorageTransferService", "DeleteAgentPool"));
self.inner.unary(req, path, codec).await
}
}
}
