// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Namespaces {
#[prost(string, repeated, tag = "1")]
pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespacedName {
#[prost(string, tag = "1")]
pub namespace: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespacedNames {
#[prost(message, repeated, tag = "1")]
pub namespaced_names: ::prost::alloc::vec::Vec<NamespacedName>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionKey {
#[prost(string, tag = "1")]
pub gcp_kms_encryption_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VolumeTypeEnum {}
/// Nested message and enum types in `VolumeTypeEnum`.
pub mod volume_type_enum {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolumeType {
Unspecified = 0,
GcePersistentDisk = 1,
}
impl VolumeType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
VolumeType::Unspecified => "VOLUME_TYPE_UNSPECIFIED",
VolumeType::GcePersistentDisk => "GCE_PERSISTENT_DISK",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VOLUME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"GCE_PERSISTENT_DISK" => Some(Self::GcePersistentDisk),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlan {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uid: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub cluster: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub retention_policy: ::core::option::Option<backup_plan::RetentionPolicy>,
#[prost(btree_map = "string, string", tag = "8")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "9")]
pub backup_schedule: ::core::option::Option<backup_plan::Schedule>,
#[prost(string, tag = "10")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "11")]
pub deactivated: bool,
#[prost(message, optional, tag = "12")]
pub backup_config: ::core::option::Option<backup_plan::BackupConfig>,
#[prost(int32, tag = "13")]
pub protected_pod_count: i32,
#[prost(enumeration = "backup_plan::State", tag = "14")]
pub state: i32,
#[prost(string, tag = "15")]
pub state_reason: ::prost::alloc::string::String,
#[prost(int32, tag = "16")]
pub rpo_risk_level: i32,
#[prost(string, tag = "17")]
pub rpo_risk_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BackupPlan`.
pub mod backup_plan {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetentionPolicy {
#[prost(int32, tag = "1")]
pub backup_delete_lock_days: i32,
#[prost(int32, tag = "2")]
pub backup_retain_days: i32,
#[prost(bool, tag = "3")]
pub locked: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schedule {
#[prost(string, tag = "1")]
pub cron_schedule: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub paused: bool,
#[prost(message, optional, tag = "3")]
pub rpo_config: ::core::option::Option<super::RpoConfig>,
#[prost(message, optional, tag = "4")]
pub next_scheduled_backup_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupConfig {
#[prost(bool, tag = "4")]
pub include_volume_data: bool,
#[prost(bool, tag = "5")]
pub include_secrets: bool,
#[prost(message, optional, tag = "6")]
pub encryption_key: ::core::option::Option<super::EncryptionKey>,
#[prost(bool, tag = "7")]
pub permissive_mode: bool,
#[prost(oneof = "backup_config::BackupScope", tags = "1, 2, 3")]
pub backup_scope: ::core::option::Option<backup_config::BackupScope>,
}
/// Nested message and enum types in `BackupConfig`.
pub mod backup_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum BackupScope {
#[prost(bool, tag = "1")]
AllNamespaces(bool),
#[prost(message, tag = "2")]
SelectedNamespaces(super::super::Namespaces),
#[prost(message, tag = "3")]
SelectedApplications(super::super::NamespacedNames),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
ClusterPending = 1,
Provisioning = 2,
Ready = 3,
Failed = 4,
Deactivated = 5,
Deleting = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::ClusterPending => "CLUSTER_PENDING",
State::Provisioning => "PROVISIONING",
State::Ready => "READY",
State::Failed => "FAILED",
State::Deactivated => "DEACTIVATED",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CLUSTER_PENDING" => Some(Self::ClusterPending),
"PROVISIONING" => Some(Self::Provisioning),
"READY" => Some(Self::Ready),
"FAILED" => Some(Self::Failed),
"DEACTIVATED" => Some(Self::Deactivated),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpoConfig {
#[prost(int32, tag = "1")]
pub target_rpo_minutes: i32,
#[prost(message, repeated, tag = "2")]
pub exclusion_windows: ::prost::alloc::vec::Vec<ExclusionWindow>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExclusionWindow {
#[prost(message, optional, tag = "1")]
pub start_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
#[prost(message, optional, tag = "2")]
pub duration: ::core::option::Option<::prost_types::Duration>,
#[prost(oneof = "exclusion_window::Recurrence", tags = "3, 4, 5")]
pub recurrence: ::core::option::Option<exclusion_window::Recurrence>,
}
/// Nested message and enum types in `ExclusionWindow`.
pub mod exclusion_window {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DayOfWeekList {
#[prost(enumeration = "super::super::super::super::r#type::DayOfWeek", repeated, packed = "false", tag = "1")]
pub days_of_week: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Recurrence {
#[prost(message, tag = "3")]
SingleOccurrenceDate(super::super::super::super::r#type::Date),
#[prost(bool, tag = "4")]
Daily(bool),
#[prost(message, tag = "5")]
DaysOfWeek(DayOfWeekList),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backup {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uid: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(bool, tag = "5")]
pub manual: bool,
#[prost(btree_map = "string, string", tag = "6")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(int32, tag = "7")]
pub delete_lock_days: i32,
#[prost(message, optional, tag = "8")]
pub delete_lock_expire_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int32, tag = "9")]
pub retain_days: i32,
#[prost(message, optional, tag = "10")]
pub retain_expire_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "11")]
pub encryption_key: ::core::option::Option<EncryptionKey>,
#[prost(bool, tag = "15")]
pub contains_volume_data: bool,
#[prost(bool, tag = "16")]
pub contains_secrets: bool,
#[prost(message, optional, tag = "17")]
pub cluster_metadata: ::core::option::Option<backup::ClusterMetadata>,
#[prost(enumeration = "backup::State", tag = "18")]
pub state: i32,
#[prost(string, tag = "19")]
pub state_reason: ::prost::alloc::string::String,
#[prost(message, optional, tag = "20")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int32, tag = "21")]
pub resource_count: i32,
#[prost(int32, tag = "22")]
pub volume_count: i32,
#[prost(int64, tag = "23")]
pub size_bytes: i64,
#[prost(string, tag = "24")]
pub etag: ::prost::alloc::string::String,
#[prost(string, tag = "25")]
pub description: ::prost::alloc::string::String,
#[prost(int32, tag = "26")]
pub pod_count: i32,
#[prost(int64, tag = "27")]
pub config_backup_size_bytes: i64,
#[prost(bool, tag = "28")]
pub permissive_mode: bool,
#[prost(oneof = "backup::BackupScope", tags = "12, 13, 14")]
pub backup_scope: ::core::option::Option<backup::BackupScope>,
}
/// Nested message and enum types in `Backup`.
pub mod backup {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterMetadata {
#[prost(string, tag = "1")]
pub cluster: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub k8s_version: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "3")]
pub backup_crd_versions: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(oneof = "cluster_metadata::PlatformVersion", tags = "4, 5")]
pub platform_version: ::core::option::Option<cluster_metadata::PlatformVersion>,
}
/// Nested message and enum types in `ClusterMetadata`.
pub mod cluster_metadata {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum PlatformVersion {
#[prost(string, tag = "4")]
GkeVersion(::prost::alloc::string::String),
#[prost(string, tag = "5")]
AnthosVersion(::prost::alloc::string::String),
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
InProgress = 2,
Succeeded = 3,
Failed = 4,
Deleting = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::InProgress => "IN_PROGRESS",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"IN_PROGRESS" => Some(Self::InProgress),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum BackupScope {
#[prost(bool, tag = "12")]
AllNamespaces(bool),
#[prost(message, tag = "13")]
SelectedNamespaces(super::Namespaces),
#[prost(message, tag = "14")]
SelectedApplications(super::NamespacedNames),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restore {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uid: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub backup: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub cluster: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub restore_config: ::core::option::Option<RestoreConfig>,
#[prost(btree_map = "string, string", tag = "9")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(enumeration = "restore::State", tag = "10")]
pub state: i32,
#[prost(string, tag = "11")]
pub state_reason: ::prost::alloc::string::String,
#[prost(message, optional, tag = "12")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(int32, tag = "13")]
pub resources_restored_count: i32,
#[prost(int32, tag = "14")]
pub resources_excluded_count: i32,
#[prost(int32, tag = "15")]
pub resources_failed_count: i32,
#[prost(int32, tag = "16")]
pub volumes_restored_count: i32,
#[prost(string, tag = "17")]
pub etag: ::prost::alloc::string::String,
#[prost(message, optional, tag = "18")]
pub filter: ::core::option::Option<restore::Filter>,
#[prost(message, repeated, tag = "19")]
pub volume_data_restore_policy_overrides: ::prost::alloc::vec::Vec<VolumeDataRestorePolicyOverride>,
}
/// Nested message and enum types in `Restore`.
pub mod restore {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
#[prost(message, repeated, tag = "1")]
pub inclusion_filters: ::prost::alloc::vec::Vec<super::ResourceSelector>,
#[prost(message, repeated, tag = "2")]
pub exclusion_filters: ::prost::alloc::vec::Vec<super::ResourceSelector>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
InProgress = 2,
Succeeded = 3,
Failed = 4,
Deleting = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::InProgress => "IN_PROGRESS",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"IN_PROGRESS" => Some(Self::InProgress),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreConfig {
#[prost(enumeration = "restore_config::VolumeDataRestorePolicy", tag = "1")]
pub volume_data_restore_policy: i32,
#[prost(enumeration = "restore_config::ClusterResourceConflictPolicy", tag = "2")]
pub cluster_resource_conflict_policy: i32,
#[prost(enumeration = "restore_config::NamespacedResourceRestoreMode", tag = "3")]
pub namespaced_resource_restore_mode: i32,
#[prost(message, optional, tag = "4")]
pub cluster_resource_restore_scope: ::core::option::Option<restore_config::ClusterResourceRestoreScope>,
#[prost(message, repeated, tag = "8")]
pub substitution_rules: ::prost::alloc::vec::Vec<restore_config::SubstitutionRule>,
#[prost(message, repeated, tag = "11")]
pub transformation_rules: ::prost::alloc::vec::Vec<restore_config::TransformationRule>,
#[prost(message, repeated, tag = "12")]
pub volume_data_restore_policy_bindings: ::prost::alloc::vec::Vec<restore_config::VolumeDataRestorePolicyBinding>,
#[prost(message, optional, tag = "13")]
pub restore_order: ::core::option::Option<restore_config::RestoreOrder>,
#[prost(oneof = "restore_config::NamespacedResourceRestoreScope", tags = "5, 6, 7, 9, 10")]
pub namespaced_resource_restore_scope: ::core::option::Option<restore_config::NamespacedResourceRestoreScope>,
}
/// Nested message and enum types in `RestoreConfig`.
pub mod restore_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupKind {
#[prost(string, tag = "1")]
pub resource_group: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub resource_kind: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterResourceRestoreScope {
#[prost(message, repeated, tag = "1")]
pub selected_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
#[prost(message, repeated, tag = "2")]
pub excluded_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
#[prost(bool, tag = "3")]
pub all_group_kinds: bool,
#[prost(bool, tag = "4")]
pub no_group_kinds: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubstitutionRule {
#[prost(string, repeated, tag = "1")]
pub target_namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "2")]
pub target_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
#[prost(string, tag = "3")]
pub target_json_path: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub original_value_pattern: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub new_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformationRuleAction {
#[prost(enumeration = "transformation_rule_action::Op", tag = "1")]
pub op: i32,
#[prost(string, tag = "2")]
pub from_path: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub path: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub value: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TransformationRuleAction`.
pub mod transformation_rule_action {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Op {
Unspecified = 0,
Remove = 1,
Move = 2,
Copy = 3,
Add = 4,
Test = 5,
Replace = 6,
}
impl Op {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Op::Unspecified => "OP_UNSPECIFIED",
Op::Remove => "REMOVE",
Op::Move => "MOVE",
Op::Copy => "COPY",
Op::Add => "ADD",
Op::Test => "TEST",
Op::Replace => "REPLACE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"OP_UNSPECIFIED" => Some(Self::Unspecified),
"REMOVE" => Some(Self::Remove),
"MOVE" => Some(Self::Move),
"COPY" => Some(Self::Copy),
"ADD" => Some(Self::Add),
"TEST" => Some(Self::Test),
"REPLACE" => Some(Self::Replace),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceFilter {
#[prost(string, repeated, tag = "1")]
pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "2")]
pub group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
#[prost(string, tag = "3")]
pub json_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformationRule {
#[prost(message, repeated, tag = "1")]
pub field_actions: ::prost::alloc::vec::Vec<TransformationRuleAction>,
#[prost(message, optional, tag = "2")]
pub resource_filter: ::core::option::Option<ResourceFilter>,
#[prost(string, tag = "3")]
pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VolumeDataRestorePolicyBinding {
#[prost(enumeration = "VolumeDataRestorePolicy", tag = "1")]
pub policy: i32,
#[prost(oneof = "volume_data_restore_policy_binding::Scope", tags = "2")]
pub scope: ::core::option::Option<volume_data_restore_policy_binding::Scope>,
}
/// Nested message and enum types in `VolumeDataRestorePolicyBinding`.
pub mod volume_data_restore_policy_binding {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Scope {
#[prost(enumeration = "super::super::volume_type_enum::VolumeType", tag = "2")]
VolumeType(i32),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreOrder {
#[prost(message, repeated, tag = "1")]
pub group_kind_dependencies: ::prost::alloc::vec::Vec<restore_order::GroupKindDependency>,
}
/// Nested message and enum types in `RestoreOrder`.
pub mod restore_order {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupKindDependency {
#[prost(message, optional, tag = "1")]
pub satisfying: ::core::option::Option<super::GroupKind>,
#[prost(message, optional, tag = "2")]
pub requiring: ::core::option::Option<super::GroupKind>,
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolumeDataRestorePolicy {
Unspecified = 0,
RestoreVolumeDataFromBackup = 1,
ReuseVolumeHandleFromBackup = 2,
NoVolumeDataRestoration = 3,
}
impl VolumeDataRestorePolicy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
VolumeDataRestorePolicy::Unspecified => "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED",
VolumeDataRestorePolicy::RestoreVolumeDataFromBackup => "RESTORE_VOLUME_DATA_FROM_BACKUP",
VolumeDataRestorePolicy::ReuseVolumeHandleFromBackup => "REUSE_VOLUME_HANDLE_FROM_BACKUP",
VolumeDataRestorePolicy::NoVolumeDataRestoration => "NO_VOLUME_DATA_RESTORATION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
"RESTORE_VOLUME_DATA_FROM_BACKUP" => Some(Self::RestoreVolumeDataFromBackup),
"REUSE_VOLUME_HANDLE_FROM_BACKUP" => Some(Self::ReuseVolumeHandleFromBackup),
"NO_VOLUME_DATA_RESTORATION" => Some(Self::NoVolumeDataRestoration),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClusterResourceConflictPolicy {
Unspecified = 0,
UseExistingVersion = 1,
UseBackupVersion = 2,
}
impl ClusterResourceConflictPolicy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ClusterResourceConflictPolicy::Unspecified => "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED",
ClusterResourceConflictPolicy::UseExistingVersion => "USE_EXISTING_VERSION",
ClusterResourceConflictPolicy::UseBackupVersion => "USE_BACKUP_VERSION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
"USE_EXISTING_VERSION" => Some(Self::UseExistingVersion),
"USE_BACKUP_VERSION" => Some(Self::UseBackupVersion),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NamespacedResourceRestoreMode {
Unspecified = 0,
DeleteAndRestore = 1,
FailOnConflict = 2,
MergeSkipOnConflict = 3,
MergeReplaceVolumeOnConflict = 4,
MergeReplaceOnConflict = 5,
}
impl NamespacedResourceRestoreMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
NamespacedResourceRestoreMode::Unspecified => "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED",
NamespacedResourceRestoreMode::DeleteAndRestore => "DELETE_AND_RESTORE",
NamespacedResourceRestoreMode::FailOnConflict => "FAIL_ON_CONFLICT",
NamespacedResourceRestoreMode::MergeSkipOnConflict => "MERGE_SKIP_ON_CONFLICT",
NamespacedResourceRestoreMode::MergeReplaceVolumeOnConflict => "MERGE_REPLACE_VOLUME_ON_CONFLICT",
NamespacedResourceRestoreMode::MergeReplaceOnConflict => "MERGE_REPLACE_ON_CONFLICT",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"DELETE_AND_RESTORE" => Some(Self::DeleteAndRestore),
"FAIL_ON_CONFLICT" => Some(Self::FailOnConflict),
"MERGE_SKIP_ON_CONFLICT" => Some(Self::MergeSkipOnConflict),
"MERGE_REPLACE_VOLUME_ON_CONFLICT" => Some(Self::MergeReplaceVolumeOnConflict),
"MERGE_REPLACE_ON_CONFLICT" => Some(Self::MergeReplaceOnConflict),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum NamespacedResourceRestoreScope {
#[prost(bool, tag = "5")]
AllNamespaces(bool),
#[prost(message, tag = "6")]
SelectedNamespaces(super::Namespaces),
#[prost(message, tag = "7")]
SelectedApplications(super::NamespacedNames),
#[prost(bool, tag = "9")]
NoNamespaces(bool),
#[prost(message, tag = "10")]
ExcludedNamespaces(super::Namespaces),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceSelector {
#[prost(message, optional, tag = "1")]
pub group_kind: ::core::option::Option<restore_config::GroupKind>,
#[prost(string, tag = "2")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub namespace: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "4")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VolumeDataRestorePolicyOverride {
#[prost(enumeration = "restore_config::VolumeDataRestorePolicy", tag = "1")]
pub policy: i32,
#[prost(oneof = "volume_data_restore_policy_override::Scope", tags = "2")]
pub scope: ::core::option::Option<volume_data_restore_policy_override::Scope>,
}
/// Nested message and enum types in `VolumeDataRestorePolicyOverride`.
pub mod volume_data_restore_policy_override {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Scope {
#[prost(message, tag = "2")]
SelectedPvcs(super::NamespacedNames),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlan {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uid: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub backup_plan: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub cluster: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub restore_config: ::core::option::Option<RestoreConfig>,
#[prost(btree_map = "string, string", tag = "9")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(string, tag = "10")]
pub etag: ::prost::alloc::string::String,
#[prost(enumeration = "restore_plan::State", tag = "11")]
pub state: i32,
#[prost(string, tag = "12")]
pub state_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RestorePlan`.
pub mod restore_plan {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
ClusterPending = 1,
Ready = 2,
Failed = 3,
Deleting = 4,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::ClusterPending => "CLUSTER_PENDING",
State::Ready => "READY",
State::Failed => "FAILED",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CLUSTER_PENDING" => Some(Self::ClusterPending),
"READY" => Some(Self::Ready),
"FAILED" => Some(Self::Failed),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VolumeBackup {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uid: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "5")]
pub source_pvc: ::core::option::Option<NamespacedName>,
#[prost(string, tag = "6")]
pub volume_backup_handle: ::prost::alloc::string::String,
#[prost(enumeration = "volume_backup::VolumeBackupFormat", tag = "7")]
pub format: i32,
#[prost(int64, tag = "8")]
pub storage_bytes: i64,
#[prost(int64, tag = "9")]
pub disk_size_bytes: i64,
#[prost(message, optional, tag = "10")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "volume_backup::State", tag = "11")]
pub state: i32,
#[prost(string, tag = "12")]
pub state_message: ::prost::alloc::string::String,
#[prost(string, tag = "13")]
pub etag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `VolumeBackup`.
pub mod volume_backup {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolumeBackupFormat {
Unspecified = 0,
GcePersistentDisk = 1,
}
impl VolumeBackupFormat {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
VolumeBackupFormat::Unspecified => "VOLUME_BACKUP_FORMAT_UNSPECIFIED",
VolumeBackupFormat::GcePersistentDisk => "GCE_PERSISTENT_DISK",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VOLUME_BACKUP_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
"GCE_PERSISTENT_DISK" => Some(Self::GcePersistentDisk),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Snapshotting = 2,
Uploading = 3,
Succeeded = 4,
Failed = 5,
Deleting = 6,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Snapshotting => "SNAPSHOTTING",
State::Uploading => "UPLOADING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"SNAPSHOTTING" => Some(Self::Snapshotting),
"UPLOADING" => Some(Self::Uploading),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VolumeRestore {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub uid: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub volume_backup: ::prost::alloc::string::String,
#[prost(message, optional, tag = "6")]
pub target_pvc: ::core::option::Option<NamespacedName>,
#[prost(string, tag = "7")]
pub volume_handle: ::prost::alloc::string::String,
#[prost(enumeration = "volume_restore::VolumeType", tag = "8")]
pub volume_type: i32,
#[prost(message, optional, tag = "9")]
pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "volume_restore::State", tag = "10")]
pub state: i32,
#[prost(string, tag = "11")]
pub state_message: ::prost::alloc::string::String,
#[prost(string, tag = "12")]
pub etag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `VolumeRestore`.
pub mod volume_restore {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolumeType {
Unspecified = 0,
GcePersistentDisk = 1,
}
impl VolumeType {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
VolumeType::Unspecified => "VOLUME_TYPE_UNSPECIFIED",
VolumeType::GcePersistentDisk => "GCE_PERSISTENT_DISK",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"VOLUME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"GCE_PERSISTENT_DISK" => Some(Self::GcePersistentDisk),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Creating = 1,
Restoring = 2,
Succeeded = 3,
Failed = 4,
Deleting = 5,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Creating => "CREATING",
State::Restoring => "RESTORING",
State::Succeeded => "SUCCEEDED",
State::Failed => "FAILED",
State::Deleting => "DELETING",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"CREATING" => Some(Self::Creating),
"RESTORING" => Some(Self::Restoring),
"SUCCEEDED" => Some(Self::Succeeded),
"FAILED" => Some(Self::Failed),
"DELETING" => Some(Self::Deleting),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
#[prost(message, optional, tag = "1")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub end_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "3")]
pub target: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub verb: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub status_message: ::prost::alloc::string::String,
#[prost(bool, tag = "6")]
pub requested_cancellation: bool,
#[prost(string, tag = "7")]
pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupPlanRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub backup_plan: ::core::option::Option<BackupPlan>,
#[prost(string, tag = "3")]
pub backup_plan_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupPlansRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupPlansResponse {
#[prost(message, repeated, tag = "1")]
pub backup_plans: ::prost::alloc::vec::Vec<BackupPlan>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupPlanRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackupPlanRequest {
#[prost(message, optional, tag = "1")]
pub backup_plan: ::core::option::Option<BackupPlan>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackupPlanRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub backup: ::core::option::Option<Backup>,
#[prost(string, tag = "3")]
pub backup_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsResponse {
#[prost(message, repeated, tag = "1")]
pub backups: ::prost::alloc::vec::Vec<Backup>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackupRequest {
#[prost(message, optional, tag = "1")]
pub backup: ::core::option::Option<Backup>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackupRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVolumeBackupsRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVolumeBackupsResponse {
#[prost(message, repeated, tag = "1")]
pub volume_backups: ::prost::alloc::vec::Vec<VolumeBackup>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVolumeBackupRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRestorePlanRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub restore_plan: ::core::option::Option<RestorePlan>,
#[prost(string, tag = "3")]
pub restore_plan_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRestorePlansRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRestorePlansResponse {
#[prost(message, repeated, tag = "1")]
pub restore_plans: ::prost::alloc::vec::Vec<RestorePlan>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRestorePlanRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRestorePlanRequest {
#[prost(message, optional, tag = "1")]
pub restore_plan: ::core::option::Option<RestorePlan>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRestorePlanRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRestoreRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub restore: ::core::option::Option<Restore>,
#[prost(string, tag = "3")]
pub restore_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRestoresRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRestoresResponse {
#[prost(message, repeated, tag = "1")]
pub restores: ::prost::alloc::vec::Vec<Restore>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "3")]
pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRestoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRestoreRequest {
#[prost(message, optional, tag = "1")]
pub restore: ::core::option::Option<Restore>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRestoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub etag: ::prost::alloc::string::String,
#[prost(bool, tag = "3")]
pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVolumeRestoresRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVolumeRestoresResponse {
#[prost(message, repeated, tag = "1")]
pub volume_restores: ::prost::alloc::vec::Vec<VolumeRestore>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVolumeRestoreRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupIndexDownloadUrlRequest {
#[prost(string, tag = "1")]
pub backup: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupIndexDownloadUrlResponse {
#[prost(string, tag = "1")]
pub signed_url: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod backup_for_gke_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// BackupForGKE allows Kubernetes administrators to configure, execute, and
/// manage backup and restore operations for their GKE clusters.
#[derive(Debug, Clone)]
pub struct BackupForGkeClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> BackupForGkeClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> BackupForGkeClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
BackupForGkeClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new BackupPlan in a given location.
pub async fn create_backup_plan(&mut self, request: impl tonic::IntoRequest<super::CreateBackupPlanRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/CreateBackupPlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "CreateBackupPlan"));
self.inner.unary(req, path, codec).await
}
/// Lists BackupPlans in a given location.
pub async fn list_backup_plans(&mut self, request: impl tonic::IntoRequest<super::ListBackupPlansRequest>) -> std::result::Result<tonic::Response<super::ListBackupPlansResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/ListBackupPlans");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "ListBackupPlans"));
self.inner.unary(req, path, codec).await
}
/// Retrieve the details of a single BackupPlan.
pub async fn get_backup_plan(&mut self, request: impl tonic::IntoRequest<super::GetBackupPlanRequest>) -> std::result::Result<tonic::Response<super::BackupPlan>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/GetBackupPlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "GetBackupPlan"));
self.inner.unary(req, path, codec).await
}
/// Update a BackupPlan.
pub async fn update_backup_plan(&mut self, request: impl tonic::IntoRequest<super::UpdateBackupPlanRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/UpdateBackupPlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "UpdateBackupPlan"));
self.inner.unary(req, path, codec).await
}
/// Deletes an existing BackupPlan.
pub async fn delete_backup_plan(&mut self, request: impl tonic::IntoRequest<super::DeleteBackupPlanRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/DeleteBackupPlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "DeleteBackupPlan"));
self.inner.unary(req, path, codec).await
}
/// Creates a Backup for the given BackupPlan.
pub async fn create_backup(&mut self, request: impl tonic::IntoRequest<super::CreateBackupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/CreateBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "CreateBackup"));
self.inner.unary(req, path, codec).await
}
/// Lists the Backups for a given BackupPlan.
pub async fn list_backups(&mut self, request: impl tonic::IntoRequest<super::ListBackupsRequest>) -> std::result::Result<tonic::Response<super::ListBackupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/ListBackups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "ListBackups"));
self.inner.unary(req, path, codec).await
}
/// Retrieve the details of a single Backup.
pub async fn get_backup(&mut self, request: impl tonic::IntoRequest<super::GetBackupRequest>) -> std::result::Result<tonic::Response<super::Backup>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/GetBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "GetBackup"));
self.inner.unary(req, path, codec).await
}
/// Update a Backup.
pub async fn update_backup(&mut self, request: impl tonic::IntoRequest<super::UpdateBackupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/UpdateBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "UpdateBackup"));
self.inner.unary(req, path, codec).await
}
/// Deletes an existing Backup.
pub async fn delete_backup(&mut self, request: impl tonic::IntoRequest<super::DeleteBackupRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/DeleteBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "DeleteBackup"));
self.inner.unary(req, path, codec).await
}
/// Lists the VolumeBackups for a given Backup.
pub async fn list_volume_backups(&mut self, request: impl tonic::IntoRequest<super::ListVolumeBackupsRequest>) -> std::result::Result<tonic::Response<super::ListVolumeBackupsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/ListVolumeBackups");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "ListVolumeBackups"));
self.inner.unary(req, path, codec).await
}
/// Retrieve the details of a single VolumeBackup.
pub async fn get_volume_backup(&mut self, request: impl tonic::IntoRequest<super::GetVolumeBackupRequest>) -> std::result::Result<tonic::Response<super::VolumeBackup>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/GetVolumeBackup");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "GetVolumeBackup"));
self.inner.unary(req, path, codec).await
}
/// Creates a new RestorePlan in a given location.
pub async fn create_restore_plan(&mut self, request: impl tonic::IntoRequest<super::CreateRestorePlanRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/CreateRestorePlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "CreateRestorePlan"));
self.inner.unary(req, path, codec).await
}
/// Lists RestorePlans in a given location.
pub async fn list_restore_plans(&mut self, request: impl tonic::IntoRequest<super::ListRestorePlansRequest>) -> std::result::Result<tonic::Response<super::ListRestorePlansResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/ListRestorePlans");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "ListRestorePlans"));
self.inner.unary(req, path, codec).await
}
/// Retrieve the details of a single RestorePlan.
pub async fn get_restore_plan(&mut self, request: impl tonic::IntoRequest<super::GetRestorePlanRequest>) -> std::result::Result<tonic::Response<super::RestorePlan>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/GetRestorePlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "GetRestorePlan"));
self.inner.unary(req, path, codec).await
}
/// Update a RestorePlan.
pub async fn update_restore_plan(&mut self, request: impl tonic::IntoRequest<super::UpdateRestorePlanRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/UpdateRestorePlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "UpdateRestorePlan"));
self.inner.unary(req, path, codec).await
}
/// Deletes an existing RestorePlan.
pub async fn delete_restore_plan(&mut self, request: impl tonic::IntoRequest<super::DeleteRestorePlanRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/DeleteRestorePlan");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "DeleteRestorePlan"));
self.inner.unary(req, path, codec).await
}
/// Creates a new Restore for the given RestorePlan.
pub async fn create_restore(&mut self, request: impl tonic::IntoRequest<super::CreateRestoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/CreateRestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "CreateRestore"));
self.inner.unary(req, path, codec).await
}
/// Lists the Restores for a given RestorePlan.
pub async fn list_restores(&mut self, request: impl tonic::IntoRequest<super::ListRestoresRequest>) -> std::result::Result<tonic::Response<super::ListRestoresResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/ListRestores");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "ListRestores"));
self.inner.unary(req, path, codec).await
}
/// Retrieves the details of a single Restore.
pub async fn get_restore(&mut self, request: impl tonic::IntoRequest<super::GetRestoreRequest>) -> std::result::Result<tonic::Response<super::Restore>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/GetRestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "GetRestore"));
self.inner.unary(req, path, codec).await
}
/// Update a Restore.
pub async fn update_restore(&mut self, request: impl tonic::IntoRequest<super::UpdateRestoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/UpdateRestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "UpdateRestore"));
self.inner.unary(req, path, codec).await
}
/// Deletes an existing Restore.
pub async fn delete_restore(&mut self, request: impl tonic::IntoRequest<super::DeleteRestoreRequest>) -> std::result::Result<tonic::Response<super::super::super::super::longrunning::Operation>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/DeleteRestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "DeleteRestore"));
self.inner.unary(req, path, codec).await
}
/// Lists the VolumeRestores for a given Restore.
pub async fn list_volume_restores(&mut self, request: impl tonic::IntoRequest<super::ListVolumeRestoresRequest>) -> std::result::Result<tonic::Response<super::ListVolumeRestoresResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/ListVolumeRestores");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "ListVolumeRestores"));
self.inner.unary(req, path, codec).await
}
/// Retrieve the details of a single VolumeRestore.
pub async fn get_volume_restore(&mut self, request: impl tonic::IntoRequest<super::GetVolumeRestoreRequest>) -> std::result::Result<tonic::Response<super::VolumeRestore>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/GetVolumeRestore");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "GetVolumeRestore"));
self.inner.unary(req, path, codec).await
}
/// Retrieve the link to the backupIndex.
pub async fn get_backup_index_download_url(&mut self, request: impl tonic::IntoRequest<super::GetBackupIndexDownloadUrlRequest>) -> std::result::Result<tonic::Response<super::GetBackupIndexDownloadUrlResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.gkebackup.v1.BackupForGKE/GetBackupIndexDownloadUrl");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.gkebackup.v1.BackupForGKE", "GetBackupIndexDownloadUrl"));
self.inner.unary(req, path, codec).await
}
}
}
