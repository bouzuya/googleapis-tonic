// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(enumeration = "operation_metadata::OperationType", tag = "1")]
    pub operation_type: i32,
}
/// Nested message and enum types in `OperationMetadata`.
pub mod operation_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationType {
        Unspecified = 0,
        CreateEntitlement = 1,
        ChangeRenewalSettings = 3,
        StartPaidService = 5,
        ActivateEntitlement = 7,
        SuspendEntitlement = 8,
        CancelEntitlement = 9,
        TransferEntitlements = 10,
        TransferEntitlementsToGoogle = 11,
        ChangeOffer = 14,
        ChangeParameters = 15,
        ProvisionCloudIdentity = 16,
    }
    impl OperationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperationType::Unspecified => "OPERATION_TYPE_UNSPECIFIED",
                OperationType::CreateEntitlement => "CREATE_ENTITLEMENT",
                OperationType::ChangeRenewalSettings => "CHANGE_RENEWAL_SETTINGS",
                OperationType::StartPaidService => "START_PAID_SERVICE",
                OperationType::ActivateEntitlement => "ACTIVATE_ENTITLEMENT",
                OperationType::SuspendEntitlement => "SUSPEND_ENTITLEMENT",
                OperationType::CancelEntitlement => "CANCEL_ENTITLEMENT",
                OperationType::TransferEntitlements => "TRANSFER_ENTITLEMENTS",
                OperationType::TransferEntitlementsToGoogle => {
                    "TRANSFER_ENTITLEMENTS_TO_GOOGLE"
                }
                OperationType::ChangeOffer => "CHANGE_OFFER",
                OperationType::ChangeParameters => "CHANGE_PARAMETERS",
                OperationType::ProvisionCloudIdentity => "PROVISION_CLOUD_IDENTITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE_ENTITLEMENT" => Some(Self::CreateEntitlement),
                "CHANGE_RENEWAL_SETTINGS" => Some(Self::ChangeRenewalSettings),
                "START_PAID_SERVICE" => Some(Self::StartPaidService),
                "ACTIVATE_ENTITLEMENT" => Some(Self::ActivateEntitlement),
                "SUSPEND_ENTITLEMENT" => Some(Self::SuspendEntitlement),
                "CANCEL_ENTITLEMENT" => Some(Self::CancelEntitlement),
                "TRANSFER_ENTITLEMENTS" => Some(Self::TransferEntitlements),
                "TRANSFER_ENTITLEMENTS_TO_GOOGLE" => {
                    Some(Self::TransferEntitlementsToGoogle)
                }
                "CHANGE_OFFER" => Some(Self::ChangeOffer),
                "CHANGE_PARAMETERS" => Some(Self::ChangeParameters),
                "PROVISION_CLOUD_IDENTITY" => Some(Self::ProvisionCloudIdentity),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingAccount {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub currency_code: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub region_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EduData {
    #[prost(enumeration = "edu_data::InstituteType", tag = "1")]
    pub institute_type: i32,
    #[prost(enumeration = "edu_data::InstituteSize", tag = "2")]
    pub institute_size: i32,
    #[prost(string, tag = "3")]
    pub website: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EduData`.
pub mod edu_data {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstituteType {
        Unspecified = 0,
        K12 = 1,
        University = 2,
    }
    impl InstituteType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstituteType::Unspecified => "INSTITUTE_TYPE_UNSPECIFIED",
                InstituteType::K12 => "K12",
                InstituteType::University => "UNIVERSITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTITUTE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "K12" => Some(Self::K12),
                "UNIVERSITY" => Some(Self::University),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstituteSize {
        Unspecified = 0,
        Size1100 = 1,
        Size101500 = 2,
        Size5011000 = 3,
        Size10012000 = 4,
        Size20015000 = 5,
        Size500110000 = 6,
        Size10001OrMore = 7,
    }
    impl InstituteSize {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstituteSize::Unspecified => "INSTITUTE_SIZE_UNSPECIFIED",
                InstituteSize::Size1100 => "SIZE_1_100",
                InstituteSize::Size101500 => "SIZE_101_500",
                InstituteSize::Size5011000 => "SIZE_501_1000",
                InstituteSize::Size10012000 => "SIZE_1001_2000",
                InstituteSize::Size20015000 => "SIZE_2001_5000",
                InstituteSize::Size500110000 => "SIZE_5001_10000",
                InstituteSize::Size10001OrMore => "SIZE_10001_OR_MORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTITUTE_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
                "SIZE_1_100" => Some(Self::Size1100),
                "SIZE_101_500" => Some(Self::Size101500),
                "SIZE_501_1000" => Some(Self::Size5011000),
                "SIZE_1001_2000" => Some(Self::Size10012000),
                "SIZE_2001_5000" => Some(Self::Size20015000),
                "SIZE_5001_10000" => Some(Self::Size500110000),
                "SIZE_10001_OR_MORE" => Some(Self::Size10001OrMore),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudIdentityInfo {
    #[prost(enumeration = "cloud_identity_info::CustomerType", tag = "1")]
    pub customer_type: i32,
    #[prost(string, tag = "9")]
    pub primary_domain: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub is_domain_verified: bool,
    #[prost(string, tag = "6")]
    pub alternate_email: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub phone_number: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub admin_console_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "22")]
    pub edu_data: ::core::option::Option<EduData>,
}
/// Nested message and enum types in `CloudIdentityInfo`.
pub mod cloud_identity_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerType {
        Unspecified = 0,
        Domain = 1,
        Team = 2,
    }
    impl CustomerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerType::Unspecified => "CUSTOMER_TYPE_UNSPECIFIED",
                CustomerType::Domain => "DOMAIN",
                CustomerType::Team => "TEAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOMER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DOMAIN" => Some(Self::Domain),
                "TEAM" => Some(Self::Team),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::Kind", tags = "1, 2, 3, 4, 5")]
    pub kind: ::core::option::Option<value::Kind>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(int64, tag = "1")]
        Int64Value(i64),
        #[prost(string, tag = "2")]
        StringValue(::prost::alloc::string::String),
        #[prost(double, tag = "3")]
        DoubleValue(f64),
        #[prost(message, tag = "4")]
        ProtoValue(::prost_types::Any),
        #[prost(bool, tag = "5")]
        BoolValue(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdminUser {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub given_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub family_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Product {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub marketing_info: ::core::option::Option<MarketingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sku {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub marketing_info: ::core::option::Option<MarketingInfo>,
    #[prost(message, optional, tag = "3")]
    pub product: ::core::option::Option<Product>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketingInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub default_logo: ::core::option::Option<Media>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Media {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(enumeration = "MediaType", tag = "3")]
    pub r#type: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MediaType {
    Unspecified = 0,
    Image = 1,
}
impl MediaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MediaType::Unspecified => "MEDIA_TYPE_UNSPECIFIED",
            MediaType::Image => "MEDIA_TYPE_IMAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MEDIA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MEDIA_TYPE_IMAGE" => Some(Self::Image),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Offer {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub marketing_info: ::core::option::Option<MarketingInfo>,
    #[prost(message, optional, tag = "3")]
    pub sku: ::core::option::Option<Sku>,
    #[prost(message, optional, tag = "4")]
    pub plan: ::core::option::Option<Plan>,
    #[prost(message, optional, tag = "5")]
    pub constraints: ::core::option::Option<Constraints>,
    #[prost(message, repeated, tag = "6")]
    pub price_by_resources: ::prost::alloc::vec::Vec<PriceByResource>,
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "9")]
    pub parameter_definitions: ::prost::alloc::vec::Vec<ParameterDefinition>,
    #[prost(string, tag = "12")]
    pub deal_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterDefinition {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "parameter_definition::ParameterType", tag = "2")]
    pub parameter_type: i32,
    #[prost(message, optional, tag = "3")]
    pub min_value: ::core::option::Option<Value>,
    #[prost(message, optional, tag = "4")]
    pub max_value: ::core::option::Option<Value>,
    #[prost(message, repeated, tag = "5")]
    pub allowed_values: ::prost::alloc::vec::Vec<Value>,
    #[prost(bool, tag = "6")]
    pub optional: bool,
}
/// Nested message and enum types in `ParameterDefinition`.
pub mod parameter_definition {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParameterType {
        Unspecified = 0,
        Int64 = 1,
        String = 2,
        Double = 3,
        Boolean = 4,
    }
    impl ParameterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ParameterType::Unspecified => "PARAMETER_TYPE_UNSPECIFIED",
                ParameterType::Int64 => "INT64",
                ParameterType::String => "STRING",
                ParameterType::Double => "DOUBLE",
                ParameterType::Boolean => "BOOLEAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARAMETER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INT64" => Some(Self::Int64),
                "STRING" => Some(Self::String),
                "DOUBLE" => Some(Self::Double),
                "BOOLEAN" => Some(Self::Boolean),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Constraints {
    #[prost(message, optional, tag = "1")]
    pub customer_constraints: ::core::option::Option<CustomerConstraints>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerConstraints {
    #[prost(string, repeated, tag = "1")]
    pub allowed_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "cloud_identity_info::CustomerType", repeated, tag = "2")]
    pub allowed_customer_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "PromotionalOrderType", repeated, tag = "3")]
    pub promotional_order_types: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Plan {
    #[prost(enumeration = "PaymentPlan", tag = "1")]
    pub payment_plan: i32,
    #[prost(enumeration = "PaymentType", tag = "2")]
    pub payment_type: i32,
    #[prost(message, optional, tag = "3")]
    pub payment_cycle: ::core::option::Option<Period>,
    #[prost(message, optional, tag = "4")]
    pub trial_period: ::core::option::Option<Period>,
    #[prost(string, tag = "5")]
    pub billing_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriceByResource {
    #[prost(enumeration = "ResourceType", tag = "1")]
    pub resource_type: i32,
    #[prost(message, optional, tag = "2")]
    pub price: ::core::option::Option<Price>,
    #[prost(message, repeated, tag = "3")]
    pub price_phases: ::prost::alloc::vec::Vec<PricePhase>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Price {
    #[prost(message, optional, tag = "1")]
    pub base_price: ::core::option::Option<super::super::super::r#type::Money>,
    #[prost(double, tag = "2")]
    pub discount: f64,
    #[prost(message, optional, tag = "3")]
    pub effective_price: ::core::option::Option<super::super::super::r#type::Money>,
    #[prost(string, tag = "4")]
    pub external_price_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PricePhase {
    #[prost(enumeration = "PeriodType", tag = "1")]
    pub period_type: i32,
    #[prost(int32, tag = "2")]
    pub first_period: i32,
    #[prost(int32, tag = "3")]
    pub last_period: i32,
    #[prost(message, optional, tag = "4")]
    pub price: ::core::option::Option<Price>,
    #[prost(message, repeated, tag = "5")]
    pub price_tiers: ::prost::alloc::vec::Vec<PriceTier>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriceTier {
    #[prost(int32, tag = "1")]
    pub first_resource: i32,
    #[prost(int32, tag = "2")]
    pub last_resource: i32,
    #[prost(message, optional, tag = "3")]
    pub price: ::core::option::Option<Price>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Period {
    #[prost(int32, tag = "1")]
    pub duration: i32,
    #[prost(enumeration = "PeriodType", tag = "2")]
    pub period_type: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PromotionalOrderType {
    PromotionalTypeUnspecified = 0,
    NewUpgrade = 1,
    Transfer = 2,
    PromotionSwitch = 3,
}
impl PromotionalOrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PromotionalOrderType::PromotionalTypeUnspecified => {
                "PROMOTIONAL_TYPE_UNSPECIFIED"
            }
            PromotionalOrderType::NewUpgrade => "NEW_UPGRADE",
            PromotionalOrderType::Transfer => "TRANSFER",
            PromotionalOrderType::PromotionSwitch => "PROMOTION_SWITCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROMOTIONAL_TYPE_UNSPECIFIED" => Some(Self::PromotionalTypeUnspecified),
            "NEW_UPGRADE" => Some(Self::NewUpgrade),
            "TRANSFER" => Some(Self::Transfer),
            "PROMOTION_SWITCH" => Some(Self::PromotionSwitch),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PaymentPlan {
    Unspecified = 0,
    Commitment = 1,
    Flexible = 2,
    Free = 3,
    Trial = 4,
    Offline = 5,
}
impl PaymentPlan {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PaymentPlan::Unspecified => "PAYMENT_PLAN_UNSPECIFIED",
            PaymentPlan::Commitment => "COMMITMENT",
            PaymentPlan::Flexible => "FLEXIBLE",
            PaymentPlan::Free => "FREE",
            PaymentPlan::Trial => "TRIAL",
            PaymentPlan::Offline => "OFFLINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYMENT_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMITMENT" => Some(Self::Commitment),
            "FLEXIBLE" => Some(Self::Flexible),
            "FREE" => Some(Self::Free),
            "TRIAL" => Some(Self::Trial),
            "OFFLINE" => Some(Self::Offline),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PaymentType {
    Unspecified = 0,
    Prepay = 1,
    Postpay = 2,
}
impl PaymentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PaymentType::Unspecified => "PAYMENT_TYPE_UNSPECIFIED",
            PaymentType::Prepay => "PREPAY",
            PaymentType::Postpay => "POSTPAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PREPAY" => Some(Self::Prepay),
            "POSTPAY" => Some(Self::Postpay),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceType {
    Unspecified = 0,
    Seat = 1,
    Mau = 2,
    Gb = 3,
    LicensedUser = 4,
    Minutes = 5,
    IaasUsage = 6,
    Subscription = 7,
}
impl ResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResourceType::Unspecified => "RESOURCE_TYPE_UNSPECIFIED",
            ResourceType::Seat => "SEAT",
            ResourceType::Mau => "MAU",
            ResourceType::Gb => "GB",
            ResourceType::LicensedUser => "LICENSED_USER",
            ResourceType::Minutes => "MINUTES",
            ResourceType::IaasUsage => "IAAS_USAGE",
            ResourceType::Subscription => "SUBSCRIPTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SEAT" => Some(Self::Seat),
            "MAU" => Some(Self::Mau),
            "GB" => Some(Self::Gb),
            "LICENSED_USER" => Some(Self::LicensedUser),
            "MINUTES" => Some(Self::Minutes),
            "IAAS_USAGE" => Some(Self::IaasUsage),
            "SUBSCRIPTION" => Some(Self::Subscription),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PeriodType {
    Unspecified = 0,
    Day = 1,
    Month = 2,
    Year = 3,
}
impl PeriodType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PeriodType::Unspecified => "PERIOD_TYPE_UNSPECIFIED",
            PeriodType::Day => "DAY",
            PeriodType::Month => "MONTH",
            PeriodType::Year => "YEAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERIOD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DAY" => Some(Self::Day),
            "MONTH" => Some(Self::Month),
            "YEAR" => Some(Self::Year),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Customer {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub org_display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub org_postal_address: ::core::option::Option<
        super::super::super::r#type::PostalAddress,
    >,
    #[prost(message, optional, tag = "4")]
    pub primary_contact_info: ::core::option::Option<ContactInfo>,
    #[prost(string, tag = "5")]
    pub alternate_email: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "9")]
    pub cloud_identity_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub cloud_identity_info: ::core::option::Option<CloudIdentityInfo>,
    #[prost(string, tag = "13")]
    pub channel_partner_id: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub correlation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactInfo {
    #[prost(string, tag = "1")]
    pub first_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub last_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub phone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entitlement {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "8")]
    pub offer: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub commitment_settings: ::core::option::Option<CommitmentSettings>,
    #[prost(enumeration = "entitlement::ProvisioningState", tag = "13")]
    pub provisioning_state: i32,
    #[prost(message, optional, tag = "16")]
    pub provisioned_service: ::core::option::Option<ProvisionedService>,
    #[prost(
        enumeration = "entitlement::SuspensionReason",
        repeated,
        packed = "false",
        tag = "18"
    )]
    pub suspension_reasons: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "19")]
    pub purchase_order_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "21")]
    pub trial_settings: ::core::option::Option<TrialSettings>,
    #[prost(message, optional, tag = "23")]
    pub association_info: ::core::option::Option<AssociationInfo>,
    #[prost(message, repeated, tag = "26")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
    #[prost(string, tag = "28")]
    pub billing_account: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Entitlement`.
pub mod entitlement {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningState {
        Unspecified = 0,
        Active = 1,
        Suspended = 5,
    }
    impl ProvisioningState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProvisioningState::Unspecified => "PROVISIONING_STATE_UNSPECIFIED",
                ProvisioningState::Active => "ACTIVE",
                ProvisioningState::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVISIONING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SuspensionReason {
        Unspecified = 0,
        ResellerInitiated = 1,
        TrialEnded = 2,
        RenewalWithTypeCancel = 3,
        PendingTosAcceptance = 4,
        Other = 100,
    }
    impl SuspensionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SuspensionReason::Unspecified => "SUSPENSION_REASON_UNSPECIFIED",
                SuspensionReason::ResellerInitiated => "RESELLER_INITIATED",
                SuspensionReason::TrialEnded => "TRIAL_ENDED",
                SuspensionReason::RenewalWithTypeCancel => "RENEWAL_WITH_TYPE_CANCEL",
                SuspensionReason::PendingTosAcceptance => "PENDING_TOS_ACCEPTANCE",
                SuspensionReason::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUSPENSION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "RESELLER_INITIATED" => Some(Self::ResellerInitiated),
                "TRIAL_ENDED" => Some(Self::TrialEnded),
                "RENEWAL_WITH_TYPE_CANCEL" => Some(Self::RenewalWithTypeCancel),
                "PENDING_TOS_ACCEPTANCE" => Some(Self::PendingTosAcceptance),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Value>,
    #[prost(bool, tag = "3")]
    pub editable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssociationInfo {
    #[prost(string, tag = "1")]
    pub base_entitlement: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionedService {
    #[prost(string, tag = "1")]
    pub provisioning_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sku_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommitmentSettings {
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub renewal_settings: ::core::option::Option<RenewalSettings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RenewalSettings {
    #[prost(bool, tag = "1")]
    pub enable_renewal: bool,
    #[prost(bool, tag = "2")]
    pub resize_unit_count: bool,
    #[prost(enumeration = "PaymentPlan", tag = "5")]
    pub payment_plan: i32,
    #[prost(message, optional, tag = "6")]
    pub payment_cycle: ::core::option::Option<Period>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrialSettings {
    #[prost(bool, tag = "1")]
    pub trial: bool,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferableSku {
    #[prost(message, optional, tag = "9")]
    pub transfer_eligibility: ::core::option::Option<TransferEligibility>,
    #[prost(message, optional, tag = "11")]
    pub sku: ::core::option::Option<Sku>,
    #[prost(message, optional, tag = "12")]
    pub legacy_sku: ::core::option::Option<Sku>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferEligibility {
    #[prost(bool, tag = "1")]
    pub is_eligible: bool,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "transfer_eligibility::Reason", tag = "3")]
    pub ineligibility_reason: i32,
}
/// Nested message and enum types in `TransferEligibility`.
pub mod transfer_eligibility {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        Unspecified = 0,
        PendingTosAcceptance = 1,
        SkuNotEligible = 2,
        SkuSuspended = 3,
        ChannelPartnerNotAuthorizedForSku = 4,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unspecified => "REASON_UNSPECIFIED",
                Reason::PendingTosAcceptance => "PENDING_TOS_ACCEPTANCE",
                Reason::SkuNotEligible => "SKU_NOT_ELIGIBLE",
                Reason::SkuSuspended => "SKU_SUSPENDED",
                Reason::ChannelPartnerNotAuthorizedForSku => {
                    "CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING_TOS_ACCEPTANCE" => Some(Self::PendingTosAcceptance),
                "SKU_NOT_ELIGIBLE" => Some(Self::SkuNotEligible),
                "SKU_SUSPENDED" => Some(Self::SkuSuspended),
                "CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU" => {
                    Some(Self::ChannelPartnerNotAuthorizedForSku)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelPartnerLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reseller_cloud_identity_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ChannelPartnerLinkState", tag = "3")]
    pub link_state: i32,
    #[prost(string, tag = "4")]
    pub invite_link_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "7")]
    pub public_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub channel_partner_cloud_identity_info: ::core::option::Option<CloudIdentityInfo>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChannelPartnerLinkView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl ChannelPartnerLinkView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChannelPartnerLinkView::Unspecified => "UNSPECIFIED",
            ChannelPartnerLinkView::Basic => "BASIC",
            ChannelPartnerLinkView::Full => "FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "BASIC" => Some(Self::Basic),
            "FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChannelPartnerLinkState {
    Unspecified = 0,
    Invited = 1,
    Active = 2,
    Revoked = 3,
    Suspended = 4,
}
impl ChannelPartnerLinkState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChannelPartnerLinkState::Unspecified => {
                "CHANNEL_PARTNER_LINK_STATE_UNSPECIFIED"
            }
            ChannelPartnerLinkState::Invited => "INVITED",
            ChannelPartnerLinkState::Active => "ACTIVE",
            ChannelPartnerLinkState::Revoked => "REVOKED",
            ChannelPartnerLinkState::Suspended => "SUSPENDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANNEL_PARTNER_LINK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "INVITED" => Some(Self::Invited),
            "ACTIVE" => Some(Self::Active),
            "REVOKED" => Some(Self::Revoked),
            "SUSPENDED" => Some(Self::Suspended),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntitlementChange {
    #[prost(string, tag = "1")]
    pub entitlement: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub offer: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub provisioned_service: ::core::option::Option<ProvisionedService>,
    #[prost(enumeration = "entitlement_change::ChangeType", tag = "4")]
    pub change_type: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "entitlement_change::OperatorType", tag = "6")]
    pub operator_type: i32,
    #[prost(message, repeated, tag = "8")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
    #[prost(string, tag = "12")]
    pub operator: ::prost::alloc::string::String,
    #[prost(oneof = "entitlement_change::ChangeReason", tags = "9, 10, 11, 100")]
    pub change_reason: ::core::option::Option<entitlement_change::ChangeReason>,
}
/// Nested message and enum types in `EntitlementChange`.
pub mod entitlement_change {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeType {
        Unspecified = 0,
        Created = 1,
        PricePlanSwitched = 3,
        CommitmentChanged = 4,
        Renewed = 5,
        Suspended = 6,
        Activated = 7,
        Cancelled = 8,
        SkuChanged = 9,
        RenewalSettingChanged = 10,
        PaidSubscriptionStarted = 11,
        LicenseCapChanged = 12,
        SuspensionDetailsChanged = 13,
        TrialEndDateExtended = 14,
        TrialStarted = 15,
    }
    impl ChangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeType::Unspecified => "CHANGE_TYPE_UNSPECIFIED",
                ChangeType::Created => "CREATED",
                ChangeType::PricePlanSwitched => "PRICE_PLAN_SWITCHED",
                ChangeType::CommitmentChanged => "COMMITMENT_CHANGED",
                ChangeType::Renewed => "RENEWED",
                ChangeType::Suspended => "SUSPENDED",
                ChangeType::Activated => "ACTIVATED",
                ChangeType::Cancelled => "CANCELLED",
                ChangeType::SkuChanged => "SKU_CHANGED",
                ChangeType::RenewalSettingChanged => "RENEWAL_SETTING_CHANGED",
                ChangeType::PaidSubscriptionStarted => "PAID_SUBSCRIPTION_STARTED",
                ChangeType::LicenseCapChanged => "LICENSE_CAP_CHANGED",
                ChangeType::SuspensionDetailsChanged => "SUSPENSION_DETAILS_CHANGED",
                ChangeType::TrialEndDateExtended => "TRIAL_END_DATE_EXTENDED",
                ChangeType::TrialStarted => "TRIAL_STARTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHANGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATED" => Some(Self::Created),
                "PRICE_PLAN_SWITCHED" => Some(Self::PricePlanSwitched),
                "COMMITMENT_CHANGED" => Some(Self::CommitmentChanged),
                "RENEWED" => Some(Self::Renewed),
                "SUSPENDED" => Some(Self::Suspended),
                "ACTIVATED" => Some(Self::Activated),
                "CANCELLED" => Some(Self::Cancelled),
                "SKU_CHANGED" => Some(Self::SkuChanged),
                "RENEWAL_SETTING_CHANGED" => Some(Self::RenewalSettingChanged),
                "PAID_SUBSCRIPTION_STARTED" => Some(Self::PaidSubscriptionStarted),
                "LICENSE_CAP_CHANGED" => Some(Self::LicenseCapChanged),
                "SUSPENSION_DETAILS_CHANGED" => Some(Self::SuspensionDetailsChanged),
                "TRIAL_END_DATE_EXTENDED" => Some(Self::TrialEndDateExtended),
                "TRIAL_STARTED" => Some(Self::TrialStarted),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperatorType {
        Unspecified = 0,
        CustomerServiceRepresentative = 1,
        System = 2,
        Customer = 3,
        Reseller = 4,
    }
    impl OperatorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperatorType::Unspecified => "OPERATOR_TYPE_UNSPECIFIED",
                OperatorType::CustomerServiceRepresentative => {
                    "CUSTOMER_SERVICE_REPRESENTATIVE"
                }
                OperatorType::System => "SYSTEM",
                OperatorType::Customer => "CUSTOMER",
                OperatorType::Reseller => "RESELLER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOMER_SERVICE_REPRESENTATIVE" => {
                    Some(Self::CustomerServiceRepresentative)
                }
                "SYSTEM" => Some(Self::System),
                "CUSTOMER" => Some(Self::Customer),
                "RESELLER" => Some(Self::Reseller),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CancellationReason {
        Unspecified = 0,
        ServiceTerminated = 1,
        RelationshipEnded = 2,
        PartialTransfer = 3,
    }
    impl CancellationReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CancellationReason::Unspecified => "CANCELLATION_REASON_UNSPECIFIED",
                CancellationReason::ServiceTerminated => "SERVICE_TERMINATED",
                CancellationReason::RelationshipEnded => "RELATIONSHIP_ENDED",
                CancellationReason::PartialTransfer => "PARTIAL_TRANSFER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CANCELLATION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "SERVICE_TERMINATED" => Some(Self::ServiceTerminated),
                "RELATIONSHIP_ENDED" => Some(Self::RelationshipEnded),
                "PARTIAL_TRANSFER" => Some(Self::PartialTransfer),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ActivationReason {
        Unspecified = 0,
        ResellerRevokedSuspension = 1,
        CustomerAcceptedPendingTos = 2,
        RenewalSettingsChanged = 3,
        OtherActivationReason = 100,
    }
    impl ActivationReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ActivationReason::Unspecified => "ACTIVATION_REASON_UNSPECIFIED",
                ActivationReason::ResellerRevokedSuspension => {
                    "RESELLER_REVOKED_SUSPENSION"
                }
                ActivationReason::CustomerAcceptedPendingTos => {
                    "CUSTOMER_ACCEPTED_PENDING_TOS"
                }
                ActivationReason::RenewalSettingsChanged => "RENEWAL_SETTINGS_CHANGED",
                ActivationReason::OtherActivationReason => "OTHER_ACTIVATION_REASON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTIVATION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "RESELLER_REVOKED_SUSPENSION" => Some(Self::ResellerRevokedSuspension),
                "CUSTOMER_ACCEPTED_PENDING_TOS" => Some(Self::CustomerAcceptedPendingTos),
                "RENEWAL_SETTINGS_CHANGED" => Some(Self::RenewalSettingsChanged),
                "OTHER_ACTIVATION_REASON" => Some(Self::OtherActivationReason),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ChangeReason {
        #[prost(enumeration = "super::entitlement::SuspensionReason", tag = "9")]
        SuspensionReason(i32),
        #[prost(enumeration = "CancellationReason", tag = "10")]
        CancellationReason(i32),
        #[prost(enumeration = "ActivationReason", tag = "11")]
        ActivationReason(i32),
        #[prost(string, tag = "100")]
        OtherChangeReason(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerRepricingConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub repricing_config: ::core::option::Option<RepricingConfig>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelPartnerRepricingConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub repricing_config: ::core::option::Option<RepricingConfig>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepricingConfig {
    #[prost(message, optional, tag = "1")]
    pub effective_invoice_month: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    #[prost(message, optional, tag = "2")]
    pub adjustment: ::core::option::Option<RepricingAdjustment>,
    #[prost(enumeration = "RebillingBasis", tag = "3")]
    pub rebilling_basis: i32,
    #[prost(message, repeated, tag = "6")]
    pub conditional_overrides: ::prost::alloc::vec::Vec<ConditionalOverride>,
    #[prost(oneof = "repricing_config::Granularity", tags = "4, 5")]
    pub granularity: ::core::option::Option<repricing_config::Granularity>,
}
/// Nested message and enum types in `RepricingConfig`.
pub mod repricing_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EntitlementGranularity {
        #[prost(string, tag = "1")]
        pub entitlement: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ChannelPartnerGranularity {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Granularity {
        #[prost(message, tag = "4")]
        EntitlementGranularity(EntitlementGranularity),
        #[prost(message, tag = "5")]
        ChannelPartnerGranularity(ChannelPartnerGranularity),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepricingAdjustment {
    #[prost(oneof = "repricing_adjustment::Adjustment", tags = "2")]
    pub adjustment: ::core::option::Option<repricing_adjustment::Adjustment>,
}
/// Nested message and enum types in `RepricingAdjustment`.
pub mod repricing_adjustment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Adjustment {
        #[prost(message, tag = "2")]
        PercentageAdjustment(super::PercentageAdjustment),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PercentageAdjustment {
    #[prost(message, optional, tag = "2")]
    pub percentage: ::core::option::Option<super::super::super::r#type::Decimal>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionalOverride {
    #[prost(message, optional, tag = "1")]
    pub adjustment: ::core::option::Option<RepricingAdjustment>,
    #[prost(enumeration = "RebillingBasis", tag = "2")]
    pub rebilling_basis: i32,
    #[prost(message, optional, tag = "3")]
    pub repricing_condition: ::core::option::Option<RepricingCondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepricingCondition {
    #[prost(oneof = "repricing_condition::Condition", tags = "1")]
    pub condition: ::core::option::Option<repricing_condition::Condition>,
}
/// Nested message and enum types in `RepricingCondition`.
pub mod repricing_condition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Condition {
        #[prost(message, tag = "1")]
        SkuGroupCondition(super::SkuGroupCondition),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuGroupCondition {
    #[prost(string, tag = "1")]
    pub sku_group: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RebillingBasis {
    Unspecified = 0,
    CostAtList = 1,
    DirectCustomerCost = 2,
}
impl RebillingBasis {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RebillingBasis::Unspecified => "REBILLING_BASIS_UNSPECIFIED",
            RebillingBasis::CostAtList => "COST_AT_LIST",
            RebillingBasis::DirectCustomerCost => "DIRECT_CUSTOMER_COST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REBILLING_BASIS_UNSPECIFIED" => Some(Self::Unspecified),
            "COST_AT_LIST" => Some(Self::CostAtList),
            "DIRECT_CUSTOMER_COST" => Some(Self::DirectCustomerCost),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckCloudIdentityAccountsExistRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudIdentityCustomerAccount {
    #[prost(bool, tag = "1")]
    pub existing: bool,
    #[prost(bool, tag = "2")]
    pub owned: bool,
    #[prost(string, tag = "3")]
    pub customer_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub customer_cloud_identity_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckCloudIdentityAccountsExistResponse {
    #[prost(message, repeated, tag = "1")]
    pub cloud_identity_accounts: ::prost::alloc::vec::Vec<CloudIdentityCustomerAccount>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomersResponse {
    #[prost(message, repeated, tag = "1")]
    pub customers: ::prost::alloc::vec::Vec<Customer>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub customer: ::core::option::Option<Customer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomerRequest {
    #[prost(message, optional, tag = "2")]
    pub customer: ::core::option::Option<Customer>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomerRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCustomerRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub overwrite_if_exists: bool,
    #[prost(string, tag = "6")]
    pub channel_partner_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub customer: ::prost::alloc::string::String,
    #[prost(oneof = "import_customer_request::CustomerIdentity", tags = "2, 3")]
    pub customer_identity: ::core::option::Option<
        import_customer_request::CustomerIdentity,
    >,
}
/// Nested message and enum types in `ImportCustomerRequest`.
pub mod import_customer_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CustomerIdentity {
        #[prost(string, tag = "2")]
        Domain(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        CloudIdentityId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionCloudIdentityRequest {
    #[prost(string, tag = "1")]
    pub customer: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub cloud_identity_info: ::core::option::Option<CloudIdentityInfo>,
    #[prost(message, optional, tag = "3")]
    pub user: ::core::option::Option<AdminUser>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitlementsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitlementsResponse {
    #[prost(message, repeated, tag = "1")]
    pub entitlements: ::prost::alloc::vec::Vec<Entitlement>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransferableSkusRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(
        oneof = "list_transferable_skus_request::TransferredCustomerIdentity",
        tags = "4, 7"
    )]
    pub transferred_customer_identity: ::core::option::Option<
        list_transferable_skus_request::TransferredCustomerIdentity,
    >,
}
/// Nested message and enum types in `ListTransferableSkusRequest`.
pub mod list_transferable_skus_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TransferredCustomerIdentity {
        #[prost(string, tag = "4")]
        CloudIdentityId(::prost::alloc::string::String),
        #[prost(string, tag = "7")]
        CustomerName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransferableSkusResponse {
    #[prost(message, repeated, tag = "1")]
    pub transferable_skus: ::prost::alloc::vec::Vec<TransferableSku>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransferableOffersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub sku: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub billing_account: ::prost::alloc::string::String,
    #[prost(
        oneof = "list_transferable_offers_request::TransferredCustomerIdentity",
        tags = "4, 5"
    )]
    pub transferred_customer_identity: ::core::option::Option<
        list_transferable_offers_request::TransferredCustomerIdentity,
    >,
}
/// Nested message and enum types in `ListTransferableOffersRequest`.
pub mod list_transferable_offers_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TransferredCustomerIdentity {
        #[prost(string, tag = "4")]
        CloudIdentityId(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        CustomerName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransferableOffersResponse {
    #[prost(message, repeated, tag = "1")]
    pub transferable_offers: ::prost::alloc::vec::Vec<TransferableOffer>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferableOffer {
    #[prost(message, optional, tag = "1")]
    pub offer: ::core::option::Option<Offer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntitlementRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelPartnerLinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "ChannelPartnerLinkView", tag = "4")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelPartnerLinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub channel_partner_links: ::prost::alloc::vec::Vec<ChannelPartnerLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChannelPartnerLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ChannelPartnerLinkView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChannelPartnerLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub channel_partner_link: ::core::option::Option<ChannelPartnerLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateChannelPartnerLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub channel_partner_link: ::core::option::Option<ChannelPartnerLink>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerRepricingConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomerRepricingConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomerRepricingConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub customer_repricing_configs: ::prost::alloc::vec::Vec<CustomerRepricingConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerRepricingConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub customer_repricing_config: ::core::option::Option<CustomerRepricingConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomerRepricingConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub customer_repricing_config: ::core::option::Option<CustomerRepricingConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomerRepricingConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChannelPartnerRepricingConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelPartnerRepricingConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelPartnerRepricingConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub channel_partner_repricing_configs: ::prost::alloc::vec::Vec<
        ChannelPartnerRepricingConfig,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChannelPartnerRepricingConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub channel_partner_repricing_config: ::core::option::Option<
        ChannelPartnerRepricingConfig,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateChannelPartnerRepricingConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub channel_partner_repricing_config: ::core::option::Option<
        ChannelPartnerRepricingConfig,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteChannelPartnerRepricingConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkuGroupsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkuGroupBillableSkusRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkuGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub sku_groups: ::prost::alloc::vec::Vec<SkuGroup>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkuGroupBillableSkusResponse {
    #[prost(message, repeated, tag = "1")]
    pub billable_skus: ::prost::alloc::vec::Vec<BillableSku>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillableSku {
    #[prost(string, tag = "1")]
    pub sku: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub sku_display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub service: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub service_display_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntitlementRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub entitlement: ::core::option::Option<Entitlement>,
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferEntitlementsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entitlements: ::prost::alloc::vec::Vec<Entitlement>,
    #[prost(string, tag = "4")]
    pub auth_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferEntitlementsResponse {
    #[prost(message, repeated, tag = "1")]
    pub entitlements: ::prost::alloc::vec::Vec<Entitlement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferEntitlementsToGoogleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entitlements: ::prost::alloc::vec::Vec<Entitlement>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeParametersRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub purchase_order_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeRenewalSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub renewal_settings: ::core::option::Option<RenewalSettings>,
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeOfferRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub offer: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
    #[prost(string, tag = "5")]
    pub purchase_order_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub billing_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartPaidServiceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelEntitlementRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendEntitlementRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivateEntitlementRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupOfferRequest {
    #[prost(string, tag = "1")]
    pub entitlement: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsRequest {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductsResponse {
    #[prost(message, repeated, tag = "1")]
    pub products: ::prost::alloc::vec::Vec<Product>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub account: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusResponse {
    #[prost(message, repeated, tag = "1")]
    pub skus: ::prost::alloc::vec::Vec<Sku>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOffersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub show_future_offers: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOffersResponse {
    #[prost(message, repeated, tag = "1")]
    pub offers: ::prost::alloc::vec::Vec<Offer>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPurchasableSkusRequest {
    #[prost(string, tag = "1")]
    pub customer: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(oneof = "list_purchasable_skus_request::PurchaseOption", tags = "2, 3")]
    pub purchase_option: ::core::option::Option<
        list_purchasable_skus_request::PurchaseOption,
    >,
}
/// Nested message and enum types in `ListPurchasableSkusRequest`.
pub mod list_purchasable_skus_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateEntitlementPurchase {
        #[prost(string, tag = "1")]
        pub product: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChangeOfferPurchase {
        #[prost(string, tag = "1")]
        pub entitlement: ::prost::alloc::string::String,
        #[prost(enumeration = "change_offer_purchase::ChangeType", tag = "2")]
        pub change_type: i32,
    }
    /// Nested message and enum types in `ChangeOfferPurchase`.
    pub mod change_offer_purchase {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ChangeType {
            Unspecified = 0,
            Upgrade = 1,
            Downgrade = 2,
        }
        impl ChangeType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ChangeType::Unspecified => "CHANGE_TYPE_UNSPECIFIED",
                    ChangeType::Upgrade => "UPGRADE",
                    ChangeType::Downgrade => "DOWNGRADE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CHANGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "UPGRADE" => Some(Self::Upgrade),
                    "DOWNGRADE" => Some(Self::Downgrade),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PurchaseOption {
        #[prost(message, tag = "2")]
        CreateEntitlementPurchase(CreateEntitlementPurchase),
        #[prost(message, tag = "3")]
        ChangeOfferPurchase(ChangeOfferPurchase),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPurchasableSkusResponse {
    #[prost(message, repeated, tag = "1")]
    pub purchasable_skus: ::prost::alloc::vec::Vec<PurchasableSku>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurchasableSku {
    #[prost(message, optional, tag = "1")]
    pub sku: ::core::option::Option<Sku>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPurchasableOffersRequest {
    #[prost(string, tag = "1")]
    pub customer: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(oneof = "list_purchasable_offers_request::PurchaseOption", tags = "2, 3")]
    pub purchase_option: ::core::option::Option<
        list_purchasable_offers_request::PurchaseOption,
    >,
}
/// Nested message and enum types in `ListPurchasableOffersRequest`.
pub mod list_purchasable_offers_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateEntitlementPurchase {
        #[prost(string, tag = "1")]
        pub sku: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub billing_account: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChangeOfferPurchase {
        #[prost(string, tag = "1")]
        pub entitlement: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub new_sku: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub billing_account: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PurchaseOption {
        #[prost(message, tag = "2")]
        CreateEntitlementPurchase(CreateEntitlementPurchase),
        #[prost(message, tag = "3")]
        ChangeOfferPurchase(ChangeOfferPurchase),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPurchasableOffersResponse {
    #[prost(message, repeated, tag = "1")]
    pub purchasable_offers: ::prost::alloc::vec::Vec<PurchasableOffer>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurchasableOffer {
    #[prost(message, optional, tag = "1")]
    pub offer: ::core::option::Option<Offer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryEligibleBillingAccountsRequest {
    #[prost(string, tag = "1")]
    pub customer: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub skus: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryEligibleBillingAccountsResponse {
    #[prost(message, repeated, tag = "1")]
    pub sku_purchase_groups: ::prost::alloc::vec::Vec<SkuPurchaseGroup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuPurchaseGroup {
    #[prost(string, repeated, tag = "1")]
    pub skus: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub billing_account_purchase_infos: ::prost::alloc::vec::Vec<
        BillingAccountPurchaseInfo,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingAccountPurchaseInfo {
    #[prost(message, optional, tag = "1")]
    pub billing_account: ::core::option::Option<BillingAccount>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterSubscriberRequest {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub service_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterSubscriberResponse {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterSubscriberRequest {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub service_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterSubscriberResponse {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscribersRequest {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscribersResponse {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub service_accounts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitlementChangesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitlementChangesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entitlement_changes: ::prost::alloc::vec::Vec<EntitlementChange>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod cloud_channel_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// CloudChannelService lets Google cloud resellers and distributors manage
    /// their customers, channel partners, entitlements, and reports.
    ///
    /// Using this service:
    /// 1. Resellers and distributors can manage a customer entity.
    /// 2. Distributors can register an authorized reseller in their channel and
    ///    provide them with delegated admin access.
    /// 3. Resellers and distributors can manage customer entitlements.
    ///
    /// CloudChannelService exposes the following resources:
    /// - [Customer][google.cloud.channel.v1.Customer]s: An entity-usually an
    /// enterprise-managed by a reseller or distributor.
    ///
    /// - [Entitlement][google.cloud.channel.v1.Entitlement]s: An entity that
    /// provides a customer with the means to use a service. Entitlements are created
    /// or updated as a result of a successful fulfillment.
    ///
    /// - [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]s: An
    /// entity that identifies links between distributors and their indirect
    /// resellers in a channel.
    #[derive(Debug, Clone)]
    pub struct CloudChannelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CloudChannelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CloudChannelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CloudChannelServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List [Customer][google.cloud.channel.v1.Customer]s.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        ///
        /// Return value:
        /// List of [Customer][google.cloud.channel.v1.Customer]s, or an empty list if
        /// there are no customers.
        pub async fn list_customers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListCustomers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListCustomers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested [Customer][google.cloud.channel.v1.Customer]
        /// resource.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: The customer resource doesn't exist. Usually the result of an
        /// invalid name parameter.
        ///
        /// Return value:
        /// The [Customer][google.cloud.channel.v1.Customer] resource.
        pub async fn get_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerRequest>,
        ) -> std::result::Result<tonic::Response<super::Customer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/GetCustomer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "GetCustomer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Confirms the existence of Cloud Identity accounts based on the domain and
        /// if the Cloud Identity accounts are owned by the reseller.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * INVALID_VALUE: Invalid domain value in the request.
        ///
        /// Return value:
        /// A list of
        /// [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
        /// resources for the domain (may be empty)
        ///
        /// Note: in the v1alpha1 version of the API, a NOT_FOUND error returns if
        /// no
        /// [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
        /// resources match the domain.
        pub async fn check_cloud_identity_accounts_exist(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CheckCloudIdentityAccountsExistRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::CheckCloudIdentityAccountsExistResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/CheckCloudIdentityAccountsExist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "CheckCloudIdentityAccountsExist",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new [Customer][google.cloud.channel.v1.Customer] resource under
        /// the reseller or distributor account.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED:
        ///     * The reseller account making the request is different from the
        ///     reseller account in the API request.
        ///     * You are not authorized to create a customer. See
        ///     https://support.google.com/channelservices/answer/9759265
        /// * INVALID_ARGUMENT:
        ///     * Required request parameters are missing or invalid.
        ///     * Domain field value doesn't match the primary email domain.
        ///
        /// Return value:
        /// The newly created [Customer][google.cloud.channel.v1.Customer] resource.
        pub async fn create_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomerRequest>,
        ) -> std::result::Result<tonic::Response<super::Customer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/CreateCustomer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "CreateCustomer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing [Customer][google.cloud.channel.v1.Customer] resource
        /// for the reseller or distributor.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
        /// for the name in the request.
        ///
        /// Return value:
        /// The updated [Customer][google.cloud.channel.v1.Customer] resource.
        pub async fn update_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCustomerRequest>,
        ) -> std::result::Result<tonic::Response<super::Customer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/UpdateCustomer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "UpdateCustomer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the given [Customer][google.cloud.channel.v1.Customer] permanently.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The account making the request does not own
        /// this customer.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * FAILED_PRECONDITION: The customer has existing entitlements.
        /// * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
        /// for the name in the request.
        pub async fn delete_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCustomerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/DeleteCustomer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "DeleteCustomer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports a [Customer][google.cloud.channel.v1.Customer] from the Cloud
        /// Identity associated with the provided Cloud Identity ID or domain before a
        /// TransferEntitlements call. If a linked Customer already exists and
        /// overwrite_if_exists is true, it will update that Customer's data.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED:
        ///     * The reseller account making the request is different from the
        ///     reseller account in the API request.
        ///     * You are not authorized to import the customer. See
        ///     https://support.google.com/channelservices/answer/9759265
        /// * NOT_FOUND: Cloud Identity doesn't exist or was deleted.
        /// * INVALID_ARGUMENT: Required parameters are missing, or the auth_token is
        /// expired or invalid.
        /// * ALREADY_EXISTS: A customer already exists and has conflicting critical
        /// fields. Requires an overwrite.
        ///
        /// Return value:
        /// The [Customer][google.cloud.channel.v1.Customer].
        pub async fn import_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportCustomerRequest>,
        ) -> std::result::Result<tonic::Response<super::Customer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ImportCustomer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ImportCustomer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Cloud Identity for the given customer using the customer's
        /// information, or the information provided here.
        ///
        /// Possible error codes:
        ///
        /// *  PERMISSION_DENIED:
        ///      * The customer doesn't belong to the reseller.
        ///      * You are not authorized to provision cloud identity id. See
        ///      https://support.google.com/channelservices/answer/9759265
        /// *  INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// *  NOT_FOUND: The customer was not found.
        /// *  ALREADY_EXISTS: The customer's primary email already exists. Retry
        ///    after changing the customer's primary contact email.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata contains an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn provision_cloud_identity(
            &mut self,
            request: impl tonic::IntoRequest<super::ProvisionCloudIdentityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ProvisionCloudIdentity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ProvisionCloudIdentity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists [Entitlement][google.cloud.channel.v1.Entitlement]s belonging to a
        /// customer.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        ///
        /// Return value:
        /// A list of the customer's
        /// [Entitlement][google.cloud.channel.v1.Entitlement]s.
        pub async fn list_entitlements(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitlementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitlementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListEntitlements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListEntitlements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List [TransferableSku][google.cloud.channel.v1.TransferableSku]s of a
        /// customer based on the Cloud Identity ID or Customer Name in the request.
        ///
        /// Use this method to list the entitlements information of an
        /// unowned customer. You should provide the customer's
        /// Cloud Identity ID or Customer Name.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED:
        ///     * The customer doesn't belong to the reseller and has no auth token.
        ///     * The supplied auth token is invalid.
        ///     * The reseller account making the request is different
        ///     from the reseller account in the query.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        ///
        /// Return value:
        /// A list of the customer's
        /// [TransferableSku][google.cloud.channel.v1.TransferableSku].
        pub async fn list_transferable_skus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTransferableSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTransferableSkusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListTransferableSkus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListTransferableSkus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List [TransferableOffer][google.cloud.channel.v1.TransferableOffer]s of a
        /// customer based on Cloud Identity ID or Customer Name in the request.
        ///
        /// Use this method when a reseller gets the entitlement information of an
        /// unowned customer. The reseller should provide the customer's
        /// Cloud Identity ID or Customer Name.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED:
        ///     * The customer doesn't belong to the reseller and has no auth token.
        ///     * The customer provided incorrect reseller information when generating
        ///     auth token.
        ///     * The reseller account making the request is different
        ///     from the reseller account in the query.
        ///     * The reseller is not authorized to transact on this Product. See
        ///     https://support.google.com/channelservices/answer/9759265
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        ///
        /// Return value:
        /// List of [TransferableOffer][google.cloud.channel.v1.TransferableOffer] for
        /// the given customer and SKU.
        pub async fn list_transferable_offers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTransferableOffersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTransferableOffersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListTransferableOffers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListTransferableOffers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested [Entitlement][google.cloud.channel.v1.Entitlement]
        /// resource.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: The customer entitlement was not found.
        ///
        /// Return value:
        /// The requested [Entitlement][google.cloud.channel.v1.Entitlement] resource.
        pub async fn get_entitlement(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntitlementRequest>,
        ) -> std::result::Result<tonic::Response<super::Entitlement>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/GetEntitlement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "GetEntitlement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an entitlement for a customer.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED:
        ///     * The customer doesn't belong to the reseller.
        ///     * The reseller is not authorized to transact on this Product. See
        ///     https://support.google.com/channelservices/answer/9759265
        /// * INVALID_ARGUMENT:
        ///     * Required request parameters are missing or invalid.
        ///     * There is already a customer entitlement for a SKU from the same
        ///     product family.
        /// * INVALID_VALUE: Make sure the OfferId is valid. If it is, contact
        /// Google Channel support for further troubleshooting.
        /// * NOT_FOUND: The customer or offer resource was not found.
        /// * ALREADY_EXISTS:
        ///     * The SKU was already purchased for the customer.
        ///     * The customer's primary email already exists. Retry
        ///     after changing the customer's primary contact email.
        /// * CONDITION_NOT_MET or FAILED_PRECONDITION:
        ///     * The domain required for purchasing a SKU has not been verified.
        ///     * A pre-requisite SKU required to purchase an Add-On SKU is missing.
        ///     For example, Google Workspace Business Starter is required to purchase
        ///     Vault or Drive.
        ///     * (Developer accounts only) Reseller and resold domain must meet the
        ///     following naming requirements:
        ///         * Domain names must start with goog-test.
        ///         * Domain names must include the reseller domain.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn create_entitlement(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntitlementRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/CreateEntitlement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "CreateEntitlement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Change parameters of the entitlement.
        ///
        /// An entitlement update is a long-running operation and it updates the
        /// entitlement as a result of fulfillment.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// For example, the number of seats being changed is greater than the allowed
        /// number of max seats, or decreasing seats for a commitment based plan.
        /// * NOT_FOUND: Entitlement resource not found.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn change_parameters(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeParametersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ChangeParameters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ChangeParameters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the renewal settings for an existing customer entitlement.
        ///
        /// An entitlement update is a long-running operation and it updates the
        /// entitlement as a result of fulfillment.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: Entitlement resource not found.
        /// * NOT_COMMITMENT_PLAN: Renewal Settings are only applicable for a
        /// commitment plan. Can't enable or disable renewals for non-commitment plans.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        ///   Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn change_renewal_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeRenewalSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ChangeRenewalSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ChangeRenewalSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the Offer for an existing customer entitlement.
        ///
        /// An entitlement update is a long-running operation and it updates the
        /// entitlement as a result of fulfillment.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: Offer or Entitlement resource not found.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn change_offer(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeOfferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ChangeOffer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ChangeOffer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts paid service for a trial entitlement.
        ///
        /// Starts paid service for a trial entitlement immediately. This method is
        /// only applicable if a plan is set up for a trial entitlement but has some
        /// trial days remaining.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: Entitlement resource not found.
        /// * FAILED_PRECONDITION/NOT_IN_TRIAL: This method only works for
        /// entitlement on trial plans.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn start_paid_service(
            &mut self,
            request: impl tonic::IntoRequest<super::StartPaidServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/StartPaidService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "StartPaidService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Suspends a previously fulfilled entitlement.
        ///
        /// An entitlement suspension is a long-running operation.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: Entitlement resource not found.
        /// * NOT_ACTIVE: Entitlement is not active.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn suspend_entitlement(
            &mut self,
            request: impl tonic::IntoRequest<super::SuspendEntitlementRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/SuspendEntitlement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "SuspendEntitlement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels a previously fulfilled entitlement.
        ///
        /// An entitlement cancellation is a long-running operation.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * FAILED_PRECONDITION: There are Google Cloud projects linked to the
        /// Google Cloud entitlement's Cloud Billing subaccount.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: Entitlement resource not found.
        /// * DELETION_TYPE_NOT_ALLOWED: Cancel is only allowed for Google Workspace
        /// add-ons, or entitlements for Google Cloud's development platform.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The response will contain
        /// google.protobuf.Empty on success. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn cancel_entitlement(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelEntitlementRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/CancelEntitlement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "CancelEntitlement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Activates a previously suspended entitlement. Entitlements suspended for
        /// pending ToS acceptance can't be activated using this method.
        ///
        /// An entitlement activation is a long-running operation and it updates
        /// the state of the customer entitlement.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: Entitlement resource not found.
        /// * SUSPENSION_NOT_RESELLER_INITIATED: Can only activate reseller-initiated
        /// suspensions and entitlements that have accepted the TOS.
        /// * NOT_SUSPENDED: Can only activate suspended entitlements not in an ACTIVE
        /// state.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn activate_entitlement(
            &mut self,
            request: impl tonic::IntoRequest<super::ActivateEntitlementRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ActivateEntitlement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ActivateEntitlement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Transfers customer entitlements to new reseller.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED:
        ///     * The customer doesn't belong to the reseller.
        ///     * The reseller is not authorized to transact on this Product. See
        ///     https://support.google.com/channelservices/answer/9759265
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: The customer or offer resource was not found.
        /// * ALREADY_EXISTS: The SKU was already transferred for the customer.
        /// * CONDITION_NOT_MET or FAILED_PRECONDITION:
        ///     * The SKU requires domain verification to transfer, but the domain is
        ///     not verified.
        ///     * An Add-On SKU (example, Vault or Drive) is missing the
        ///     pre-requisite SKU (example, G Suite Basic).
        ///     * (Developer accounts only) Reseller and resold domain must meet the
        ///     following naming requirements:
        ///         * Domain names must start with goog-test.
        ///         * Domain names must include the reseller domain.
        ///     * Specify all transferring entitlements.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn transfer_entitlements(
            &mut self,
            request: impl tonic::IntoRequest<super::TransferEntitlementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/TransferEntitlements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "TransferEntitlements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Transfers customer entitlements from their current reseller to Google.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: The customer or offer resource was not found.
        /// * ALREADY_EXISTS: The SKU was already transferred for the customer.
        /// * CONDITION_NOT_MET or FAILED_PRECONDITION:
        ///     * The SKU requires domain verification to transfer, but the domain is
        ///     not verified.
        ///     * An Add-On SKU (example, Vault or Drive) is missing the
        ///     pre-requisite SKU (example, G Suite Basic).
        ///     * (Developer accounts only) Reseller and resold domain must meet the
        ///     following naming requirements:
        ///         * Domain names must start with goog-test.
        ///         * Domain names must include the reseller domain.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The response will contain
        /// google.protobuf.Empty on success. The Operation metadata will contain an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        pub async fn transfer_entitlements_to_google(
            &mut self,
            request: impl tonic::IntoRequest<super::TransferEntitlementsToGoogleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/TransferEntitlementsToGoogle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "TransferEntitlementsToGoogle",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]s
        /// belonging to a distributor. You must be a distributor to call this method.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        ///
        /// Return value:
        /// The list of the distributor account's
        /// [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resources.
        pub async fn list_channel_partner_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChannelPartnerLinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChannelPartnerLinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListChannelPartnerLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListChannelPartnerLinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested
        /// [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
        /// You must be a distributor to call this method.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: ChannelPartnerLink resource not found because of an
        /// invalid channel partner link name.
        ///
        /// Return value:
        /// The [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
        /// resource.
        pub async fn get_channel_partner_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChannelPartnerLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChannelPartnerLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/GetChannelPartnerLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "GetChannelPartnerLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initiates a channel partner link between a distributor and a reseller, or
        /// between resellers in an n-tier reseller channel.
        /// Invited partners need to follow the invite_link_uri provided in the
        /// response to accept. After accepting the invitation, a link is set up
        /// between the two parties.
        /// You must be a distributor to call this method.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * ALREADY_EXISTS: The ChannelPartnerLink sent in the request already
        /// exists.
        /// * NOT_FOUND: No Cloud Identity customer exists for provided domain.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The new [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
        /// resource.
        pub async fn create_channel_partner_link(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateChannelPartnerLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChannelPartnerLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/CreateChannelPartnerLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "CreateChannelPartnerLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a channel partner link. Distributors call this method to change a
        /// link's status. For example, to suspend a partner link.
        /// You must be a distributor to call this method.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request is different
        /// from the reseller account in the API request.
        /// * INVALID_ARGUMENT:
        ///     * Required request parameters are missing or invalid.
        ///     * Link state cannot change from invited to active or suspended.
        ///     * Cannot send reseller_cloud_identity_id, invite_url, or name in update
        ///     mask.
        /// * NOT_FOUND: ChannelPartnerLink resource not found.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The updated
        /// [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
        pub async fn update_channel_partner_link(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateChannelPartnerLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChannelPartnerLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/UpdateChannelPartnerLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "UpdateChannelPartnerLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about how a Reseller modifies their bill before sending
        /// it to a Customer.
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * NOT_FOUND: The
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// was not found.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// resource, otherwise returns an error.
        pub async fn get_customer_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerRepricingConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomerRepricingConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/GetCustomerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "GetCustomerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists information about how a Reseller modifies their bill before sending
        /// it to a Customer.
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * NOT_FOUND: The
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// specified does not exist or is not associated with the given account.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// resources. The data for each resource is displayed in the ascending order
        /// of:
        ///
        /// * Customer ID
        /// * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement]
        /// * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// * [CustomerRepricingConfig.update_time][google.cloud.channel.v1.CustomerRepricingConfig.update_time]
        ///
        /// If unsuccessful, returns an error.
        pub async fn list_customer_repricing_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomerRepricingConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomerRepricingConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListCustomerRepricingConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListCustomerRepricingConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a CustomerRepricingConfig. Call this method to set modifications
        /// for a specific customer's bill. You can only create configs if the
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// is a future month. If needed, you can create a config for the current
        /// month, with some restrictions.
        ///
        /// When creating a config for a future month, make sure there are no existing
        /// configs for that
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
        ///
        /// The following restrictions are for creating configs in the current month.
        ///
        /// * This functionality is reserved for recovering from an erroneous config,
        /// and should not be used for regular business cases.
        /// * The new config will not modify exports used with other configs.
        /// Changes to the config may be immediate, but may take up to 24 hours.
        /// * There is a limit of ten configs for any
        /// [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
        /// for any
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
        /// * The contained
        /// [CustomerRepricingConfig.repricing_config][google.cloud.channel.v1.CustomerRepricingConfig.repricing_config]
        /// value must be different from the value used in the current config for a
        /// [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement].
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * INVALID_ARGUMENT: Missing or invalid required parameters in the
        /// request. Also displays if the updated config is for the current month or
        /// past months.
        /// * NOT_FOUND: The
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// specified does not exist or is not associated with the given account.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the updated
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// resource, otherwise returns an error.
        pub async fn create_customer_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomerRepricingConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomerRepricingConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/CreateCustomerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "CreateCustomerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a CustomerRepricingConfig. Call this method to set modifications
        /// for a specific customer's bill. This method overwrites the existing
        /// CustomerRepricingConfig.
        ///
        /// You can only update configs if the
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// is a future month. To make changes to configs for the current month, use
        /// [CreateCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateCustomerRepricingConfig],
        /// taking note of its restrictions. You cannot update the
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
        ///
        /// When updating a config in the future:
        ///
        /// * This config must already exist.
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * INVALID_ARGUMENT: Missing or invalid required parameters in the
        /// request. Also displays if the updated config is for the current month or
        /// past months.
        /// * NOT_FOUND: The
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// specified does not exist or is not associated with the given account.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the updated
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// resource, otherwise returns an error.
        pub async fn update_customer_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCustomerRepricingConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomerRepricingConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/UpdateCustomerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "UpdateCustomerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the given
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// permanently. You can only delete configs if their
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// is set to a date after the current month.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The account making the request does not own
        /// this customer.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * FAILED_PRECONDITION: The
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// is active or in the past.
        /// * NOT_FOUND: No
        /// [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
        /// found for the name in the request.
        pub async fn delete_customer_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCustomerRepricingConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/DeleteCustomerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "DeleteCustomerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about how a Distributor modifies their bill before sending
        /// it to a ChannelPartner.
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * NOT_FOUND: The
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// was not found.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// resource, otherwise returns an error.
        pub async fn get_channel_partner_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetChannelPartnerRepricingConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ChannelPartnerRepricingConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/GetChannelPartnerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "GetChannelPartnerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists information about how a Reseller modifies their bill before sending
        /// it to a ChannelPartner.
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * NOT_FOUND: The
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// specified does not exist or is not associated with the given account.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// resources. The data for each resource is displayed in the ascending order
        /// of:
        ///
        /// * Channel Partner ID
        /// * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// * [ChannelPartnerRepricingConfig.update_time][google.cloud.channel.v1.ChannelPartnerRepricingConfig.update_time]
        ///
        /// If unsuccessful, returns an error.
        pub async fn list_channel_partner_repricing_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListChannelPartnerRepricingConfigsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListChannelPartnerRepricingConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListChannelPartnerRepricingConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListChannelPartnerRepricingConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a ChannelPartnerRepricingConfig. Call this method to set
        /// modifications for a specific ChannelPartner's bill. You can only create
        /// configs if the
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// is a future month. If needed, you can create a config for the current
        /// month, with some restrictions.
        ///
        /// When creating a config for a future month, make sure there are no existing
        /// configs for that
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
        ///
        /// The following restrictions are for creating configs in the current month.
        ///
        /// * This functionality is reserved for recovering from an erroneous config,
        /// and should not be used for regular business cases.
        /// * The new config will not modify exports used with other configs.
        /// Changes to the config may be immediate, but may take up to 24 hours.
        /// * There is a limit of ten configs for any ChannelPartner or
        /// [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
        /// for any
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
        /// * The contained
        /// [ChannelPartnerRepricingConfig.repricing_config][google.cloud.channel.v1.ChannelPartnerRepricingConfig.repricing_config]
        /// value must be different from the value used in the current config for a
        /// ChannelPartner.
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * INVALID_ARGUMENT: Missing or invalid required parameters in the
        /// request. Also displays if the updated config is for the current month or
        /// past months.
        /// * NOT_FOUND: The
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// specified does not exist or is not associated with the given account.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the updated
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// resource, otherwise returns an error.
        pub async fn create_channel_partner_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateChannelPartnerRepricingConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ChannelPartnerRepricingConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/CreateChannelPartnerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "CreateChannelPartnerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a ChannelPartnerRepricingConfig. Call this method to set
        /// modifications for a specific ChannelPartner's bill. This method overwrites
        /// the existing CustomerRepricingConfig.
        ///
        /// You can only update configs if the
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// is a future month. To make changes to configs for the current month, use
        /// [CreateChannelPartnerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateChannelPartnerRepricingConfig],
        /// taking note of its restrictions. You cannot update the
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
        ///
        /// When updating a config in the future:
        ///
        /// * This config must already exist.
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different.
        /// * INVALID_ARGUMENT: Missing or invalid required parameters in the
        /// request. Also displays if the updated config is for the current month or
        /// past months.
        /// * NOT_FOUND: The
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// specified does not exist or is not associated with the given account.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the updated
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// resource, otherwise returns an error.
        pub async fn update_channel_partner_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateChannelPartnerRepricingConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ChannelPartnerRepricingConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/UpdateChannelPartnerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "UpdateChannelPartnerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the given
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// permanently. You can only delete configs if their
        /// [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
        /// is set to a date after the current month.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The account making the request does not own
        /// this customer.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * FAILED_PRECONDITION: The
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// is active or in the past.
        /// * NOT_FOUND: No
        /// [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
        /// found for the name in the request.
        pub async fn delete_channel_partner_repricing_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteChannelPartnerRepricingConfigRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/DeleteChannelPartnerRepricingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "DeleteChannelPartnerRepricingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Rebilling supported SKU groups the account is authorized to
        /// sell.
        /// Reference: https://cloud.google.com/skus/sku-groups
        ///
        /// Possible Error Codes:
        ///
        /// * PERMISSION_DENIED: If the account making the request and the account
        /// being queried are different, or the account doesn't exist.
        /// * INTERNAL: Any non-user error related to technical issues in the
        /// backend. In this case, contact Cloud Channel support.
        ///
        /// Return Value:
        /// If successful, the [SkuGroup][google.cloud.channel.v1.SkuGroup] resources.
        /// The data for each resource is displayed in the alphabetical order of SKU
        /// group display name.
        /// The data for each resource is displayed in the ascending order of
        /// [SkuGroup.display_name][google.cloud.channel.v1.SkuGroup.display_name]
        ///
        /// If unsuccessful, returns an error.
        pub async fn list_sku_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSkuGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSkuGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListSkuGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListSkuGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Billable SKUs in a given SKU group.
        ///
        /// Possible error codes:
        /// PERMISSION_DENIED: If the account making the request and the account
        /// being queried for are different, or the account doesn't exist.
        /// INVALID_ARGUMENT: Missing or invalid required parameters in the
        /// request.
        /// INTERNAL: Any non-user error related to technical issue in the
        /// backend. In this case, contact cloud channel support.
        ///
        /// Return Value:
        /// If successful, the [BillableSku][google.cloud.channel.v1.BillableSku]
        /// resources. The data for each resource is displayed in the ascending order
        /// of:
        ///
        /// * [BillableSku.service_display_name][google.cloud.channel.v1.BillableSku.service_display_name]
        /// * [BillableSku.sku_display_name][google.cloud.channel.v1.BillableSku.sku_display_name]
        ///
        /// If unsuccessful, returns an error.
        pub async fn list_sku_group_billable_skus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSkuGroupBillableSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSkuGroupBillableSkusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListSkuGroupBillableSkus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListSkuGroupBillableSkus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the requested [Offer][google.cloud.channel.v1.Offer] resource.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The entitlement doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: Entitlement or offer was not found.
        ///
        /// Return value:
        /// The [Offer][google.cloud.channel.v1.Offer] resource.
        pub async fn lookup_offer(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupOfferRequest>,
        ) -> std::result::Result<tonic::Response<super::Offer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/LookupOffer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "LookupOffer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Products the reseller is authorized to sell.
        ///
        /// Possible error codes:
        ///
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        pub async fn list_products(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProductsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProductsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListProducts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the SKUs for a product the reseller is authorized to sell.
        ///
        /// Possible error codes:
        ///
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        pub async fn list_skus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSkusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListSkus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListSkus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Offers the reseller can sell.
        ///
        /// Possible error codes:
        ///
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        pub async fn list_offers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOffersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOffersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListOffers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListOffers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the following:
        ///
        /// * SKUs that you can purchase for a customer
        /// * SKUs that you can upgrade or downgrade for an entitlement.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        pub async fn list_purchasable_skus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPurchasableSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPurchasableSkusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListPurchasableSkus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListPurchasableSkus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the following:
        ///
        /// * Offers that you can purchase for a customer.
        /// * Offers that you can change for an entitlement.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED:
        ///     * The customer doesn't belong to the reseller
        ///     * The reseller is not authorized to transact on this Product. See
        ///     https://support.google.com/channelservices/answer/9759265
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        pub async fn list_purchasable_offers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPurchasableOffersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPurchasableOffersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListPurchasableOffers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListPurchasableOffers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the billing accounts that are eligible to purchase particular SKUs
        /// for a given customer.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The customer doesn't belong to the reseller.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        ///
        /// Return value:
        /// Based on the provided list of SKUs, returns a list of SKU groups that must
        /// be purchased using the same billing account and the billing accounts
        /// eligible to purchase each SKU group.
        pub async fn query_eligible_billing_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryEligibleBillingAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryEligibleBillingAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/QueryEligibleBillingAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "QueryEligibleBillingAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Registers a service account with subscriber privileges on the Cloud Pub/Sub
        /// topic for this Channel Services account. After you create a
        /// subscriber, you get the events through
        /// [SubscriberEvent][google.cloud.channel.v1.SubscriberEvent]
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request and the
        /// provided reseller account are different, or the impersonated user
        /// is not a super admin.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The topic name with the registered service email address.
        pub async fn register_subscriber(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterSubscriberRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterSubscriberResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/RegisterSubscriber",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "RegisterSubscriber",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Unregisters a service account with subscriber privileges on the Cloud
        /// Pub/Sub topic created for this Channel Services account. If there are no
        /// service accounts left with subscriber privileges, this deletes the topic.
        /// You can call ListSubscribers to check for these accounts.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request and the
        /// provided reseller account are different, or the impersonated user
        /// is not a super admin.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: The topic resource doesn't exist.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// The topic name that unregistered the service email address.
        /// Returns a success response if the service email address wasn't registered
        /// with the topic.
        pub async fn unregister_subscriber(
            &mut self,
            request: impl tonic::IntoRequest<super::UnregisterSubscriberRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnregisterSubscriberResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/UnregisterSubscriber",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "UnregisterSubscriber",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists service accounts with subscriber privileges on the Cloud Pub/Sub
        /// topic created for this Channel Services account.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request and the
        /// provided reseller account are different, or the impersonated user
        /// is not a super admin.
        /// * INVALID_ARGUMENT: Required request parameters are missing or invalid.
        /// * NOT_FOUND: The topic resource doesn't exist.
        /// * INTERNAL: Any non-user error related to a technical issue in the
        /// backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// Contact Cloud Channel support.
        ///
        /// Return value:
        /// A list of service email addresses.
        pub async fn list_subscribers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubscribersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubscribersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListSubscribers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListSubscribers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List entitlement history.
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The reseller account making the request and the
        /// provided reseller account are different.
        /// * INVALID_ARGUMENT: Missing or invalid required fields in the request.
        /// * NOT_FOUND: The parent resource doesn't exist. Usually the result of an
        /// invalid name parameter.
        /// * INTERNAL: Any non-user error related to a technical issue in the backend.
        /// In this case, contact CloudChannel support.
        /// * UNKNOWN: Any non-user error related to a technical issue in the backend.
        /// In this case, contact Cloud Channel support.
        ///
        /// Return value:
        /// List of [EntitlementChange][google.cloud.channel.v1.EntitlementChange]s.
        pub async fn list_entitlement_changes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitlementChangesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitlementChangesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelService/ListEntitlementChanges",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelService",
                        "ListEntitlementChanges",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerEvent {
    #[prost(string, tag = "1")]
    pub customer: ::prost::alloc::string::String,
    #[prost(enumeration = "customer_event::Type", tag = "2")]
    pub event_type: i32,
}
/// Nested message and enum types in `CustomerEvent`.
pub mod customer_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        PrimaryDomainChanged = 1,
        PrimaryDomainVerified = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::PrimaryDomainChanged => "PRIMARY_DOMAIN_CHANGED",
                Type::PrimaryDomainVerified => "PRIMARY_DOMAIN_VERIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIMARY_DOMAIN_CHANGED" => Some(Self::PrimaryDomainChanged),
                "PRIMARY_DOMAIN_VERIFIED" => Some(Self::PrimaryDomainVerified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntitlementEvent {
    #[prost(string, tag = "1")]
    pub entitlement: ::prost::alloc::string::String,
    #[prost(enumeration = "entitlement_event::Type", tag = "2")]
    pub event_type: i32,
}
/// Nested message and enum types in `EntitlementEvent`.
pub mod entitlement_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Created = 1,
        PricePlanSwitched = 3,
        CommitmentChanged = 4,
        Renewed = 5,
        Suspended = 6,
        Activated = 7,
        Cancelled = 8,
        SkuChanged = 9,
        RenewalSettingChanged = 10,
        PaidServiceStarted = 11,
        LicenseAssignmentChanged = 12,
        LicenseCapChanged = 13,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Created => "CREATED",
                Type::PricePlanSwitched => "PRICE_PLAN_SWITCHED",
                Type::CommitmentChanged => "COMMITMENT_CHANGED",
                Type::Renewed => "RENEWED",
                Type::Suspended => "SUSPENDED",
                Type::Activated => "ACTIVATED",
                Type::Cancelled => "CANCELLED",
                Type::SkuChanged => "SKU_CHANGED",
                Type::RenewalSettingChanged => "RENEWAL_SETTING_CHANGED",
                Type::PaidServiceStarted => "PAID_SERVICE_STARTED",
                Type::LicenseAssignmentChanged => "LICENSE_ASSIGNMENT_CHANGED",
                Type::LicenseCapChanged => "LICENSE_CAP_CHANGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATED" => Some(Self::Created),
                "PRICE_PLAN_SWITCHED" => Some(Self::PricePlanSwitched),
                "COMMITMENT_CHANGED" => Some(Self::CommitmentChanged),
                "RENEWED" => Some(Self::Renewed),
                "SUSPENDED" => Some(Self::Suspended),
                "ACTIVATED" => Some(Self::Activated),
                "CANCELLED" => Some(Self::Cancelled),
                "SKU_CHANGED" => Some(Self::SkuChanged),
                "RENEWAL_SETTING_CHANGED" => Some(Self::RenewalSettingChanged),
                "PAID_SERVICE_STARTED" => Some(Self::PaidServiceStarted),
                "LICENSE_ASSIGNMENT_CHANGED" => Some(Self::LicenseAssignmentChanged),
                "LICENSE_CAP_CHANGED" => Some(Self::LicenseCapChanged),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriberEvent {
    #[prost(oneof = "subscriber_event::Event", tags = "1, 2")]
    pub event: ::core::option::Option<subscriber_event::Event>,
}
/// Nested message and enum types in `SubscriberEvent`.
pub mod subscriber_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        CustomerEvent(super::CustomerEvent),
        #[prost(message, tag = "2")]
        EntitlementEvent(super::EntitlementEvent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunReportJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub date_range: ::core::option::Option<DateRange>,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunReportJobResponse {
    #[prost(message, optional, tag = "1")]
    pub report_job: ::core::option::Option<ReportJob>,
    #[prost(message, optional, tag = "2")]
    pub report_metadata: ::core::option::Option<ReportResultsMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchReportResultsRequest {
    #[prost(string, tag = "1")]
    pub report_job: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub partition_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchReportResultsResponse {
    #[prost(message, optional, tag = "1")]
    pub report_metadata: ::core::option::Option<ReportResultsMetadata>,
    #[prost(message, repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<Row>,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReportsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReportsResponse {
    #[prost(message, repeated, tag = "1")]
    pub reports: ::prost::alloc::vec::Vec<Report>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub report_status: ::core::option::Option<ReportStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportResultsMetadata {
    #[prost(message, optional, tag = "1")]
    pub report: ::core::option::Option<Report>,
    #[prost(int64, tag = "2")]
    pub row_count: i64,
    #[prost(message, optional, tag = "3")]
    pub date_range: ::core::option::Option<DateRange>,
    #[prost(message, optional, tag = "4")]
    pub preceding_date_range: ::core::option::Option<DateRange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Column {
    #[prost(string, tag = "1")]
    pub column_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "column::DataType", tag = "3")]
    pub data_type: i32,
}
/// Nested message and enum types in `Column`.
pub mod column {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Unspecified = 0,
        String = 1,
        Int = 2,
        Decimal = 3,
        Money = 4,
        Date = 5,
        DateTime = 6,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataType::Unspecified => "DATA_TYPE_UNSPECIFIED",
                DataType::String => "STRING",
                DataType::Int => "INT",
                DataType::Decimal => "DECIMAL",
                DataType::Money => "MONEY",
                DataType::Date => "DATE",
                DataType::DateTime => "DATE_TIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "INT" => Some(Self::Int),
                "DECIMAL" => Some(Self::Decimal),
                "MONEY" => Some(Self::Money),
                "DATE" => Some(Self::Date),
                "DATE_TIME" => Some(Self::DateTime),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DateRange {
    #[prost(message, optional, tag = "1")]
    pub usage_start_date_time: ::core::option::Option<
        super::super::super::r#type::DateTime,
    >,
    #[prost(message, optional, tag = "2")]
    pub usage_end_date_time: ::core::option::Option<
        super::super::super::r#type::DateTime,
    >,
    #[prost(message, optional, tag = "3")]
    pub invoice_start_date: ::core::option::Option<super::super::super::r#type::Date>,
    #[prost(message, optional, tag = "4")]
    pub invoice_end_date: ::core::option::Option<super::super::super::r#type::Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Row {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<ReportValue>,
    #[prost(string, tag = "2")]
    pub partition_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportValue {
    #[prost(oneof = "report_value::Value", tags = "1, 2, 3, 4, 5, 6")]
    pub value: ::core::option::Option<report_value::Value>,
}
/// Nested message and enum types in `ReportValue`.
pub mod report_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
        #[prost(int64, tag = "2")]
        IntValue(i64),
        #[prost(message, tag = "3")]
        DecimalValue(super::super::super::super::r#type::Decimal),
        #[prost(message, tag = "4")]
        MoneyValue(super::super::super::super::r#type::Money),
        #[prost(message, tag = "5")]
        DateValue(super::super::super::super::r#type::Date),
        #[prost(message, tag = "6")]
        DateTimeValue(super::super::super::super::r#type::DateTime),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportStatus {
    #[prost(enumeration = "report_status::State", tag = "1")]
    pub state: i32,
    #[prost(message, optional, tag = "2")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `ReportStatus`.
pub mod report_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Started = 1,
        Writing = 2,
        Available = 3,
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Started => "STARTED",
                State::Writing => "WRITING",
                State::Available => "AVAILABLE",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STARTED" => Some(Self::Started),
                "WRITING" => Some(Self::Writing),
                "AVAILABLE" => Some(Self::Available),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Report {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod cloud_channel_reports_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// CloudChannelReportsService lets Google Cloud resellers and
    /// distributors retrieve and combine a variety of data in Cloud Channel for
    /// multiple products (Google Cloud, Google Voice, and Google Workspace.)
    ///
    /// Deprecated: This service is being deprecated. Please use [Export Channel
    /// Services data to
    /// BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
    /// instead.
    #[derive(Debug, Clone)]
    pub struct CloudChannelReportsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CloudChannelReportsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CloudChannelReportsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CloudChannelReportsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Begins generation of data for a given report. The report
        /// identifier is a UID (for example, `613bf59q`).
        ///
        /// Possible error codes:
        ///
        /// * PERMISSION_DENIED: The user doesn't have access to this report.
        /// * INVALID_ARGUMENT: Required request parameters are missing
        ///   or invalid.
        /// * NOT_FOUND: The report identifier was not found.
        /// * INTERNAL: Any non-user error related to a technical issue
        ///   in the backend. Contact Cloud Channel support.
        /// * UNKNOWN: Any non-user error related to a technical issue
        ///   in the backend. Contact Cloud Channel support.
        ///
        /// Return value:
        /// The ID of a long-running operation.
        ///
        /// To get the results of the operation, call the GetOperation method of
        /// CloudChannelOperationsService. The Operation metadata contains an
        /// instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
        ///
        /// To get the results of report generation, call
        /// [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults]
        /// with the
        /// [RunReportJobResponse.report_job][google.cloud.channel.v1.RunReportJobResponse.report_job].
        ///
        /// Deprecated: Please use [Export Channel Services data to
        /// BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
        /// instead.
        pub async fn run_report_job(
            &mut self,
            request: impl tonic::IntoRequest<super::RunReportJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelReportsService/RunReportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelReportsService",
                        "RunReportJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves data generated by
        /// [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob].
        ///
        /// Deprecated: Please use [Export Channel Services data to
        /// BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
        /// instead.
        pub async fn fetch_report_results(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchReportResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchReportResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelReportsService/FetchReportResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelReportsService",
                        "FetchReportResults",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the reports that RunReportJob can run. These reports include an ID,
        /// a description, and the list of columns that will be in the result.
        ///
        /// Deprecated: Please use [Export Channel Services data to
        /// BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
        /// instead.
        pub async fn list_reports(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReportsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReportsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.channel.v1.CloudChannelReportsService/ListReports",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.channel.v1.CloudChannelReportsService",
                        "ListReports",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
