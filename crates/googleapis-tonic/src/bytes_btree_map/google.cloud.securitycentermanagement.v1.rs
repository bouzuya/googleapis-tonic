// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityCenterService {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(enumeration = "security_center_service::EnablementState", tag = "2")]
pub intended_enablement_state: i32,
#[prost(enumeration = "security_center_service::EnablementState", tag = "3")]
pub effective_enablement_state: i32,
#[prost(btree_map = "string, message", tag = "4")]
pub modules: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, security_center_service::ModuleSettings>,
#[prost(message, optional, tag = "5")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "6")]
pub service_config: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `SecurityCenterService`.
pub mod security_center_service {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleSettings {
#[prost(enumeration = "EnablementState", tag = "1")]
pub intended_enablement_state: i32,
#[prost(enumeration = "EnablementState", tag = "2")]
pub effective_enablement_state: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnablementState {
Unspecified = 0,
Inherited = 1,
Enabled = 2,
Disabled = 3,
IngestOnly = 4,
}
impl EnablementState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EnablementState::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
EnablementState::Inherited => "INHERITED",
EnablementState::Enabled => "ENABLED",
EnablementState::Disabled => "DISABLED",
EnablementState::IngestOnly => "INGEST_ONLY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"INHERITED" => Some(Self::Inherited),
"ENABLED" => Some(Self::Enabled),
"DISABLED" => Some(Self::Disabled),
"INGEST_ONLY" => Some(Self::IngestOnly),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffectiveSecurityHealthAnalyticsCustomModule {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub custom_config: ::core::option::Option<CustomConfig>,
#[prost(enumeration = "effective_security_health_analytics_custom_module::EnablementState", tag = "3")]
pub enablement_state: i32,
#[prost(string, tag = "4")]
pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EffectiveSecurityHealthAnalyticsCustomModule`.
pub mod effective_security_health_analytics_custom_module {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnablementState {
Unspecified = 0,
Enabled = 1,
Disabled = 2,
}
impl EnablementState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EnablementState::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
EnablementState::Enabled => "ENABLED",
EnablementState::Disabled => "DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ENABLED" => Some(Self::Enabled),
"DISABLED" => Some(Self::Disabled),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveSecurityHealthAnalyticsCustomModulesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveSecurityHealthAnalyticsCustomModulesResponse {
#[prost(message, repeated, tag = "1")]
pub effective_security_health_analytics_custom_modules: ::prost::alloc::vec::Vec<EffectiveSecurityHealthAnalyticsCustomModule>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectiveSecurityHealthAnalyticsCustomModuleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityHealthAnalyticsCustomModule {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub display_name: ::prost::alloc::string::String,
#[prost(enumeration = "security_health_analytics_custom_module::EnablementState", tag = "3")]
pub enablement_state: i32,
#[prost(message, optional, tag = "4")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub last_editor: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub ancestor_module: ::prost::alloc::string::String,
#[prost(message, optional, tag = "7")]
pub custom_config: ::core::option::Option<CustomConfig>,
}
/// Nested message and enum types in `SecurityHealthAnalyticsCustomModule`.
pub mod security_health_analytics_custom_module {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnablementState {
Unspecified = 0,
Enabled = 1,
Disabled = 2,
Inherited = 3,
}
impl EnablementState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EnablementState::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
EnablementState::Enabled => "ENABLED",
EnablementState::Disabled => "DISABLED",
EnablementState::Inherited => "INHERITED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ENABLED" => Some(Self::Enabled),
"DISABLED" => Some(Self::Disabled),
"INHERITED" => Some(Self::Inherited),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomConfig {
#[prost(message, optional, tag = "1")]
pub predicate: ::core::option::Option<super::super::super::r#type::Expr>,
#[prost(message, optional, tag = "2")]
pub custom_output: ::core::option::Option<custom_config::CustomOutputSpec>,
#[prost(message, optional, tag = "3")]
pub resource_selector: ::core::option::Option<custom_config::ResourceSelector>,
#[prost(enumeration = "custom_config::Severity", tag = "4")]
pub severity: i32,
#[prost(string, tag = "5")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub recommendation: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CustomConfig`.
pub mod custom_config {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomOutputSpec {
#[prost(message, repeated, tag = "1")]
pub properties: ::prost::alloc::vec::Vec<custom_output_spec::Property>,
}
/// Nested message and enum types in `CustomOutputSpec`.
pub mod custom_output_spec {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub value_expression: ::core::option::Option<super::super::super::super::super::r#type::Expr>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceSelector {
#[prost(string, repeated, tag = "1")]
pub resource_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
Unspecified = 0,
Critical = 1,
High = 2,
Medium = 3,
Low = 4,
}
impl Severity {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Severity::Unspecified => "SEVERITY_UNSPECIFIED",
Severity::Critical => "CRITICAL",
Severity::High => "HIGH",
Severity::Medium => "MEDIUM",
Severity::Low => "LOW",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
"CRITICAL" => Some(Self::Critical),
"HIGH" => Some(Self::High),
"MEDIUM" => Some(Self::Medium),
"LOW" => Some(Self::Low),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityHealthAnalyticsCustomModulesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityHealthAnalyticsCustomModulesResponse {
#[prost(message, repeated, tag = "1")]
pub security_health_analytics_custom_modules: ::prost::alloc::vec::Vec<SecurityHealthAnalyticsCustomModule>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantSecurityHealthAnalyticsCustomModulesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantSecurityHealthAnalyticsCustomModulesResponse {
#[prost(message, repeated, tag = "1")]
pub security_health_analytics_custom_modules: ::prost::alloc::vec::Vec<SecurityHealthAnalyticsCustomModule>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSecurityHealthAnalyticsCustomModuleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSecurityHealthAnalyticsCustomModuleRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub security_health_analytics_custom_module: ::core::option::Option<SecurityHealthAnalyticsCustomModule>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSecurityHealthAnalyticsCustomModuleRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub security_health_analytics_custom_module: ::core::option::Option<SecurityHealthAnalyticsCustomModule>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSecurityHealthAnalyticsCustomModuleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateSecurityHealthAnalyticsCustomModuleRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub custom_config: ::core::option::Option<CustomConfig>,
#[prost(message, optional, tag = "3")]
pub resource: ::core::option::Option<simulate_security_health_analytics_custom_module_request::SimulatedResource>,
}
/// Nested message and enum types in `SimulateSecurityHealthAnalyticsCustomModuleRequest`.
pub mod simulate_security_health_analytics_custom_module_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulatedResource {
#[prost(string, tag = "1")]
pub resource_type: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub resource_data: ::core::option::Option<::prost_types::Struct>,
#[prost(message, optional, tag = "3")]
pub iam_policy_data: ::core::option::Option<super::super::super::super::iam::v1::Policy>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulatedFinding {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub resource_name: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub category: ::prost::alloc::string::String,
#[prost(enumeration = "simulated_finding::State", tag = "5")]
pub state: i32,
#[prost(btree_map = "string, message", tag = "6")]
pub source_properties: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost_types::Value>,
#[prost(message, optional, tag = "7")]
pub event_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(enumeration = "simulated_finding::Severity", tag = "8")]
pub severity: i32,
#[prost(enumeration = "simulated_finding::FindingClass", tag = "9")]
pub finding_class: i32,
}
/// Nested message and enum types in `SimulatedFinding`.
pub mod simulated_finding {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
Unspecified = 0,
Active = 1,
Inactive = 2,
}
impl State {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
State::Unspecified => "STATE_UNSPECIFIED",
State::Active => "ACTIVE",
State::Inactive => "INACTIVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ACTIVE" => Some(Self::Active),
"INACTIVE" => Some(Self::Inactive),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
Unspecified = 0,
Critical = 1,
High = 2,
Medium = 3,
Low = 4,
}
impl Severity {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Severity::Unspecified => "SEVERITY_UNSPECIFIED",
Severity::Critical => "CRITICAL",
Severity::High => "HIGH",
Severity::Medium => "MEDIUM",
Severity::Low => "LOW",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
"CRITICAL" => Some(Self::Critical),
"HIGH" => Some(Self::High),
"MEDIUM" => Some(Self::Medium),
"LOW" => Some(Self::Low),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FindingClass {
Unspecified = 0,
Threat = 1,
Vulnerability = 2,
Misconfiguration = 3,
Observation = 4,
SccError = 5,
PostureViolation = 6,
ToxicCombination = 7,
}
impl FindingClass {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
FindingClass::Unspecified => "FINDING_CLASS_UNSPECIFIED",
FindingClass::Threat => "THREAT",
FindingClass::Vulnerability => "VULNERABILITY",
FindingClass::Misconfiguration => "MISCONFIGURATION",
FindingClass::Observation => "OBSERVATION",
FindingClass::SccError => "SCC_ERROR",
FindingClass::PostureViolation => "POSTURE_VIOLATION",
FindingClass::ToxicCombination => "TOXIC_COMBINATION",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"FINDING_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
"THREAT" => Some(Self::Threat),
"VULNERABILITY" => Some(Self::Vulnerability),
"MISCONFIGURATION" => Some(Self::Misconfiguration),
"OBSERVATION" => Some(Self::Observation),
"SCC_ERROR" => Some(Self::SccError),
"POSTURE_VIOLATION" => Some(Self::PostureViolation),
"TOXIC_COMBINATION" => Some(Self::ToxicCombination),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateSecurityHealthAnalyticsCustomModuleResponse {
#[prost(message, optional, tag = "1")]
pub result: ::core::option::Option<simulate_security_health_analytics_custom_module_response::SimulatedResult>,
}
/// Nested message and enum types in `SimulateSecurityHealthAnalyticsCustomModuleResponse`.
pub mod simulate_security_health_analytics_custom_module_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulatedResult {
#[prost(oneof = "simulated_result::Result", tags = "1, 2, 3")]
pub result: ::core::option::Option<simulated_result::Result>,
}
/// Nested message and enum types in `SimulatedResult`.
pub mod simulated_result {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Result {
#[prost(message, tag = "1")]
Finding(super::super::SimulatedFinding),
#[prost(message, tag = "2")]
NoViolation(()),
#[prost(message, tag = "3")]
Error(super::super::super::super::super::rpc::Status),
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffectiveEventThreatDetectionCustomModule {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub config: ::core::option::Option<::prost_types::Struct>,
#[prost(enumeration = "effective_event_threat_detection_custom_module::EnablementState", tag = "3")]
pub enablement_state: i32,
#[prost(string, tag = "4")]
pub r#type: ::prost::alloc::string::String,
#[prost(string, tag = "5")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EffectiveEventThreatDetectionCustomModule`.
pub mod effective_event_threat_detection_custom_module {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnablementState {
Unspecified = 0,
Enabled = 1,
Disabled = 2,
}
impl EnablementState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EnablementState::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
EnablementState::Enabled => "ENABLED",
EnablementState::Disabled => "DISABLED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ENABLED" => Some(Self::Enabled),
"DISABLED" => Some(Self::Disabled),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveEventThreatDetectionCustomModulesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveEventThreatDetectionCustomModulesResponse {
#[prost(message, repeated, tag = "1")]
pub effective_event_threat_detection_custom_modules: ::prost::alloc::vec::Vec<EffectiveEventThreatDetectionCustomModule>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectiveEventThreatDetectionCustomModuleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventThreatDetectionCustomModule {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub config: ::core::option::Option<::prost_types::Struct>,
#[prost(string, tag = "3")]
pub ancestor_module: ::prost::alloc::string::String,
#[prost(enumeration = "event_threat_detection_custom_module::EnablementState", tag = "4")]
pub enablement_state: i32,
#[prost(string, tag = "5")]
pub r#type: ::prost::alloc::string::String,
#[prost(string, tag = "6")]
pub display_name: ::prost::alloc::string::String,
#[prost(string, tag = "7")]
pub description: ::prost::alloc::string::String,
#[prost(message, optional, tag = "8")]
pub update_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "9")]
pub last_editor: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EventThreatDetectionCustomModule`.
pub mod event_threat_detection_custom_module {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnablementState {
Unspecified = 0,
Enabled = 1,
Disabled = 2,
Inherited = 3,
}
impl EnablementState {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
EnablementState::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
EnablementState::Enabled => "ENABLED",
EnablementState::Disabled => "DISABLED",
EnablementState::Inherited => "INHERITED",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
"ENABLED" => Some(Self::Enabled),
"DISABLED" => Some(Self::Disabled),
"INHERITED" => Some(Self::Inherited),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventThreatDetectionCustomModulesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventThreatDetectionCustomModulesResponse {
#[prost(message, repeated, tag = "1")]
pub event_threat_detection_custom_modules: ::prost::alloc::vec::Vec<EventThreatDetectionCustomModule>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantEventThreatDetectionCustomModulesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantEventThreatDetectionCustomModulesResponse {
#[prost(message, repeated, tag = "1")]
pub event_threat_detection_custom_modules: ::prost::alloc::vec::Vec<EventThreatDetectionCustomModule>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventThreatDetectionCustomModuleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEventThreatDetectionCustomModuleRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub event_threat_detection_custom_module: ::core::option::Option<EventThreatDetectionCustomModule>,
#[prost(bool, tag = "4")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEventThreatDetectionCustomModuleRequest {
#[prost(message, optional, tag = "1")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(message, optional, tag = "2")]
pub event_threat_detection_custom_module: ::core::option::Option<EventThreatDetectionCustomModule>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEventThreatDetectionCustomModuleRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateEventThreatDetectionCustomModuleRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub raw_text: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateEventThreatDetectionCustomModuleResponse {
#[prost(message, repeated, tag = "2")]
pub errors: ::prost::alloc::vec::Vec<validate_event_threat_detection_custom_module_response::CustomModuleValidationError>,
}
/// Nested message and enum types in `ValidateEventThreatDetectionCustomModuleResponse`.
pub mod validate_event_threat_detection_custom_module_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomModuleValidationError {
#[prost(string, tag = "1")]
pub description: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub field_path: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub start: ::core::option::Option<Position>,
#[prost(message, optional, tag = "4")]
pub end: ::core::option::Option<Position>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Position {
#[prost(int32, tag = "1")]
pub line_number: i32,
#[prost(int32, tag = "2")]
pub column_number: i32,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSecurityCenterServiceRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(bool, tag = "2")]
pub show_eligible_modules_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityCenterServicesRequest {
#[prost(string, tag = "1")]
pub parent: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(bool, tag = "4")]
pub show_eligible_modules_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityCenterServicesResponse {
#[prost(message, repeated, tag = "1")]
pub security_center_services: ::prost::alloc::vec::Vec<SecurityCenterService>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSecurityCenterServiceRequest {
#[prost(message, optional, tag = "1")]
pub security_center_service: ::core::option::Option<SecurityCenterService>,
#[prost(message, optional, tag = "2")]
pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
#[prost(bool, tag = "3")]
pub validate_only: bool,
}
/// Generated client implementations.
pub mod security_center_management_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Service describing handlers for resources
#[derive(Debug, Clone)]
pub struct SecurityCenterManagementClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SecurityCenterManagementClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SecurityCenterManagementClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SecurityCenterManagementClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Returns a list of all EffectiveSecurityHealthAnalyticsCustomModules for the
/// given parent. This includes resident modules defined at the scope of the
/// parent, and inherited modules, inherited from CRM ancestors (no
/// descendants).
pub async fn list_effective_security_health_analytics_custom_modules(&mut self, request: impl tonic::IntoRequest<super::ListEffectiveSecurityHealthAnalyticsCustomModulesRequest>) -> std::result::Result<tonic::Response<super::ListEffectiveSecurityHealthAnalyticsCustomModulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ListEffectiveSecurityHealthAnalyticsCustomModules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ListEffectiveSecurityHealthAnalyticsCustomModules"));
self.inner.unary(req, path, codec).await
}
/// Gets details of a single EffectiveSecurityHealthAnalyticsCustomModule.
pub async fn get_effective_security_health_analytics_custom_module(&mut self, request: impl tonic::IntoRequest<super::GetEffectiveSecurityHealthAnalyticsCustomModuleRequest>) -> std::result::Result<tonic::Response<super::EffectiveSecurityHealthAnalyticsCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/GetEffectiveSecurityHealthAnalyticsCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "GetEffectiveSecurityHealthAnalyticsCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all SecurityHealthAnalyticsCustomModules for the given
/// parent. This includes resident modules defined at the scope of the parent,
/// and inherited modules, inherited from CRM ancestors (no descendants).
pub async fn list_security_health_analytics_custom_modules(&mut self, request: impl tonic::IntoRequest<super::ListSecurityHealthAnalyticsCustomModulesRequest>) -> std::result::Result<tonic::Response<super::ListSecurityHealthAnalyticsCustomModulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ListSecurityHealthAnalyticsCustomModules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ListSecurityHealthAnalyticsCustomModules"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all resident SecurityHealthAnalyticsCustomModules under
/// the given CRM parent and all of the parent's CRM descendants.
pub async fn list_descendant_security_health_analytics_custom_modules(&mut self, request: impl tonic::IntoRequest<super::ListDescendantSecurityHealthAnalyticsCustomModulesRequest>) -> std::result::Result<tonic::Response<super::ListDescendantSecurityHealthAnalyticsCustomModulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ListDescendantSecurityHealthAnalyticsCustomModules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ListDescendantSecurityHealthAnalyticsCustomModules"));
self.inner.unary(req, path, codec).await
}
/// Retrieves a SecurityHealthAnalyticsCustomModule.
pub async fn get_security_health_analytics_custom_module(&mut self, request: impl tonic::IntoRequest<super::GetSecurityHealthAnalyticsCustomModuleRequest>) -> std::result::Result<tonic::Response<super::SecurityHealthAnalyticsCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/GetSecurityHealthAnalyticsCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "GetSecurityHealthAnalyticsCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Creates a resident SecurityHealthAnalyticsCustomModule at the scope of the
/// given CRM parent, and also creates inherited
/// SecurityHealthAnalyticsCustomModules for all CRM descendants of the given
/// parent. These modules are enabled by default.
pub async fn create_security_health_analytics_custom_module(&mut self, request: impl tonic::IntoRequest<super::CreateSecurityHealthAnalyticsCustomModuleRequest>) -> std::result::Result<tonic::Response<super::SecurityHealthAnalyticsCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/CreateSecurityHealthAnalyticsCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "CreateSecurityHealthAnalyticsCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Updates the SecurityHealthAnalyticsCustomModule under the given name based
/// on the given update mask. Updating the enablement state is supported on
/// both resident and inherited modules (though resident modules cannot have an
/// enablement state of "inherited"). Updating the display name and custom
/// config of a module is supported on resident modules only.
pub async fn update_security_health_analytics_custom_module(&mut self, request: impl tonic::IntoRequest<super::UpdateSecurityHealthAnalyticsCustomModuleRequest>) -> std::result::Result<tonic::Response<super::SecurityHealthAnalyticsCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/UpdateSecurityHealthAnalyticsCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "UpdateSecurityHealthAnalyticsCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified SecurityHealthAnalyticsCustomModule and all of its
/// descendants in the CRM hierarchy. This method is only supported for
/// resident custom modules.
pub async fn delete_security_health_analytics_custom_module(&mut self, request: impl tonic::IntoRequest<super::DeleteSecurityHealthAnalyticsCustomModuleRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/DeleteSecurityHealthAnalyticsCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "DeleteSecurityHealthAnalyticsCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Simulates a given SecurityHealthAnalyticsCustomModule and Resource.
pub async fn simulate_security_health_analytics_custom_module(&mut self, request: impl tonic::IntoRequest<super::SimulateSecurityHealthAnalyticsCustomModuleRequest>) -> std::result::Result<tonic::Response<super::SimulateSecurityHealthAnalyticsCustomModuleResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/SimulateSecurityHealthAnalyticsCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "SimulateSecurityHealthAnalyticsCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Lists all effective Event Threat Detection custom modules for the
/// given parent. This includes resident modules defined at the scope of the
/// parent along with modules inherited from its ancestors.
pub async fn list_effective_event_threat_detection_custom_modules(&mut self, request: impl tonic::IntoRequest<super::ListEffectiveEventThreatDetectionCustomModulesRequest>) -> std::result::Result<tonic::Response<super::ListEffectiveEventThreatDetectionCustomModulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ListEffectiveEventThreatDetectionCustomModules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ListEffectiveEventThreatDetectionCustomModules"));
self.inner.unary(req, path, codec).await
}
/// Gets an effective ETD custom module. Retrieves the effective module at the
/// given level. The difference between an EffectiveCustomModule and a
/// CustomModule is that the fields for an EffectiveCustomModule are computed
/// from ancestors if needed. For example, the enablement_state for a
/// CustomModule can be either ENABLED, DISABLED, or INHERITED. Where as the
/// enablement_state for an EffectiveCustomModule is always computed to ENABLED
/// or DISABLED (the effective enablement_state).
pub async fn get_effective_event_threat_detection_custom_module(&mut self, request: impl tonic::IntoRequest<super::GetEffectiveEventThreatDetectionCustomModuleRequest>) -> std::result::Result<tonic::Response<super::EffectiveEventThreatDetectionCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/GetEffectiveEventThreatDetectionCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "GetEffectiveEventThreatDetectionCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Lists all Event Threat Detection custom modules for the given
/// Resource Manager parent. This includes resident modules defined at the
/// scope of the parent along with modules inherited from ancestors.
pub async fn list_event_threat_detection_custom_modules(&mut self, request: impl tonic::IntoRequest<super::ListEventThreatDetectionCustomModulesRequest>) -> std::result::Result<tonic::Response<super::ListEventThreatDetectionCustomModulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ListEventThreatDetectionCustomModules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ListEventThreatDetectionCustomModules"));
self.inner.unary(req, path, codec).await
}
/// Lists all resident Event Threat Detection custom modules under the
/// given Resource Manager parent and its descendants.
pub async fn list_descendant_event_threat_detection_custom_modules(&mut self, request: impl tonic::IntoRequest<super::ListDescendantEventThreatDetectionCustomModulesRequest>) -> std::result::Result<tonic::Response<super::ListDescendantEventThreatDetectionCustomModulesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ListDescendantEventThreatDetectionCustomModules");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ListDescendantEventThreatDetectionCustomModules"));
self.inner.unary(req, path, codec).await
}
/// Gets an Event Threat Detection custom module.
pub async fn get_event_threat_detection_custom_module(&mut self, request: impl tonic::IntoRequest<super::GetEventThreatDetectionCustomModuleRequest>) -> std::result::Result<tonic::Response<super::EventThreatDetectionCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/GetEventThreatDetectionCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "GetEventThreatDetectionCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Creates a resident Event Threat Detection custom module at the scope of the
/// given Resource Manager parent, and also creates inherited custom modules
/// for all descendants of the given parent. These modules are enabled by
/// default.
pub async fn create_event_threat_detection_custom_module(&mut self, request: impl tonic::IntoRequest<super::CreateEventThreatDetectionCustomModuleRequest>) -> std::result::Result<tonic::Response<super::EventThreatDetectionCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/CreateEventThreatDetectionCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "CreateEventThreatDetectionCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Updates the Event Threat Detection custom module with the given name based
/// on the given update mask. Updating the enablement state is supported for
/// both resident and inherited modules (though resident modules cannot have an
/// enablement state of "inherited"). Updating the display name or
/// configuration of a module is supported for resident modules only. The type
/// of a module cannot be changed.
pub async fn update_event_threat_detection_custom_module(&mut self, request: impl tonic::IntoRequest<super::UpdateEventThreatDetectionCustomModuleRequest>) -> std::result::Result<tonic::Response<super::EventThreatDetectionCustomModule>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/UpdateEventThreatDetectionCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "UpdateEventThreatDetectionCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Deletes the specified Event Threat Detection custom module and all of its
/// descendants in the Resource Manager hierarchy. This method is only
/// supported for resident custom modules.
pub async fn delete_event_threat_detection_custom_module(&mut self, request: impl tonic::IntoRequest<super::DeleteEventThreatDetectionCustomModuleRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/DeleteEventThreatDetectionCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "DeleteEventThreatDetectionCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Validates the given Event Threat Detection custom module.
pub async fn validate_event_threat_detection_custom_module(&mut self, request: impl tonic::IntoRequest<super::ValidateEventThreatDetectionCustomModuleRequest>) -> std::result::Result<tonic::Response<super::ValidateEventThreatDetectionCustomModuleResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ValidateEventThreatDetectionCustomModule");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ValidateEventThreatDetectionCustomModule"));
self.inner.unary(req, path, codec).await
}
/// Gets service settings for the specified Security Command Center service.
pub async fn get_security_center_service(&mut self, request: impl tonic::IntoRequest<super::GetSecurityCenterServiceRequest>) -> std::result::Result<tonic::Response<super::SecurityCenterService>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/GetSecurityCenterService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "GetSecurityCenterService"));
self.inner.unary(req, path, codec).await
}
/// Returns a list of all Security Command Center services for the given
/// parent.
pub async fn list_security_center_services(&mut self, request: impl tonic::IntoRequest<super::ListSecurityCenterServicesRequest>) -> std::result::Result<tonic::Response<super::ListSecurityCenterServicesResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/ListSecurityCenterServices");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "ListSecurityCenterServices"));
self.inner.unary(req, path, codec).await
}
/// Updates a Security Command Center service using the given update mask.
pub async fn update_security_center_service(&mut self, request: impl tonic::IntoRequest<super::UpdateSecurityCenterServiceRequest>) -> std::result::Result<tonic::Response<super::SecurityCenterService>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.cloud.securitycentermanagement.v1.SecurityCenterManagement/UpdateSecurityCenterService");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.cloud.securitycentermanagement.v1.SecurityCenterManagement", "UpdateSecurityCenterService"));
self.inner.unary(req, path, codec).await
}
}
}
