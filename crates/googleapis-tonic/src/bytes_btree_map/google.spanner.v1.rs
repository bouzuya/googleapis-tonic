// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyRange {
#[prost(oneof = "key_range::StartKeyType", tags = "1, 2")]
pub start_key_type: ::core::option::Option<key_range::StartKeyType>,
#[prost(oneof = "key_range::EndKeyType", tags = "3, 4")]
pub end_key_type: ::core::option::Option<key_range::EndKeyType>,
}
/// Nested message and enum types in `KeyRange`.
pub mod key_range {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum StartKeyType {
#[prost(message, tag = "1")]
StartClosed(::prost_types::ListValue),
#[prost(message, tag = "2")]
StartOpen(::prost_types::ListValue),
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum EndKeyType {
#[prost(message, tag = "3")]
EndClosed(::prost_types::ListValue),
#[prost(message, tag = "4")]
EndOpen(::prost_types::ListValue),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeySet {
#[prost(message, repeated, tag = "1")]
pub keys: ::prost::alloc::vec::Vec<::prost_types::ListValue>,
#[prost(message, repeated, tag = "2")]
pub ranges: ::prost::alloc::vec::Vec<KeyRange>,
#[prost(bool, tag = "3")]
pub all: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mutation {
#[prost(oneof = "mutation::Operation", tags = "1, 2, 3, 4, 5")]
pub operation: ::core::option::Option<mutation::Operation>,
}
/// Nested message and enum types in `Mutation`.
pub mod mutation {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Write {
#[prost(string, tag = "1")]
pub table: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "2")]
pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, repeated, tag = "3")]
pub values: ::prost::alloc::vec::Vec<::prost_types::ListValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Delete {
#[prost(string, tag = "1")]
pub table: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub key_set: ::core::option::Option<super::KeySet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Operation {
#[prost(message, tag = "1")]
Insert(Write),
#[prost(message, tag = "2")]
Update(Write),
#[prost(message, tag = "3")]
InsertOrUpdate(Write),
#[prost(message, tag = "4")]
Replace(Write),
#[prost(message, tag = "5")]
Delete(Delete),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommitResponse {
#[prost(message, optional, tag = "1")]
pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "2")]
pub commit_stats: ::core::option::Option<commit_response::CommitStats>,
}
/// Nested message and enum types in `CommitResponse`.
pub mod commit_response {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommitStats {
#[prost(int64, tag = "1")]
pub mutation_count: i64,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanNode {
#[prost(int32, tag = "1")]
pub index: i32,
#[prost(enumeration = "plan_node::Kind", tag = "2")]
pub kind: i32,
#[prost(string, tag = "3")]
pub display_name: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub child_links: ::prost::alloc::vec::Vec<plan_node::ChildLink>,
#[prost(message, optional, tag = "5")]
pub short_representation: ::core::option::Option<plan_node::ShortRepresentation>,
#[prost(message, optional, tag = "6")]
pub metadata: ::core::option::Option<::prost_types::Struct>,
#[prost(message, optional, tag = "7")]
pub execution_stats: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `PlanNode`.
pub mod plan_node {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildLink {
#[prost(int32, tag = "1")]
pub child_index: i32,
#[prost(string, tag = "2")]
pub r#type: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub variable: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShortRepresentation {
#[prost(string, tag = "1")]
pub description: ::prost::alloc::string::String,
#[prost(btree_map = "string, int32", tag = "2")]
pub subqueries: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Kind {
Unspecified = 0,
Relational = 1,
Scalar = 2,
}
impl Kind {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Kind::Unspecified => "KIND_UNSPECIFIED",
Kind::Relational => "RELATIONAL",
Kind::Scalar => "SCALAR",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"KIND_UNSPECIFIED" => Some(Self::Unspecified),
"RELATIONAL" => Some(Self::Relational),
"SCALAR" => Some(Self::Scalar),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPlan {
#[prost(message, repeated, tag = "1")]
pub plan_nodes: ::prost::alloc::vec::Vec<PlanNode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionOptions {
#[prost(bool, tag = "5")]
pub exclude_txn_from_change_streams: bool,
#[prost(oneof = "transaction_options::Mode", tags = "1, 3, 2")]
pub mode: ::core::option::Option<transaction_options::Mode>,
}
/// Nested message and enum types in `TransactionOptions`.
pub mod transaction_options {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadWrite {
#[prost(enumeration = "read_write::ReadLockMode", tag = "1")]
pub read_lock_mode: i32,
}
/// Nested message and enum types in `ReadWrite`.
pub mod read_write {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReadLockMode {
Unspecified = 0,
Pessimistic = 1,
Optimistic = 2,
}
impl ReadLockMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
ReadLockMode::Unspecified => "READ_LOCK_MODE_UNSPECIFIED",
ReadLockMode::Pessimistic => "PESSIMISTIC",
ReadLockMode::Optimistic => "OPTIMISTIC",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"READ_LOCK_MODE_UNSPECIFIED" => Some(Self::Unspecified),
"PESSIMISTIC" => Some(Self::Pessimistic),
"OPTIMISTIC" => Some(Self::Optimistic),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartitionedDml {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadOnly {
#[prost(bool, tag = "6")]
pub return_read_timestamp: bool,
#[prost(oneof = "read_only::TimestampBound", tags = "1, 2, 3, 4, 5")]
pub timestamp_bound: ::core::option::Option<read_only::TimestampBound>,
}
/// Nested message and enum types in `ReadOnly`.
pub mod read_only {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum TimestampBound {
#[prost(bool, tag = "1")]
Strong(bool),
#[prost(message, tag = "2")]
MinReadTimestamp(::prost_types::Timestamp),
#[prost(message, tag = "3")]
MaxStaleness(::prost_types::Duration),
#[prost(message, tag = "4")]
ReadTimestamp(::prost_types::Timestamp),
#[prost(message, tag = "5")]
ExactStaleness(::prost_types::Duration),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum Mode {
#[prost(message, tag = "1")]
ReadWrite(ReadWrite),
#[prost(message, tag = "3")]
PartitionedDml(PartitionedDml),
#[prost(message, tag = "2")]
ReadOnly(ReadOnly),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
#[prost(bytes = "bytes", tag = "1")]
pub id: ::prost::bytes::Bytes,
#[prost(message, optional, tag = "2")]
pub read_timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionSelector {
#[prost(oneof = "transaction_selector::Selector", tags = "1, 2, 3")]
pub selector: ::core::option::Option<transaction_selector::Selector>,
}
/// Nested message and enum types in `TransactionSelector`.
pub mod transaction_selector {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Selector {
#[prost(message, tag = "1")]
SingleUse(super::TransactionOptions),
#[prost(bytes, tag = "2")]
Id(::prost::bytes::Bytes),
#[prost(message, tag = "3")]
Begin(super::TransactionOptions),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Type {
#[prost(enumeration = "TypeCode", tag = "1")]
pub code: i32,
#[prost(message, optional, boxed, tag = "2")]
pub array_element_type: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
#[prost(message, optional, tag = "3")]
pub struct_type: ::core::option::Option<StructType>,
#[prost(enumeration = "TypeAnnotationCode", tag = "4")]
pub type_annotation: i32,
#[prost(string, tag = "5")]
pub proto_type_fqn: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructType {
#[prost(message, repeated, tag = "1")]
pub fields: ::prost::alloc::vec::Vec<struct_type::Field>,
}
/// Nested message and enum types in `StructType`.
pub mod struct_type {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub r#type: ::core::option::Option<super::Type>,
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TypeCode {
Unspecified = 0,
Bool = 1,
Int64 = 2,
Float64 = 3,
Float32 = 15,
Timestamp = 4,
Date = 5,
String = 6,
Bytes = 7,
Array = 8,
Struct = 9,
Numeric = 10,
Json = 11,
Proto = 13,
Enum = 14,
}
impl TypeCode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TypeCode::Unspecified => "TYPE_CODE_UNSPECIFIED",
TypeCode::Bool => "BOOL",
TypeCode::Int64 => "INT64",
TypeCode::Float64 => "FLOAT64",
TypeCode::Float32 => "FLOAT32",
TypeCode::Timestamp => "TIMESTAMP",
TypeCode::Date => "DATE",
TypeCode::String => "STRING",
TypeCode::Bytes => "BYTES",
TypeCode::Array => "ARRAY",
TypeCode::Struct => "STRUCT",
TypeCode::Numeric => "NUMERIC",
TypeCode::Json => "JSON",
TypeCode::Proto => "PROTO",
TypeCode::Enum => "ENUM",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_CODE_UNSPECIFIED" => Some(Self::Unspecified),
"BOOL" => Some(Self::Bool),
"INT64" => Some(Self::Int64),
"FLOAT64" => Some(Self::Float64),
"FLOAT32" => Some(Self::Float32),
"TIMESTAMP" => Some(Self::Timestamp),
"DATE" => Some(Self::Date),
"STRING" => Some(Self::String),
"BYTES" => Some(Self::Bytes),
"ARRAY" => Some(Self::Array),
"STRUCT" => Some(Self::Struct),
"NUMERIC" => Some(Self::Numeric),
"JSON" => Some(Self::Json),
"PROTO" => Some(Self::Proto),
"ENUM" => Some(Self::Enum),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TypeAnnotationCode {
Unspecified = 0,
PgNumeric = 2,
PgJsonb = 3,
PgOid = 4,
}
impl TypeAnnotationCode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
TypeAnnotationCode::Unspecified => "TYPE_ANNOTATION_CODE_UNSPECIFIED",
TypeAnnotationCode::PgNumeric => "PG_NUMERIC",
TypeAnnotationCode::PgJsonb => "PG_JSONB",
TypeAnnotationCode::PgOid => "PG_OID",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_ANNOTATION_CODE_UNSPECIFIED" => Some(Self::Unspecified),
"PG_NUMERIC" => Some(Self::PgNumeric),
"PG_JSONB" => Some(Self::PgJsonb),
"PG_OID" => Some(Self::PgOid),
_ => None,
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultSet {
#[prost(message, optional, tag = "1")]
pub metadata: ::core::option::Option<ResultSetMetadata>,
#[prost(message, repeated, tag = "2")]
pub rows: ::prost::alloc::vec::Vec<::prost_types::ListValue>,
#[prost(message, optional, tag = "3")]
pub stats: ::core::option::Option<ResultSetStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartialResultSet {
#[prost(message, optional, tag = "1")]
pub metadata: ::core::option::Option<ResultSetMetadata>,
#[prost(message, repeated, tag = "2")]
pub values: ::prost::alloc::vec::Vec<::prost_types::Value>,
#[prost(bool, tag = "3")]
pub chunked_value: bool,
#[prost(bytes = "bytes", tag = "4")]
pub resume_token: ::prost::bytes::Bytes,
#[prost(message, optional, tag = "5")]
pub stats: ::core::option::Option<ResultSetStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultSetMetadata {
#[prost(message, optional, tag = "1")]
pub row_type: ::core::option::Option<StructType>,
#[prost(message, optional, tag = "2")]
pub transaction: ::core::option::Option<Transaction>,
#[prost(message, optional, tag = "3")]
pub undeclared_parameters: ::core::option::Option<StructType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultSetStats {
#[prost(message, optional, tag = "1")]
pub query_plan: ::core::option::Option<QueryPlan>,
#[prost(message, optional, tag = "2")]
pub query_stats: ::core::option::Option<::prost_types::Struct>,
#[prost(oneof = "result_set_stats::RowCount", tags = "3, 4")]
pub row_count: ::core::option::Option<result_set_stats::RowCount>,
}
/// Nested message and enum types in `ResultSetStats`.
pub mod result_set_stats {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
pub enum RowCount {
#[prost(int64, tag = "3")]
RowCountExact(i64),
#[prost(int64, tag = "4")]
RowCountLowerBound(i64),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionRequest {
#[prost(string, tag = "1")]
pub database: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub session: ::core::option::Option<Session>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateSessionsRequest {
#[prost(string, tag = "1")]
pub database: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub session_template: ::core::option::Option<Session>,
#[prost(int32, tag = "3")]
pub session_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateSessionsResponse {
#[prost(message, repeated, tag = "1")]
pub session: ::prost::alloc::vec::Vec<Session>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
#[prost(btree_map = "string, string", tag = "2")]
pub labels: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
#[prost(message, optional, tag = "3")]
pub create_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(message, optional, tag = "4")]
pub approximate_last_use_time: ::core::option::Option<::prost_types::Timestamp>,
#[prost(string, tag = "5")]
pub creator_role: ::prost::alloc::string::String,
#[prost(bool, tag = "6")]
pub multiplexed: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsRequest {
#[prost(string, tag = "1")]
pub database: ::prost::alloc::string::String,
#[prost(int32, tag = "2")]
pub page_size: i32,
#[prost(string, tag = "3")]
pub page_token: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
#[prost(message, repeated, tag = "1")]
pub sessions: ::prost::alloc::vec::Vec<Session>,
#[prost(string, tag = "2")]
pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSessionRequest {
#[prost(string, tag = "1")]
pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestOptions {
#[prost(enumeration = "request_options::Priority", tag = "1")]
pub priority: i32,
#[prost(string, tag = "2")]
pub request_tag: ::prost::alloc::string::String,
#[prost(string, tag = "3")]
pub transaction_tag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RequestOptions`.
pub mod request_options {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Priority {
Unspecified = 0,
Low = 1,
Medium = 2,
High = 3,
}
impl Priority {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Priority::Unspecified => "PRIORITY_UNSPECIFIED",
Priority::Low => "PRIORITY_LOW",
Priority::Medium => "PRIORITY_MEDIUM",
Priority::High => "PRIORITY_HIGH",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"PRIORITY_UNSPECIFIED" => Some(Self::Unspecified),
"PRIORITY_LOW" => Some(Self::Low),
"PRIORITY_MEDIUM" => Some(Self::Medium),
"PRIORITY_HIGH" => Some(Self::High),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectedReadOptions {
#[prost(oneof = "directed_read_options::Replicas", tags = "1, 2")]
pub replicas: ::core::option::Option<directed_read_options::Replicas>,
}
/// Nested message and enum types in `DirectedReadOptions`.
pub mod directed_read_options {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicaSelection {
#[prost(string, tag = "1")]
pub location: ::prost::alloc::string::String,
#[prost(enumeration = "replica_selection::Type", tag = "2")]
pub r#type: i32,
}
/// Nested message and enum types in `ReplicaSelection`.
pub mod replica_selection {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
Unspecified = 0,
ReadWrite = 1,
ReadOnly = 2,
}
impl Type {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
Type::Unspecified => "TYPE_UNSPECIFIED",
Type::ReadWrite => "READ_WRITE",
Type::ReadOnly => "READ_ONLY",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"TYPE_UNSPECIFIED" => Some(Self::Unspecified),
"READ_WRITE" => Some(Self::ReadWrite),
"READ_ONLY" => Some(Self::ReadOnly),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncludeReplicas {
#[prost(message, repeated, tag = "1")]
pub replica_selections: ::prost::alloc::vec::Vec<ReplicaSelection>,
#[prost(bool, tag = "2")]
pub auto_failover_disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExcludeReplicas {
#[prost(message, repeated, tag = "1")]
pub replica_selections: ::prost::alloc::vec::Vec<ReplicaSelection>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Replicas {
#[prost(message, tag = "1")]
IncludeReplicas(IncludeReplicas),
#[prost(message, tag = "2")]
ExcludeReplicas(ExcludeReplicas),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteSqlRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub transaction: ::core::option::Option<TransactionSelector>,
#[prost(string, tag = "3")]
pub sql: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub params: ::core::option::Option<::prost_types::Struct>,
#[prost(btree_map = "string, message", tag = "5")]
pub param_types: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, Type>,
#[prost(bytes = "bytes", tag = "6")]
pub resume_token: ::prost::bytes::Bytes,
#[prost(enumeration = "execute_sql_request::QueryMode", tag = "7")]
pub query_mode: i32,
#[prost(bytes = "bytes", tag = "8")]
pub partition_token: ::prost::bytes::Bytes,
#[prost(int64, tag = "9")]
pub seqno: i64,
#[prost(message, optional, tag = "10")]
pub query_options: ::core::option::Option<execute_sql_request::QueryOptions>,
#[prost(message, optional, tag = "11")]
pub request_options: ::core::option::Option<RequestOptions>,
#[prost(message, optional, tag = "15")]
pub directed_read_options: ::core::option::Option<DirectedReadOptions>,
#[prost(bool, tag = "16")]
pub data_boost_enabled: bool,
}
/// Nested message and enum types in `ExecuteSqlRequest`.
pub mod execute_sql_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOptions {
#[prost(string, tag = "1")]
pub optimizer_version: ::prost::alloc::string::String,
#[prost(string, tag = "2")]
pub optimizer_statistics_package: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryMode {
Normal = 0,
Plan = 1,
Profile = 2,
}
impl QueryMode {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
QueryMode::Normal => "NORMAL",
QueryMode::Plan => "PLAN",
QueryMode::Profile => "PROFILE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"NORMAL" => Some(Self::Normal),
"PLAN" => Some(Self::Plan),
"PROFILE" => Some(Self::Profile),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteBatchDmlRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub transaction: ::core::option::Option<TransactionSelector>,
#[prost(message, repeated, tag = "3")]
pub statements: ::prost::alloc::vec::Vec<execute_batch_dml_request::Statement>,
#[prost(int64, tag = "4")]
pub seqno: i64,
#[prost(message, optional, tag = "5")]
pub request_options: ::core::option::Option<RequestOptions>,
}
/// Nested message and enum types in `ExecuteBatchDmlRequest`.
pub mod execute_batch_dml_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Statement {
#[prost(string, tag = "1")]
pub sql: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub params: ::core::option::Option<::prost_types::Struct>,
#[prost(btree_map = "string, message", tag = "3")]
pub param_types: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::Type>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteBatchDmlResponse {
#[prost(message, repeated, tag = "1")]
pub result_sets: ::prost::alloc::vec::Vec<ResultSet>,
#[prost(message, optional, tag = "2")]
pub status: ::core::option::Option<super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartitionOptions {
#[prost(int64, tag = "1")]
pub partition_size_bytes: i64,
#[prost(int64, tag = "2")]
pub max_partitions: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionQueryRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub transaction: ::core::option::Option<TransactionSelector>,
#[prost(string, tag = "3")]
pub sql: ::prost::alloc::string::String,
#[prost(message, optional, tag = "4")]
pub params: ::core::option::Option<::prost_types::Struct>,
#[prost(btree_map = "string, message", tag = "5")]
pub param_types: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, Type>,
#[prost(message, optional, tag = "6")]
pub partition_options: ::core::option::Option<PartitionOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionReadRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub transaction: ::core::option::Option<TransactionSelector>,
#[prost(string, tag = "3")]
pub table: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub index: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "5")]
pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "6")]
pub key_set: ::core::option::Option<KeySet>,
#[prost(message, optional, tag = "9")]
pub partition_options: ::core::option::Option<PartitionOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Partition {
#[prost(bytes = "bytes", tag = "1")]
pub partition_token: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionResponse {
#[prost(message, repeated, tag = "1")]
pub partitions: ::prost::alloc::vec::Vec<Partition>,
#[prost(message, optional, tag = "2")]
pub transaction: ::core::option::Option<Transaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub transaction: ::core::option::Option<TransactionSelector>,
#[prost(string, tag = "3")]
pub table: ::prost::alloc::string::String,
#[prost(string, tag = "4")]
pub index: ::prost::alloc::string::String,
#[prost(string, repeated, tag = "5")]
pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
#[prost(message, optional, tag = "6")]
pub key_set: ::core::option::Option<KeySet>,
#[prost(int64, tag = "8")]
pub limit: i64,
#[prost(bytes = "bytes", tag = "9")]
pub resume_token: ::prost::bytes::Bytes,
#[prost(bytes = "bytes", tag = "10")]
pub partition_token: ::prost::bytes::Bytes,
#[prost(message, optional, tag = "11")]
pub request_options: ::core::option::Option<RequestOptions>,
#[prost(message, optional, tag = "14")]
pub directed_read_options: ::core::option::Option<DirectedReadOptions>,
#[prost(bool, tag = "15")]
pub data_boost_enabled: bool,
#[prost(enumeration = "read_request::OrderBy", tag = "16")]
pub order_by: i32,
#[prost(enumeration = "read_request::LockHint", tag = "17")]
pub lock_hint: i32,
}
/// Nested message and enum types in `ReadRequest`.
pub mod read_request {
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderBy {
Unspecified = 0,
PrimaryKey = 1,
NoOrder = 2,
}
impl OrderBy {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
OrderBy::Unspecified => "ORDER_BY_UNSPECIFIED",
OrderBy::PrimaryKey => "ORDER_BY_PRIMARY_KEY",
OrderBy::NoOrder => "ORDER_BY_NO_ORDER",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"ORDER_BY_UNSPECIFIED" => Some(Self::Unspecified),
"ORDER_BY_PRIMARY_KEY" => Some(Self::PrimaryKey),
"ORDER_BY_NO_ORDER" => Some(Self::NoOrder),
_ => None,
}
}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LockHint {
Unspecified = 0,
Shared = 1,
Exclusive = 2,
}
impl LockHint {
/// String value of the enum field names used in the ProtoBuf definition.
///
/// The values are not transformed in any way and thus are considered stable
/// (if the ProtoBuf definition does not change) and safe for programmatic use.
pub fn as_str_name(&self) -> &'static str {
match self {
LockHint::Unspecified => "LOCK_HINT_UNSPECIFIED",
LockHint::Shared => "LOCK_HINT_SHARED",
LockHint::Exclusive => "LOCK_HINT_EXCLUSIVE",
}
}
/// Creates an enum from field names used in the ProtoBuf definition.
pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
match value {
"LOCK_HINT_UNSPECIFIED" => Some(Self::Unspecified),
"LOCK_HINT_SHARED" => Some(Self::Shared),
"LOCK_HINT_EXCLUSIVE" => Some(Self::Exclusive),
_ => None,
}
}
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginTransactionRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "2")]
pub options: ::core::option::Option<TransactionOptions>,
#[prost(message, optional, tag = "3")]
pub request_options: ::core::option::Option<RequestOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, repeated, tag = "4")]
pub mutations: ::prost::alloc::vec::Vec<Mutation>,
#[prost(bool, tag = "5")]
pub return_commit_stats: bool,
#[prost(message, optional, tag = "8")]
pub max_commit_delay: ::core::option::Option<::prost_types::Duration>,
#[prost(message, optional, tag = "6")]
pub request_options: ::core::option::Option<RequestOptions>,
#[prost(oneof = "commit_request::Transaction", tags = "2, 3")]
pub transaction: ::core::option::Option<commit_request::Transaction>,
}
/// Nested message and enum types in `CommitRequest`.
pub mod commit_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
pub enum Transaction {
#[prost(bytes, tag = "2")]
TransactionId(::prost::bytes::Bytes),
#[prost(message, tag = "3")]
SingleUseTransaction(super::TransactionOptions),
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(bytes = "bytes", tag = "2")]
pub transaction_id: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRequest {
#[prost(string, tag = "1")]
pub session: ::prost::alloc::string::String,
#[prost(message, optional, tag = "3")]
pub request_options: ::core::option::Option<RequestOptions>,
#[prost(message, repeated, tag = "4")]
pub mutation_groups: ::prost::alloc::vec::Vec<batch_write_request::MutationGroup>,
#[prost(bool, tag = "5")]
pub exclude_txn_from_change_streams: bool,
}
/// Nested message and enum types in `BatchWriteRequest`.
pub mod batch_write_request {
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutationGroup {
#[prost(message, repeated, tag = "1")]
pub mutations: ::prost::alloc::vec::Vec<super::Mutation>,
}
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteResponse {
#[prost(int32, repeated, tag = "1")]
pub indexes: ::prost::alloc::vec::Vec<i32>,
#[prost(message, optional, tag = "2")]
pub status: ::core::option::Option<super::super::rpc::Status>,
#[prost(message, optional, tag = "3")]
pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod spanner_client {
#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
use tonic::codegen::http::Uri;
use tonic::codegen::*;
/// Cloud Spanner API
///
/// The Cloud Spanner API can be used to manage sessions and execute
/// transactions on data stored in Cloud Spanner databases.
#[derive(Debug, Clone)]
pub struct SpannerClient<T> {
inner: tonic::client::Grpc<T>,
}
impl<T> SpannerClient<T>
where
T: tonic::client::GrpcService<tonic::body::BoxBody>,
T::Error: Into<StdError>,
T::ResponseBody: Body<Data = Bytes> + Send + 'static,
<T::ResponseBody as Body>::Error: Into<StdError> + Send,
{
pub fn new(inner: T) -> Self {
let inner = tonic::client::Grpc::new(inner);
Self { inner }
}
pub fn with_origin(inner: T, origin: Uri) -> Self {
let inner = tonic::client::Grpc::with_origin(inner, origin);
Self { inner }
}
pub fn with_interceptor<F>(inner: T, interceptor: F) -> SpannerClient<InterceptedService<T, F>>
where
F: tonic::service::Interceptor,
T::ResponseBody: Default,
T: tonic::codegen::Service<http::Request<tonic::body::BoxBody>, Response = http::Response<<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody>>,
<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error: Into<StdError> + Send + Sync,
{
SpannerClient::new(InterceptedService::new(inner, interceptor))
}
/// Compress requests with the given encoding.
///
/// This requires the server to support it otherwise it might respond with an
/// error.
#[must_use]
pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.send_compressed(encoding);
self
}
/// Enable decompressing responses.
#[must_use]
pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
self.inner = self.inner.accept_compressed(encoding);
self
}
/// Limits the maximum size of a decoded message.
///
/// Default: `4MB`
#[must_use]
pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_decoding_message_size(limit);
self
}
/// Limits the maximum size of an encoded message.
///
/// Default: `usize::MAX`
#[must_use]
pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
self.inner = self.inner.max_encoding_message_size(limit);
self
}
/// Creates a new session. A session can be used to perform
/// transactions that read and/or modify data in a Cloud Spanner database.
/// Sessions are meant to be reused for many consecutive
/// transactions.
///
/// Sessions can only execute one transaction at a time. To execute
/// multiple concurrent read-write/write-only transactions, create
/// multiple sessions. Note that standalone reads and queries use a
/// transaction internally, and count toward the one transaction
/// limit.
///
/// Active sessions use additional server resources, so it is a good idea to
/// delete idle and unneeded sessions.
/// Aside from explicit deletes, Cloud Spanner may delete sessions for which no
/// operations are sent for more than an hour. If a session is deleted,
/// requests to it return `NOT_FOUND`.
///
/// Idle sessions can be kept alive by sending a trivial SQL query
/// periodically, e.g., `"SELECT 1"`.
pub async fn create_session(&mut self, request: impl tonic::IntoRequest<super::CreateSessionRequest>) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/CreateSession");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "CreateSession"));
self.inner.unary(req, path, codec).await
}
/// Creates multiple new sessions.
///
/// This API can be used to initialize a session cache on the clients.
/// See https://goo.gl/TgSFN2 for best practices on session cache management.
pub async fn batch_create_sessions(&mut self, request: impl tonic::IntoRequest<super::BatchCreateSessionsRequest>) -> std::result::Result<tonic::Response<super::BatchCreateSessionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/BatchCreateSessions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "BatchCreateSessions"));
self.inner.unary(req, path, codec).await
}
/// Gets a session. Returns `NOT_FOUND` if the session does not exist.
/// This is mainly useful for determining whether a session is still
/// alive.
pub async fn get_session(&mut self, request: impl tonic::IntoRequest<super::GetSessionRequest>) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/GetSession");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "GetSession"));
self.inner.unary(req, path, codec).await
}
/// Lists all sessions in a given database.
pub async fn list_sessions(&mut self, request: impl tonic::IntoRequest<super::ListSessionsRequest>) -> std::result::Result<tonic::Response<super::ListSessionsResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/ListSessions");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "ListSessions"));
self.inner.unary(req, path, codec).await
}
/// Ends a session, releasing server resources associated with it. This will
/// asynchronously trigger cancellation of any operations that are running with
/// this session.
pub async fn delete_session(&mut self, request: impl tonic::IntoRequest<super::DeleteSessionRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/DeleteSession");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "DeleteSession"));
self.inner.unary(req, path, codec).await
}
/// Executes an SQL statement, returning all results in a single reply. This
/// method cannot be used to return a result set larger than 10 MiB;
/// if the query yields more data than that, the query fails with
/// a `FAILED_PRECONDITION` error.
///
/// Operations inside read-write transactions might return `ABORTED`. If
/// this occurs, the application should restart the transaction from
/// the beginning. See [Transaction][google.spanner.v1.Transaction] for more
/// details.
///
/// Larger result sets can be fetched in streaming fashion by calling
/// [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql]
/// instead.
pub async fn execute_sql(&mut self, request: impl tonic::IntoRequest<super::ExecuteSqlRequest>) -> std::result::Result<tonic::Response<super::ResultSet>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/ExecuteSql");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "ExecuteSql"));
self.inner.unary(req, path, codec).await
}
/// Like [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], except returns the
/// result set as a stream. Unlike
/// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], there is no limit on
/// the size of the returned result set. However, no individual row in the
/// result set can exceed 100 MiB, and no column value can exceed 10 MiB.
pub async fn execute_streaming_sql(&mut self, request: impl tonic::IntoRequest<super::ExecuteSqlRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::PartialResultSet>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/ExecuteStreamingSql");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "ExecuteStreamingSql"));
self.inner.server_streaming(req, path, codec).await
}
/// Executes a batch of SQL DML statements. This method allows many statements
/// to be run with lower latency than submitting them sequentially with
/// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].
///
/// Statements are executed in sequential order. A request can succeed even if
/// a statement fails. The
/// [ExecuteBatchDmlResponse.status][google.spanner.v1.ExecuteBatchDmlResponse.status]
/// field in the response provides information about the statement that failed.
/// Clients must inspect this field to determine whether an error occurred.
///
/// Execution stops after the first failed statement; the remaining statements
/// are not executed.
pub async fn execute_batch_dml(&mut self, request: impl tonic::IntoRequest<super::ExecuteBatchDmlRequest>) -> std::result::Result<tonic::Response<super::ExecuteBatchDmlResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/ExecuteBatchDml");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "ExecuteBatchDml"));
self.inner.unary(req, path, codec).await
}
/// Reads rows from the database using key lookups and scans, as a
/// simple key/value style alternative to
/// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].  This method cannot be
/// used to return a result set larger than 10 MiB; if the read matches more
/// data than that, the read fails with a `FAILED_PRECONDITION`
/// error.
///
/// Reads inside read-write transactions might return `ABORTED`. If
/// this occurs, the application should restart the transaction from
/// the beginning. See [Transaction][google.spanner.v1.Transaction] for more
/// details.
///
/// Larger result sets can be yielded in streaming fashion by calling
/// [StreamingRead][google.spanner.v1.Spanner.StreamingRead] instead.
pub async fn read(&mut self, request: impl tonic::IntoRequest<super::ReadRequest>) -> std::result::Result<tonic::Response<super::ResultSet>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/Read");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "Read"));
self.inner.unary(req, path, codec).await
}
/// Like [Read][google.spanner.v1.Spanner.Read], except returns the result set
/// as a stream. Unlike [Read][google.spanner.v1.Spanner.Read], there is no
/// limit on the size of the returned result set. However, no individual row in
/// the result set can exceed 100 MiB, and no column value can exceed
/// 10 MiB.
pub async fn streaming_read(&mut self, request: impl tonic::IntoRequest<super::ReadRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::PartialResultSet>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/StreamingRead");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "StreamingRead"));
self.inner.server_streaming(req, path, codec).await
}
/// Begins a new transaction. This step can often be skipped:
/// [Read][google.spanner.v1.Spanner.Read],
/// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
/// [Commit][google.spanner.v1.Spanner.Commit] can begin a new transaction as a
/// side-effect.
pub async fn begin_transaction(&mut self, request: impl tonic::IntoRequest<super::BeginTransactionRequest>) -> std::result::Result<tonic::Response<super::Transaction>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/BeginTransaction");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "BeginTransaction"));
self.inner.unary(req, path, codec).await
}
/// Commits a transaction. The request includes the mutations to be
/// applied to rows in the database.
///
/// `Commit` might return an `ABORTED` error. This can occur at any time;
/// commonly, the cause is conflicts with concurrent
/// transactions. However, it can also happen for a variety of other
/// reasons. If `Commit` returns `ABORTED`, the caller should re-attempt
/// the transaction from the beginning, re-using the same session.
///
/// On very rare occasions, `Commit` might return `UNKNOWN`. This can happen,
/// for example, if the client job experiences a 1+ hour networking failure.
/// At that point, Cloud Spanner has lost track of the transaction outcome and
/// we recommend that you perform another read from the database to see the
/// state of things as they are now.
pub async fn commit(&mut self, request: impl tonic::IntoRequest<super::CommitRequest>) -> std::result::Result<tonic::Response<super::CommitResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/Commit");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "Commit"));
self.inner.unary(req, path, codec).await
}
/// Rolls back a transaction, releasing any locks it holds. It is a good
/// idea to call this for any transaction that includes one or more
/// [Read][google.spanner.v1.Spanner.Read] or
/// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] requests and ultimately
/// decides not to commit.
///
/// `Rollback` returns `OK` if it successfully aborts the transaction, the
/// transaction was already aborted, or the transaction is not
/// found. `Rollback` never returns `ABORTED`.
pub async fn rollback(&mut self, request: impl tonic::IntoRequest<super::RollbackRequest>) -> std::result::Result<tonic::Response<()>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/Rollback");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "Rollback"));
self.inner.unary(req, path, codec).await
}
/// Creates a set of partition tokens that can be used to execute a query
/// operation in parallel.  Each of the returned partition tokens can be used
/// by [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] to
/// specify a subset of the query result to read.  The same session and
/// read-only transaction must be used by the PartitionQueryRequest used to
/// create the partition tokens and the ExecuteSqlRequests that use the
/// partition tokens.
///
/// Partition tokens become invalid when the session used to create them
/// is deleted, is idle for too long, begins a new transaction, or becomes too
/// old.  When any of these happen, it is not possible to resume the query, and
/// the whole operation must be restarted from the beginning.
pub async fn partition_query(&mut self, request: impl tonic::IntoRequest<super::PartitionQueryRequest>) -> std::result::Result<tonic::Response<super::PartitionResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/PartitionQuery");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "PartitionQuery"));
self.inner.unary(req, path, codec).await
}
/// Creates a set of partition tokens that can be used to execute a read
/// operation in parallel.  Each of the returned partition tokens can be used
/// by [StreamingRead][google.spanner.v1.Spanner.StreamingRead] to specify a
/// subset of the read result to read.  The same session and read-only
/// transaction must be used by the PartitionReadRequest used to create the
/// partition tokens and the ReadRequests that use the partition tokens.  There
/// are no ordering guarantees on rows returned among the returned partition
/// tokens, or even within each individual StreamingRead call issued with a
/// partition_token.
///
/// Partition tokens become invalid when the session used to create them
/// is deleted, is idle for too long, begins a new transaction, or becomes too
/// old.  When any of these happen, it is not possible to resume the read, and
/// the whole operation must be restarted from the beginning.
pub async fn partition_read(&mut self, request: impl tonic::IntoRequest<super::PartitionReadRequest>) -> std::result::Result<tonic::Response<super::PartitionResponse>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/PartitionRead");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "PartitionRead"));
self.inner.unary(req, path, codec).await
}
/// Batches the supplied mutation groups in a collection of efficient
/// transactions. All mutations in a group are committed atomically. However,
/// mutations across groups can be committed non-atomically in an unspecified
/// order and thus, they must be independent of each other. Partial failure is
/// possible, i.e., some groups may have been committed successfully, while
/// some may have failed. The results of individual batches are streamed into
/// the response as the batches are applied.
///
/// BatchWrite requests are not replay protected, meaning that each mutation
/// group may be applied more than once. Replays of non-idempotent mutations
/// may have undesirable effects. For example, replays of an insert mutation
/// may produce an already exists error or if you use generated or commit
/// timestamp-based keys, it may result in additional rows being added to the
/// mutation's table. We recommend structuring your mutation groups to be
/// idempotent to avoid this issue.
pub async fn batch_write(&mut self, request: impl tonic::IntoRequest<super::BatchWriteRequest>) -> std::result::Result<tonic::Response<tonic::codec::Streaming<super::BatchWriteResponse>>, tonic::Status> {
self.inner.ready().await.map_err(|e| tonic::Status::new(tonic::Code::Unknown, format!("Service was not ready: {}", e.into())))?;
let codec = tonic::codec::ProstCodec::default();
let path = http::uri::PathAndQuery::from_static("/google.spanner.v1.Spanner/BatchWrite");
let mut req = request.into_request();
req.extensions_mut().insert(GrpcMethod::new("google.spanner.v1.Spanner", "BatchWrite"));
self.inner.server_streaming(req, path, codec).await
}
}
}
