// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentMask {
    #[prost(string, repeated, tag = "1")]
    pub field_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Precondition {
    #[prost(oneof = "precondition::ConditionType", tags = "1, 2")]
    pub condition_type: ::core::option::Option<precondition::ConditionType>,
}
/// Nested message and enum types in `Precondition`.
pub mod precondition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ConditionType {
        #[prost(bool, tag = "1")]
        Exists(bool),
        #[prost(message, tag = "2")]
        UpdateTime(::prost_types::Timestamp),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionOptions {
    #[prost(oneof = "transaction_options::Mode", tags = "2, 3")]
    pub mode: ::core::option::Option<transaction_options::Mode>,
}
/// Nested message and enum types in `TransactionOptions`.
pub mod transaction_options {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReadWrite {
        #[prost(bytes = "bytes", tag = "1")]
        pub retry_transaction: ::prost::bytes::Bytes,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReadOnly {
        #[prost(oneof = "read_only::ConsistencySelector", tags = "2")]
        pub consistency_selector: ::core::option::Option<read_only::ConsistencySelector>,
    }
    /// Nested message and enum types in `ReadOnly`.
    pub mod read_only {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum ConsistencySelector {
            #[prost(message, tag = "2")]
            ReadTime(::prost_types::Timestamp),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        #[prost(message, tag = "2")]
        ReadOnly(ReadOnly),
        #[prost(message, tag = "3")]
        ReadWrite(ReadWrite),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "2")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::ValueType", tags = "11, 1, 2, 3, 10, 17, 18, 5, 8, 9, 6")]
    pub value_type: ::core::option::Option<value::ValueType>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueType {
        #[prost(enumeration = "::prost_types::NullValue", tag = "11")]
        NullValue(i32),
        #[prost(bool, tag = "1")]
        BooleanValue(bool),
        #[prost(int64, tag = "2")]
        IntegerValue(i64),
        #[prost(double, tag = "3")]
        DoubleValue(f64),
        #[prost(message, tag = "10")]
        TimestampValue(::prost_types::Timestamp),
        #[prost(string, tag = "17")]
        StringValue(::prost::alloc::string::String),
        #[prost(bytes, tag = "18")]
        BytesValue(::prost::bytes::Bytes),
        #[prost(string, tag = "5")]
        ReferenceValue(::prost::alloc::string::String),
        #[prost(message, tag = "8")]
        GeoPointValue(super::super::super::r#type::LatLng),
        #[prost(message, tag = "9")]
        ArrayValue(super::ArrayValue),
        #[prost(message, tag = "6")]
        MapValue(super::MapValue),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayValue {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapValue {
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Write {
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<DocumentMask>,
    #[prost(message, repeated, tag = "7")]
    pub update_transforms: ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
    #[prost(message, optional, tag = "4")]
    pub current_document: ::core::option::Option<Precondition>,
    #[prost(oneof = "write::Operation", tags = "1, 2, 6")]
    pub operation: ::core::option::Option<write::Operation>,
}
/// Nested message and enum types in `Write`.
pub mod write {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "1")]
        Update(super::Document),
        #[prost(string, tag = "2")]
        Delete(::prost::alloc::string::String),
        #[prost(message, tag = "6")]
        Transform(super::DocumentTransform),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentTransform {
    #[prost(string, tag = "1")]
    pub document: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub field_transforms: ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
}
/// Nested message and enum types in `DocumentTransform`.
pub mod document_transform {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldTransform {
        #[prost(string, tag = "1")]
        pub field_path: ::prost::alloc::string::String,
        #[prost(oneof = "field_transform::TransformType", tags = "2, 3, 4, 5, 6, 7")]
        pub transform_type: ::core::option::Option<field_transform::TransformType>,
    }
    /// Nested message and enum types in `FieldTransform`.
    pub mod field_transform {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ServerValue {
            Unspecified = 0,
            RequestTime = 1,
        }
        impl ServerValue {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ServerValue::Unspecified => "SERVER_VALUE_UNSPECIFIED",
                    ServerValue::RequestTime => "REQUEST_TIME",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SERVER_VALUE_UNSPECIFIED" => Some(Self::Unspecified),
                    "REQUEST_TIME" => Some(Self::RequestTime),
                    _ => None,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TransformType {
            #[prost(enumeration = "ServerValue", tag = "2")]
            SetToServerValue(i32),
            #[prost(message, tag = "3")]
            Increment(super::super::Value),
            #[prost(message, tag = "4")]
            Maximum(super::super::Value),
            #[prost(message, tag = "5")]
            Minimum(super::super::Value),
            #[prost(message, tag = "6")]
            AppendMissingElements(super::super::ArrayValue),
            #[prost(message, tag = "7")]
            RemoveAllFromArray(super::super::ArrayValue),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResult {
    #[prost(message, optional, tag = "1")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "2")]
    pub transform_results: ::prost::alloc::vec::Vec<Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentChange {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(int32, repeated, tag = "5")]
    pub target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, tag = "6")]
    pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentDelete {
    #[prost(string, tag = "1")]
    pub document: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "6")]
    pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentRemove {
    #[prost(string, tag = "1")]
    pub document: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "2")]
    pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExistenceFilter {
    #[prost(int32, tag = "1")]
    pub target_id: i32,
    #[prost(int32, tag = "2")]
    pub count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeliverableFirstGenEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(enumeration = "undeliverable_first_gen_event::Reason", tag = "2")]
    pub reason: i32,
    #[prost(string, tag = "3")]
    pub document_name: ::prost::alloc::string::String,
    #[prost(
        enumeration = "undeliverable_first_gen_event::DocumentChangeType",
        tag = "4"
    )]
    pub document_change_type: i32,
    #[prost(string, repeated, tag = "5")]
    pub function_name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub triggered_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `UndeliverableFirstGenEvent`.
pub mod undeliverable_first_gen_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        Unspecified = 0,
        ExceedingSizeLimit = 1,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unspecified => "REASON_UNSPECIFIED",
                Reason::ExceedingSizeLimit => "EXCEEDING_SIZE_LIMIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "EXCEEDING_SIZE_LIMIT" => Some(Self::ExceedingSizeLimit),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DocumentChangeType {
        Unspecified = 0,
        Create = 1,
        Delete = 2,
        Update = 3,
    }
    impl DocumentChangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DocumentChangeType::Unspecified => "DOCUMENT_CHANGE_TYPE_UNSPECIFIED",
                DocumentChangeType::Create => "CREATE",
                DocumentChangeType::Delete => "DELETE",
                DocumentChangeType::Update => "UPDATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DOCUMENT_CHANGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE" => Some(Self::Create),
                "DELETE" => Some(Self::Delete),
                "UPDATE" => Some(Self::Update),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredQuery {
    #[prost(message, optional, tag = "1")]
    pub select: ::core::option::Option<structured_query::Projection>,
    #[prost(message, repeated, tag = "2")]
    pub from: ::prost::alloc::vec::Vec<structured_query::CollectionSelector>,
    #[prost(message, optional, tag = "3")]
    pub r#where: ::core::option::Option<structured_query::Filter>,
    #[prost(message, repeated, tag = "4")]
    pub order_by: ::prost::alloc::vec::Vec<structured_query::Order>,
    #[prost(message, optional, tag = "7")]
    pub start_at: ::core::option::Option<Cursor>,
    #[prost(message, optional, tag = "8")]
    pub end_at: ::core::option::Option<Cursor>,
    #[prost(int32, tag = "6")]
    pub offset: i32,
    #[prost(message, optional, tag = "5")]
    pub limit: ::core::option::Option<i32>,
}
/// Nested message and enum types in `StructuredQuery`.
pub mod structured_query {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CollectionSelector {
        #[prost(string, tag = "2")]
        pub collection_id: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub all_descendants: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Filter {
        #[prost(oneof = "filter::FilterType", tags = "1, 2, 3")]
        pub filter_type: ::core::option::Option<filter::FilterType>,
    }
    /// Nested message and enum types in `Filter`.
    pub mod filter {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum FilterType {
            #[prost(message, tag = "1")]
            CompositeFilter(super::CompositeFilter),
            #[prost(message, tag = "2")]
            FieldFilter(super::FieldFilter),
            #[prost(message, tag = "3")]
            UnaryFilter(super::UnaryFilter),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompositeFilter {
        #[prost(enumeration = "composite_filter::Operator", tag = "1")]
        pub op: i32,
        #[prost(message, repeated, tag = "2")]
        pub filters: ::prost::alloc::vec::Vec<Filter>,
    }
    /// Nested message and enum types in `CompositeFilter`.
    pub mod composite_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            And = 1,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Operator::Unspecified => "OPERATOR_UNSPECIFIED",
                    Operator::And => "AND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "AND" => Some(Self::And),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldFilter {
        #[prost(message, optional, tag = "1")]
        pub field: ::core::option::Option<FieldReference>,
        #[prost(enumeration = "field_filter::Operator", tag = "2")]
        pub op: i32,
        #[prost(message, optional, tag = "3")]
        pub value: ::core::option::Option<super::Value>,
    }
    /// Nested message and enum types in `FieldFilter`.
    pub mod field_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            LessThan = 1,
            LessThanOrEqual = 2,
            GreaterThan = 3,
            GreaterThanOrEqual = 4,
            Equal = 5,
            NotEqual = 6,
            ArrayContains = 7,
            In = 8,
            ArrayContainsAny = 9,
            NotIn = 10,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Operator::Unspecified => "OPERATOR_UNSPECIFIED",
                    Operator::LessThan => "LESS_THAN",
                    Operator::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
                    Operator::GreaterThan => "GREATER_THAN",
                    Operator::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
                    Operator::Equal => "EQUAL",
                    Operator::NotEqual => "NOT_EQUAL",
                    Operator::ArrayContains => "ARRAY_CONTAINS",
                    Operator::In => "IN",
                    Operator::ArrayContainsAny => "ARRAY_CONTAINS_ANY",
                    Operator::NotIn => "NOT_IN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "LESS_THAN" => Some(Self::LessThan),
                    "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                    "GREATER_THAN" => Some(Self::GreaterThan),
                    "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                    "EQUAL" => Some(Self::Equal),
                    "NOT_EQUAL" => Some(Self::NotEqual),
                    "ARRAY_CONTAINS" => Some(Self::ArrayContains),
                    "IN" => Some(Self::In),
                    "ARRAY_CONTAINS_ANY" => Some(Self::ArrayContainsAny),
                    "NOT_IN" => Some(Self::NotIn),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UnaryFilter {
        #[prost(enumeration = "unary_filter::Operator", tag = "1")]
        pub op: i32,
        #[prost(oneof = "unary_filter::OperandType", tags = "2")]
        pub operand_type: ::core::option::Option<unary_filter::OperandType>,
    }
    /// Nested message and enum types in `UnaryFilter`.
    pub mod unary_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            IsNan = 2,
            IsNull = 3,
            IsNotNan = 4,
            IsNotNull = 5,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Operator::Unspecified => "OPERATOR_UNSPECIFIED",
                    Operator::IsNan => "IS_NAN",
                    Operator::IsNull => "IS_NULL",
                    Operator::IsNotNan => "IS_NOT_NAN",
                    Operator::IsNotNull => "IS_NOT_NULL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "IS_NAN" => Some(Self::IsNan),
                    "IS_NULL" => Some(Self::IsNull),
                    "IS_NOT_NAN" => Some(Self::IsNotNan),
                    "IS_NOT_NULL" => Some(Self::IsNotNull),
                    _ => None,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum OperandType {
            #[prost(message, tag = "2")]
            Field(super::FieldReference),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldReference {
        #[prost(string, tag = "2")]
        pub field_path: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Order {
        #[prost(message, optional, tag = "1")]
        pub field: ::core::option::Option<FieldReference>,
        #[prost(enumeration = "Direction", tag = "2")]
        pub direction: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Projection {
        #[prost(message, repeated, tag = "2")]
        pub fields: ::prost::alloc::vec::Vec<FieldReference>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        Unspecified = 0,
        Ascending = 1,
        Descending = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Direction::Unspecified => "DIRECTION_UNSPECIFIED",
                Direction::Ascending => "ASCENDING",
                Direction::Descending => "DESCENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ASCENDING" => Some(Self::Ascending),
                "DESCENDING" => Some(Self::Descending),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cursor {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
    #[prost(bool, tag = "2")]
    pub before: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(oneof = "get_document_request::ConsistencySelector", tags = "3, 5")]
    pub consistency_selector: ::core::option::Option<
        get_document_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `GetDocumentRequest`.
pub mod get_document_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "3")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "5")]
        ReadTime(::prost_types::Timestamp),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(bool, tag = "12")]
    pub show_missing: bool,
    #[prost(oneof = "list_documents_request::ConsistencySelector", tags = "8, 10")]
    pub consistency_selector: ::core::option::Option<
        list_documents_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `ListDocumentsRequest`.
pub mod list_documents_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "8")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "10")]
        ReadTime(::prost_types::Timestamp),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub document_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "5")]
    pub mask: ::core::option::Option<DocumentMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<DocumentMask>,
    #[prost(message, optional, tag = "3")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(message, optional, tag = "4")]
    pub current_document: ::core::option::Option<Precondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub current_document: ::core::option::Option<Precondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetDocumentsRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(
        oneof = "batch_get_documents_request::ConsistencySelector",
        tags = "4, 5, 7"
    )]
    pub consistency_selector: ::core::option::Option<
        batch_get_documents_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `BatchGetDocumentsRequest`.
pub mod batch_get_documents_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "4")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "5")]
        NewTransaction(super::TransactionOptions),
        #[prost(message, tag = "7")]
        ReadTime(::prost_types::Timestamp),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetDocumentsResponse {
    #[prost(bytes = "bytes", tag = "3")]
    pub transaction: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "batch_get_documents_response::Result", tags = "1, 2")]
    pub result: ::core::option::Option<batch_get_documents_response::Result>,
}
/// Nested message and enum types in `BatchGetDocumentsResponse`.
pub mod batch_get_documents_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Found(super::Document),
        #[prost(string, tag = "2")]
        Missing(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginTransactionRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<TransactionOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginTransactionResponse {
    #[prost(bytes = "bytes", tag = "1")]
    pub transaction: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub writes: ::prost::alloc::vec::Vec<Write>,
    #[prost(bytes = "bytes", tag = "3")]
    pub transaction: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitResponse {
    #[prost(message, repeated, tag = "1")]
    pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
    #[prost(message, optional, tag = "2")]
    pub commit_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub transaction: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunQueryRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(oneof = "run_query_request::QueryType", tags = "2")]
    pub query_type: ::core::option::Option<run_query_request::QueryType>,
    #[prost(oneof = "run_query_request::ConsistencySelector", tags = "5, 6, 7")]
    pub consistency_selector: ::core::option::Option<
        run_query_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `RunQueryRequest`.
pub mod run_query_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum QueryType {
        #[prost(message, tag = "2")]
        StructuredQuery(super::StructuredQuery),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "5")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "6")]
        NewTransaction(super::TransactionOptions),
        #[prost(message, tag = "7")]
        ReadTime(::prost_types::Timestamp),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunQueryResponse {
    #[prost(bytes = "bytes", tag = "2")]
    pub transaction: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "3")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "4")]
    pub skipped_results: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionQueryRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub partition_count: i64,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    #[prost(oneof = "partition_query_request::QueryType", tags = "2")]
    pub query_type: ::core::option::Option<partition_query_request::QueryType>,
}
/// Nested message and enum types in `PartitionQueryRequest`.
pub mod partition_query_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum QueryType {
        #[prost(message, tag = "2")]
        StructuredQuery(super::StructuredQuery),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionQueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub partitions: ::prost::alloc::vec::Vec<Cursor>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub writes: ::prost::alloc::vec::Vec<Write>,
    #[prost(bytes = "bytes", tag = "4")]
    pub stream_token: ::prost::bytes::Bytes,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResponse {
    #[prost(string, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub stream_token: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "3")]
    pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
    #[prost(message, optional, tag = "4")]
    pub commit_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "listen_request::TargetChange", tags = "2, 3")]
    pub target_change: ::core::option::Option<listen_request::TargetChange>,
}
/// Nested message and enum types in `ListenRequest`.
pub mod listen_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetChange {
        #[prost(message, tag = "2")]
        AddTarget(super::Target),
        #[prost(int32, tag = "3")]
        RemoveTarget(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenResponse {
    #[prost(oneof = "listen_response::ResponseType", tags = "2, 3, 4, 6, 5")]
    pub response_type: ::core::option::Option<listen_response::ResponseType>,
}
/// Nested message and enum types in `ListenResponse`.
pub mod listen_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        #[prost(message, tag = "2")]
        TargetChange(super::TargetChange),
        #[prost(message, tag = "3")]
        DocumentChange(super::DocumentChange),
        #[prost(message, tag = "4")]
        DocumentDelete(super::DocumentDelete),
        #[prost(message, tag = "6")]
        DocumentRemove(super::DocumentRemove),
        #[prost(message, tag = "5")]
        Filter(super::ExistenceFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    #[prost(int32, tag = "5")]
    pub target_id: i32,
    #[prost(bool, tag = "6")]
    pub once: bool,
    #[prost(oneof = "target::TargetType", tags = "2, 3")]
    pub target_type: ::core::option::Option<target::TargetType>,
    #[prost(oneof = "target::ResumeType", tags = "4, 11")]
    pub resume_type: ::core::option::Option<target::ResumeType>,
}
/// Nested message and enum types in `Target`.
pub mod target {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DocumentsTarget {
        #[prost(string, repeated, tag = "2")]
        pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryTarget {
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        #[prost(oneof = "query_target::QueryType", tags = "2")]
        pub query_type: ::core::option::Option<query_target::QueryType>,
    }
    /// Nested message and enum types in `QueryTarget`.
    pub mod query_target {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum QueryType {
            #[prost(message, tag = "2")]
            StructuredQuery(super::super::StructuredQuery),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetType {
        #[prost(message, tag = "2")]
        Query(QueryTarget),
        #[prost(message, tag = "3")]
        Documents(DocumentsTarget),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResumeType {
        #[prost(bytes, tag = "4")]
        ResumeToken(::prost::bytes::Bytes),
        #[prost(message, tag = "11")]
        ReadTime(::prost_types::Timestamp),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetChange {
    #[prost(enumeration = "target_change::TargetChangeType", tag = "1")]
    pub target_change_type: i32,
    #[prost(int32, repeated, tag = "2")]
    pub target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "3")]
    pub cause: ::core::option::Option<super::super::rpc::Status>,
    #[prost(bytes = "bytes", tag = "4")]
    pub resume_token: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "6")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TargetChange`.
pub mod target_change {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetChangeType {
        NoChange = 0,
        Add = 1,
        Remove = 2,
        Current = 3,
        Reset = 4,
    }
    impl TargetChangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetChangeType::NoChange => "NO_CHANGE",
                TargetChangeType::Add => "ADD",
                TargetChangeType::Remove => "REMOVE",
                TargetChangeType::Current => "CURRENT",
                TargetChangeType::Reset => "RESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NO_CHANGE" => Some(Self::NoChange),
                "ADD" => Some(Self::Add),
                "REMOVE" => Some(Self::Remove),
                "CURRENT" => Some(Self::Current),
                "RESET" => Some(Self::Reset),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionIdsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionIdsResponse {
    #[prost(string, repeated, tag = "1")]
    pub collection_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub writes: ::prost::alloc::vec::Vec<Write>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteResponse {
    #[prost(message, repeated, tag = "1")]
    pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
    #[prost(message, repeated, tag = "2")]
    pub status: ::prost::alloc::vec::Vec<super::super::rpc::Status>,
}
/// Generated client implementations.
pub mod firestore_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Cloud Firestore service.
    ///
    /// Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL
    /// document database that simplifies storing, syncing, and querying data for
    /// your mobile, web, and IoT apps at global scale. Its client libraries provide
    /// live synchronization and offline support, while its security features and
    /// integrations with Firebase and Google Cloud Platform (GCP) accelerate
    /// building truly serverless apps.
    #[derive(Debug, Clone)]
    pub struct FirestoreClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FirestoreClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FirestoreClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            FirestoreClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets a single document.
        pub async fn get_document(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/GetDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.firestore.v1beta1.Firestore", "GetDocument"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists documents.
        pub async fn list_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDocumentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/ListDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "ListDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates or inserts a document.
        pub async fn update_document(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/UpdateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "UpdateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a document.
        pub async fn delete_document(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/DeleteDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "DeleteDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets multiple documents.
        ///
        /// Documents returned by this method are not guaranteed to be returned in the
        /// same order that they were requested.
        pub async fn batch_get_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BatchGetDocumentsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/BatchGetDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "BatchGetDocuments",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Starts a new transaction.
        pub async fn begin_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::BeginTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BeginTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/BeginTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "BeginTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Commits a transaction, while optionally updating documents.
        pub async fn commit(
            &mut self,
            request: impl tonic::IntoRequest<super::CommitRequest>,
        ) -> std::result::Result<tonic::Response<super::CommitResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/Commit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.firestore.v1beta1.Firestore", "Commit"));
            self.inner.unary(req, path, codec).await
        }
        /// Rolls back a transaction.
        pub async fn rollback(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/Rollback",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.firestore.v1beta1.Firestore", "Rollback"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs a query.
        pub async fn run_query(
            &mut self,
            request: impl tonic::IntoRequest<super::RunQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RunQueryResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/RunQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.firestore.v1beta1.Firestore", "RunQuery"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Partitions a query by returning partition cursors that can be used to run
        /// the query in parallel. The returned partition cursors are split points that
        /// can be used by RunQuery as starting/end points for the query results.
        pub async fn partition_query(
            &mut self,
            request: impl tonic::IntoRequest<super::PartitionQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PartitionQueryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/PartitionQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "PartitionQuery",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Streams batches of document updates and deletes, in order.
        pub async fn write(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::WriteRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WriteResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/Write",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.firestore.v1beta1.Firestore", "Write"));
            self.inner.streaming(req, path, codec).await
        }
        /// Listens to changes.
        pub async fn listen(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ListenRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ListenResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/Listen",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.firestore.v1beta1.Firestore", "Listen"));
            self.inner.streaming(req, path, codec).await
        }
        /// Lists all the collection IDs underneath a document.
        pub async fn list_collection_ids(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCollectionIdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCollectionIdsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/ListCollectionIds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "ListCollectionIds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies a batch of write operations.
        ///
        /// The BatchWrite method does not apply the write operations atomically
        /// and can apply them out of order. Method does not allow more than one write
        /// per document. Each write succeeds or fails independently. See the
        /// [BatchWriteResponse][google.firestore.v1beta1.BatchWriteResponse] for the success status of each write.
        ///
        /// If you require an atomically applied set of writes, use
        /// [Commit][google.firestore.v1beta1.Firestore.Commit] instead.
        pub async fn batch_write(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchWriteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/BatchWrite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.firestore.v1beta1.Firestore", "BatchWrite"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new document.
        pub async fn create_document(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.firestore.v1beta1.Firestore/CreateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.firestore.v1beta1.Firestore",
                        "CreateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
