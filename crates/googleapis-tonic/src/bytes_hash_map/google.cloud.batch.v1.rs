// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Volume {
    #[prost(string, tag = "4")]
    pub mount_path: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub mount_options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "volume::Source", tags = "1, 3, 6")]
    pub source: ::core::option::Option<volume::Source>,
}
/// Nested message and enum types in `Volume`.
pub mod volume {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        Nfs(super::Nfs),
        #[prost(message, tag = "3")]
        Gcs(super::Gcs),
        #[prost(string, tag = "6")]
        DeviceName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nfs {
    #[prost(string, tag = "1")]
    pub server: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub remote_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gcs {
    #[prost(string, tag = "1")]
    pub remote_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ComputeResource {
    #[prost(int64, tag = "1")]
    pub cpu_milli: i64,
    #[prost(int64, tag = "2")]
    pub memory_mib: i64,
    #[prost(int64, tag = "4")]
    pub boot_disk_mib: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusEvent {
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub task_execution: ::core::option::Option<TaskExecution>,
    #[prost(enumeration = "task_status::State", tag = "5")]
    pub task_state: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskExecution {
    #[prost(int32, tag = "1")]
    pub exit_code: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskStatus {
    #[prost(enumeration = "task_status::State", tag = "1")]
    pub state: i32,
    #[prost(message, repeated, tag = "2")]
    pub status_events: ::prost::alloc::vec::Vec<StatusEvent>,
}
/// Nested message and enum types in `TaskStatus`.
pub mod task_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Pending = 1,
        Assigned = 2,
        Running = 3,
        Failed = 4,
        Succeeded = 5,
        Unexecuted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Pending => "PENDING",
                State::Assigned => "ASSIGNED",
                State::Running => "RUNNING",
                State::Failed => "FAILED",
                State::Succeeded => "SUCCEEDED",
                State::Unexecuted => "UNEXECUTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "ASSIGNED" => Some(Self::Assigned),
                "RUNNING" => Some(Self::Running),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "UNEXECUTED" => Some(Self::Unexecuted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Runnable {
    #[prost(string, tag = "10")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub ignore_exit_status: bool,
    #[prost(bool, tag = "4")]
    pub background: bool,
    #[prost(bool, tag = "5")]
    pub always_run: bool,
    #[prost(message, optional, tag = "7")]
    pub environment: ::core::option::Option<Environment>,
    #[prost(message, optional, tag = "8")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "runnable::Executable", tags = "1, 2, 6")]
    pub executable: ::core::option::Option<runnable::Executable>,
}
/// Nested message and enum types in `Runnable`.
pub mod runnable {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Container {
        #[prost(string, tag = "1")]
        pub image_uri: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub commands: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "3")]
        pub entrypoint: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "7")]
        pub volumes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "8")]
        pub options: ::prost::alloc::string::String,
        #[prost(bool, tag = "9")]
        pub block_external_network: bool,
        #[prost(string, tag = "10")]
        pub username: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub password: ::prost::alloc::string::String,
        #[prost(bool, tag = "12")]
        pub enable_image_streaming: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Script {
        #[prost(oneof = "script::Command", tags = "1, 2")]
        pub command: ::core::option::Option<script::Command>,
    }
    /// Nested message and enum types in `Script`.
    pub mod script {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Command {
            #[prost(string, tag = "1")]
            Path(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            Text(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Barrier {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Executable {
        #[prost(message, tag = "1")]
        Container(Container),
        #[prost(message, tag = "2")]
        Script(Script),
        #[prost(message, tag = "6")]
        Barrier(Barrier),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskSpec {
    #[prost(message, repeated, tag = "8")]
    pub runnables: ::prost::alloc::vec::Vec<Runnable>,
    #[prost(message, optional, tag = "3")]
    pub compute_resource: ::core::option::Option<ComputeResource>,
    #[prost(message, optional, tag = "4")]
    pub max_run_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(int32, tag = "5")]
    pub max_retry_count: i32,
    #[prost(message, repeated, tag = "9")]
    pub lifecycle_policies: ::prost::alloc::vec::Vec<LifecyclePolicy>,
    #[prost(map = "string, string", tag = "6")]
    pub environments: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "7")]
    pub volumes: ::prost::alloc::vec::Vec<Volume>,
    #[prost(message, optional, tag = "10")]
    pub environment: ::core::option::Option<Environment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifecyclePolicy {
    #[prost(enumeration = "lifecycle_policy::Action", tag = "1")]
    pub action: i32,
    #[prost(message, optional, tag = "2")]
    pub action_condition: ::core::option::Option<lifecycle_policy::ActionCondition>,
}
/// Nested message and enum types in `LifecyclePolicy`.
pub mod lifecycle_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionCondition {
        #[prost(int32, repeated, tag = "1")]
        pub exit_codes: ::prost::alloc::vec::Vec<i32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Unspecified = 0,
        RetryTask = 1,
        FailTask = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Unspecified => "ACTION_UNSPECIFIED",
                Action::RetryTask => "RETRY_TASK",
                Action::FailTask => "FAIL_TASK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "RETRY_TASK" => Some(Self::RetryTask),
                "FAIL_TASK" => Some(Self::FailTask),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<TaskStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Environment {
    #[prost(map = "string, string", tag = "1")]
    pub variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "2")]
    pub secret_variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "3")]
    pub encrypted_variables: ::core::option::Option<environment::KmsEnvMap>,
}
/// Nested message and enum types in `Environment`.
pub mod environment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KmsEnvMap {
        #[prost(string, tag = "1")]
        pub key_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub cipher_text: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub priority: i64,
    #[prost(message, repeated, tag = "4")]
    pub task_groups: ::prost::alloc::vec::Vec<TaskGroup>,
    #[prost(message, optional, tag = "7")]
    pub allocation_policy: ::core::option::Option<AllocationPolicy>,
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "9")]
    pub status: ::core::option::Option<JobStatus>,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub logs_policy: ::core::option::Option<LogsPolicy>,
    #[prost(message, repeated, tag = "14")]
    pub notifications: ::prost::alloc::vec::Vec<JobNotification>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsPolicy {
    #[prost(enumeration = "logs_policy::Destination", tag = "1")]
    pub destination: i32,
    #[prost(string, tag = "2")]
    pub logs_path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub cloud_logging_option: ::core::option::Option<logs_policy::CloudLoggingOption>,
}
/// Nested message and enum types in `LogsPolicy`.
pub mod logs_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CloudLoggingOption {
        #[prost(bool, tag = "1")]
        pub use_generic_task_monitored_resource: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Destination {
        Unspecified = 0,
        CloudLogging = 1,
        Path = 2,
    }
    impl Destination {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Destination::Unspecified => "DESTINATION_UNSPECIFIED",
                Destination::CloudLogging => "CLOUD_LOGGING",
                Destination::Path => "PATH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DESTINATION_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_LOGGING" => Some(Self::CloudLogging),
                "PATH" => Some(Self::Path),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobStatus {
    #[prost(enumeration = "job_status::State", tag = "1")]
    pub state: i32,
    #[prost(message, repeated, tag = "2")]
    pub status_events: ::prost::alloc::vec::Vec<StatusEvent>,
    #[prost(map = "string, message", tag = "4")]
    pub task_groups: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        job_status::TaskGroupStatus,
    >,
    #[prost(message, optional, tag = "5")]
    pub run_duration: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `JobStatus`.
pub mod job_status {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstanceStatus {
        #[prost(string, tag = "1")]
        pub machine_type: ::prost::alloc::string::String,
        #[prost(enumeration = "super::allocation_policy::ProvisioningModel", tag = "2")]
        pub provisioning_model: i32,
        #[prost(int64, tag = "3")]
        pub task_pack: i64,
        #[prost(message, optional, tag = "4")]
        pub boot_disk: ::core::option::Option<super::allocation_policy::Disk>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TaskGroupStatus {
        #[prost(map = "string, int64", tag = "1")]
        pub counts: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
        #[prost(message, repeated, tag = "2")]
        pub instances: ::prost::alloc::vec::Vec<InstanceStatus>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Queued = 1,
        Scheduled = 2,
        Running = 3,
        Succeeded = 4,
        Failed = 5,
        DeletionInProgress = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Queued => "QUEUED",
                State::Scheduled => "SCHEDULED",
                State::Running => "RUNNING",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::DeletionInProgress => "DELETION_IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "QUEUED" => Some(Self::Queued),
                "SCHEDULED" => Some(Self::Scheduled),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETION_IN_PROGRESS" => Some(Self::DeletionInProgress),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobNotification {
    #[prost(string, tag = "1")]
    pub pubsub_topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<job_notification::Message>,
}
/// Nested message and enum types in `JobNotification`.
pub mod job_notification {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Message {
        #[prost(enumeration = "Type", tag = "1")]
        pub r#type: i32,
        #[prost(enumeration = "super::job_status::State", tag = "2")]
        pub new_job_state: i32,
        #[prost(enumeration = "super::task_status::State", tag = "3")]
        pub new_task_state: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        JobStateChanged = 1,
        TaskStateChanged = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::JobStateChanged => "JOB_STATE_CHANGED",
                Type::TaskStateChanged => "TASK_STATE_CHANGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "JOB_STATE_CHANGED" => Some(Self::JobStateChanged),
                "TASK_STATE_CHANGED" => Some(Self::TaskStateChanged),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationPolicy {
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<allocation_policy::LocationPolicy>,
    #[prost(message, repeated, tag = "8")]
    pub instances: ::prost::alloc::vec::Vec<allocation_policy::InstancePolicyOrTemplate>,
    #[prost(message, optional, tag = "9")]
    pub service_account: ::core::option::Option<ServiceAccount>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub network: ::core::option::Option<allocation_policy::NetworkPolicy>,
    #[prost(message, optional, tag = "10")]
    pub placement: ::core::option::Option<allocation_policy::PlacementPolicy>,
    #[prost(string, repeated, tag = "11")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AllocationPolicy`.
pub mod allocation_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocationPolicy {
        #[prost(string, repeated, tag = "1")]
        pub allowed_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Disk {
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub size_gb: i64,
        #[prost(string, tag = "6")]
        pub disk_interface: ::prost::alloc::string::String,
        #[prost(oneof = "disk::DataSource", tags = "4, 5")]
        pub data_source: ::core::option::Option<disk::DataSource>,
    }
    /// Nested message and enum types in `Disk`.
    pub mod disk {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum DataSource {
            #[prost(string, tag = "4")]
            Image(::prost::alloc::string::String),
            #[prost(string, tag = "5")]
            Snapshot(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttachedDisk {
        #[prost(string, tag = "3")]
        pub device_name: ::prost::alloc::string::String,
        #[prost(oneof = "attached_disk::Attached", tags = "1, 2")]
        pub attached: ::core::option::Option<attached_disk::Attached>,
    }
    /// Nested message and enum types in `AttachedDisk`.
    pub mod attached_disk {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Attached {
            #[prost(message, tag = "1")]
            NewDisk(super::Disk),
            #[prost(string, tag = "2")]
            ExistingDisk(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Accelerator {
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub count: i64,
        #[deprecated]
        #[prost(bool, tag = "3")]
        pub install_gpu_drivers: bool,
        #[prost(string, tag = "4")]
        pub driver_version: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstancePolicy {
        #[prost(string, tag = "2")]
        pub machine_type: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub min_cpu_platform: ::prost::alloc::string::String,
        #[prost(enumeration = "ProvisioningModel", tag = "4")]
        pub provisioning_model: i32,
        #[prost(message, repeated, tag = "5")]
        pub accelerators: ::prost::alloc::vec::Vec<Accelerator>,
        #[prost(message, optional, tag = "8")]
        pub boot_disk: ::core::option::Option<Disk>,
        #[prost(message, repeated, tag = "6")]
        pub disks: ::prost::alloc::vec::Vec<AttachedDisk>,
        #[prost(string, tag = "7")]
        pub reservation: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstancePolicyOrTemplate {
        #[prost(bool, tag = "3")]
        pub install_gpu_drivers: bool,
        #[prost(bool, tag = "4")]
        pub install_ops_agent: bool,
        #[prost(oneof = "instance_policy_or_template::PolicyTemplate", tags = "1, 2")]
        pub policy_template: ::core::option::Option<
            instance_policy_or_template::PolicyTemplate,
        >,
    }
    /// Nested message and enum types in `InstancePolicyOrTemplate`.
    pub mod instance_policy_or_template {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum PolicyTemplate {
            #[prost(message, tag = "1")]
            Policy(super::InstancePolicy),
            #[prost(string, tag = "2")]
            InstanceTemplate(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkInterface {
        #[prost(string, tag = "1")]
        pub network: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub subnetwork: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub no_external_ip_address: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkPolicy {
        #[prost(message, repeated, tag = "1")]
        pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlacementPolicy {
        #[prost(string, tag = "1")]
        pub collocation: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub max_distance: i64,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningModel {
        Unspecified = 0,
        Standard = 1,
        Spot = 2,
        Preemptible = 3,
    }
    impl ProvisioningModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProvisioningModel::Unspecified => "PROVISIONING_MODEL_UNSPECIFIED",
                ProvisioningModel::Standard => "STANDARD",
                ProvisioningModel::Spot => "SPOT",
                ProvisioningModel::Preemptible => "PREEMPTIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVISIONING_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "SPOT" => Some(Self::Spot),
                "PREEMPTIBLE" => Some(Self::Preemptible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub task_spec: ::core::option::Option<TaskSpec>,
    #[prost(int64, tag = "4")]
    pub task_count: i64,
    #[prost(int64, tag = "5")]
    pub parallelism: i64,
    #[prost(enumeration = "task_group::SchedulingPolicy", tag = "6")]
    pub scheduling_policy: i32,
    #[prost(message, repeated, tag = "9")]
    pub task_environments: ::prost::alloc::vec::Vec<Environment>,
    #[prost(int64, tag = "10")]
    pub task_count_per_node: i64,
    #[prost(bool, tag = "11")]
    pub require_hosts_file: bool,
    #[prost(bool, tag = "12")]
    pub permissive_ssh: bool,
    #[prost(bool, tag = "14")]
    pub run_as_non_root: bool,
}
/// Nested message and enum types in `TaskGroup`.
pub mod task_group {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SchedulingPolicy {
        Unspecified = 0,
        AsSoonAsPossible = 1,
        InOrder = 2,
    }
    impl SchedulingPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SchedulingPolicy::Unspecified => "SCHEDULING_POLICY_UNSPECIFIED",
                SchedulingPolicy::AsSoonAsPossible => "AS_SOON_AS_POSSIBLE",
                SchedulingPolicy::InOrder => "IN_ORDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCHEDULING_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "AS_SOON_AS_POSSIBLE" => Some(Self::AsSoonAsPossible),
                "IN_ORDER" => Some(Self::InOrder),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccount {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub job: ::core::option::Option<Job>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub jobs: ::prost::alloc::vec::Vec<Job>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksResponse {
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod batch_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Google Batch Service.
    /// The service manages user submitted batch jobs and allocates Google Compute
    /// Engine VM instances to run the jobs.
    #[derive(Debug, Clone)]
    pub struct BatchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> BatchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BatchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            BatchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a Job.
        pub async fn create_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1.BatchService/CreateJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.batch.v1.BatchService", "CreateJob"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a Job specified by its resource name.
        pub async fn get_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1.BatchService/GetJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.batch.v1.BatchService", "GetJob"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a Job.
        pub async fn delete_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1.BatchService/DeleteJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.batch.v1.BatchService", "DeleteJob"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all Jobs for a project within a region.
        pub async fn list_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1.BatchService/ListJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.batch.v1.BatchService", "ListJobs"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Return a single Task.
        pub async fn get_task(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::Task>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1.BatchService/GetTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.batch.v1.BatchService", "GetTask"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List Tasks associated with a job.
        pub async fn list_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTasksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTasksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1.BatchService/ListTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.batch.v1.BatchService", "ListTasks"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
