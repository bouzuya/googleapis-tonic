// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "20")]
    pub insight_list: ::core::option::Option<InsightList>,
    #[prost(message, optional, tag = "21")]
    pub performance_data: ::core::option::Option<AssetPerformanceData>,
    #[prost(string, repeated, tag = "22")]
    pub sources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "23")]
    pub assigned_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "asset::AssetDetails", tags = "6")]
    pub asset_details: ::core::option::Option<asset::AssetDetails>,
}
/// Nested message and enum types in `Asset`.
pub mod asset {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AssetDetails {
        #[prost(message, tag = "6")]
        MachineDetails(super::MachineDetails),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreferenceSet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub virtual_machine_preferences: ::core::option::Option<VirtualMachinePreferences>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "import_job::ImportJobState", tag = "6")]
    pub state: i32,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub asset_source: ::prost::alloc::string::String,
    #[prost(oneof = "import_job::Report", tags = "10, 11")]
    pub report: ::core::option::Option<import_job::Report>,
}
/// Nested message and enum types in `ImportJob`.
pub mod import_job {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImportJobState {
        Unspecified = 0,
        Pending = 1,
        Running = 2,
        Completed = 3,
        Failed = 4,
        Validating = 5,
        FailedValidation = 6,
        Ready = 7,
    }
    impl ImportJobState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImportJobState::Unspecified => "IMPORT_JOB_STATE_UNSPECIFIED",
                ImportJobState::Pending => "IMPORT_JOB_STATE_PENDING",
                ImportJobState::Running => "IMPORT_JOB_STATE_RUNNING",
                ImportJobState::Completed => "IMPORT_JOB_STATE_COMPLETED",
                ImportJobState::Failed => "IMPORT_JOB_STATE_FAILED",
                ImportJobState::Validating => "IMPORT_JOB_STATE_VALIDATING",
                ImportJobState::FailedValidation => "IMPORT_JOB_STATE_FAILED_VALIDATION",
                ImportJobState::Ready => "IMPORT_JOB_STATE_READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMPORT_JOB_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPORT_JOB_STATE_PENDING" => Some(Self::Pending),
                "IMPORT_JOB_STATE_RUNNING" => Some(Self::Running),
                "IMPORT_JOB_STATE_COMPLETED" => Some(Self::Completed),
                "IMPORT_JOB_STATE_FAILED" => Some(Self::Failed),
                "IMPORT_JOB_STATE_VALIDATING" => Some(Self::Validating),
                "IMPORT_JOB_STATE_FAILED_VALIDATION" => Some(Self::FailedValidation),
                "IMPORT_JOB_STATE_READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Report {
        #[prost(message, tag = "10")]
        ValidationReport(super::ValidationReport),
        #[prost(message, tag = "11")]
        ExecutionReport(super::ExecutionReport),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataFile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "ImportJobFormat", tag = "2")]
    pub format: i32,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "import_data_file::State", tag = "4")]
    pub state: i32,
    #[prost(oneof = "import_data_file::FileInfo", tags = "5")]
    pub file_info: ::core::option::Option<import_data_file::FileInfo>,
}
/// Nested message and enum types in `ImportDataFile`.
pub mod import_data_file {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Creating = 1,
        Active = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FileInfo {
        #[prost(message, tag = "5")]
        UploadFileInfo(super::UploadFileInfo),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorFrame {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub violations: ::prost::alloc::vec::Vec<FrameViolationEntry>,
    #[prost(message, optional, tag = "3")]
    pub original_frame: ::core::option::Option<AssetFrame>,
    #[prost(message, optional, tag = "4")]
    pub ingestion_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Source {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "source::SourceType", tag = "6")]
    pub r#type: i32,
    #[prost(int32, tag = "7")]
    pub priority: i32,
    #[prost(bool, tag = "8")]
    pub managed: bool,
    #[prost(int32, tag = "9")]
    pub pending_frame_count: i32,
    #[prost(int32, tag = "10")]
    pub error_frame_count: i32,
    #[prost(enumeration = "source::State", tag = "11")]
    pub state: i32,
}
/// Nested message and enum types in `Source`.
pub mod source {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceType {
        Unknown = 0,
        Upload = 1,
        GuestOsScan = 2,
        InventoryScan = 3,
        Custom = 4,
    }
    impl SourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceType::Unknown => "SOURCE_TYPE_UNKNOWN",
                SourceType::Upload => "SOURCE_TYPE_UPLOAD",
                SourceType::GuestOsScan => "SOURCE_TYPE_GUEST_OS_SCAN",
                SourceType::InventoryScan => "SOURCE_TYPE_INVENTORY_SCAN",
                SourceType::Custom => "SOURCE_TYPE_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_TYPE_UNKNOWN" => Some(Self::Unknown),
                "SOURCE_TYPE_UPLOAD" => Some(Self::Upload),
                "SOURCE_TYPE_GUEST_OS_SCAN" => Some(Self::GuestOsScan),
                "SOURCE_TYPE_INVENTORY_SCAN" => Some(Self::InventoryScan),
                "SOURCE_TYPE_CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Deleting = 2,
        Invalid = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Deleting => "DELETING",
                State::Invalid => "INVALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "INVALID" => Some(Self::Invalid),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub group_preferenceset_assignments: ::prost::alloc::vec::Vec<
        report_config::GroupPreferenceSetAssignment,
    >,
}
/// Nested message and enum types in `ReportConfig`.
pub mod report_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupPreferenceSetAssignment {
        #[prost(string, tag = "1")]
        pub group: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub preference_set: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Report {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "report::Type", tag = "6")]
    pub r#type: i32,
    #[prost(enumeration = "report::State", tag = "7")]
    pub state: i32,
    #[prost(message, optional, tag = "8")]
    pub summary: ::core::option::Option<ReportSummary>,
}
/// Nested message and enum types in `Report`.
pub mod report {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        TotalCostOfOwnership = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::TotalCostOfOwnership => "TOTAL_COST_OF_OWNERSHIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TOTAL_COST_OF_OWNERSHIP" => Some(Self::TotalCostOfOwnership),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Pending = 1,
        Succeeded = 2,
        Failed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Pending => "PENDING",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(enumeration = "AssetView", tag = "6")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "AssetView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAssetRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<Asset>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateAssetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateAssetRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateAssetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAssetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteAssetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportAssetFramesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub frames: ::core::option::Option<Frames>,
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportAssetFramesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateAssetsValuesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub aggregations: ::prost::alloc::vec::Vec<Aggregation>,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateAssetsValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<AggregationResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateImportJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub import_job_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub import_job: ::core::option::Option<ImportJob>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImportJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(enumeration = "ImportJobView", tag = "6")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImportJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub import_jobs: ::prost::alloc::vec::Vec<ImportJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImportJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ImportJobView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteImportJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateImportJobRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub import_job: ::core::option::Option<ImportJob>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateImportJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunImportJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImportDataFileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImportDataFilesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImportDataFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub import_data_files: ::prost::alloc::vec::Vec<ImportDataFile>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateImportDataFileRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub import_data_file_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub import_data_file: ::core::option::Option<ImportDataFile>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteImportDataFileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<Group>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub group: ::core::option::Option<Group>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGroupRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub group: ::core::option::Option<Group>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddAssetsToGroupRequest {
    #[prost(string, tag = "1")]
    pub group: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub assets: ::core::option::Option<AssetList>,
    #[prost(bool, tag = "4")]
    pub allow_existing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveAssetsFromGroupRequest {
    #[prost(string, tag = "1")]
    pub group: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub assets: ::core::option::Option<AssetList>,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListErrorFramesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(enumeration = "ErrorFrameView", tag = "4")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListErrorFramesResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_frames: ::prost::alloc::vec::Vec<ErrorFrame>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetErrorFrameRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ErrorFrameView", tag = "2")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSourcesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub sources: ::prost::alloc::vec::Vec<Source>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSourceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSourceRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub source: ::core::option::Option<Source>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSourceRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub source: ::core::option::Option<Source>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSourceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPreferenceSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPreferenceSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub preference_sets: ::prost::alloc::vec::Vec<PreferenceSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreferenceSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePreferenceSetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub preference_set_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub preference_set: ::core::option::Option<PreferenceSet>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePreferenceSetRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub preference_set: ::core::option::Option<PreferenceSet>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePreferenceSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<Settings>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReportConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub report_config_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub report_config: ::core::option::Option<ReportConfig>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReportConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReportRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ReportView", tag = "6")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReportsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(enumeration = "ReportView", tag = "6")]
    pub view: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReportsResponse {
    #[prost(message, repeated, tag = "1")]
    pub reports: ::prost::alloc::vec::Vec<Report>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReportRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReportConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReportConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReportConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub report_configs: ::prost::alloc::vec::Vec<ReportConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReportRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub report_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub report: ::core::option::Option<Report>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Frames {
    #[prost(message, repeated, tag = "1")]
    pub frames_data: ::prost::alloc::vec::Vec<AssetFrame>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetFrame {
    #[prost(message, optional, tag = "10")]
    pub report_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "11")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "12")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "13")]
    pub performance_samples: ::prost::alloc::vec::Vec<PerformanceSample>,
    #[prost(string, tag = "14")]
    pub trace_token: ::prost::alloc::string::String,
    #[prost(oneof = "asset_frame::FrameData", tags = "1")]
    pub frame_data: ::core::option::Option<asset_frame::FrameData>,
}
/// Nested message and enum types in `AssetFrame`.
pub mod asset_frame {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FrameData {
        #[prost(message, tag = "1")]
        MachineDetails(super::MachineDetails),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineDetails {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub machine_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "4")]
    pub core_count: i32,
    #[prost(int32, tag = "5")]
    pub memory_mb: i32,
    #[prost(enumeration = "machine_details::PowerState", tag = "6")]
    pub power_state: i32,
    #[prost(message, optional, tag = "7")]
    pub architecture: ::core::option::Option<MachineArchitectureDetails>,
    #[prost(message, optional, tag = "8")]
    pub guest_os: ::core::option::Option<GuestOsDetails>,
    #[prost(message, optional, tag = "9")]
    pub network: ::core::option::Option<MachineNetworkDetails>,
    #[prost(message, optional, tag = "10")]
    pub disks: ::core::option::Option<MachineDiskDetails>,
    #[prost(message, optional, tag = "11")]
    pub platform: ::core::option::Option<PlatformDetails>,
}
/// Nested message and enum types in `MachineDetails`.
pub mod machine_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PowerState {
        Unspecified = 0,
        Pending = 1,
        Active = 2,
        Suspending = 3,
        Suspended = 4,
        Deleting = 5,
        Deleted = 6,
    }
    impl PowerState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PowerState::Unspecified => "POWER_STATE_UNSPECIFIED",
                PowerState::Pending => "PENDING",
                PowerState::Active => "ACTIVE",
                PowerState::Suspending => "SUSPENDING",
                PowerState::Suspended => "SUSPENDED",
                PowerState::Deleting => "DELETING",
                PowerState::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POWER_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "ACTIVE" => Some(Self::Active),
                "SUSPENDING" => Some(Self::Suspending),
                "SUSPENDED" => Some(Self::Suspended),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineArchitectureDetails {
    #[prost(string, tag = "1")]
    pub cpu_architecture: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cpu_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub vendor: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub cpu_thread_count: i32,
    #[prost(int32, tag = "5")]
    pub cpu_socket_count: i32,
    #[prost(message, optional, tag = "6")]
    pub bios: ::core::option::Option<BiosDetails>,
    #[prost(enumeration = "machine_architecture_details::FirmwareType", tag = "7")]
    pub firmware_type: i32,
    #[prost(enumeration = "machine_architecture_details::CpuHyperThreading", tag = "8")]
    pub hyperthreading: i32,
}
/// Nested message and enum types in `MachineArchitectureDetails`.
pub mod machine_architecture_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FirmwareType {
        Unspecified = 0,
        Bios = 1,
        Efi = 2,
    }
    impl FirmwareType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FirmwareType::Unspecified => "FIRMWARE_TYPE_UNSPECIFIED",
                FirmwareType::Bios => "BIOS",
                FirmwareType::Efi => "EFI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIRMWARE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BIOS" => Some(Self::Bios),
                "EFI" => Some(Self::Efi),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CpuHyperThreading {
        Unspecified = 0,
        Disabled = 1,
        Enabled = 2,
    }
    impl CpuHyperThreading {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CpuHyperThreading::Unspecified => "CPU_HYPER_THREADING_UNSPECIFIED",
                CpuHyperThreading::Disabled => "DISABLED",
                CpuHyperThreading::Enabled => "ENABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CPU_HYPER_THREADING_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLED" => Some(Self::Disabled),
                "ENABLED" => Some(Self::Enabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiosDetails {
    #[deprecated]
    #[prost(string, tag = "1")]
    pub bios_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub manufacturer: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub release_date: ::core::option::Option<super::super::super::r#type::Date>,
    #[prost(string, tag = "6")]
    pub smbios_uuid: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineNetworkDetails {
    #[prost(string, tag = "1")]
    pub primary_ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub public_ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub primary_mac_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub adapters: ::core::option::Option<NetworkAdapterList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAdapterList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<NetworkAdapterDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAdapterDetails {
    #[prost(string, tag = "1")]
    pub adapter_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mac_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub addresses: ::core::option::Option<NetworkAddressList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAddressList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<NetworkAddress>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAddress {
    #[prost(string, tag = "1")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subnet_mask: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub bcast: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub fqdn: ::prost::alloc::string::String,
    #[prost(enumeration = "network_address::AddressAssignment", tag = "5")]
    pub assignment: i32,
}
/// Nested message and enum types in `NetworkAddress`.
pub mod network_address {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AddressAssignment {
        Unspecified = 0,
        Static = 1,
        Dhcp = 2,
    }
    impl AddressAssignment {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AddressAssignment::Unspecified => "ADDRESS_ASSIGNMENT_UNSPECIFIED",
                AddressAssignment::Static => "ADDRESS_ASSIGNMENT_STATIC",
                AddressAssignment::Dhcp => "ADDRESS_ASSIGNMENT_DHCP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADDRESS_ASSIGNMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDRESS_ASSIGNMENT_STATIC" => Some(Self::Static),
                "ADDRESS_ASSIGNMENT_DHCP" => Some(Self::Dhcp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineDiskDetails {
    #[prost(int64, tag = "1")]
    pub total_capacity_bytes: i64,
    #[prost(int64, tag = "2")]
    pub total_free_bytes: i64,
    #[prost(message, optional, tag = "3")]
    pub disks: ::core::option::Option<DiskEntryList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskEntryList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<DiskEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskEntry {
    #[prost(int64, tag = "1")]
    pub capacity_bytes: i64,
    #[prost(int64, tag = "2")]
    pub free_bytes: i64,
    #[prost(string, tag = "3")]
    pub disk_label: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub disk_label_type: ::prost::alloc::string::String,
    #[prost(enumeration = "disk_entry::InterfaceType", tag = "5")]
    pub interface_type: i32,
    #[prost(message, optional, tag = "6")]
    pub partitions: ::core::option::Option<DiskPartitionList>,
    #[prost(string, tag = "7")]
    pub hw_address: ::prost::alloc::string::String,
    #[prost(oneof = "disk_entry::PlatformSpecific", tags = "20")]
    pub platform_specific: ::core::option::Option<disk_entry::PlatformSpecific>,
}
/// Nested message and enum types in `DiskEntry`.
pub mod disk_entry {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InterfaceType {
        Unspecified = 0,
        Ide = 1,
        Sata = 2,
        Sas = 3,
        Scsi = 4,
        Nvme = 5,
        Fc = 6,
        Iscsi = 7,
    }
    impl InterfaceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InterfaceType::Unspecified => "INTERFACE_TYPE_UNSPECIFIED",
                InterfaceType::Ide => "IDE",
                InterfaceType::Sata => "SATA",
                InterfaceType::Sas => "SAS",
                InterfaceType::Scsi => "SCSI",
                InterfaceType::Nvme => "NVME",
                InterfaceType::Fc => "FC",
                InterfaceType::Iscsi => "ISCSI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INTERFACE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IDE" => Some(Self::Ide),
                "SATA" => Some(Self::Sata),
                "SAS" => Some(Self::Sas),
                "SCSI" => Some(Self::Scsi),
                "NVME" => Some(Self::Nvme),
                "FC" => Some(Self::Fc),
                "ISCSI" => Some(Self::Iscsi),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum PlatformSpecific {
        #[prost(message, tag = "20")]
        Vmware(super::VmwareDiskConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskPartitionList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<DiskPartition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskPartition {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub file_system: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub mount_point: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub capacity_bytes: i64,
    #[prost(int64, tag = "5")]
    pub free_bytes: i64,
    #[prost(string, tag = "6")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub sub_partitions: ::core::option::Option<DiskPartitionList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VmwareDiskConfig {
    #[prost(enumeration = "vmware_disk_config::BackingType", tag = "1")]
    pub backing_type: i32,
    #[prost(bool, tag = "2")]
    pub shared: bool,
    #[prost(enumeration = "vmware_disk_config::VmdkMode", tag = "3")]
    pub vmdk_mode: i32,
    #[prost(enumeration = "vmware_disk_config::RdmCompatibility", tag = "4")]
    pub rdm_compatibility: i32,
}
/// Nested message and enum types in `VmwareDiskConfig`.
pub mod vmware_disk_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackingType {
        Unspecified = 0,
        FlatV1 = 1,
        FlatV2 = 2,
        Pmem = 3,
        RdmV1 = 4,
        RdmV2 = 5,
        Sesparse = 6,
        SesparseV1 = 7,
        SesparseV2 = 8,
    }
    impl BackingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BackingType::Unspecified => "BACKING_TYPE_UNSPECIFIED",
                BackingType::FlatV1 => "BACKING_TYPE_FLAT_V1",
                BackingType::FlatV2 => "BACKING_TYPE_FLAT_V2",
                BackingType::Pmem => "BACKING_TYPE_PMEM",
                BackingType::RdmV1 => "BACKING_TYPE_RDM_V1",
                BackingType::RdmV2 => "BACKING_TYPE_RDM_V2",
                BackingType::Sesparse => "BACKING_TYPE_SESPARSE",
                BackingType::SesparseV1 => "BACKING_TYPE_SESPARSE_V1",
                BackingType::SesparseV2 => "BACKING_TYPE_SESPARSE_V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKING_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BACKING_TYPE_FLAT_V1" => Some(Self::FlatV1),
                "BACKING_TYPE_FLAT_V2" => Some(Self::FlatV2),
                "BACKING_TYPE_PMEM" => Some(Self::Pmem),
                "BACKING_TYPE_RDM_V1" => Some(Self::RdmV1),
                "BACKING_TYPE_RDM_V2" => Some(Self::RdmV2),
                "BACKING_TYPE_SESPARSE" => Some(Self::Sesparse),
                "BACKING_TYPE_SESPARSE_V1" => Some(Self::SesparseV1),
                "BACKING_TYPE_SESPARSE_V2" => Some(Self::SesparseV2),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VmdkMode {
        Unspecified = 0,
        Dependent = 1,
        IndependentPersistent = 2,
        IndependentNonpersistent = 3,
    }
    impl VmdkMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VmdkMode::Unspecified => "VMDK_MODE_UNSPECIFIED",
                VmdkMode::Dependent => "DEPENDENT",
                VmdkMode::IndependentPersistent => "INDEPENDENT_PERSISTENT",
                VmdkMode::IndependentNonpersistent => "INDEPENDENT_NONPERSISTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VMDK_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DEPENDENT" => Some(Self::Dependent),
                "INDEPENDENT_PERSISTENT" => Some(Self::IndependentPersistent),
                "INDEPENDENT_NONPERSISTENT" => Some(Self::IndependentNonpersistent),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RdmCompatibility {
        Unspecified = 0,
        PhysicalCompatibility = 1,
        VirtualCompatibility = 2,
    }
    impl RdmCompatibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RdmCompatibility::Unspecified => "RDM_COMPATIBILITY_UNSPECIFIED",
                RdmCompatibility::PhysicalCompatibility => "PHYSICAL_COMPATIBILITY",
                RdmCompatibility::VirtualCompatibility => "VIRTUAL_COMPATIBILITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RDM_COMPATIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "PHYSICAL_COMPATIBILITY" => Some(Self::PhysicalCompatibility),
                "VIRTUAL_COMPATIBILITY" => Some(Self::VirtualCompatibility),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestOsDetails {
    #[prost(string, tag = "1")]
    pub os_name: ::prost::alloc::string::String,
    #[prost(enumeration = "OperatingSystemFamily", tag = "2")]
    pub family: i32,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub config: ::core::option::Option<GuestConfigDetails>,
    #[prost(message, optional, tag = "5")]
    pub runtime: ::core::option::Option<GuestRuntimeDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestConfigDetails {
    #[prost(string, tag = "1")]
    pub issue: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub fstab: ::core::option::Option<FstabEntryList>,
    #[prost(message, optional, tag = "3")]
    pub hosts: ::core::option::Option<HostsEntryList>,
    #[prost(message, optional, tag = "4")]
    pub nfs_exports: ::core::option::Option<NfsExportList>,
    #[prost(enumeration = "guest_config_details::SeLinuxMode", tag = "5")]
    pub selinux_mode: i32,
}
/// Nested message and enum types in `GuestConfigDetails`.
pub mod guest_config_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SeLinuxMode {
        Unspecified = 0,
        Disabled = 1,
        Permissive = 2,
        Enforcing = 3,
    }
    impl SeLinuxMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SeLinuxMode::Unspecified => "SE_LINUX_MODE_UNSPECIFIED",
                SeLinuxMode::Disabled => "SE_LINUX_MODE_DISABLED",
                SeLinuxMode::Permissive => "SE_LINUX_MODE_PERMISSIVE",
                SeLinuxMode::Enforcing => "SE_LINUX_MODE_ENFORCING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SE_LINUX_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "SE_LINUX_MODE_DISABLED" => Some(Self::Disabled),
                "SE_LINUX_MODE_PERMISSIVE" => Some(Self::Permissive),
                "SE_LINUX_MODE_ENFORCING" => Some(Self::Enforcing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FstabEntryList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<FstabEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FstabEntry {
    #[prost(string, tag = "1")]
    pub spec: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub file: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub vfstype: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub mntops: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub freq: i32,
    #[prost(int32, tag = "6")]
    pub passno: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostsEntryList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<HostsEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostsEntry {
    #[prost(string, tag = "1")]
    pub ip: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub host_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfsExportList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<NfsExport>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfsExport {
    #[prost(string, tag = "1")]
    pub export_directory: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub hosts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestRuntimeDetails {
    #[prost(message, optional, tag = "1")]
    pub services: ::core::option::Option<RunningServiceList>,
    #[prost(message, optional, tag = "2")]
    pub processes: ::core::option::Option<RunningProcessList>,
    #[prost(message, optional, tag = "3")]
    pub network: ::core::option::Option<RuntimeNetworkInfo>,
    #[prost(message, optional, tag = "4")]
    pub last_boot_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub machine_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub installed_apps: ::core::option::Option<GuestInstalledApplicationList>,
    #[prost(message, optional, tag = "8")]
    pub open_file_list: ::core::option::Option<OpenFileList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningServiceList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<RunningService>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningService {
    #[prost(string, tag = "1")]
    pub service_name: ::prost::alloc::string::String,
    #[prost(enumeration = "running_service::State", tag = "2")]
    pub state: i32,
    #[prost(enumeration = "running_service::StartMode", tag = "3")]
    pub start_mode: i32,
    #[prost(string, tag = "4")]
    pub exe_path: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub cmdline: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub pid: i64,
}
/// Nested message and enum types in `RunningService`.
pub mod running_service {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Paused = 2,
        Stopped = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Paused => "PAUSED",
                State::Stopped => "STOPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PAUSED" => Some(Self::Paused),
                "STOPPED" => Some(Self::Stopped),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StartMode {
        Unspecified = 0,
        Boot = 1,
        System = 2,
        Auto = 3,
        Manual = 4,
        Disabled = 5,
    }
    impl StartMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StartMode::Unspecified => "START_MODE_UNSPECIFIED",
                StartMode::Boot => "BOOT",
                StartMode::System => "SYSTEM",
                StartMode::Auto => "AUTO",
                StartMode::Manual => "MANUAL",
                StartMode::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "BOOT" => Some(Self::Boot),
                "SYSTEM" => Some(Self::System),
                "AUTO" => Some(Self::Auto),
                "MANUAL" => Some(Self::Manual),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningProcessList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<RunningProcess>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningProcess {
    #[prost(int64, tag = "1")]
    pub pid: i64,
    #[prost(string, tag = "2")]
    pub exe_path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub cmdline: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub user: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "100")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeNetworkInfo {
    #[prost(message, optional, tag = "1")]
    pub scan_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub connections: ::core::option::Option<NetworkConnectionList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConnectionList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<NetworkConnection>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConnection {
    #[prost(string, tag = "1")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub local_ip_address: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub local_port: i32,
    #[prost(string, tag = "4")]
    pub remote_ip_address: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub remote_port: i32,
    #[prost(enumeration = "network_connection::State", tag = "6")]
    pub state: i32,
    #[prost(int64, tag = "7")]
    pub pid: i64,
    #[prost(string, tag = "8")]
    pub process_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NetworkConnection`.
pub mod network_connection {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Opening = 1,
        Open = 2,
        Listen = 3,
        Closing = 4,
        Closed = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Opening => "OPENING",
                State::Open => "OPEN",
                State::Listen => "LISTEN",
                State::Closing => "CLOSING",
                State::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "OPENING" => Some(Self::Opening),
                "OPEN" => Some(Self::Open),
                "LISTEN" => Some(Self::Listen),
                "CLOSING" => Some(Self::Closing),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestInstalledApplicationList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<GuestInstalledApplication>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestInstalledApplication {
    #[prost(string, tag = "1")]
    pub application_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vendor: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub install_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenFileList {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<OpenFileDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenFileDetails {
    #[prost(string, tag = "1")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub file_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub file_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlatformDetails {
    #[prost(oneof = "platform_details::VendorDetails", tags = "1, 2, 3, 4, 5")]
    pub vendor_details: ::core::option::Option<platform_details::VendorDetails>,
}
/// Nested message and enum types in `PlatformDetails`.
pub mod platform_details {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VendorDetails {
        #[prost(message, tag = "1")]
        VmwareDetails(super::VmwarePlatformDetails),
        #[prost(message, tag = "2")]
        AwsEc2Details(super::AwsEc2PlatformDetails),
        #[prost(message, tag = "3")]
        AzureVmDetails(super::AzureVmPlatformDetails),
        #[prost(message, tag = "4")]
        GenericDetails(super::GenericPlatformDetails),
        #[prost(message, tag = "5")]
        PhysicalDetails(super::PhysicalPlatformDetails),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmwarePlatformDetails {
    #[prost(string, tag = "1")]
    pub vcenter_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub esx_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub osid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub vcenter_folder: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub vcenter_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub vcenter_vm_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsEc2PlatformDetails {
    #[prost(string, tag = "1")]
    pub machine_type_label: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AzureVmPlatformDetails {
    #[prost(string, tag = "1")]
    pub machine_type_label: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub provisioning_state: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericPlatformDetails {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhysicalPlatformDetails {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MemoryUsageSample {
    #[prost(float, tag = "1")]
    pub utilized_percentage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuUsageSample {
    #[prost(float, tag = "1")]
    pub utilized_percentage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkUsageSample {
    #[prost(float, tag = "1")]
    pub average_ingress_bps: f32,
    #[prost(float, tag = "2")]
    pub average_egress_bps: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiskUsageSample {
    #[prost(float, tag = "1")]
    pub average_iops: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformanceSample {
    #[prost(message, optional, tag = "1")]
    pub sample_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub memory: ::core::option::Option<MemoryUsageSample>,
    #[prost(message, optional, tag = "3")]
    pub cpu: ::core::option::Option<CpuUsageSample>,
    #[prost(message, optional, tag = "4")]
    pub network: ::core::option::Option<NetworkUsageSample>,
    #[prost(message, optional, tag = "5")]
    pub disk: ::core::option::Option<DiskUsageSample>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetPerformanceData {
    #[prost(message, repeated, tag = "1")]
    pub daily_resource_usage_aggregations: ::prost::alloc::vec::Vec<
        DailyResourceUsageAggregation,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyResourceUsageAggregation {
    #[prost(message, optional, tag = "1")]
    pub date: ::core::option::Option<super::super::super::r#type::Date>,
    #[prost(message, optional, tag = "2")]
    pub cpu: ::core::option::Option<daily_resource_usage_aggregation::Cpu>,
    #[prost(message, optional, tag = "3")]
    pub memory: ::core::option::Option<daily_resource_usage_aggregation::Memory>,
    #[prost(message, optional, tag = "4")]
    pub network: ::core::option::Option<daily_resource_usage_aggregation::Network>,
    #[prost(message, optional, tag = "5")]
    pub disk: ::core::option::Option<daily_resource_usage_aggregation::Disk>,
}
/// Nested message and enum types in `DailyResourceUsageAggregation`.
pub mod daily_resource_usage_aggregation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Stats {
        #[prost(float, tag = "1")]
        pub average: f32,
        #[prost(float, tag = "2")]
        pub median: f32,
        #[prost(float, tag = "3")]
        pub nintey_fifth_percentile: f32,
        #[prost(float, tag = "4")]
        pub peak: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Cpu {
        #[prost(message, optional, tag = "1")]
        pub utilization_percentage: ::core::option::Option<Stats>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Memory {
        #[prost(message, optional, tag = "1")]
        pub utilization_percentage: ::core::option::Option<Stats>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Network {
        #[prost(message, optional, tag = "1")]
        pub ingress_bps: ::core::option::Option<Stats>,
        #[prost(message, optional, tag = "2")]
        pub egress_bps: ::core::option::Option<Stats>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Disk {
        #[prost(message, optional, tag = "1")]
        pub iops: ::core::option::Option<Stats>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsightList {
    #[prost(message, repeated, tag = "1")]
    pub insights: ::prost::alloc::vec::Vec<Insight>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Insight {
    #[prost(oneof = "insight::Insight", tags = "1, 2")]
    pub insight: ::core::option::Option<insight::Insight>,
}
/// Nested message and enum types in `Insight`.
pub mod insight {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Insight {
        #[prost(message, tag = "1")]
        MigrationInsight(super::MigrationInsight),
        #[prost(message, tag = "2")]
        GenericInsight(super::GenericInsight),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericInsight {
    #[prost(int64, tag = "1")]
    pub message_id: i64,
    #[prost(string, tag = "2")]
    pub default_message: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub additional_information: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationInsight {
    #[prost(message, optional, tag = "1")]
    pub fit: ::core::option::Option<FitDescriptor>,
    #[prost(oneof = "migration_insight::MigrationTarget", tags = "10")]
    pub migration_target: ::core::option::Option<migration_insight::MigrationTarget>,
}
/// Nested message and enum types in `MigrationInsight`.
pub mod migration_insight {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MigrationTarget {
        #[prost(message, tag = "10")]
        ComputeEngineTarget(super::ComputeEngineMigrationTarget),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeEngineMigrationTarget {
    #[prost(message, optional, tag = "1")]
    pub shape: ::core::option::Option<ComputeEngineShapeDescriptor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeEngineShapeDescriptor {
    #[prost(int32, tag = "1")]
    pub memory_mb: i32,
    #[prost(int32, tag = "2")]
    pub physical_core_count: i32,
    #[prost(int32, tag = "3")]
    pub logical_core_count: i32,
    #[prost(string, tag = "4")]
    pub series: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub machine_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub storage: ::prost::alloc::vec::Vec<ComputeStorageDescriptor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ComputeStorageDescriptor {
    #[prost(enumeration = "PersistentDiskType", tag = "1")]
    pub r#type: i32,
    #[prost(int32, tag = "2")]
    pub size_gb: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FitDescriptor {
    #[prost(enumeration = "fit_descriptor::FitLevel", tag = "1")]
    pub fit_level: i32,
}
/// Nested message and enum types in `FitDescriptor`.
pub mod fit_descriptor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FitLevel {
        Unspecified = 0,
        Fit = 1,
        NoFit = 2,
        RequiresEffort = 3,
    }
    impl FitLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FitLevel::Unspecified => "FIT_LEVEL_UNSPECIFIED",
                FitLevel::Fit => "FIT",
                FitLevel::NoFit => "NO_FIT",
                FitLevel::RequiresEffort => "REQUIRES_EFFORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIT_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "FIT" => Some(Self::Fit),
                "NO_FIT" => Some(Self::NoFit),
                "REQUIRES_EFFORT" => Some(Self::RequiresEffort),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aggregation {
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    #[prost(oneof = "aggregation::AggregationFunction", tags = "2, 3, 4, 5")]
    pub aggregation_function: ::core::option::Option<aggregation::AggregationFunction>,
}
/// Nested message and enum types in `Aggregation`.
pub mod aggregation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Count {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Sum {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Histogram {
        #[prost(double, repeated, tag = "1")]
        pub lower_bounds: ::prost::alloc::vec::Vec<f64>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Frequency {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AggregationFunction {
        #[prost(message, tag = "2")]
        Count(Count),
        #[prost(message, tag = "3")]
        Sum(Sum),
        #[prost(message, tag = "4")]
        Histogram(Histogram),
        #[prost(message, tag = "5")]
        Frequency(Frequency),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationResult {
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    #[prost(oneof = "aggregation_result::Result", tags = "2, 3, 4, 5")]
    pub result: ::core::option::Option<aggregation_result::Result>,
}
/// Nested message and enum types in `AggregationResult`.
pub mod aggregation_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Count {
        #[prost(int64, tag = "1")]
        pub value: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Sum {
        #[prost(double, tag = "1")]
        pub value: f64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Histogram {
        #[prost(message, repeated, tag = "1")]
        pub buckets: ::prost::alloc::vec::Vec<histogram::Bucket>,
    }
    /// Nested message and enum types in `Histogram`.
    pub mod histogram {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Bucket {
            #[prost(double, tag = "1")]
            pub lower_bound: f64,
            #[prost(double, tag = "2")]
            pub upper_bound: f64,
            #[prost(int64, tag = "3")]
            pub count: i64,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Frequency {
        #[prost(map = "string, int64", tag = "1")]
        pub values: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "2")]
        Count(Count),
        #[prost(message, tag = "3")]
        Sum(Sum),
        #[prost(message, tag = "4")]
        Histogram(Histogram),
        #[prost(message, tag = "5")]
        Frequency(Frequency),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileValidationReport {
    #[prost(string, tag = "1")]
    pub file_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub row_errors: ::prost::alloc::vec::Vec<ImportRowError>,
    #[prost(bool, tag = "3")]
    pub partial_report: bool,
    #[prost(message, repeated, tag = "4")]
    pub file_errors: ::prost::alloc::vec::Vec<ImportError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationReport {
    #[prost(message, repeated, tag = "1")]
    pub file_validations: ::prost::alloc::vec::Vec<FileValidationReport>,
    #[prost(message, repeated, tag = "2")]
    pub job_errors: ::prost::alloc::vec::Vec<ImportError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionReport {
    #[prost(int32, tag = "1")]
    pub frames_reported: i32,
    #[prost(message, optional, tag = "2")]
    pub execution_errors: ::core::option::Option<ValidationReport>,
    #[prost(int32, tag = "3")]
    pub total_rows_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportError {
    #[prost(string, tag = "1")]
    pub error_details: ::prost::alloc::string::String,
    #[prost(enumeration = "import_error::Severity", tag = "2")]
    pub severity: i32,
}
/// Nested message and enum types in `ImportError`.
pub mod import_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Severity {
        Unspecified = 0,
        Error = 1,
        Warning = 2,
        Info = 3,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Severity::Unspecified => "SEVERITY_UNSPECIFIED",
                Severity::Error => "ERROR",
                Severity::Warning => "WARNING",
                Severity::Info => "INFO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "ERROR" => Some(Self::Error),
                "WARNING" => Some(Self::Warning),
                "INFO" => Some(Self::Info),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportRowError {
    #[deprecated]
    #[prost(int32, tag = "1")]
    pub row_number: i32,
    #[prost(string, tag = "2")]
    pub vm_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub vm_uuid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub errors: ::prost::alloc::vec::Vec<ImportError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadFileInfo {
    #[prost(string, tag = "1")]
    pub signed_uri: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "3")]
    pub uri_expiration_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetList {
    #[prost(string, repeated, tag = "1")]
    pub asset_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameViolationEntry {
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub violation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualMachinePreferences {
    #[prost(enumeration = "ComputeMigrationTargetProduct", tag = "2")]
    pub target_product: i32,
    #[prost(message, optional, tag = "3")]
    pub region_preferences: ::core::option::Option<RegionPreferences>,
    #[prost(enumeration = "CommitmentPlan", tag = "4")]
    pub commitment_plan: i32,
    #[prost(enumeration = "SizingOptimizationStrategy", tag = "5")]
    pub sizing_optimization_strategy: i32,
    #[prost(message, optional, tag = "6")]
    pub compute_engine_preferences: ::core::option::Option<ComputeEnginePreferences>,
    #[prost(message, optional, tag = "7")]
    pub vmware_engine_preferences: ::core::option::Option<VmwareEnginePreferences>,
    #[prost(message, optional, tag = "8")]
    pub sole_tenancy_preferences: ::core::option::Option<SoleTenancyPreferences>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeEnginePreferences {
    #[prost(message, optional, tag = "2")]
    pub machine_preferences: ::core::option::Option<MachinePreferences>,
    #[prost(enumeration = "LicenseType", tag = "3")]
    pub license_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachinePreferences {
    #[prost(message, repeated, tag = "1")]
    pub allowed_machine_series: ::prost::alloc::vec::Vec<MachineSeries>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineSeries {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VmwareEnginePreferences {
    #[prost(double, tag = "1")]
    pub cpu_overcommit_ratio: f64,
    #[prost(double, tag = "2")]
    pub memory_overcommit_ratio: f64,
    #[prost(double, tag = "3")]
    pub storage_deduplication_compression_ratio: f64,
    #[prost(enumeration = "vmware_engine_preferences::CommitmentPlan", tag = "4")]
    pub commitment_plan: i32,
}
/// Nested message and enum types in `VmwareEnginePreferences`.
pub mod vmware_engine_preferences {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommitmentPlan {
        Unspecified = 0,
        OnDemand = 1,
        Commitment1YearMonthlyPayments = 2,
        Commitment3YearMonthlyPayments = 3,
        Commitment1YearUpfrontPayment = 4,
        Commitment3YearUpfrontPayment = 5,
    }
    impl CommitmentPlan {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CommitmentPlan::Unspecified => "COMMITMENT_PLAN_UNSPECIFIED",
                CommitmentPlan::OnDemand => "ON_DEMAND",
                CommitmentPlan::Commitment1YearMonthlyPayments => {
                    "COMMITMENT_1_YEAR_MONTHLY_PAYMENTS"
                }
                CommitmentPlan::Commitment3YearMonthlyPayments => {
                    "COMMITMENT_3_YEAR_MONTHLY_PAYMENTS"
                }
                CommitmentPlan::Commitment1YearUpfrontPayment => {
                    "COMMITMENT_1_YEAR_UPFRONT_PAYMENT"
                }
                CommitmentPlan::Commitment3YearUpfrontPayment => {
                    "COMMITMENT_3_YEAR_UPFRONT_PAYMENT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMITMENT_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
                "ON_DEMAND" => Some(Self::OnDemand),
                "COMMITMENT_1_YEAR_MONTHLY_PAYMENTS" => {
                    Some(Self::Commitment1YearMonthlyPayments)
                }
                "COMMITMENT_3_YEAR_MONTHLY_PAYMENTS" => {
                    Some(Self::Commitment3YearMonthlyPayments)
                }
                "COMMITMENT_1_YEAR_UPFRONT_PAYMENT" => {
                    Some(Self::Commitment1YearUpfrontPayment)
                }
                "COMMITMENT_3_YEAR_UPFRONT_PAYMENT" => {
                    Some(Self::Commitment3YearUpfrontPayment)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SoleTenancyPreferences {
    #[prost(double, tag = "1")]
    pub cpu_overcommit_ratio: f64,
    #[prost(enumeration = "sole_tenancy_preferences::HostMaintenancePolicy", tag = "2")]
    pub host_maintenance_policy: i32,
    #[prost(enumeration = "sole_tenancy_preferences::CommitmentPlan", tag = "3")]
    pub commitment_plan: i32,
    #[prost(message, repeated, tag = "4")]
    pub node_types: ::prost::alloc::vec::Vec<SoleTenantNodeType>,
}
/// Nested message and enum types in `SoleTenancyPreferences`.
pub mod sole_tenancy_preferences {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HostMaintenancePolicy {
        Unspecified = 0,
        Default = 1,
        RestartInPlace = 2,
        MigrateWithinNodeGroup = 3,
    }
    impl HostMaintenancePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HostMaintenancePolicy::Unspecified => {
                    "HOST_MAINTENANCE_POLICY_UNSPECIFIED"
                }
                HostMaintenancePolicy::Default => "HOST_MAINTENANCE_POLICY_DEFAULT",
                HostMaintenancePolicy::RestartInPlace => {
                    "HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE"
                }
                HostMaintenancePolicy::MigrateWithinNodeGroup => {
                    "HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HOST_MAINTENANCE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "HOST_MAINTENANCE_POLICY_DEFAULT" => Some(Self::Default),
                "HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE" => Some(Self::RestartInPlace),
                "HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP" => {
                    Some(Self::MigrateWithinNodeGroup)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommitmentPlan {
        Unspecified = 0,
        OnDemand = 1,
        Commitment1Year = 2,
        Commitment3Year = 3,
    }
    impl CommitmentPlan {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CommitmentPlan::Unspecified => "COMMITMENT_PLAN_UNSPECIFIED",
                CommitmentPlan::OnDemand => "ON_DEMAND",
                CommitmentPlan::Commitment1Year => "COMMITMENT_1_YEAR",
                CommitmentPlan::Commitment3Year => "COMMITMENT_3_YEAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMITMENT_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
                "ON_DEMAND" => Some(Self::OnDemand),
                "COMMITMENT_1_YEAR" => Some(Self::Commitment1Year),
                "COMMITMENT_3_YEAR" => Some(Self::Commitment3Year),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SoleTenantNodeType {
    #[prost(string, tag = "1")]
    pub node_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionPreferences {
    #[prost(string, repeated, tag = "1")]
    pub preferred_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub preference_set: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportSummary {
    #[prost(message, optional, tag = "1")]
    pub all_assets_stats: ::core::option::Option<report_summary::AssetAggregateStats>,
    #[prost(message, repeated, tag = "2")]
    pub group_findings: ::prost::alloc::vec::Vec<report_summary::GroupFinding>,
}
/// Nested message and enum types in `ReportSummary`.
pub mod report_summary {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChartData {
        #[prost(message, repeated, tag = "1")]
        pub data_points: ::prost::alloc::vec::Vec<chart_data::DataPoint>,
    }
    /// Nested message and enum types in `ChartData`.
    pub mod chart_data {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DataPoint {
            #[prost(string, tag = "1")]
            pub label: ::prost::alloc::string::String,
            #[prost(double, tag = "2")]
            pub value: f64,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UtilizationChartData {
        #[prost(int64, tag = "1")]
        pub used: i64,
        #[prost(int64, tag = "2")]
        pub free: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HistogramChartData {
        #[prost(message, repeated, tag = "1")]
        pub buckets: ::prost::alloc::vec::Vec<histogram_chart_data::Bucket>,
    }
    /// Nested message and enum types in `HistogramChartData`.
    pub mod histogram_chart_data {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Bucket {
            #[prost(int64, tag = "1")]
            pub lower_bound: i64,
            #[prost(int64, tag = "2")]
            pub upper_bound: i64,
            #[prost(int64, tag = "3")]
            pub count: i64,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AssetAggregateStats {
        #[prost(int64, tag = "1")]
        pub total_memory_bytes: i64,
        #[prost(int64, tag = "2")]
        pub total_storage_bytes: i64,
        #[prost(int64, tag = "3")]
        pub total_cores: i64,
        #[prost(int64, tag = "4")]
        pub total_assets: i64,
        #[prost(message, optional, tag = "5")]
        pub memory_utilization_chart: ::core::option::Option<UtilizationChartData>,
        #[prost(message, optional, tag = "6")]
        pub storage_utilization_chart: ::core::option::Option<UtilizationChartData>,
        #[prost(message, optional, tag = "7")]
        pub operating_system: ::core::option::Option<ChartData>,
        #[prost(message, optional, tag = "8")]
        pub core_count_histogram: ::core::option::Option<HistogramChartData>,
        #[prost(message, optional, tag = "9")]
        pub memory_bytes_histogram: ::core::option::Option<HistogramChartData>,
        #[prost(message, optional, tag = "10")]
        pub storage_bytes_histogram: ::core::option::Option<HistogramChartData>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MachineSeriesAllocation {
        #[prost(message, optional, tag = "1")]
        pub machine_series: ::core::option::Option<super::MachineSeries>,
        #[prost(int64, tag = "2")]
        pub allocated_asset_count: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ComputeEngineFinding {
        #[prost(string, repeated, tag = "1")]
        pub allocated_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(int64, tag = "2")]
        pub allocated_asset_count: i64,
        #[prost(message, repeated, tag = "3")]
        pub machine_series_allocations: ::prost::alloc::vec::Vec<
            MachineSeriesAllocation,
        >,
        #[prost(enumeration = "super::PersistentDiskType", repeated, tag = "4")]
        pub allocated_disk_types: ::prost::alloc::vec::Vec<i32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VmwareEngineFinding {
        #[prost(string, repeated, tag = "1")]
        pub allocated_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(int64, tag = "2")]
        pub allocated_asset_count: i64,
        #[prost(message, repeated, tag = "3")]
        pub node_allocations: ::prost::alloc::vec::Vec<VmwareNodeAllocation>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VmwareNodeAllocation {
        #[prost(message, optional, tag = "1")]
        pub vmware_node: ::core::option::Option<VmwareNode>,
        #[prost(int64, tag = "2")]
        pub node_count: i64,
        #[prost(int64, tag = "3")]
        pub allocated_asset_count: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VmwareNode {
        #[prost(string, tag = "1")]
        pub code: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SoleTenantFinding {
        #[prost(string, repeated, tag = "1")]
        pub allocated_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(int64, tag = "2")]
        pub allocated_asset_count: i64,
        #[prost(message, repeated, tag = "3")]
        pub node_allocations: ::prost::alloc::vec::Vec<SoleTenantNodeAllocation>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SoleTenantNodeAllocation {
        #[prost(message, optional, tag = "1")]
        pub node: ::core::option::Option<super::SoleTenantNodeType>,
        #[prost(int64, tag = "2")]
        pub node_count: i64,
        #[prost(int64, tag = "3")]
        pub allocated_asset_count: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupPreferenceSetFinding {
        #[prost(string, tag = "1")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub machine_preferences: ::core::option::Option<
            super::VirtualMachinePreferences,
        >,
        #[prost(message, optional, tag = "4")]
        pub monthly_cost_total: ::core::option::Option<
            super::super::super::super::r#type::Money,
        >,
        #[prost(message, optional, tag = "5")]
        pub monthly_cost_compute: ::core::option::Option<
            super::super::super::super::r#type::Money,
        >,
        #[prost(message, optional, tag = "6")]
        pub monthly_cost_os_license: ::core::option::Option<
            super::super::super::super::r#type::Money,
        >,
        #[prost(message, optional, tag = "7")]
        pub monthly_cost_network_egress: ::core::option::Option<
            super::super::super::super::r#type::Money,
        >,
        #[prost(message, optional, tag = "8")]
        pub monthly_cost_storage: ::core::option::Option<
            super::super::super::super::r#type::Money,
        >,
        #[prost(message, optional, tag = "9")]
        pub monthly_cost_other: ::core::option::Option<
            super::super::super::super::r#type::Money,
        >,
        #[prost(message, optional, tag = "10")]
        pub compute_engine_finding: ::core::option::Option<ComputeEngineFinding>,
        #[prost(message, optional, tag = "11")]
        pub vmware_engine_finding: ::core::option::Option<VmwareEngineFinding>,
        #[prost(message, optional, tag = "12")]
        pub sole_tenant_finding: ::core::option::Option<SoleTenantFinding>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupFinding {
        #[prost(string, tag = "1")]
        pub display_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub asset_aggregate_stats: ::core::option::Option<AssetAggregateStats>,
        #[deprecated]
        #[prost(int64, tag = "4")]
        pub overlapping_asset_count: i64,
        #[prost(message, repeated, tag = "5")]
        pub preference_set_findings: ::prost::alloc::vec::Vec<GroupPreferenceSetFinding>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AssetView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl AssetView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AssetView::Unspecified => "ASSET_VIEW_UNSPECIFIED",
            AssetView::Basic => "ASSET_VIEW_BASIC",
            AssetView::Full => "ASSET_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASSET_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "ASSET_VIEW_BASIC" => Some(Self::Basic),
            "ASSET_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperatingSystemFamily {
    OsFamilyUnknown = 0,
    OsFamilyWindows = 1,
    OsFamilyLinux = 2,
    OsFamilyUnix = 3,
}
impl OperatingSystemFamily {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OperatingSystemFamily::OsFamilyUnknown => "OS_FAMILY_UNKNOWN",
            OperatingSystemFamily::OsFamilyWindows => "OS_FAMILY_WINDOWS",
            OperatingSystemFamily::OsFamilyLinux => "OS_FAMILY_LINUX",
            OperatingSystemFamily::OsFamilyUnix => "OS_FAMILY_UNIX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OS_FAMILY_UNKNOWN" => Some(Self::OsFamilyUnknown),
            "OS_FAMILY_WINDOWS" => Some(Self::OsFamilyWindows),
            "OS_FAMILY_LINUX" => Some(Self::OsFamilyLinux),
            "OS_FAMILY_UNIX" => Some(Self::OsFamilyUnix),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImportJobFormat {
    Unspecified = 0,
    RvtoolsXlsx = 1,
    RvtoolsCsv = 2,
    ExportedAwsCsv = 4,
    ExportedAzureCsv = 5,
    StratozoneCsv = 6,
}
impl ImportJobFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ImportJobFormat::Unspecified => "IMPORT_JOB_FORMAT_UNSPECIFIED",
            ImportJobFormat::RvtoolsXlsx => "IMPORT_JOB_FORMAT_RVTOOLS_XLSX",
            ImportJobFormat::RvtoolsCsv => "IMPORT_JOB_FORMAT_RVTOOLS_CSV",
            ImportJobFormat::ExportedAwsCsv => "IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV",
            ImportJobFormat::ExportedAzureCsv => "IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV",
            ImportJobFormat::StratozoneCsv => "IMPORT_JOB_FORMAT_STRATOZONE_CSV",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMPORT_JOB_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "IMPORT_JOB_FORMAT_RVTOOLS_XLSX" => Some(Self::RvtoolsXlsx),
            "IMPORT_JOB_FORMAT_RVTOOLS_CSV" => Some(Self::RvtoolsCsv),
            "IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV" => Some(Self::ExportedAwsCsv),
            "IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV" => Some(Self::ExportedAzureCsv),
            "IMPORT_JOB_FORMAT_STRATOZONE_CSV" => Some(Self::StratozoneCsv),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImportJobView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl ImportJobView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ImportJobView::Unspecified => "IMPORT_JOB_VIEW_UNSPECIFIED",
            ImportJobView::Basic => "IMPORT_JOB_VIEW_BASIC",
            ImportJobView::Full => "IMPORT_JOB_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMPORT_JOB_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "IMPORT_JOB_VIEW_BASIC" => Some(Self::Basic),
            "IMPORT_JOB_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorFrameView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl ErrorFrameView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ErrorFrameView::Unspecified => "ERROR_FRAME_VIEW_UNSPECIFIED",
            ErrorFrameView::Basic => "ERROR_FRAME_VIEW_BASIC",
            ErrorFrameView::Full => "ERROR_FRAME_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_FRAME_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_FRAME_VIEW_BASIC" => Some(Self::Basic),
            "ERROR_FRAME_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PersistentDiskType {
    Unspecified = 0,
    Standard = 1,
    Balanced = 2,
    Ssd = 3,
}
impl PersistentDiskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PersistentDiskType::Unspecified => "PERSISTENT_DISK_TYPE_UNSPECIFIED",
            PersistentDiskType::Standard => "PERSISTENT_DISK_TYPE_STANDARD",
            PersistentDiskType::Balanced => "PERSISTENT_DISK_TYPE_BALANCED",
            PersistentDiskType::Ssd => "PERSISTENT_DISK_TYPE_SSD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERSISTENT_DISK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PERSISTENT_DISK_TYPE_STANDARD" => Some(Self::Standard),
            "PERSISTENT_DISK_TYPE_BALANCED" => Some(Self::Balanced),
            "PERSISTENT_DISK_TYPE_SSD" => Some(Self::Ssd),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LicenseType {
    Unspecified = 0,
    Default = 1,
    BringYourOwnLicense = 2,
}
impl LicenseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LicenseType::Unspecified => "LICENSE_TYPE_UNSPECIFIED",
            LicenseType::Default => "LICENSE_TYPE_DEFAULT",
            LicenseType::BringYourOwnLicense => "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LICENSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "LICENSE_TYPE_DEFAULT" => Some(Self::Default),
            "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE" => Some(Self::BringYourOwnLicense),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SizingOptimizationStrategy {
    Unspecified = 0,
    SameAsSource = 1,
    Moderate = 2,
    Aggressive = 3,
}
impl SizingOptimizationStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SizingOptimizationStrategy::Unspecified => {
                "SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED"
            }
            SizingOptimizationStrategy::SameAsSource => {
                "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE"
            }
            SizingOptimizationStrategy::Moderate => {
                "SIZING_OPTIMIZATION_STRATEGY_MODERATE"
            }
            SizingOptimizationStrategy::Aggressive => {
                "SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
            "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE" => Some(Self::SameAsSource),
            "SIZING_OPTIMIZATION_STRATEGY_MODERATE" => Some(Self::Moderate),
            "SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE" => Some(Self::Aggressive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommitmentPlan {
    Unspecified = 0,
    None = 1,
    OneYear = 2,
    ThreeYears = 3,
}
impl CommitmentPlan {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CommitmentPlan::Unspecified => "COMMITMENT_PLAN_UNSPECIFIED",
            CommitmentPlan::None => "COMMITMENT_PLAN_NONE",
            CommitmentPlan::OneYear => "COMMITMENT_PLAN_ONE_YEAR",
            CommitmentPlan::ThreeYears => "COMMITMENT_PLAN_THREE_YEARS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMITMENT_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMITMENT_PLAN_NONE" => Some(Self::None),
            "COMMITMENT_PLAN_ONE_YEAR" => Some(Self::OneYear),
            "COMMITMENT_PLAN_THREE_YEARS" => Some(Self::ThreeYears),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComputeMigrationTargetProduct {
    Unspecified = 0,
    ComputeEngine = 1,
    VmwareEngine = 2,
    SoleTenancy = 3,
}
impl ComputeMigrationTargetProduct {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ComputeMigrationTargetProduct::Unspecified => {
                "COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED"
            }
            ComputeMigrationTargetProduct::ComputeEngine => {
                "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE"
            }
            ComputeMigrationTargetProduct::VmwareEngine => {
                "COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE"
            }
            ComputeMigrationTargetProduct::SoleTenancy => {
                "COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE" => {
                Some(Self::ComputeEngine)
            }
            "COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE" => Some(Self::VmwareEngine),
            "COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY" => Some(Self::SoleTenancy),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReportView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
    Standard = 3,
}
impl ReportView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReportView::Unspecified => "REPORT_VIEW_UNSPECIFIED",
            ReportView::Basic => "REPORT_VIEW_BASIC",
            ReportView::Full => "REPORT_VIEW_FULL",
            ReportView::Standard => "REPORT_VIEW_STANDARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPORT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "REPORT_VIEW_BASIC" => Some(Self::Basic),
            "REPORT_VIEW_FULL" => Some(Self::Full),
            "REPORT_VIEW_STANDARD" => Some(Self::Standard),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod migration_center_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources.
    #[derive(Debug, Clone)]
    pub struct MigrationCenterClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MigrationCenterClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MigrationCenterClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MigrationCenterClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all the assets in a given project and location.
        pub async fn list_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of an asset.
        pub async fn get_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetRequest>,
        ) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of an asset.
        pub async fn update_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAssetRequest>,
        ) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/UpdateAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "UpdateAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a list of assets.
        pub async fn batch_update_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/BatchUpdateAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "BatchUpdateAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an asset.
        pub async fn delete_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAssetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeleteAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeleteAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes list of Assets.
        pub async fn batch_delete_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteAssetsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/BatchDeleteAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "BatchDeleteAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reports a set of frames.
        pub async fn report_asset_frames(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportAssetFramesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportAssetFramesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ReportAssetFrames",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ReportAssetFrames",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Aggregates the requested fields based on provided function.
        pub async fn aggregate_assets_values(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregateAssetsValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AggregateAssetsValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/AggregateAssetsValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "AggregateAssetsValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an import job.
        pub async fn create_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateImportJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/CreateImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "CreateImportJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all import jobs.
        pub async fn list_import_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListImportJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListImportJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListImportJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListImportJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of an import job.
        pub async fn get_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetImportJobRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetImportJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an import job.
        pub async fn delete_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteImportJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeleteImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeleteImportJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an import job.
        pub async fn update_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateImportJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/UpdateImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "UpdateImportJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Validates an import job.
        pub async fn validate_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateImportJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ValidateImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ValidateImportJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs an import job.
        pub async fn run_import_job(
            &mut self,
            request: impl tonic::IntoRequest<super::RunImportJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/RunImportJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "RunImportJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an import data file.
        pub async fn get_import_data_file(
            &mut self,
            request: impl tonic::IntoRequest<super::GetImportDataFileRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportDataFile>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetImportDataFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetImportDataFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List import data files.
        pub async fn list_import_data_files(
            &mut self,
            request: impl tonic::IntoRequest<super::ListImportDataFilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListImportDataFilesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListImportDataFiles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListImportDataFiles",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an import data file.
        pub async fn create_import_data_file(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateImportDataFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/CreateImportDataFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "CreateImportDataFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an import data file.
        pub async fn delete_import_data_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteImportDataFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeleteImportDataFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeleteImportDataFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all groups in a given project and location.
        pub async fn list_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a group.
        pub async fn get_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Group>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new group in a given project and location.
        pub async fn create_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/CreateGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "CreateGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a group.
        pub async fn update_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/UpdateGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "UpdateGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a group.
        pub async fn delete_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeleteGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeleteGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds assets to a group.
        pub async fn add_assets_to_group(
            &mut self,
            request: impl tonic::IntoRequest<super::AddAssetsToGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/AddAssetsToGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "AddAssetsToGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes assets from a group.
        pub async fn remove_assets_from_group(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveAssetsFromGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/RemoveAssetsFromGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "RemoveAssetsFromGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all error frames in a given source and location.
        pub async fn list_error_frames(
            &mut self,
            request: impl tonic::IntoRequest<super::ListErrorFramesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListErrorFramesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListErrorFrames",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListErrorFrames",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of an error frame.
        pub async fn get_error_frame(
            &mut self,
            request: impl tonic::IntoRequest<super::GetErrorFrameRequest>,
        ) -> std::result::Result<tonic::Response<super::ErrorFrame>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetErrorFrame",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetErrorFrame",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the sources in a given project and location.
        pub async fn list_sources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListSources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListSources",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a source.
        pub async fn get_source(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSourceRequest>,
        ) -> std::result::Result<tonic::Response<super::Source>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new source in a given project and location.
        pub async fn create_source(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/CreateSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "CreateSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a source.
        pub async fn update_source(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/UpdateSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "UpdateSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a source.
        pub async fn delete_source(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeleteSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeleteSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the preference sets in a given project and location.
        pub async fn list_preference_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPreferenceSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPreferenceSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListPreferenceSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListPreferenceSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a preference set.
        pub async fn get_preference_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPreferenceSetRequest>,
        ) -> std::result::Result<tonic::Response<super::PreferenceSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetPreferenceSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetPreferenceSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new preference set in a given project and location.
        pub async fn create_preference_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePreferenceSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/CreatePreferenceSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "CreatePreferenceSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a preference set.
        pub async fn update_preference_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePreferenceSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/UpdatePreferenceSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "UpdatePreferenceSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a preference set.
        pub async fn delete_preference_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePreferenceSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeletePreferenceSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeletePreferenceSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of regional settings.
        pub async fn get_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the regional-level project settings.
        pub async fn update_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/UpdateSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "UpdateSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a report configuration.
        pub async fn create_report_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReportConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/CreateReportConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "CreateReportConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ReportConfig.
        pub async fn get_report_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReportConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ReportConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetReportConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetReportConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists ReportConfigs in a given project and location.
        pub async fn list_report_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReportConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReportConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListReportConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListReportConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a ReportConfig.
        pub async fn delete_report_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReportConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeleteReportConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeleteReportConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a report.
        pub async fn create_report(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/CreateReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "CreateReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Report.
        pub async fn get_report(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReportRequest>,
        ) -> std::result::Result<tonic::Response<super::Report>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/GetReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "GetReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Reports in a given ReportConfig.
        pub async fn list_reports(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReportsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReportsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/ListReports",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "ListReports",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Report.
        pub async fn delete_report(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.migrationcenter.v1.MigrationCenter/DeleteReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.migrationcenter.v1.MigrationCenter",
                        "DeleteReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
