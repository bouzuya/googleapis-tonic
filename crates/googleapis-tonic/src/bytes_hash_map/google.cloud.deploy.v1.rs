// This file is @generated by prost-build.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
    Unspecified = 0,
    PubsubNotificationFailure = 1,
    ResourceStateChange = 3,
    ProcessAborted = 4,
    RestrictionViolated = 5,
    ResourceDeleted = 6,
    RolloutUpdate = 7,
    RenderStatuesChange = 2,
}
impl Type {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Type::Unspecified => "TYPE_UNSPECIFIED",
            Type::PubsubNotificationFailure => "TYPE_PUBSUB_NOTIFICATION_FAILURE",
            Type::ResourceStateChange => "TYPE_RESOURCE_STATE_CHANGE",
            Type::ProcessAborted => "TYPE_PROCESS_ABORTED",
            Type::RestrictionViolated => "TYPE_RESTRICTION_VIOLATED",
            Type::ResourceDeleted => "TYPE_RESOURCE_DELETED",
            Type::RolloutUpdate => "TYPE_ROLLOUT_UPDATE",
            Type::RenderStatuesChange => "TYPE_RENDER_STATUES_CHANGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TYPE_PUBSUB_NOTIFICATION_FAILURE" => Some(Self::PubsubNotificationFailure),
            "TYPE_RESOURCE_STATE_CHANGE" => Some(Self::ResourceStateChange),
            "TYPE_PROCESS_ABORTED" => Some(Self::ProcessAborted),
            "TYPE_RESTRICTION_VIOLATED" => Some(Self::RestrictionViolated),
            "TYPE_RESOURCE_DELETED" => Some(Self::ResourceDeleted),
            "TYPE_ROLLOUT_UPDATE" => Some(Self::RolloutUpdate),
            "TYPE_RENDER_STATUES_CHANGE" => Some(Self::RenderStatuesChange),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub automation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "4")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutUpdateEvent {
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub release_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub release: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "7")]
    pub r#type: i32,
    #[prost(enumeration = "rollout_update_event::RolloutUpdateType", tag = "5")]
    pub rollout_update_type: i32,
}
/// Nested message and enum types in `RolloutUpdateEvent`.
pub mod rollout_update_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RolloutUpdateType {
        Unspecified = 0,
        Pending = 1,
        PendingRelease = 2,
        InProgress = 3,
        Cancelling = 4,
        Cancelled = 5,
        Halted = 6,
        Succeeded = 7,
        Failed = 8,
        ApprovalRequired = 9,
        Approved = 10,
        Rejected = 11,
        AdvanceRequired = 12,
        Advanced = 13,
    }
    impl RolloutUpdateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RolloutUpdateType::Unspecified => "ROLLOUT_UPDATE_TYPE_UNSPECIFIED",
                RolloutUpdateType::Pending => "PENDING",
                RolloutUpdateType::PendingRelease => "PENDING_RELEASE",
                RolloutUpdateType::InProgress => "IN_PROGRESS",
                RolloutUpdateType::Cancelling => "CANCELLING",
                RolloutUpdateType::Cancelled => "CANCELLED",
                RolloutUpdateType::Halted => "HALTED",
                RolloutUpdateType::Succeeded => "SUCCEEDED",
                RolloutUpdateType::Failed => "FAILED",
                RolloutUpdateType::ApprovalRequired => "APPROVAL_REQUIRED",
                RolloutUpdateType::Approved => "APPROVED",
                RolloutUpdateType::Rejected => "REJECTED",
                RolloutUpdateType::AdvanceRequired => "ADVANCE_REQUIRED",
                RolloutUpdateType::Advanced => "ADVANCED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLLOUT_UPDATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "PENDING_RELEASE" => Some(Self::PendingRelease),
                "IN_PROGRESS" => Some(Self::InProgress),
                "CANCELLING" => Some(Self::Cancelling),
                "CANCELLED" => Some(Self::Cancelled),
                "HALTED" => Some(Self::Halted),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "APPROVAL_REQUIRED" => Some(Self::ApprovalRequired),
                "APPROVED" => Some(Self::Approved),
                "REJECTED" => Some(Self::Rejected),
                "ADVANCE_REQUIRED" => Some(Self::AdvanceRequired),
                "ADVANCED" => Some(Self::Advanced),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipeline {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub condition: ::core::option::Option<PipelineCondition>,
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    #[prost(bool, tag = "12")]
    pub suspended: bool,
    #[prost(oneof = "delivery_pipeline::Pipeline", tags = "8")]
    pub pipeline: ::core::option::Option<delivery_pipeline::Pipeline>,
}
/// Nested message and enum types in `DeliveryPipeline`.
pub mod delivery_pipeline {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pipeline {
        #[prost(message, tag = "8")]
        SerialPipeline(super::SerialPipeline),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SerialPipeline {
    #[prost(message, repeated, tag = "1")]
    pub stages: ::prost::alloc::vec::Vec<Stage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stage {
    #[prost(string, tag = "1")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub profiles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub strategy: ::core::option::Option<Strategy>,
    #[prost(message, repeated, tag = "6")]
    pub deploy_parameters: ::prost::alloc::vec::Vec<DeployParameters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployParameters {
    #[prost(map = "string, string", tag = "1")]
    pub values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "2")]
    pub match_target_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Strategy {
    #[prost(oneof = "strategy::DeploymentStrategy", tags = "1, 2")]
    pub deployment_strategy: ::core::option::Option<strategy::DeploymentStrategy>,
}
/// Nested message and enum types in `Strategy`.
pub mod strategy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DeploymentStrategy {
        #[prost(message, tag = "1")]
        Standard(super::Standard),
        #[prost(message, tag = "2")]
        Canary(super::Canary),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Predeploy {
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Postdeploy {
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Standard {
    #[prost(bool, tag = "1")]
    pub verify: bool,
    #[prost(message, optional, tag = "2")]
    pub predeploy: ::core::option::Option<Predeploy>,
    #[prost(message, optional, tag = "3")]
    pub postdeploy: ::core::option::Option<Postdeploy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Canary {
    #[prost(message, optional, tag = "1")]
    pub runtime_config: ::core::option::Option<RuntimeConfig>,
    #[prost(oneof = "canary::Mode", tags = "2, 3")]
    pub mode: ::core::option::Option<canary::Mode>,
}
/// Nested message and enum types in `Canary`.
pub mod canary {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        #[prost(message, tag = "2")]
        CanaryDeployment(super::CanaryDeployment),
        #[prost(message, tag = "3")]
        CustomCanaryDeployment(super::CustomCanaryDeployment),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanaryDeployment {
    #[prost(int32, repeated, packed = "false", tag = "1")]
    pub percentages: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "2")]
    pub verify: bool,
    #[prost(message, optional, tag = "3")]
    pub predeploy: ::core::option::Option<Predeploy>,
    #[prost(message, optional, tag = "4")]
    pub postdeploy: ::core::option::Option<Postdeploy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomCanaryDeployment {
    #[prost(message, repeated, tag = "1")]
    pub phase_configs: ::prost::alloc::vec::Vec<custom_canary_deployment::PhaseConfig>,
}
/// Nested message and enum types in `CustomCanaryDeployment`.
pub mod custom_canary_deployment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PhaseConfig {
        #[prost(string, tag = "1")]
        pub phase_id: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub percentage: i32,
        #[prost(string, repeated, tag = "3")]
        pub profiles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "4")]
        pub verify: bool,
        #[prost(message, optional, tag = "5")]
        pub predeploy: ::core::option::Option<super::Predeploy>,
        #[prost(message, optional, tag = "6")]
        pub postdeploy: ::core::option::Option<super::Postdeploy>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KubernetesConfig {
    #[prost(oneof = "kubernetes_config::ServiceDefinition", tags = "1, 2")]
    pub service_definition: ::core::option::Option<kubernetes_config::ServiceDefinition>,
}
/// Nested message and enum types in `KubernetesConfig`.
pub mod kubernetes_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GatewayServiceMesh {
        #[prost(string, tag = "1")]
        pub http_route: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub service: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub deployment: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub route_update_wait_time: ::core::option::Option<::prost_types::Duration>,
        #[prost(message, optional, tag = "5")]
        pub stable_cutback_duration: ::core::option::Option<::prost_types::Duration>,
        #[prost(string, tag = "6")]
        pub pod_selector_label: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceNetworking {
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub deployment: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub disable_pod_overprovisioning: bool,
        #[prost(string, tag = "4")]
        pub pod_selector_label: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ServiceDefinition {
        #[prost(message, tag = "1")]
        GatewayServiceMesh(GatewayServiceMesh),
        #[prost(message, tag = "2")]
        ServiceNetworking(ServiceNetworking),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunConfig {
    #[prost(bool, tag = "1")]
    pub automatic_traffic_control: bool,
    #[prost(string, repeated, tag = "2")]
    pub canary_revision_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub prior_revision_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub stable_revision_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeConfig {
    #[prost(oneof = "runtime_config::RuntimeConfig", tags = "1, 2")]
    pub runtime_config: ::core::option::Option<runtime_config::RuntimeConfig>,
}
/// Nested message and enum types in `RuntimeConfig`.
pub mod runtime_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RuntimeConfig {
        #[prost(message, tag = "1")]
        Kubernetes(super::KubernetesConfig),
        #[prost(message, tag = "2")]
        CloudRun(super::CloudRunConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PipelineReadyCondition {
    #[prost(bool, tag = "3")]
    pub status: bool,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetsPresentCondition {
    #[prost(bool, tag = "1")]
    pub status: bool,
    #[prost(string, repeated, tag = "2")]
    pub missing_targets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetsTypeCondition {
    #[prost(bool, tag = "1")]
    pub status: bool,
    #[prost(string, tag = "2")]
    pub error_details: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineCondition {
    #[prost(message, optional, tag = "1")]
    pub pipeline_ready_condition: ::core::option::Option<PipelineReadyCondition>,
    #[prost(message, optional, tag = "3")]
    pub targets_present_condition: ::core::option::Option<TargetsPresentCondition>,
    #[prost(message, optional, tag = "4")]
    pub targets_type_condition: ::core::option::Option<TargetsTypeCondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeliveryPipelinesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeliveryPipelinesResponse {
    #[prost(message, repeated, tag = "1")]
    pub delivery_pipelines: ::prost::alloc::vec::Vec<DeliveryPipeline>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeliveryPipelineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeliveryPipelineRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub delivery_pipeline_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub delivery_pipeline: ::core::option::Option<DeliveryPipeline>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeliveryPipelineRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub delivery_pipeline: ::core::option::Option<DeliveryPipeline>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeliveryPipelineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    #[prost(bool, tag = "6")]
    pub force: bool,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackTargetConfig {
    #[prost(message, optional, tag = "1")]
    pub rollout: ::core::option::Option<Rollout>,
    #[prost(string, tag = "2")]
    pub starting_phase_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackTargetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rollout_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub release_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub rollout_to_roll_back: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub rollback_config: ::core::option::Option<RollbackTargetConfig>,
    #[prost(bool, tag = "7")]
    pub validate_only: bool,
    #[prost(string, repeated, tag = "9")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackTargetResponse {
    #[prost(message, optional, tag = "1")]
    pub rollback_config: ::core::option::Option<RollbackTargetConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "13")]
    pub require_approval: bool,
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "12")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "16")]
    pub execution_configs: ::prost::alloc::vec::Vec<ExecutionConfig>,
    #[prost(map = "string, string", tag = "20")]
    pub deploy_parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "target::DeploymentTarget", tags = "15, 17, 18, 19, 21")]
    pub deployment_target: ::core::option::Option<target::DeploymentTarget>,
}
/// Nested message and enum types in `Target`.
pub mod target {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DeploymentTarget {
        #[prost(message, tag = "15")]
        Gke(super::GkeCluster),
        #[prost(message, tag = "17")]
        AnthosCluster(super::AnthosCluster),
        #[prost(message, tag = "18")]
        Run(super::CloudRunLocation),
        #[prost(message, tag = "19")]
        MultiTarget(super::MultiTarget),
        #[prost(message, tag = "21")]
        CustomTarget(super::CustomTarget),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionConfig {
    #[prost(
        enumeration = "execution_config::ExecutionEnvironmentUsage",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub usages: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "4")]
    pub worker_pool: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub artifact_storage: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub execution_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag = "8")]
    pub verbose: bool,
    #[prost(oneof = "execution_config::ExecutionEnvironment", tags = "2, 3")]
    pub execution_environment: ::core::option::Option<
        execution_config::ExecutionEnvironment,
    >,
}
/// Nested message and enum types in `ExecutionConfig`.
pub mod execution_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionEnvironmentUsage {
        Unspecified = 0,
        Render = 1,
        Deploy = 2,
        Verify = 3,
        Predeploy = 4,
        Postdeploy = 5,
    }
    impl ExecutionEnvironmentUsage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExecutionEnvironmentUsage::Unspecified => {
                    "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED"
                }
                ExecutionEnvironmentUsage::Render => "RENDER",
                ExecutionEnvironmentUsage::Deploy => "DEPLOY",
                ExecutionEnvironmentUsage::Verify => "VERIFY",
                ExecutionEnvironmentUsage::Predeploy => "PREDEPLOY",
                ExecutionEnvironmentUsage::Postdeploy => "POSTDEPLOY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "RENDER" => Some(Self::Render),
                "DEPLOY" => Some(Self::Deploy),
                "VERIFY" => Some(Self::Verify),
                "PREDEPLOY" => Some(Self::Predeploy),
                "POSTDEPLOY" => Some(Self::Postdeploy),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExecutionEnvironment {
        #[prost(message, tag = "2")]
        DefaultPool(super::DefaultPool),
        #[prost(message, tag = "3")]
        PrivatePool(super::PrivatePool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultPool {
    #[prost(string, tag = "1")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub artifact_storage: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePool {
    #[prost(string, tag = "1")]
    pub worker_pool: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub artifact_storage: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GkeCluster {
    #[prost(string, tag = "1")]
    pub cluster: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub internal_ip: bool,
    #[prost(string, tag = "3")]
    pub proxy_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnthosCluster {
    #[prost(string, tag = "1")]
    pub membership: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunLocation {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiTarget {
    #[prost(string, repeated, tag = "1")]
    pub target_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTarget {
    #[prost(string, tag = "1")]
    pub custom_target_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub targets: ::prost::alloc::vec::Vec<Target>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTargetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub target: ::core::option::Option<Target>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTargetRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub target: ::core::option::Option<Target>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub custom_target_type_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    #[prost(oneof = "custom_target_type::Definition", tags = "10")]
    pub definition: ::core::option::Option<custom_target_type::Definition>,
}
/// Nested message and enum types in `CustomTargetType`.
pub mod custom_target_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Definition {
        #[prost(message, tag = "10")]
        CustomActions(super::CustomTargetSkaffoldActions),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetSkaffoldActions {
    #[prost(string, tag = "1")]
    pub render_action: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deploy_action: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub include_skaffold_modules: ::prost::alloc::vec::Vec<SkaffoldModules>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkaffoldModules {
    #[prost(string, repeated, tag = "1")]
    pub configs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "skaffold_modules::Source", tags = "2, 3, 4")]
    pub source: ::core::option::Option<skaffold_modules::Source>,
}
/// Nested message and enum types in `SkaffoldModules`.
pub mod skaffold_modules {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SkaffoldGitSource {
        #[prost(string, tag = "1")]
        pub repo: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub r#ref: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SkaffoldGcsSource {
        #[prost(string, tag = "1")]
        pub source: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SkaffoldGcbRepoSource {
        #[prost(string, tag = "1")]
        pub repository: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub r#ref: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        Git(SkaffoldGitSource),
        #[prost(message, tag = "3")]
        GoogleCloudStorage(SkaffoldGcsSource),
        #[prost(message, tag = "4")]
        GoogleCloudBuildRepo(SkaffoldGcbRepoSource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub custom_target_types: ::prost::alloc::vec::Vec<CustomTargetType>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomTargetTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomTargetTypeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub custom_target_type_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub custom_target_type: ::core::option::Option<CustomTargetType>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomTargetTypeRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub custom_target_type: ::core::option::Option<CustomTargetType>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomTargetTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployPolicy {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "8")]
    pub suspended: bool,
    #[prost(message, repeated, tag = "12")]
    pub selectors: ::prost::alloc::vec::Vec<DeployPolicyResourceSelector>,
    #[prost(message, repeated, tag = "10")]
    pub rules: ::prost::alloc::vec::Vec<PolicyRule>,
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DeployPolicy`.
pub mod deploy_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Invoker {
        Unspecified = 0,
        User = 1,
        DeployAutomation = 2,
    }
    impl Invoker {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Invoker::Unspecified => "INVOKER_UNSPECIFIED",
                Invoker::User => "USER",
                Invoker::DeployAutomation => "DEPLOY_AUTOMATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVOKER_UNSPECIFIED" => Some(Self::Unspecified),
                "USER" => Some(Self::User),
                "DEPLOY_AUTOMATION" => Some(Self::DeployAutomation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployPolicyResourceSelector {
    #[prost(message, optional, tag = "1")]
    pub delivery_pipeline: ::core::option::Option<DeliveryPipelineAttribute>,
    #[prost(message, optional, tag = "2")]
    pub target: ::core::option::Option<TargetAttribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipelineAttribute {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetAttribute {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyRule {
    #[prost(oneof = "policy_rule::Rule", tags = "1")]
    pub rule: ::core::option::Option<policy_rule::Rule>,
}
/// Nested message and enum types in `PolicyRule`.
pub mod policy_rule {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Rule {
        #[prost(message, tag = "1")]
        RestrictRollouts(super::RestrictRollout),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestrictRollout {
    #[prost(string, tag = "5")]
    pub id: ::prost::alloc::string::String,
    #[prost(
        enumeration = "deploy_policy::Invoker",
        repeated,
        packed = "false",
        tag = "6"
    )]
    pub invokers: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "restrict_rollout::Actions", repeated, tag = "3")]
    pub actions: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub time_window: ::core::option::Option<TimeWindow>,
}
/// Nested message and enum types in `RestrictRollout`.
pub mod restrict_rollout {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Actions {
        Unspecified = 0,
        Advance = 1,
        Approve = 2,
        Cancel = 3,
        Create = 4,
        IgnoreJob = 5,
        RetryJob = 6,
        Rollback = 7,
        TerminateJobrun = 8,
    }
    impl Actions {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Actions::Unspecified => "ACTIONS_UNSPECIFIED",
                Actions::Advance => "ADVANCE",
                Actions::Approve => "APPROVE",
                Actions::Cancel => "CANCEL",
                Actions::Create => "CREATE",
                Actions::IgnoreJob => "IGNORE_JOB",
                Actions::RetryJob => "RETRY_JOB",
                Actions::Rollback => "ROLLBACK",
                Actions::TerminateJobrun => "TERMINATE_JOBRUN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTIONS_UNSPECIFIED" => Some(Self::Unspecified),
                "ADVANCE" => Some(Self::Advance),
                "APPROVE" => Some(Self::Approve),
                "CANCEL" => Some(Self::Cancel),
                "CREATE" => Some(Self::Create),
                "IGNORE_JOB" => Some(Self::IgnoreJob),
                "RETRY_JOB" => Some(Self::RetryJob),
                "ROLLBACK" => Some(Self::Rollback),
                "TERMINATE_JOBRUN" => Some(Self::TerminateJobrun),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeWindow {
    #[prost(string, tag = "1")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub ranges: ::prost::alloc::vec::Vec<Range>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Range {
    #[prost(message, optional, tag = "1")]
    pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
    #[prost(message, optional, tag = "2")]
    pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
    #[prost(message, optional, tag = "3")]
    pub start_time_of_day: ::core::option::Option<
        super::super::super::r#type::TimeOfDay,
    >,
    #[prost(message, optional, tag = "4")]
    pub end_time_of_day: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    #[prost(enumeration = "super::super::super::r#type::DayOfWeek", repeated, tag = "5")]
    pub day_of_week: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolation {
    #[prost(message, repeated, tag = "1")]
    pub policy_violation_details: ::prost::alloc::vec::Vec<PolicyViolationDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolationDetails {
    #[prost(string, tag = "1")]
    pub policy: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub failure_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Release {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "23")]
    pub abandoned: bool,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub render_start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub render_end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "17")]
    pub skaffold_config_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub skaffold_config_path: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "10")]
    pub build_artifacts: ::prost::alloc::vec::Vec<BuildArtifact>,
    #[prost(message, optional, tag = "11")]
    pub delivery_pipeline_snapshot: ::core::option::Option<DeliveryPipeline>,
    #[prost(message, repeated, tag = "12")]
    pub target_snapshots: ::prost::alloc::vec::Vec<Target>,
    #[prost(message, repeated, tag = "27")]
    pub custom_target_type_snapshots: ::prost::alloc::vec::Vec<CustomTargetType>,
    #[prost(enumeration = "release::RenderState", tag = "13")]
    pub render_state: i32,
    #[prost(string, tag = "16")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub skaffold_version: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "20")]
    pub target_artifacts: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetArtifact,
    >,
    #[prost(map = "string, message", tag = "22")]
    pub target_renders: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        release::TargetRender,
    >,
    #[prost(message, optional, tag = "24")]
    pub condition: ::core::option::Option<release::ReleaseCondition>,
    #[prost(map = "string, string", tag = "25")]
    pub deploy_parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Release`.
pub mod release {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TargetRender {
        #[prost(string, tag = "1")]
        pub rendering_build: ::prost::alloc::string::String,
        #[prost(enumeration = "target_render::TargetRenderState", tag = "2")]
        pub rendering_state: i32,
        #[prost(message, optional, tag = "6")]
        pub metadata: ::core::option::Option<super::RenderMetadata>,
        #[prost(enumeration = "target_render::FailureCause", tag = "4")]
        pub failure_cause: i32,
        #[prost(string, tag = "5")]
        pub failure_message: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `TargetRender`.
    pub mod target_render {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TargetRenderState {
            Unspecified = 0,
            Succeeded = 1,
            Failed = 2,
            InProgress = 3,
        }
        impl TargetRenderState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    TargetRenderState::Unspecified => "TARGET_RENDER_STATE_UNSPECIFIED",
                    TargetRenderState::Succeeded => "SUCCEEDED",
                    TargetRenderState::Failed => "FAILED",
                    TargetRenderState::InProgress => "IN_PROGRESS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TARGET_RENDER_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SUCCEEDED" => Some(Self::Succeeded),
                    "FAILED" => Some(Self::Failed),
                    "IN_PROGRESS" => Some(Self::InProgress),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FailureCause {
            Unspecified = 0,
            CloudBuildUnavailable = 1,
            ExecutionFailed = 2,
            CloudBuildRequestFailed = 3,
            VerificationConfigNotFound = 4,
            CustomActionNotFound = 5,
            DeploymentStrategyNotSupported = 6,
            RenderFeatureNotSupported = 7,
        }
        impl FailureCause {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    FailureCause::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                    FailureCause::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                    FailureCause::ExecutionFailed => "EXECUTION_FAILED",
                    FailureCause::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
                    FailureCause::VerificationConfigNotFound => {
                        "VERIFICATION_CONFIG_NOT_FOUND"
                    }
                    FailureCause::CustomActionNotFound => "CUSTOM_ACTION_NOT_FOUND",
                    FailureCause::DeploymentStrategyNotSupported => {
                        "DEPLOYMENT_STRATEGY_NOT_SUPPORTED"
                    }
                    FailureCause::RenderFeatureNotSupported => {
                        "RENDER_FEATURE_NOT_SUPPORTED"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                    "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                    "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                    "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                    "VERIFICATION_CONFIG_NOT_FOUND" => {
                        Some(Self::VerificationConfigNotFound)
                    }
                    "CUSTOM_ACTION_NOT_FOUND" => Some(Self::CustomActionNotFound),
                    "DEPLOYMENT_STRATEGY_NOT_SUPPORTED" => {
                        Some(Self::DeploymentStrategyNotSupported)
                    }
                    "RENDER_FEATURE_NOT_SUPPORTED" => {
                        Some(Self::RenderFeatureNotSupported)
                    }
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseReadyCondition {
        #[prost(bool, tag = "1")]
        pub status: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SkaffoldSupportedCondition {
        #[prost(bool, tag = "1")]
        pub status: bool,
        #[prost(enumeration = "super::SkaffoldSupportState", tag = "2")]
        pub skaffold_support_state: i32,
        #[prost(message, optional, tag = "3")]
        pub maintenance_mode_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "4")]
        pub support_expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseCondition {
        #[prost(message, optional, tag = "1")]
        pub release_ready_condition: ::core::option::Option<ReleaseReadyCondition>,
        #[prost(message, optional, tag = "2")]
        pub skaffold_supported_condition: ::core::option::Option<
            SkaffoldSupportedCondition,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RenderState {
        Unspecified = 0,
        Succeeded = 1,
        Failed = 2,
        InProgress = 3,
    }
    impl RenderState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RenderState::Unspecified => "RENDER_STATE_UNSPECIFIED",
                RenderState::Succeeded => "SUCCEEDED",
                RenderState::Failed => "FAILED",
                RenderState::InProgress => "IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RENDER_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "IN_PROGRESS" => Some(Self::InProgress),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeployPolicyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deploy_policy_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub deploy_policy: ::core::option::Option<DeployPolicy>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeployPolicyRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub deploy_policy: ::core::option::Option<DeployPolicy>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeployPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeployPoliciesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeployPoliciesResponse {
    #[prost(message, repeated, tag = "1")]
    pub deploy_policies: ::prost::alloc::vec::Vec<DeployPolicy>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeployPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildArtifact {
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetArtifact {
    #[prost(string, tag = "2")]
    pub skaffold_config_path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub manifest_path: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "5")]
    pub phase_artifacts: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        target_artifact::PhaseArtifact,
    >,
    #[prost(oneof = "target_artifact::Uri", tags = "4")]
    pub uri: ::core::option::Option<target_artifact::Uri>,
}
/// Nested message and enum types in `TargetArtifact`.
pub mod target_artifact {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PhaseArtifact {
        #[prost(string, tag = "1")]
        pub skaffold_config_path: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub manifest_path: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub job_manifests_path: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Uri {
        #[prost(string, tag = "4")]
        ArtifactUri(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployArtifact {
    #[prost(string, tag = "1")]
    pub artifact_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub manifest_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunRenderMetadata {
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderMetadata {
    #[prost(message, optional, tag = "1")]
    pub cloud_run: ::core::option::Option<CloudRunRenderMetadata>,
    #[prost(message, optional, tag = "2")]
    pub custom: ::core::option::Option<CustomMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleasesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleasesResponse {
    #[prost(message, repeated, tag = "1")]
    pub releases: ::prost::alloc::vec::Vec<Release>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReleaseRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReleaseRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub release_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub release: ::core::option::Option<Release>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    #[prost(string, repeated, tag = "6")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rollout {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub approve_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub enqueue_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub deploy_start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub deploy_end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "18")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(enumeration = "rollout::ApprovalState", tag = "12")]
    pub approval_state: i32,
    #[prost(enumeration = "rollout::State", tag = "13")]
    pub state: i32,
    #[prost(string, tag = "14")]
    pub failure_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub deploying_build: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub etag: ::prost::alloc::string::String,
    #[prost(enumeration = "rollout::FailureCause", tag = "19")]
    pub deploy_failure_cause: i32,
    #[prost(message, repeated, tag = "23")]
    pub phases: ::prost::alloc::vec::Vec<Phase>,
    #[prost(message, optional, tag = "24")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "25")]
    pub controller_rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "26")]
    pub rollback_of_rollout: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "27")]
    pub rolled_back_by_rollouts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Rollout`.
pub mod rollout {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ApprovalState {
        Unspecified = 0,
        NeedsApproval = 1,
        DoesNotNeedApproval = 2,
        Approved = 3,
        Rejected = 4,
    }
    impl ApprovalState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ApprovalState::Unspecified => "APPROVAL_STATE_UNSPECIFIED",
                ApprovalState::NeedsApproval => "NEEDS_APPROVAL",
                ApprovalState::DoesNotNeedApproval => "DOES_NOT_NEED_APPROVAL",
                ApprovalState::Approved => "APPROVED",
                ApprovalState::Rejected => "REJECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPROVAL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEEDS_APPROVAL" => Some(Self::NeedsApproval),
                "DOES_NOT_NEED_APPROVAL" => Some(Self::DoesNotNeedApproval),
                "APPROVED" => Some(Self::Approved),
                "REJECTED" => Some(Self::Rejected),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Succeeded = 1,
        Failed = 2,
        InProgress = 3,
        PendingApproval = 4,
        ApprovalRejected = 5,
        Pending = 6,
        PendingRelease = 7,
        Cancelling = 8,
        Cancelled = 9,
        Halted = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::InProgress => "IN_PROGRESS",
                State::PendingApproval => "PENDING_APPROVAL",
                State::ApprovalRejected => "APPROVAL_REJECTED",
                State::Pending => "PENDING",
                State::PendingRelease => "PENDING_RELEASE",
                State::Cancelling => "CANCELLING",
                State::Cancelled => "CANCELLED",
                State::Halted => "HALTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "IN_PROGRESS" => Some(Self::InProgress),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "APPROVAL_REJECTED" => Some(Self::ApprovalRejected),
                "PENDING" => Some(Self::Pending),
                "PENDING_RELEASE" => Some(Self::PendingRelease),
                "CANCELLING" => Some(Self::Cancelling),
                "CANCELLED" => Some(Self::Cancelled),
                "HALTED" => Some(Self::Halted),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailureCause {
        Unspecified = 0,
        CloudBuildUnavailable = 1,
        ExecutionFailed = 2,
        DeadlineExceeded = 3,
        ReleaseFailed = 4,
        ReleaseAbandoned = 5,
        VerificationConfigNotFound = 6,
        CloudBuildRequestFailed = 7,
        OperationFeatureNotSupported = 8,
    }
    impl FailureCause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FailureCause::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                FailureCause::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                FailureCause::ExecutionFailed => "EXECUTION_FAILED",
                FailureCause::DeadlineExceeded => "DEADLINE_EXCEEDED",
                FailureCause::ReleaseFailed => "RELEASE_FAILED",
                FailureCause::ReleaseAbandoned => "RELEASE_ABANDONED",
                FailureCause::VerificationConfigNotFound => {
                    "VERIFICATION_CONFIG_NOT_FOUND"
                }
                FailureCause::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
                FailureCause::OperationFeatureNotSupported => {
                    "OPERATION_FEATURE_NOT_SUPPORTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                "RELEASE_FAILED" => Some(Self::ReleaseFailed),
                "RELEASE_ABANDONED" => Some(Self::ReleaseAbandoned),
                "VERIFICATION_CONFIG_NOT_FOUND" => Some(Self::VerificationConfigNotFound),
                "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                "OPERATION_FEATURE_NOT_SUPPORTED" => {
                    Some(Self::OperationFeatureNotSupported)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(message, optional, tag = "1")]
    pub cloud_run: ::core::option::Option<CloudRunMetadata>,
    #[prost(message, optional, tag = "2")]
    pub automation: ::core::option::Option<AutomationRolloutMetadata>,
    #[prost(message, optional, tag = "3")]
    pub custom: ::core::option::Option<CustomMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployJobRunMetadata {
    #[prost(message, optional, tag = "1")]
    pub cloud_run: ::core::option::Option<CloudRunMetadata>,
    #[prost(message, optional, tag = "2")]
    pub custom_target: ::core::option::Option<CustomTargetDeployMetadata>,
    #[prost(message, optional, tag = "3")]
    pub custom: ::core::option::Option<CustomMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunMetadata {
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub service_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub revision: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub job: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetDeployMetadata {
    #[prost(string, tag = "1")]
    pub skip_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRolloutMetadata {
    #[prost(string, tag = "1")]
    pub promote_automation_run: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub advance_automation_runs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "3")]
    pub repair_automation_runs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomMetadata {
    #[prost(map = "string, string", tag = "1")]
    pub values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Phase {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "phase::State", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub skip_message: ::prost::alloc::string::String,
    #[prost(oneof = "phase::Jobs", tags = "4, 5")]
    pub jobs: ::core::option::Option<phase::Jobs>,
}
/// Nested message and enum types in `Phase`.
pub mod phase {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Pending = 1,
        InProgress = 2,
        Succeeded = 3,
        Failed = 4,
        Aborted = 5,
        Skipped = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Pending => "PENDING",
                State::InProgress => "IN_PROGRESS",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Aborted => "ABORTED",
                State::Skipped => "SKIPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "ABORTED" => Some(Self::Aborted),
                "SKIPPED" => Some(Self::Skipped),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Jobs {
        #[prost(message, tag = "4")]
        DeploymentJobs(super::DeploymentJobs),
        #[prost(message, tag = "5")]
        ChildRolloutJobs(super::ChildRolloutJobs),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentJobs {
    #[prost(message, optional, tag = "1")]
    pub deploy_job: ::core::option::Option<Job>,
    #[prost(message, optional, tag = "2")]
    pub verify_job: ::core::option::Option<Job>,
    #[prost(message, optional, tag = "3")]
    pub predeploy_job: ::core::option::Option<Job>,
    #[prost(message, optional, tag = "4")]
    pub postdeploy_job: ::core::option::Option<Job>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildRolloutJobs {
    #[prost(message, repeated, tag = "1")]
    pub create_rollout_jobs: ::prost::alloc::vec::Vec<Job>,
    #[prost(message, repeated, tag = "2")]
    pub advance_rollout_jobs: ::prost::alloc::vec::Vec<Job>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "job::State", tag = "2")]
    pub state: i32,
    #[prost(string, tag = "8")]
    pub skip_message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub job_run: ::prost::alloc::string::String,
    #[prost(oneof = "job::JobType", tags = "4, 5, 9, 10, 6, 7")]
    pub job_type: ::core::option::Option<job::JobType>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Pending = 1,
        Disabled = 2,
        InProgress = 3,
        Succeeded = 4,
        Failed = 5,
        Aborted = 6,
        Skipped = 7,
        Ignored = 8,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Pending => "PENDING",
                State::Disabled => "DISABLED",
                State::InProgress => "IN_PROGRESS",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Aborted => "ABORTED",
                State::Skipped => "SKIPPED",
                State::Ignored => "IGNORED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "DISABLED" => Some(Self::Disabled),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "ABORTED" => Some(Self::Aborted),
                "SKIPPED" => Some(Self::Skipped),
                "IGNORED" => Some(Self::Ignored),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum JobType {
        #[prost(message, tag = "4")]
        DeployJob(super::DeployJob),
        #[prost(message, tag = "5")]
        VerifyJob(super::VerifyJob),
        #[prost(message, tag = "9")]
        PredeployJob(super::PredeployJob),
        #[prost(message, tag = "10")]
        PostdeployJob(super::PostdeployJob),
        #[prost(message, tag = "6")]
        CreateChildRolloutJob(super::CreateChildRolloutJob),
        #[prost(message, tag = "7")]
        AdvanceChildRolloutJob(super::AdvanceChildRolloutJob),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeployJob {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerifyJob {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredeployJob {
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostdeployJob {
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateChildRolloutJob {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvanceChildRolloutJob {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolloutsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolloutsResponse {
    #[prost(message, repeated, tag = "1")]
    pub rollouts: ::prost::alloc::vec::Vec<Rollout>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRolloutRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRolloutRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rollout_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub rollout: ::core::option::Option<Rollout>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    #[prost(string, repeated, tag = "6")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub starting_phase_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveRolloutRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub approved: bool,
    #[prost(string, repeated, tag = "3")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApproveRolloutResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdvanceRolloutRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub phase_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvanceRolloutResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelRolloutRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelRolloutResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IgnoreJobRequest {
    #[prost(string, tag = "1")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub phase_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IgnoreJobResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryJobRequest {
    #[prost(string, tag = "1")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub phase_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetryJobResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbandonReleaseRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbandonReleaseResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobRun {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub phase_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "job_run::State", tag = "8")]
    pub state: i32,
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
    #[prost(oneof = "job_run::JobRun", tags = "9, 10, 14, 15, 12, 13")]
    pub job_run: ::core::option::Option<job_run::JobRun>,
}
/// Nested message and enum types in `JobRun`.
pub mod job_run {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        InProgress = 1,
        Succeeded = 2,
        Failed = 3,
        Terminating = 4,
        Terminated = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::InProgress => "IN_PROGRESS",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Terminating => "TERMINATING",
                State::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum JobRun {
        #[prost(message, tag = "9")]
        DeployJobRun(super::DeployJobRun),
        #[prost(message, tag = "10")]
        VerifyJobRun(super::VerifyJobRun),
        #[prost(message, tag = "14")]
        PredeployJobRun(super::PredeployJobRun),
        #[prost(message, tag = "15")]
        PostdeployJobRun(super::PostdeployJobRun),
        #[prost(message, tag = "12")]
        CreateChildRolloutJobRun(super::CreateChildRolloutJobRun),
        #[prost(message, tag = "13")]
        AdvanceChildRolloutJobRun(super::AdvanceChildRolloutJobRun),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployJobRun {
    #[prost(string, tag = "1")]
    pub build: ::prost::alloc::string::String,
    #[prost(enumeration = "deploy_job_run::FailureCause", tag = "2")]
    pub failure_cause: i32,
    #[prost(string, tag = "3")]
    pub failure_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<DeployJobRunMetadata>,
    #[prost(message, optional, tag = "5")]
    pub artifact: ::core::option::Option<DeployArtifact>,
}
/// Nested message and enum types in `DeployJobRun`.
pub mod deploy_job_run {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailureCause {
        Unspecified = 0,
        CloudBuildUnavailable = 1,
        ExecutionFailed = 2,
        DeadlineExceeded = 3,
        MissingResourcesForCanary = 4,
        CloudBuildRequestFailed = 5,
        DeployFeatureNotSupported = 6,
    }
    impl FailureCause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FailureCause::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                FailureCause::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                FailureCause::ExecutionFailed => "EXECUTION_FAILED",
                FailureCause::DeadlineExceeded => "DEADLINE_EXCEEDED",
                FailureCause::MissingResourcesForCanary => "MISSING_RESOURCES_FOR_CANARY",
                FailureCause::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
                FailureCause::DeployFeatureNotSupported => "DEPLOY_FEATURE_NOT_SUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                "MISSING_RESOURCES_FOR_CANARY" => Some(Self::MissingResourcesForCanary),
                "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                "DEPLOY_FEATURE_NOT_SUPPORTED" => Some(Self::DeployFeatureNotSupported),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyJobRun {
    #[prost(string, tag = "1")]
    pub build: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub artifact_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub event_log_path: ::prost::alloc::string::String,
    #[prost(enumeration = "verify_job_run::FailureCause", tag = "4")]
    pub failure_cause: i32,
    #[prost(string, tag = "5")]
    pub failure_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `VerifyJobRun`.
pub mod verify_job_run {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailureCause {
        Unspecified = 0,
        CloudBuildUnavailable = 1,
        ExecutionFailed = 2,
        DeadlineExceeded = 3,
        VerificationConfigNotFound = 4,
        CloudBuildRequestFailed = 5,
    }
    impl FailureCause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FailureCause::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                FailureCause::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                FailureCause::ExecutionFailed => "EXECUTION_FAILED",
                FailureCause::DeadlineExceeded => "DEADLINE_EXCEEDED",
                FailureCause::VerificationConfigNotFound => {
                    "VERIFICATION_CONFIG_NOT_FOUND"
                }
                FailureCause::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                "VERIFICATION_CONFIG_NOT_FOUND" => Some(Self::VerificationConfigNotFound),
                "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredeployJobRun {
    #[prost(string, tag = "1")]
    pub build: ::prost::alloc::string::String,
    #[prost(enumeration = "predeploy_job_run::FailureCause", tag = "2")]
    pub failure_cause: i32,
    #[prost(string, tag = "3")]
    pub failure_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PredeployJobRun`.
pub mod predeploy_job_run {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailureCause {
        Unspecified = 0,
        CloudBuildUnavailable = 1,
        ExecutionFailed = 2,
        DeadlineExceeded = 3,
        CloudBuildRequestFailed = 4,
    }
    impl FailureCause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FailureCause::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                FailureCause::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                FailureCause::ExecutionFailed => "EXECUTION_FAILED",
                FailureCause::DeadlineExceeded => "DEADLINE_EXCEEDED",
                FailureCause::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostdeployJobRun {
    #[prost(string, tag = "1")]
    pub build: ::prost::alloc::string::String,
    #[prost(enumeration = "postdeploy_job_run::FailureCause", tag = "2")]
    pub failure_cause: i32,
    #[prost(string, tag = "3")]
    pub failure_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PostdeployJobRun`.
pub mod postdeploy_job_run {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailureCause {
        Unspecified = 0,
        CloudBuildUnavailable = 1,
        ExecutionFailed = 2,
        DeadlineExceeded = 3,
        CloudBuildRequestFailed = 4,
    }
    impl FailureCause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FailureCause::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                FailureCause::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                FailureCause::ExecutionFailed => "EXECUTION_FAILED",
                FailureCause::DeadlineExceeded => "DEADLINE_EXCEEDED",
                FailureCause::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChildRolloutJobRun {
    #[prost(string, tag = "1")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rollout_phase_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdvanceChildRolloutJobRun {
    #[prost(string, tag = "1")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rollout_phase_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobRunsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobRunsResponse {
    #[prost(message, repeated, tag = "1")]
    pub job_runs: ::prost::alloc::vec::Vec<JobRun>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRunRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateJobRunRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub override_deploy_policy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminateJobRunResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub supported_versions: ::prost::alloc::vec::Vec<SkaffoldVersion>,
    #[prost(string, tag = "3")]
    pub default_skaffold_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkaffoldVersion {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub maintenance_mode_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub support_expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub support_end_date: ::core::option::Option<super::super::super::r#type::Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Automation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub suspended: bool,
    #[prost(string, tag = "10")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub selector: ::core::option::Option<AutomationResourceSelector>,
    #[prost(message, repeated, tag = "14")]
    pub rules: ::prost::alloc::vec::Vec<AutomationRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationResourceSelector {
    #[prost(message, repeated, tag = "1")]
    pub targets: ::prost::alloc::vec::Vec<TargetAttribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRule {
    #[prost(oneof = "automation_rule::Rule", tags = "1, 2, 3")]
    pub rule: ::core::option::Option<automation_rule::Rule>,
}
/// Nested message and enum types in `AutomationRule`.
pub mod automation_rule {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Rule {
        #[prost(message, tag = "1")]
        PromoteReleaseRule(super::PromoteReleaseRule),
        #[prost(message, tag = "2")]
        AdvanceRolloutRule(super::AdvanceRolloutRule),
        #[prost(message, tag = "3")]
        RepairRolloutRule(super::RepairRolloutRule),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteReleaseRule {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub wait: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "7")]
    pub destination_target_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub condition: ::core::option::Option<AutomationRuleCondition>,
    #[prost(string, tag = "8")]
    pub destination_phase: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdvanceRolloutRule {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub source_phases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub wait: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "5")]
    pub condition: ::core::option::Option<AutomationRuleCondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepairRolloutRule {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub condition: ::core::option::Option<AutomationRuleCondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRuleCondition {
    #[prost(message, optional, tag = "1")]
    pub targets_present_condition: ::core::option::Option<TargetsPresentCondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAutomationRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub automation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub automation: ::core::option::Option<Automation>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAutomationRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub automation: ::core::option::Option<Automation>,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAutomationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutomationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutomationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub automations: ::prost::alloc::vec::Vec<Automation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAutomationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRun {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub automation_snapshot: ::core::option::Option<Automation>,
    #[prost(string, tag = "7")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(enumeration = "automation_run::State", tag = "8")]
    pub state: i32,
    #[prost(string, tag = "9")]
    pub state_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub policy_violation: ::core::option::Option<PolicyViolation>,
    #[prost(message, optional, tag = "11")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "12")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub automation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub wait_until_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "automation_run::Operation", tags = "13, 14, 17")]
    pub operation: ::core::option::Option<automation_run::Operation>,
}
/// Nested message and enum types in `AutomationRun`.
pub mod automation_run {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Succeeded = 1,
        Cancelled = 2,
        Failed = 3,
        InProgress = 4,
        Pending = 5,
        Aborted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Succeeded => "SUCCEEDED",
                State::Cancelled => "CANCELLED",
                State::Failed => "FAILED",
                State::InProgress => "IN_PROGRESS",
                State::Pending => "PENDING",
                State::Aborted => "ABORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "CANCELLED" => Some(Self::Cancelled),
                "FAILED" => Some(Self::Failed),
                "IN_PROGRESS" => Some(Self::InProgress),
                "PENDING" => Some(Self::Pending),
                "ABORTED" => Some(Self::Aborted),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "13")]
        PromoteReleaseOperation(super::PromoteReleaseOperation),
        #[prost(message, tag = "14")]
        AdvanceRolloutOperation(super::AdvanceRolloutOperation),
        #[prost(message, tag = "17")]
        RepairRolloutOperation(super::RepairRolloutOperation),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteReleaseOperation {
    #[prost(string, tag = "1")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub wait: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "3")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub phase: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdvanceRolloutOperation {
    #[prost(string, tag = "5")]
    pub source_phase: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub wait: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "3")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub destination_phase: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepairRolloutOperation {
    #[prost(string, tag = "1")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub repair_phases: ::prost::alloc::vec::Vec<RepairPhase>,
    #[prost(string, tag = "4")]
    pub phase_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub job_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepairPhase {
    #[prost(oneof = "repair_phase::RepairPhase", tags = "1, 2")]
    pub repair_phase: ::core::option::Option<repair_phase::RepairPhase>,
}
/// Nested message and enum types in `RepairPhase`.
pub mod repair_phase {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RepairPhase {
        #[prost(message, tag = "1")]
        Retry(super::RetryPhase),
        #[prost(message, tag = "2")]
        Rollback(super::RollbackAttempt),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryPhase {
    #[prost(int64, tag = "1")]
    pub total_attempts: i64,
    #[prost(enumeration = "BackoffMode", tag = "2")]
    pub backoff_mode: i32,
    #[prost(message, repeated, tag = "5")]
    pub attempts: ::prost::alloc::vec::Vec<RetryAttempt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryAttempt {
    #[prost(int64, tag = "1")]
    pub attempt: i64,
    #[prost(message, optional, tag = "2")]
    pub wait: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "RepairState", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub state_desc: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackAttempt {
    #[prost(string, tag = "1")]
    pub destination_phase: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rollout_id: ::prost::alloc::string::String,
    #[prost(enumeration = "RepairState", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "4")]
    pub state_desc: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutomationRunsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutomationRunsResponse {
    #[prost(message, repeated, tag = "1")]
    pub automation_runs: ::prost::alloc::vec::Vec<AutomationRun>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAutomationRunRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelAutomationRunRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelAutomationRunResponse {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SkaffoldSupportState {
    Unspecified = 0,
    Supported = 1,
    MaintenanceMode = 2,
    Unsupported = 3,
}
impl SkaffoldSupportState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SkaffoldSupportState::Unspecified => "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED",
            SkaffoldSupportState::Supported => "SKAFFOLD_SUPPORT_STATE_SUPPORTED",
            SkaffoldSupportState::MaintenanceMode => {
                "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE"
            }
            SkaffoldSupportState::Unsupported => "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "SKAFFOLD_SUPPORT_STATE_SUPPORTED" => Some(Self::Supported),
            "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE" => Some(Self::MaintenanceMode),
            "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED" => Some(Self::Unsupported),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackoffMode {
    Unspecified = 0,
    Linear = 1,
    Exponential = 2,
}
impl BackoffMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BackoffMode::Unspecified => "BACKOFF_MODE_UNSPECIFIED",
            BackoffMode::Linear => "BACKOFF_MODE_LINEAR",
            BackoffMode::Exponential => "BACKOFF_MODE_EXPONENTIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKOFF_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "BACKOFF_MODE_LINEAR" => Some(Self::Linear),
            "BACKOFF_MODE_EXPONENTIAL" => Some(Self::Exponential),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RepairState {
    Unspecified = 0,
    Succeeded = 1,
    Cancelled = 2,
    Failed = 3,
    InProgress = 4,
    Pending = 5,
    Aborted = 7,
}
impl RepairState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RepairState::Unspecified => "REPAIR_STATE_UNSPECIFIED",
            RepairState::Succeeded => "REPAIR_STATE_SUCCEEDED",
            RepairState::Cancelled => "REPAIR_STATE_CANCELLED",
            RepairState::Failed => "REPAIR_STATE_FAILED",
            RepairState::InProgress => "REPAIR_STATE_IN_PROGRESS",
            RepairState::Pending => "REPAIR_STATE_PENDING",
            RepairState::Aborted => "REPAIR_STATE_ABORTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPAIR_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "REPAIR_STATE_SUCCEEDED" => Some(Self::Succeeded),
            "REPAIR_STATE_CANCELLED" => Some(Self::Cancelled),
            "REPAIR_STATE_FAILED" => Some(Self::Failed),
            "REPAIR_STATE_IN_PROGRESS" => Some(Self::InProgress),
            "REPAIR_STATE_PENDING" => Some(Self::Pending),
            "REPAIR_STATE_ABORTED" => Some(Self::Aborted),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod cloud_deploy_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// CloudDeploy service creates and manages Continuous Delivery operations
    /// on Google Cloud Platform via Skaffold (https://skaffold.dev).
    #[derive(Debug, Clone)]
    pub struct CloudDeployClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CloudDeployClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CloudDeployClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CloudDeployClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists DeliveryPipelines in a given project and location.
        pub async fn list_delivery_pipelines(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeliveryPipelinesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeliveryPipelinesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListDeliveryPipelines",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "ListDeliveryPipelines",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single DeliveryPipeline.
        pub async fn get_delivery_pipeline(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeliveryPipelineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeliveryPipeline>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetDeliveryPipeline",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "GetDeliveryPipeline",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new DeliveryPipeline in a given project and location.
        pub async fn create_delivery_pipeline(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDeliveryPipelineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CreateDeliveryPipeline",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CreateDeliveryPipeline",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single DeliveryPipeline.
        pub async fn update_delivery_pipeline(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeliveryPipelineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/UpdateDeliveryPipeline",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "UpdateDeliveryPipeline",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single DeliveryPipeline.
        pub async fn delete_delivery_pipeline(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDeliveryPipelineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/DeleteDeliveryPipeline",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "DeleteDeliveryPipeline",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Targets in a given project and location.
        pub async fn list_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTargetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListTargets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "ListTargets"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a `Rollout` to roll back the specified target.
        pub async fn rollback_target(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RollbackTargetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/RollbackTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "RollbackTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Target.
        pub async fn get_target(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetRequest>,
        ) -> std::result::Result<tonic::Response<super::Target>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "GetTarget"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Target in a given project and location.
        pub async fn create_target(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CreateTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "CreateTarget"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Target.
        pub async fn update_target(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/UpdateTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "UpdateTarget"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Target.
        pub async fn delete_target(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/DeleteTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "DeleteTarget"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists CustomTargetTypes in a given project and location.
        pub async fn list_custom_target_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomTargetTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomTargetTypesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListCustomTargetTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "ListCustomTargetTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single CustomTargetType.
        pub async fn get_custom_target_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomTargetTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomTargetType>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetCustomTargetType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "GetCustomTargetType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new CustomTargetType in a given project and location.
        pub async fn create_custom_target_type(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomTargetTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CreateCustomTargetType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CreateCustomTargetType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single CustomTargetType.
        pub async fn update_custom_target_type(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCustomTargetTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/UpdateCustomTargetType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "UpdateCustomTargetType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single CustomTargetType.
        pub async fn delete_custom_target_type(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCustomTargetTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/DeleteCustomTargetType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "DeleteCustomTargetType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Releases in a given project and location.
        pub async fn list_releases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReleasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReleasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListReleases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "ListReleases"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Release.
        pub async fn get_release(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReleaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Release>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "GetRelease"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Release in a given project and location.
        pub async fn create_release(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReleaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CreateRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CreateRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Abandons a Release in the Delivery Pipeline.
        pub async fn abandon_release(
            &mut self,
            request: impl tonic::IntoRequest<super::AbandonReleaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AbandonReleaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/AbandonRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "AbandonRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new DeployPolicy in a given project and location.
        pub async fn create_deploy_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDeployPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CreateDeployPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CreateDeployPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single DeployPolicy.
        pub async fn update_deploy_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeployPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/UpdateDeployPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "UpdateDeployPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single DeployPolicy.
        pub async fn delete_deploy_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDeployPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/DeleteDeployPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "DeleteDeployPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DeployPolicies in a given project and location.
        pub async fn list_deploy_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeployPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeployPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListDeployPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "ListDeployPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single DeployPolicy.
        pub async fn get_deploy_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeployPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::DeployPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetDeployPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "GetDeployPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Approves a Rollout.
        pub async fn approve_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::ApproveRolloutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApproveRolloutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ApproveRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "ApproveRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Advances a Rollout in a given project and location.
        pub async fn advance_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::AdvanceRolloutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AdvanceRolloutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/AdvanceRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "AdvanceRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels a Rollout in a given project and location.
        pub async fn cancel_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelRolloutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CancelRolloutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CancelRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CancelRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Rollouts in a given project and location.
        pub async fn list_rollouts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRolloutsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRolloutsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListRollouts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "ListRollouts"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Rollout.
        pub async fn get_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRolloutRequest>,
        ) -> std::result::Result<tonic::Response<super::Rollout>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "GetRollout"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Rollout in a given project and location.
        pub async fn create_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRolloutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CreateRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CreateRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Ignores the specified Job in a Rollout.
        pub async fn ignore_job(
            &mut self,
            request: impl tonic::IntoRequest<super::IgnoreJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IgnoreJobResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/IgnoreJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "IgnoreJob"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retries the specified Job in a Rollout.
        pub async fn retry_job(
            &mut self,
            request: impl tonic::IntoRequest<super::RetryJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetryJobResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/RetryJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "RetryJob"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists JobRuns in a given project and location.
        pub async fn list_job_runs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobRunsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobRunsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListJobRuns",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "ListJobRuns"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single JobRun.
        pub async fn get_job_run(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRunRequest>,
        ) -> std::result::Result<tonic::Response<super::JobRun>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetJobRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "GetJobRun"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Terminates a Job Run in a given project and location.
        pub async fn terminate_job_run(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateJobRunRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminateJobRunResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/TerminateJobRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "TerminateJobRun",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the configuration for a location.
        pub async fn get_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::Config>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.deploy.v1.CloudDeploy", "GetConfig"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Automation in a given project and location.
        pub async fn create_automation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAutomationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CreateAutomation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CreateAutomation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Automation resource.
        pub async fn update_automation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAutomationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/UpdateAutomation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "UpdateAutomation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Automation resource.
        pub async fn delete_automation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAutomationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/DeleteAutomation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "DeleteAutomation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Automation.
        pub async fn get_automation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAutomationRequest>,
        ) -> std::result::Result<tonic::Response<super::Automation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetAutomation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "GetAutomation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Automations in a given project and location.
        pub async fn list_automations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutomationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutomationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListAutomations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "ListAutomations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single AutomationRun.
        pub async fn get_automation_run(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAutomationRunRequest>,
        ) -> std::result::Result<tonic::Response<super::AutomationRun>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/GetAutomationRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "GetAutomationRun",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists AutomationRuns in a given project and location.
        pub async fn list_automation_runs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutomationRunsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutomationRunsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/ListAutomationRuns",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "ListAutomationRuns",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels an AutomationRun. The `state` of the `AutomationRun` after
        /// cancelling is `CANCELLED`. `CancelAutomationRun` can be called on
        /// AutomationRun in the state `IN_PROGRESS` and `PENDING`; AutomationRun
        /// in a different state returns an `FAILED_PRECONDITION` error.
        pub async fn cancel_automation_run(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelAutomationRunRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CancelAutomationRunResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.deploy.v1.CloudDeploy/CancelAutomationRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.deploy.v1.CloudDeploy",
                        "CancelAutomationRun",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseRenderEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub release: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "5")]
    pub r#type: i32,
    #[prost(enumeration = "release::RenderState", tag = "3")]
    pub release_render_state: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetNotificationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "3")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetTypeNotificationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub custom_target_type_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub custom_target_type: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "3")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutNotificationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub release_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub release: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub rollout_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "5")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobRunNotificationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub job_run: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub release_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub release: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub rollout_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub rollout: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "7")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseNotificationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub release_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub release: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "3")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployPolicyNotificationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deploy_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub deploy_policy_uid: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "4")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRunEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub automation_run: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub automation_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub destination_target_id: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "7")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipelineNotificationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub delivery_pipeline: ::prost::alloc::string::String,
    #[prost(enumeration = "Type", tag = "3")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployPolicyEvaluationEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rule_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub pipeline_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub delivery_pipeline: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub target_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub target: ::prost::alloc::string::String,
    #[prost(enumeration = "deploy_policy::Invoker", tag = "8")]
    pub invoker: i32,
    #[prost(string, tag = "9")]
    pub deploy_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub deploy_policy_uid: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub allowed: bool,
    #[prost(enumeration = "deploy_policy_evaluation_event::PolicyVerdict", tag = "12")]
    pub verdict: i32,
    #[prost(
        enumeration = "deploy_policy_evaluation_event::PolicyVerdictOverride",
        repeated,
        tag = "13"
    )]
    pub overrides: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `DeployPolicyEvaluationEvent`.
pub mod deploy_policy_evaluation_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyVerdict {
        Unspecified = 0,
        AllowedByPolicy = 1,
        DeniedByPolicy = 2,
    }
    impl PolicyVerdict {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyVerdict::Unspecified => "POLICY_VERDICT_UNSPECIFIED",
                PolicyVerdict::AllowedByPolicy => "ALLOWED_BY_POLICY",
                PolicyVerdict::DeniedByPolicy => "DENIED_BY_POLICY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POLICY_VERDICT_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOWED_BY_POLICY" => Some(Self::AllowedByPolicy),
                "DENIED_BY_POLICY" => Some(Self::DeniedByPolicy),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyVerdictOverride {
        Unspecified = 0,
        PolicyOverridden = 1,
        PolicySuspended = 2,
    }
    impl PolicyVerdictOverride {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyVerdictOverride::Unspecified => {
                    "POLICY_VERDICT_OVERRIDE_UNSPECIFIED"
                }
                PolicyVerdictOverride::PolicyOverridden => "POLICY_OVERRIDDEN",
                PolicyVerdictOverride::PolicySuspended => "POLICY_SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POLICY_VERDICT_OVERRIDE_UNSPECIFIED" => Some(Self::Unspecified),
                "POLICY_OVERRIDDEN" => Some(Self::PolicyOverridden),
                "POLICY_SUSPENDED" => Some(Self::PolicySuspended),
                _ => None,
            }
        }
    }
}
