// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub provision_completion_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(btree_map = "string, message", tag = "4")]
    pub service_terms_map: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        project::ServiceTerms,
    >,
}
/// Nested message and enum types in `Project`.
pub mod project {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceTerms {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
        #[prost(enumeration = "service_terms::State", tag = "4")]
        pub state: i32,
        #[prost(message, optional, tag = "5")]
        pub accept_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "6")]
        pub decline_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `ServiceTerms`.
    pub mod service_terms {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            TermsAccepted = 1,
            TermsPending = 2,
            TermsDeclined = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::TermsAccepted => "TERMS_ACCEPTED",
                    State::TermsPending => "TERMS_PENDING",
                    State::TermsDeclined => "TERMS_DECLINED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TERMS_ACCEPTED" => Some(Self::TermsAccepted),
                    "TERMS_PENDING" => Some(Self::TermsPending),
                    "TERMS_DECLINED" => Some(Self::TermsDeclined),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SiteSearchEngine {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSite {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub provided_uri_pattern: ::prost::alloc::string::String,
    #[prost(enumeration = "target_site::Type", tag = "3")]
    pub r#type: i32,
    #[prost(bool, tag = "6")]
    pub exact_match: bool,
    #[prost(string, tag = "4")]
    pub generated_uri_pattern: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub root_domain_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub site_verification_info: ::core::option::Option<SiteVerificationInfo>,
    #[prost(enumeration = "target_site::IndexingStatus", tag = "8")]
    pub indexing_status: i32,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub failure_reason: ::core::option::Option<target_site::FailureReason>,
}
/// Nested message and enum types in `TargetSite`.
pub mod target_site {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FailureReason {
        #[prost(oneof = "failure_reason::Failure", tags = "1")]
        pub failure: ::core::option::Option<failure_reason::Failure>,
    }
    /// Nested message and enum types in `FailureReason`.
    pub mod failure_reason {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct QuotaFailure {
            #[prost(int64, tag = "1")]
            pub total_required_quota: i64,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Failure {
            #[prost(message, tag = "1")]
            QuotaFailure(QuotaFailure),
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Include = 1,
        Exclude = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Include => "INCLUDE",
                Type::Exclude => "EXCLUDE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUDE" => Some(Self::Include),
                "EXCLUDE" => Some(Self::Exclude),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IndexingStatus {
        Unspecified = 0,
        Pending = 1,
        Failed = 2,
        Succeeded = 3,
        Deleting = 4,
    }
    impl IndexingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IndexingStatus::Unspecified => "INDEXING_STATUS_UNSPECIFIED",
                IndexingStatus::Pending => "PENDING",
                IndexingStatus::Failed => "FAILED",
                IndexingStatus::Succeeded => "SUCCEEDED",
                IndexingStatus::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INDEXING_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SiteVerificationInfo {
    #[prost(enumeration = "site_verification_info::SiteVerificationState", tag = "1")]
    pub site_verification_state: i32,
    #[prost(message, optional, tag = "2")]
    pub verify_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `SiteVerificationInfo`.
pub mod site_verification_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SiteVerificationState {
        Unspecified = 0,
        Verified = 1,
        Unverified = 2,
        Exempted = 3,
    }
    impl SiteVerificationState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SiteVerificationState::Unspecified => {
                    "SITE_VERIFICATION_STATE_UNSPECIFIED"
                }
                SiteVerificationState::Verified => "VERIFIED",
                SiteVerificationState::Unverified => "UNVERIFIED",
                SiteVerificationState::Exempted => "EXEMPTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SITE_VERIFICATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "VERIFIED" => Some(Self::Verified),
                "UNVERIFIED" => Some(Self::Unverified),
                "EXEMPTED" => Some(Self::Exempted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSiteSearchEngineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTargetSiteRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub target_site: ::core::option::Option<TargetSite>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateTargetSiteMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSitesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateTargetSiteRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetSiteRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTargetSiteRequest {
    #[prost(message, optional, tag = "1")]
    pub target_site: ::core::option::Option<TargetSite>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateTargetSiteMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetSiteRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTargetSiteMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetSitesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetSitesResponse {
    #[prost(message, repeated, tag = "1")]
    pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSiteMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSitesResponse {
    #[prost(message, repeated, tag = "1")]
    pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableAdvancedSiteSearchRequest {
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableAdvancedSiteSearchResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableAdvancedSiteSearchMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableAdvancedSiteSearchRequest {
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableAdvancedSiteSearchResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableAdvancedSiteSearchMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecrawlUrisRequest {
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecrawlUrisResponse {
    #[prost(message, repeated, tag = "1")]
    pub failure_samples: ::prost::alloc::vec::Vec<recrawl_uris_response::FailureInfo>,
    #[prost(string, repeated, tag = "2")]
    pub failed_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RecrawlUrisResponse`.
pub mod recrawl_uris_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FailureInfo {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub failure_reasons: ::prost::alloc::vec::Vec<failure_info::FailureReason>,
    }
    /// Nested message and enum types in `FailureInfo`.
    pub mod failure_info {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FailureReason {
            #[prost(enumeration = "failure_reason::CorpusType", tag = "1")]
            pub corpus_type: i32,
            #[prost(string, tag = "2")]
            pub error_message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `FailureReason`.
        pub mod failure_reason {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum CorpusType {
                Unspecified = 0,
                Desktop = 1,
                Mobile = 2,
            }
            impl CorpusType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        CorpusType::Unspecified => "CORPUS_TYPE_UNSPECIFIED",
                        CorpusType::Desktop => "DESKTOP",
                        CorpusType::Mobile => "MOBILE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CORPUS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "DESKTOP" => Some(Self::Desktop),
                        "MOBILE" => Some(Self::Mobile),
                        _ => None,
                    }
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecrawlUrisMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag = "3")]
    pub invalid_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "4")]
    pub valid_uris_count: i32,
    #[prost(int32, tag = "5")]
    pub success_count: i32,
    #[prost(int32, tag = "6")]
    pub pending_count: i32,
    #[prost(int32, tag = "7")]
    pub quota_exceeded_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchVerifyTargetSitesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchVerifyTargetSitesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchVerifyTargetSitesMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchDomainVerificationStatusRequest {
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchDomainVerificationStatusResponse {
    #[prost(message, repeated, tag = "1")]
    pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod site_search_engine_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing site search related resources.
    #[derive(Debug, Clone)]
    pub struct SiteSearchEngineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SiteSearchEngineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SiteSearchEngineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SiteSearchEngineServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets the
        /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\].
        pub async fn get_site_search_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSiteSearchEngineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SiteSearchEngine>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/GetSiteSearchEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "GetSiteSearchEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn create_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTargetSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/CreateTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "CreateTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\] in a
        /// batch.
        pub async fn batch_create_target_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateTargetSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/BatchCreateTargetSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "BatchCreateTargetSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn get_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetSite>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/GetTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "GetTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn update_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTargetSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/UpdateTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "UpdateTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn delete_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/DeleteTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "DeleteTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\]s.
        pub async fn list_target_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTargetSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/ListTargetSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "ListTargetSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Upgrade from basic site search to advanced site search.
        pub async fn enable_advanced_site_search(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableAdvancedSiteSearchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/EnableAdvancedSiteSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "EnableAdvancedSiteSearch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Downgrade from advanced site search to basic site search.
        pub async fn disable_advanced_site_search(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableAdvancedSiteSearchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/DisableAdvancedSiteSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "DisableAdvancedSiteSearch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Request on-demand recrawl for a list of URIs.
        pub async fn recrawl_uris(
            &mut self,
            request: impl tonic::IntoRequest<super::RecrawlUrisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/RecrawlUris",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "RecrawlUris",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Verify target sites' ownership and validity.
        /// This API sends all the target sites under site search engine for
        /// verification.
        pub async fn batch_verify_target_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchVerifyTargetSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/BatchVerifyTargetSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "BatchVerifyTargetSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns list of target sites with its domain verification status.
        /// This method can only be called under data store with BASIC_SITE_SEARCH
        /// state at the moment.
        pub async fn fetch_domain_verification_status(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchDomainVerificationStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchDomainVerificationStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/FetchDomainVerificationStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "FetchDomainVerificationStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Interval {
    #[prost(oneof = "interval::Min", tags = "1, 2")]
    pub min: ::core::option::Option<interval::Min>,
    #[prost(oneof = "interval::Max", tags = "3, 4")]
    pub max: ::core::option::Option<interval::Max>,
}
/// Nested message and enum types in `Interval`.
pub mod interval {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Min {
        #[prost(double, tag = "1")]
        Minimum(f64),
        #[prost(double, tag = "2")]
        ExclusiveMinimum(f64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Max {
        #[prost(double, tag = "3")]
        Maximum(f64),
        #[prost(double, tag = "4")]
        ExclusiveMaximum(f64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAttribute {
    #[prost(string, repeated, tag = "1")]
    pub text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, repeated, tag = "2")]
    pub numbers: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_agent: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndustryVertical {
    Unspecified = 0,
    Generic = 1,
    Media = 2,
    HealthcareFhir = 7,
}
impl IndustryVertical {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IndustryVertical::Unspecified => "INDUSTRY_VERTICAL_UNSPECIFIED",
            IndustryVertical::Generic => "GENERIC",
            IndustryVertical::Media => "MEDIA",
            IndustryVertical::HealthcareFhir => "HEALTHCARE_FHIR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDUSTRY_VERTICAL_UNSPECIFIED" => Some(Self::Unspecified),
            "GENERIC" => Some(Self::Generic),
            "MEDIA" => Some(Self::Media),
            "HEALTHCARE_FHIR" => Some(Self::HealthcareFhir),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolutionType {
    Unspecified = 0,
    Recommendation = 1,
    Search = 2,
    Chat = 3,
    GenerativeChat = 4,
}
impl SolutionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SolutionType::Unspecified => "SOLUTION_TYPE_UNSPECIFIED",
            SolutionType::Recommendation => "SOLUTION_TYPE_RECOMMENDATION",
            SolutionType::Search => "SOLUTION_TYPE_SEARCH",
            SolutionType::Chat => "SOLUTION_TYPE_CHAT",
            SolutionType::GenerativeChat => "SOLUTION_TYPE_GENERATIVE_CHAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOLUTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SOLUTION_TYPE_RECOMMENDATION" => Some(Self::Recommendation),
            "SOLUTION_TYPE_SEARCH" => Some(Self::Search),
            "SOLUTION_TYPE_CHAT" => Some(Self::Chat),
            "SOLUTION_TYPE_GENERATIVE_CHAT" => Some(Self::GenerativeChat),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchUseCase {
    Unspecified = 0,
    Search = 1,
    Browse = 2,
}
impl SearchUseCase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SearchUseCase::Unspecified => "SEARCH_USE_CASE_UNSPECIFIED",
            SearchUseCase::Search => "SEARCH_USE_CASE_SEARCH",
            SearchUseCase::Browse => "SEARCH_USE_CASE_BROWSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEARCH_USE_CASE_UNSPECIFIED" => Some(Self::Unspecified),
            "SEARCH_USE_CASE_SEARCH" => Some(Self::Search),
            "SEARCH_USE_CASE_BROWSE" => Some(Self::Browse),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchTier {
    Unspecified = 0,
    Standard = 1,
    Enterprise = 2,
}
impl SearchTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SearchTier::Unspecified => "SEARCH_TIER_UNSPECIFIED",
            SearchTier::Standard => "SEARCH_TIER_STANDARD",
            SearchTier::Enterprise => "SEARCH_TIER_ENTERPRISE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEARCH_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "SEARCH_TIER_STANDARD" => Some(Self::Standard),
            "SEARCH_TIER_ENTERPRISE" => Some(Self::Enterprise),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchAddOn {
    Unspecified = 0,
    Llm = 1,
}
impl SearchAddOn {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SearchAddOn::Unspecified => "SEARCH_ADD_ON_UNSPECIFIED",
            SearchAddOn::Llm => "SEARCH_ADD_ON_LLM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEARCH_ADD_ON_UNSPECIFIED" => Some(Self::Unspecified),
            "SEARCH_ADD_ON_LLM" => Some(Self::Llm),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserEvent {
    #[prost(string, tag = "1")]
    pub event_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub engine: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub data_store: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub user_info: ::core::option::Option<UserInfo>,
    #[prost(bool, tag = "5")]
    pub direct_user_request: bool,
    #[prost(string, tag = "6")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub page_info: ::core::option::Option<PageInfo>,
    #[prost(string, tag = "8")]
    pub attribution_token: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "10")]
    pub documents: ::prost::alloc::vec::Vec<DocumentInfo>,
    #[prost(message, optional, tag = "11")]
    pub panel: ::core::option::Option<PanelInfo>,
    #[prost(message, optional, tag = "12")]
    pub search_info: ::core::option::Option<SearchInfo>,
    #[prost(message, optional, tag = "13")]
    pub completion_info: ::core::option::Option<CompletionInfo>,
    #[prost(message, optional, tag = "14")]
    pub transaction_info: ::core::option::Option<TransactionInfo>,
    #[prost(string, repeated, tag = "15")]
    pub tag_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "16")]
    pub promotion_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(btree_map = "string, message", tag = "17")]
    pub attributes: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        CustomAttribute,
    >,
    #[prost(message, optional, tag = "18")]
    pub media_info: ::core::option::Option<MediaInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageInfo {
    #[prost(string, tag = "1")]
    pub pageview_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub page_category: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub referrer_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchInfo {
    #[prost(string, tag = "1")]
    pub search_query: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "3")]
    pub offset: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionInfo {
    #[prost(string, tag = "1")]
    pub selected_suggestion: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub selected_position: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInfo {
    #[prost(float, optional, tag = "1")]
    pub value: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub currency: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "4")]
    pub tax: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub cost: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub discount_value: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentInfo {
    #[prost(int32, optional, tag = "3")]
    pub quantity: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "4")]
    pub promotion_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "document_info::DocumentDescriptor", tags = "1, 2, 6")]
    pub document_descriptor: ::core::option::Option<document_info::DocumentDescriptor>,
}
/// Nested message and enum types in `DocumentInfo`.
pub mod document_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DocumentDescriptor {
        #[prost(string, tag = "1")]
        Id(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        #[prost(string, tag = "6")]
        Uri(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PanelInfo {
    #[prost(string, tag = "2")]
    pub panel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "4")]
    pub panel_position: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub total_panels: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaInfo {
    #[prost(message, optional, tag = "1")]
    pub media_progress_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(float, optional, tag = "2")]
    pub media_progress_percentage: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Answer {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "answer::State", tag = "2")]
    pub state: i32,
    #[prost(string, tag = "3")]
    pub answer_text: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub citations: ::prost::alloc::vec::Vec<answer::Citation>,
    #[prost(message, repeated, tag = "5")]
    pub references: ::prost::alloc::vec::Vec<answer::Reference>,
    #[prost(string, repeated, tag = "6")]
    pub related_questions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "7")]
    pub steps: ::prost::alloc::vec::Vec<answer::Step>,
    #[prost(message, optional, tag = "10")]
    pub query_understanding_info: ::core::option::Option<answer::QueryUnderstandingInfo>,
    #[prost(enumeration = "answer::AnswerSkippedReason", repeated, tag = "11")]
    pub answer_skipped_reasons: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Answer`.
pub mod answer {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Citation {
        #[prost(int64, tag = "1")]
        pub start_index: i64,
        #[prost(int64, tag = "2")]
        pub end_index: i64,
        #[prost(message, repeated, tag = "3")]
        pub sources: ::prost::alloc::vec::Vec<CitationSource>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CitationSource {
        #[prost(string, tag = "1")]
        pub reference_id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        #[prost(oneof = "reference::Content", tags = "1, 2")]
        pub content: ::core::option::Option<reference::Content>,
    }
    /// Nested message and enum types in `Reference`.
    pub mod reference {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UnstructuredDocumentInfo {
            #[prost(string, tag = "1")]
            pub document: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub uri: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub title: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "4")]
            pub chunk_contents: ::prost::alloc::vec::Vec<
                unstructured_document_info::ChunkContent,
            >,
            #[prost(message, optional, tag = "5")]
            pub struct_data: ::core::option::Option<::prost_types::Struct>,
        }
        /// Nested message and enum types in `UnstructuredDocumentInfo`.
        pub mod unstructured_document_info {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ChunkContent {
                #[prost(string, tag = "1")]
                pub content: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub page_identifier: ::prost::alloc::string::String,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ChunkInfo {
            #[prost(string, tag = "1")]
            pub chunk: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub content: ::prost::alloc::string::String,
            #[prost(float, optional, tag = "3")]
            pub relevance_score: ::core::option::Option<f32>,
            #[prost(message, optional, tag = "4")]
            pub document_metadata: ::core::option::Option<chunk_info::DocumentMetadata>,
        }
        /// Nested message and enum types in `ChunkInfo`.
        pub mod chunk_info {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct DocumentMetadata {
                #[prost(string, tag = "1")]
                pub document: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub uri: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub title: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub page_identifier: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub struct_data: ::core::option::Option<::prost_types::Struct>,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Content {
            #[prost(message, tag = "1")]
            UnstructuredDocumentInfo(UnstructuredDocumentInfo),
            #[prost(message, tag = "2")]
            ChunkInfo(ChunkInfo),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Step {
        #[prost(enumeration = "step::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub thought: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub actions: ::prost::alloc::vec::Vec<step::Action>,
    }
    /// Nested message and enum types in `Step`.
    pub mod step {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Action {
            #[prost(message, optional, tag = "3")]
            pub observation: ::core::option::Option<action::Observation>,
            #[prost(oneof = "action::Action", tags = "2")]
            pub action: ::core::option::Option<action::Action>,
        }
        /// Nested message and enum types in `Action`.
        pub mod action {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SearchAction {
                #[prost(string, tag = "1")]
                pub query: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Observation {
                #[prost(message, repeated, tag = "2")]
                pub search_results: ::prost::alloc::vec::Vec<observation::SearchResult>,
            }
            /// Nested message and enum types in `Observation`.
            pub mod observation {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct SearchResult {
                    #[prost(string, tag = "1")]
                    pub document: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub uri: ::prost::alloc::string::String,
                    #[prost(string, tag = "3")]
                    pub title: ::prost::alloc::string::String,
                    #[prost(message, repeated, tag = "4")]
                    pub snippet_info: ::prost::alloc::vec::Vec<
                        search_result::SnippetInfo,
                    >,
                    #[prost(message, repeated, tag = "5")]
                    pub chunk_info: ::prost::alloc::vec::Vec<search_result::ChunkInfo>,
                    #[prost(message, optional, tag = "6")]
                    pub struct_data: ::core::option::Option<::prost_types::Struct>,
                }
                /// Nested message and enum types in `SearchResult`.
                pub mod search_result {
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct SnippetInfo {
                        #[prost(string, tag = "1")]
                        pub snippet: ::prost::alloc::string::String,
                        #[prost(string, tag = "2")]
                        pub snippet_status: ::prost::alloc::string::String,
                    }
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct ChunkInfo {
                        #[prost(string, tag = "1")]
                        pub chunk: ::prost::alloc::string::String,
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                        #[prost(float, optional, tag = "3")]
                        pub relevance_score: ::core::option::Option<f32>,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Action {
                #[prost(message, tag = "2")]
                SearchAction(SearchAction),
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            InProgress = 1,
            Failed = 2,
            Succeeded = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::InProgress => "IN_PROGRESS",
                    State::Failed => "FAILED",
                    State::Succeeded => "SUCCEEDED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "IN_PROGRESS" => Some(Self::InProgress),
                    "FAILED" => Some(Self::Failed),
                    "SUCCEEDED" => Some(Self::Succeeded),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryUnderstandingInfo {
        #[prost(message, repeated, tag = "1")]
        pub query_classification_info: ::prost::alloc::vec::Vec<
            query_understanding_info::QueryClassificationInfo,
        >,
    }
    /// Nested message and enum types in `QueryUnderstandingInfo`.
    pub mod query_understanding_info {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct QueryClassificationInfo {
            #[prost(enumeration = "query_classification_info::Type", tag = "1")]
            pub r#type: i32,
            #[prost(bool, tag = "2")]
            pub positive: bool,
        }
        /// Nested message and enum types in `QueryClassificationInfo`.
        pub mod query_classification_info {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Unspecified = 0,
                AdversarialQuery = 1,
                NonAnswerSeekingQuery = 2,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Type::Unspecified => "TYPE_UNSPECIFIED",
                        Type::AdversarialQuery => "ADVERSARIAL_QUERY",
                        Type::NonAnswerSeekingQuery => "NON_ANSWER_SEEKING_QUERY",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "ADVERSARIAL_QUERY" => Some(Self::AdversarialQuery),
                        "NON_ANSWER_SEEKING_QUERY" => Some(Self::NonAnswerSeekingQuery),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        InProgress = 1,
        Failed = 2,
        Succeeded = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::InProgress => "IN_PROGRESS",
                State::Failed => "FAILED",
                State::Succeeded => "SUCCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AnswerSkippedReason {
        Unspecified = 0,
        AdversarialQueryIgnored = 1,
        NonAnswerSeekingQueryIgnored = 2,
        OutOfDomainQueryIgnored = 3,
        PotentialPolicyViolation = 4,
        NoRelevantContent = 5,
    }
    impl AnswerSkippedReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AnswerSkippedReason::Unspecified => "ANSWER_SKIPPED_REASON_UNSPECIFIED",
                AnswerSkippedReason::AdversarialQueryIgnored => {
                    "ADVERSARIAL_QUERY_IGNORED"
                }
                AnswerSkippedReason::NonAnswerSeekingQueryIgnored => {
                    "NON_ANSWER_SEEKING_QUERY_IGNORED"
                }
                AnswerSkippedReason::OutOfDomainQueryIgnored => {
                    "OUT_OF_DOMAIN_QUERY_IGNORED"
                }
                AnswerSkippedReason::PotentialPolicyViolation => {
                    "POTENTIAL_POLICY_VIOLATION"
                }
                AnswerSkippedReason::NoRelevantContent => "NO_RELEVANT_CONTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANSWER_SKIPPED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "ADVERSARIAL_QUERY_IGNORED" => Some(Self::AdversarialQueryIgnored),
                "NON_ANSWER_SEEKING_QUERY_IGNORED" => {
                    Some(Self::NonAnswerSeekingQueryIgnored)
                }
                "OUT_OF_DOMAIN_QUERY_IGNORED" => Some(Self::OutOfDomainQueryIgnored),
                "POTENTIAL_POLICY_VIOLATION" => Some(Self::PotentialPolicyViolation),
                "NO_RELEVANT_CONTENT" => Some(Self::NoRelevantContent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chunk {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    #[prost(double, optional, tag = "8")]
    pub relevance_score: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "5")]
    pub document_metadata: ::core::option::Option<chunk::DocumentMetadata>,
    #[prost(message, optional, tag = "4")]
    pub derived_struct_data: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, optional, tag = "6")]
    pub page_span: ::core::option::Option<chunk::PageSpan>,
    #[prost(message, optional, tag = "7")]
    pub chunk_metadata: ::core::option::Option<chunk::ChunkMetadata>,
}
/// Nested message and enum types in `Chunk`.
pub mod chunk {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DocumentMetadata {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub struct_data: ::core::option::Option<::prost_types::Struct>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PageSpan {
        #[prost(int32, tag = "1")]
        pub page_start: i32,
        #[prost(int32, tag = "2")]
        pub page_end: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChunkMetadata {
        #[prost(message, repeated, tag = "1")]
        pub previous_chunks: ::prost::alloc::vec::Vec<super::Chunk>,
        #[prost(message, repeated, tag = "2")]
        pub next_chunks: ::prost::alloc::vec::Vec<super::Chunk>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub schema_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub content: ::core::option::Option<document::Content>,
    #[prost(string, tag = "7")]
    pub parent_document_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub derived_struct_data: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, optional, tag = "13")]
    pub index_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "document::Data", tags = "4, 5")]
    pub data: ::core::option::Option<document::Data>,
}
/// Nested message and enum types in `Document`.
pub mod document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Content {
        #[prost(string, tag = "1")]
        pub mime_type: ::prost::alloc::string::String,
        #[prost(oneof = "content::Content", tags = "2, 3")]
        pub content: ::core::option::Option<content::Content>,
    }
    /// Nested message and enum types in `Content`.
    pub mod content {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Content {
            #[prost(bytes, tag = "2")]
            RawBytes(::prost::bytes::Bytes),
            #[prost(string, tag = "3")]
            Uri(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "4")]
        StructData(::prost_types::Struct),
        #[prost(string, tag = "5")]
        JsonData(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRequest {
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub branch: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub query: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "19")]
    pub image_query: ::core::option::Option<search_request::ImageQuery>,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub offset: i32,
    #[prost(message, repeated, tag = "32")]
    pub data_store_specs: ::prost::alloc::vec::Vec<search_request::DataStoreSpec>,
    #[prost(string, tag = "7")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "29")]
    pub canonical_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "21")]
    pub user_info: ::core::option::Option<UserInfo>,
    #[prost(string, tag = "35")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub facet_specs: ::prost::alloc::vec::Vec<search_request::FacetSpec>,
    #[prost(message, optional, tag = "10")]
    pub boost_spec: ::core::option::Option<search_request::BoostSpec>,
    #[prost(btree_map = "string, message", tag = "11")]
    pub params: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
    #[prost(message, optional, tag = "13")]
    pub query_expansion_spec: ::core::option::Option<search_request::QueryExpansionSpec>,
    #[prost(message, optional, tag = "14")]
    pub spell_correction_spec: ::core::option::Option<
        search_request::SpellCorrectionSpec,
    >,
    #[prost(string, tag = "15")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "24")]
    pub content_search_spec: ::core::option::Option<search_request::ContentSearchSpec>,
    #[prost(bool, tag = "20")]
    pub safe_search: bool,
    #[prost(btree_map = "string, string", tag = "22")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "31")]
    pub search_as_you_type_spec: ::core::option::Option<
        search_request::SearchAsYouTypeSpec,
    >,
    #[prost(string, tag = "41")]
    pub session: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "42")]
    pub session_spec: ::core::option::Option<search_request::SessionSpec>,
}
/// Nested message and enum types in `SearchRequest`.
pub mod search_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageQuery {
        #[prost(oneof = "image_query::Image", tags = "1")]
        pub image: ::core::option::Option<image_query::Image>,
    }
    /// Nested message and enum types in `ImageQuery`.
    pub mod image_query {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Image {
            #[prost(string, tag = "1")]
            ImageBytes(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataStoreSpec {
        #[prost(string, tag = "1")]
        pub data_store: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FacetSpec {
        #[prost(message, optional, tag = "1")]
        pub facet_key: ::core::option::Option<facet_spec::FacetKey>,
        #[prost(int32, tag = "2")]
        pub limit: i32,
        #[prost(string, repeated, tag = "3")]
        pub excluded_filter_keys: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(bool, tag = "4")]
        pub enable_dynamic_position: bool,
    }
    /// Nested message and enum types in `FacetSpec`.
    pub mod facet_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FacetKey {
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "2")]
            pub intervals: ::prost::alloc::vec::Vec<super::super::Interval>,
            #[prost(string, repeated, tag = "3")]
            pub restricted_values: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            #[prost(string, repeated, tag = "4")]
            pub prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, repeated, tag = "5")]
            pub contains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, tag = "6")]
            pub case_insensitive: bool,
            #[prost(string, tag = "7")]
            pub order_by: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoostSpec {
        #[prost(message, repeated, tag = "1")]
        pub condition_boost_specs: ::prost::alloc::vec::Vec<
            boost_spec::ConditionBoostSpec,
        >,
    }
    /// Nested message and enum types in `BoostSpec`.
    pub mod boost_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ConditionBoostSpec {
            #[prost(string, tag = "1")]
            pub condition: ::prost::alloc::string::String,
            #[prost(float, tag = "2")]
            pub boost: f32,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QueryExpansionSpec {
        #[prost(enumeration = "query_expansion_spec::Condition", tag = "1")]
        pub condition: i32,
        #[prost(bool, tag = "2")]
        pub pin_unexpanded_results: bool,
    }
    /// Nested message and enum types in `QueryExpansionSpec`.
    pub mod query_expansion_spec {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Condition {
            Unspecified = 0,
            Disabled = 1,
            Auto = 2,
        }
        impl Condition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Condition::Unspecified => "CONDITION_UNSPECIFIED",
                    Condition::Disabled => "DISABLED",
                    Condition::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                    "DISABLED" => Some(Self::Disabled),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SpellCorrectionSpec {
        #[prost(enumeration = "spell_correction_spec::Mode", tag = "1")]
        pub mode: i32,
    }
    /// Nested message and enum types in `SpellCorrectionSpec`.
    pub mod spell_correction_spec {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            SuggestionOnly = 1,
            Auto = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Mode::Unspecified => "MODE_UNSPECIFIED",
                    Mode::SuggestionOnly => "SUGGESTION_ONLY",
                    Mode::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SUGGESTION_ONLY" => Some(Self::SuggestionOnly),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContentSearchSpec {
        #[prost(message, optional, tag = "1")]
        pub snippet_spec: ::core::option::Option<content_search_spec::SnippetSpec>,
        #[prost(message, optional, tag = "2")]
        pub summary_spec: ::core::option::Option<content_search_spec::SummarySpec>,
        #[prost(message, optional, tag = "3")]
        pub extractive_content_spec: ::core::option::Option<
            content_search_spec::ExtractiveContentSpec,
        >,
        #[prost(enumeration = "content_search_spec::SearchResultMode", tag = "4")]
        pub search_result_mode: i32,
        #[prost(message, optional, tag = "5")]
        pub chunk_spec: ::core::option::Option<content_search_spec::ChunkSpec>,
    }
    /// Nested message and enum types in `ContentSearchSpec`.
    pub mod content_search_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct SnippetSpec {
            #[deprecated]
            #[prost(int32, tag = "1")]
            pub max_snippet_count: i32,
            #[deprecated]
            #[prost(bool, tag = "2")]
            pub reference_only: bool,
            #[prost(bool, tag = "3")]
            pub return_snippet: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SummarySpec {
            #[prost(int32, tag = "1")]
            pub summary_result_count: i32,
            #[prost(bool, tag = "2")]
            pub include_citations: bool,
            #[prost(bool, tag = "3")]
            pub ignore_adversarial_query: bool,
            #[prost(bool, tag = "4")]
            pub ignore_non_summary_seeking_query: bool,
            #[prost(message, optional, tag = "5")]
            pub model_prompt_spec: ::core::option::Option<summary_spec::ModelPromptSpec>,
            #[prost(string, tag = "6")]
            pub language_code: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "7")]
            pub model_spec: ::core::option::Option<summary_spec::ModelSpec>,
            #[prost(bool, tag = "8")]
            pub use_semantic_chunks: bool,
        }
        /// Nested message and enum types in `SummarySpec`.
        pub mod summary_spec {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ModelPromptSpec {
                #[prost(string, tag = "1")]
                pub preamble: ::prost::alloc::string::String,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ModelSpec {
                #[prost(string, tag = "1")]
                pub version: ::prost::alloc::string::String,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ExtractiveContentSpec {
            #[prost(int32, tag = "1")]
            pub max_extractive_answer_count: i32,
            #[prost(int32, tag = "2")]
            pub max_extractive_segment_count: i32,
            #[prost(bool, tag = "3")]
            pub return_extractive_segment_score: bool,
            #[prost(int32, tag = "4")]
            pub num_previous_segments: i32,
            #[prost(int32, tag = "5")]
            pub num_next_segments: i32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ChunkSpec {
            #[prost(int32, tag = "1")]
            pub num_previous_chunks: i32,
            #[prost(int32, tag = "2")]
            pub num_next_chunks: i32,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SearchResultMode {
            Unspecified = 0,
            Documents = 1,
            Chunks = 2,
        }
        impl SearchResultMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    SearchResultMode::Unspecified => "SEARCH_RESULT_MODE_UNSPECIFIED",
                    SearchResultMode::Documents => "DOCUMENTS",
                    SearchResultMode::Chunks => "CHUNKS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SEARCH_RESULT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "DOCUMENTS" => Some(Self::Documents),
                    "CHUNKS" => Some(Self::Chunks),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SearchAsYouTypeSpec {
        #[prost(enumeration = "search_as_you_type_spec::Condition", tag = "1")]
        pub condition: i32,
    }
    /// Nested message and enum types in `SearchAsYouTypeSpec`.
    pub mod search_as_you_type_spec {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Condition {
            Unspecified = 0,
            Disabled = 1,
            Enabled = 2,
        }
        impl Condition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Condition::Unspecified => "CONDITION_UNSPECIFIED",
                    Condition::Disabled => "DISABLED",
                    Condition::Enabled => "ENABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                    "DISABLED" => Some(Self::Disabled),
                    "ENABLED" => Some(Self::Enabled),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionSpec {
        #[prost(string, tag = "1")]
        pub query_id: ::prost::alloc::string::String,
        #[prost(int32, optional, tag = "2")]
        pub search_result_persistence_count: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<search_response::SearchResult>,
    #[prost(message, repeated, tag = "2")]
    pub facets: ::prost::alloc::vec::Vec<search_response::Facet>,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
    #[prost(string, tag = "4")]
    pub attribution_token: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub redirect_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub corrected_query: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub summary: ::core::option::Option<search_response::Summary>,
    #[prost(message, optional, tag = "14")]
    pub query_expansion_info: ::core::option::Option<
        search_response::QueryExpansionInfo,
    >,
    #[prost(message, optional, tag = "19")]
    pub session_info: ::core::option::Option<search_response::SessionInfo>,
}
/// Nested message and enum types in `SearchResponse`.
pub mod search_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SearchResult {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub document: ::core::option::Option<super::Document>,
        #[prost(message, optional, tag = "18")]
        pub chunk: ::core::option::Option<super::Chunk>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Facet {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub values: ::prost::alloc::vec::Vec<facet::FacetValue>,
        #[prost(bool, tag = "3")]
        pub dynamic_facet: bool,
    }
    /// Nested message and enum types in `Facet`.
    pub mod facet {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FacetValue {
            #[prost(int64, tag = "3")]
            pub count: i64,
            #[prost(oneof = "facet_value::FacetValue", tags = "1, 2")]
            pub facet_value: ::core::option::Option<facet_value::FacetValue>,
        }
        /// Nested message and enum types in `FacetValue`.
        pub mod facet_value {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum FacetValue {
                #[prost(string, tag = "1")]
                Value(::prost::alloc::string::String),
                #[prost(message, tag = "2")]
                Interval(super::super::super::Interval),
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Summary {
        #[prost(string, tag = "1")]
        pub summary_text: ::prost::alloc::string::String,
        #[prost(enumeration = "summary::SummarySkippedReason", repeated, tag = "2")]
        pub summary_skipped_reasons: ::prost::alloc::vec::Vec<i32>,
        #[prost(message, optional, tag = "3")]
        pub safety_attributes: ::core::option::Option<summary::SafetyAttributes>,
        #[prost(message, optional, tag = "4")]
        pub summary_with_metadata: ::core::option::Option<summary::SummaryWithMetadata>,
    }
    /// Nested message and enum types in `Summary`.
    pub mod summary {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SafetyAttributes {
            #[prost(string, repeated, tag = "1")]
            pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(float, repeated, tag = "2")]
            pub scores: ::prost::alloc::vec::Vec<f32>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CitationMetadata {
            #[prost(message, repeated, tag = "1")]
            pub citations: ::prost::alloc::vec::Vec<Citation>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Citation {
            #[prost(int64, tag = "1")]
            pub start_index: i64,
            #[prost(int64, tag = "2")]
            pub end_index: i64,
            #[prost(message, repeated, tag = "3")]
            pub sources: ::prost::alloc::vec::Vec<CitationSource>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct CitationSource {
            #[prost(int64, tag = "4")]
            pub reference_index: i64,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Reference {
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub document: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub uri: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "4")]
            pub chunk_contents: ::prost::alloc::vec::Vec<reference::ChunkContent>,
        }
        /// Nested message and enum types in `Reference`.
        pub mod reference {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ChunkContent {
                #[prost(string, tag = "1")]
                pub content: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub page_identifier: ::prost::alloc::string::String,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SummaryWithMetadata {
            #[prost(string, tag = "1")]
            pub summary: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub citation_metadata: ::core::option::Option<CitationMetadata>,
            #[prost(message, repeated, tag = "3")]
            pub references: ::prost::alloc::vec::Vec<Reference>,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SummarySkippedReason {
            Unspecified = 0,
            AdversarialQueryIgnored = 1,
            NonSummarySeekingQueryIgnored = 2,
            OutOfDomainQueryIgnored = 3,
            PotentialPolicyViolation = 4,
            LlmAddonNotEnabled = 5,
        }
        impl SummarySkippedReason {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    SummarySkippedReason::Unspecified => {
                        "SUMMARY_SKIPPED_REASON_UNSPECIFIED"
                    }
                    SummarySkippedReason::AdversarialQueryIgnored => {
                        "ADVERSARIAL_QUERY_IGNORED"
                    }
                    SummarySkippedReason::NonSummarySeekingQueryIgnored => {
                        "NON_SUMMARY_SEEKING_QUERY_IGNORED"
                    }
                    SummarySkippedReason::OutOfDomainQueryIgnored => {
                        "OUT_OF_DOMAIN_QUERY_IGNORED"
                    }
                    SummarySkippedReason::PotentialPolicyViolation => {
                        "POTENTIAL_POLICY_VIOLATION"
                    }
                    SummarySkippedReason::LlmAddonNotEnabled => "LLM_ADDON_NOT_ENABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUMMARY_SKIPPED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                    "ADVERSARIAL_QUERY_IGNORED" => Some(Self::AdversarialQueryIgnored),
                    "NON_SUMMARY_SEEKING_QUERY_IGNORED" => {
                        Some(Self::NonSummarySeekingQueryIgnored)
                    }
                    "OUT_OF_DOMAIN_QUERY_IGNORED" => Some(Self::OutOfDomainQueryIgnored),
                    "POTENTIAL_POLICY_VIOLATION" => Some(Self::PotentialPolicyViolation),
                    "LLM_ADDON_NOT_ENABLED" => Some(Self::LlmAddonNotEnabled),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QueryExpansionInfo {
        #[prost(bool, tag = "1")]
        pub expanded_query: bool,
        #[prost(int64, tag = "2")]
        pub pinned_result_count: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionInfo {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub query_id: ::prost::alloc::string::String,
    }
}
/// Generated client implementations.
pub mod search_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for search.
    #[derive(Debug, Clone)]
    pub struct SearchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SearchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SearchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SearchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Performs a search.
        pub async fn search(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SearchService/Search",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SearchService",
                        "Search",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "conversation::State", tag = "2")]
    pub state: i32,
    #[prost(string, tag = "3")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub messages: ::prost::alloc::vec::Vec<ConversationMessage>,
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Conversation`.
pub mod conversation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        InProgress = 1,
        Completed = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::InProgress => "IN_PROGRESS",
                State::Completed => "COMPLETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reply {
    #[prost(message, optional, tag = "3")]
    pub summary: ::core::option::Option<search_response::Summary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationContext {
    #[prost(string, repeated, tag = "1")]
    pub context_documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub active_document: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInput {
    #[prost(string, tag = "1")]
    pub input: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub context: ::core::option::Option<ConversationContext>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationMessage {
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "conversation_message::Message", tags = "1, 2")]
    pub message: ::core::option::Option<conversation_message::Message>,
}
/// Nested message and enum types in `ConversationMessage`.
pub mod conversation_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        UserInput(super::TextInput),
        #[prost(message, tag = "2")]
        Reply(super::Reply),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "session::State", tag = "2")]
    pub state: i32,
    #[prost(string, tag = "3")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub turns: ::prost::alloc::vec::Vec<session::Turn>,
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Session`.
pub mod session {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Turn {
        #[prost(message, optional, tag = "1")]
        pub query: ::core::option::Option<super::Query>,
        #[prost(string, tag = "2")]
        pub answer: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        InProgress = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::InProgress => "IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    #[prost(oneof = "query::Content", tags = "2")]
    pub content: ::core::option::Option<query::Content>,
}
/// Nested message and enum types in `Query`.
pub mod query {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(string, tag = "2")]
        Text(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConverseConversationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<TextInput>,
    #[prost(string, tag = "3")]
    pub serving_config: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub conversation: ::core::option::Option<Conversation>,
    #[prost(bool, tag = "6")]
    pub safe_search: bool,
    #[prost(btree_map = "string, string", tag = "7")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "8")]
    pub summary_spec: ::core::option::Option<
        search_request::content_search_spec::SummarySpec,
    >,
    #[prost(string, tag = "9")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub boost_spec: ::core::option::Option<search_request::BoostSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConverseConversationResponse {
    #[prost(message, optional, tag = "1")]
    pub reply: ::core::option::Option<Reply>,
    #[prost(message, optional, tag = "2")]
    pub conversation: ::core::option::Option<Conversation>,
    #[prost(message, repeated, tag = "3")]
    pub search_results: ::prost::alloc::vec::Vec<search_response::SearchResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub conversation: ::core::option::Option<Conversation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversationRequest {
    #[prost(message, optional, tag = "1")]
    pub conversation: ::core::option::Option<Conversation>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConversationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQueryRequest {
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<Query>,
    #[prost(string, tag = "3")]
    pub session: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub safety_spec: ::core::option::Option<answer_query_request::SafetySpec>,
    #[prost(message, optional, tag = "5")]
    pub related_questions_spec: ::core::option::Option<
        answer_query_request::RelatedQuestionsSpec,
    >,
    #[prost(message, optional, tag = "7")]
    pub answer_generation_spec: ::core::option::Option<
        answer_query_request::AnswerGenerationSpec,
    >,
    #[prost(message, optional, tag = "8")]
    pub search_spec: ::core::option::Option<answer_query_request::SearchSpec>,
    #[prost(message, optional, tag = "9")]
    pub query_understanding_spec: ::core::option::Option<
        answer_query_request::QueryUnderstandingSpec,
    >,
    #[prost(bool, tag = "10")]
    pub asynchronous_mode: bool,
    #[prost(string, tag = "12")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "13")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `AnswerQueryRequest`.
pub mod answer_query_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SafetySpec {
        #[prost(bool, tag = "1")]
        pub enable: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RelatedQuestionsSpec {
        #[prost(bool, tag = "1")]
        pub enable: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnswerGenerationSpec {
        #[prost(message, optional, tag = "1")]
        pub model_spec: ::core::option::Option<answer_generation_spec::ModelSpec>,
        #[prost(message, optional, tag = "2")]
        pub prompt_spec: ::core::option::Option<answer_generation_spec::PromptSpec>,
        #[prost(bool, tag = "3")]
        pub include_citations: bool,
        #[prost(string, tag = "4")]
        pub answer_language_code: ::prost::alloc::string::String,
        #[prost(bool, tag = "5")]
        pub ignore_adversarial_query: bool,
        #[prost(bool, tag = "6")]
        pub ignore_non_answer_seeking_query: bool,
        #[prost(bool, optional, tag = "7")]
        pub ignore_low_relevant_content: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `AnswerGenerationSpec`.
    pub mod answer_generation_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ModelSpec {
            #[prost(string, tag = "1")]
            pub model_version: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PromptSpec {
            #[prost(string, tag = "1")]
            pub preamble: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SearchSpec {
        #[prost(oneof = "search_spec::Input", tags = "1, 2")]
        pub input: ::core::option::Option<search_spec::Input>,
    }
    /// Nested message and enum types in `SearchSpec`.
    pub mod search_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SearchParams {
            #[prost(int32, tag = "1")]
            pub max_return_results: i32,
            #[prost(string, tag = "2")]
            pub filter: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub boost_spec: ::core::option::Option<
                super::super::search_request::BoostSpec,
            >,
            #[prost(string, tag = "4")]
            pub order_by: ::prost::alloc::string::String,
            #[prost(
                enumeration = "super::super::search_request::content_search_spec::SearchResultMode",
                tag = "5"
            )]
            pub search_result_mode: i32,
            #[prost(message, repeated, tag = "7")]
            pub data_store_specs: ::prost::alloc::vec::Vec<
                super::super::search_request::DataStoreSpec,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SearchResultList {
            #[prost(message, repeated, tag = "1")]
            pub search_results: ::prost::alloc::vec::Vec<
                search_result_list::SearchResult,
            >,
        }
        /// Nested message and enum types in `SearchResultList`.
        pub mod search_result_list {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SearchResult {
                #[prost(oneof = "search_result::Content", tags = "1, 2")]
                pub content: ::core::option::Option<search_result::Content>,
            }
            /// Nested message and enum types in `SearchResult`.
            pub mod search_result {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct UnstructuredDocumentInfo {
                    #[prost(string, tag = "1")]
                    pub document: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub uri: ::prost::alloc::string::String,
                    #[prost(string, tag = "3")]
                    pub title: ::prost::alloc::string::String,
                    #[prost(message, repeated, tag = "4")]
                    pub document_contexts: ::prost::alloc::vec::Vec<
                        unstructured_document_info::DocumentContext,
                    >,
                    #[prost(message, repeated, tag = "5")]
                    pub extractive_segments: ::prost::alloc::vec::Vec<
                        unstructured_document_info::ExtractiveSegment,
                    >,
                    #[prost(message, repeated, tag = "6")]
                    pub extractive_answers: ::prost::alloc::vec::Vec<
                        unstructured_document_info::ExtractiveAnswer,
                    >,
                }
                /// Nested message and enum types in `UnstructuredDocumentInfo`.
                pub mod unstructured_document_info {
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct DocumentContext {
                        #[prost(string, tag = "1")]
                        pub page_identifier: ::prost::alloc::string::String,
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                    }
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct ExtractiveSegment {
                        #[prost(string, tag = "1")]
                        pub page_identifier: ::prost::alloc::string::String,
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                    }
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct ExtractiveAnswer {
                        #[prost(string, tag = "1")]
                        pub page_identifier: ::prost::alloc::string::String,
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ChunkInfo {
                    #[prost(string, tag = "1")]
                    pub chunk: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub content: ::prost::alloc::string::String,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Content {
                    #[prost(message, tag = "1")]
                    UnstructuredDocumentInfo(UnstructuredDocumentInfo),
                    #[prost(message, tag = "2")]
                    ChunkInfo(ChunkInfo),
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Input {
            #[prost(message, tag = "1")]
            SearchParams(SearchParams),
            #[prost(message, tag = "2")]
            SearchResultList(SearchResultList),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryUnderstandingSpec {
        #[prost(message, optional, tag = "1")]
        pub query_classification_spec: ::core::option::Option<
            query_understanding_spec::QueryClassificationSpec,
        >,
        #[prost(message, optional, tag = "2")]
        pub query_rephraser_spec: ::core::option::Option<
            query_understanding_spec::QueryRephraserSpec,
        >,
    }
    /// Nested message and enum types in `QueryUnderstandingSpec`.
    pub mod query_understanding_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct QueryClassificationSpec {
            #[prost(
                enumeration = "query_classification_spec::Type",
                repeated,
                tag = "1"
            )]
            pub types: ::prost::alloc::vec::Vec<i32>,
        }
        /// Nested message and enum types in `QueryClassificationSpec`.
        pub mod query_classification_spec {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Unspecified = 0,
                AdversarialQuery = 1,
                NonAnswerSeekingQuery = 2,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Type::Unspecified => "TYPE_UNSPECIFIED",
                        Type::AdversarialQuery => "ADVERSARIAL_QUERY",
                        Type::NonAnswerSeekingQuery => "NON_ANSWER_SEEKING_QUERY",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "ADVERSARIAL_QUERY" => Some(Self::AdversarialQuery),
                        "NON_ANSWER_SEEKING_QUERY" => Some(Self::NonAnswerSeekingQuery),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct QueryRephraserSpec {
            #[prost(bool, tag = "1")]
            pub disable: bool,
            #[prost(int32, tag = "2")]
            pub max_rephrase_steps: i32,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQueryResponse {
    #[prost(message, optional, tag = "1")]
    pub answer: ::core::option::Option<Answer>,
    #[prost(message, optional, tag = "2")]
    pub session: ::core::option::Option<Session>,
    #[prost(string, tag = "3")]
    pub answer_query_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnswerRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub session: ::core::option::Option<Session>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSessionRequest {
    #[prost(message, optional, tag = "1")]
    pub session: ::core::option::Option<Session>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSessionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod conversational_search_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for conversational search.
    #[derive(Debug, Clone)]
    pub struct ConversationalSearchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ConversationalSearchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConversationalSearchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ConversationalSearchServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Converses a conversation.
        pub async fn converse_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::ConverseConversationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConverseConversationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/ConverseConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "ConverseConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Conversation.
        ///
        /// If the \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] to
        /// create already exists, an ALREADY_EXISTS error is returned.
        pub async fn create_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/CreateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "CreateConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Conversation.
        ///
        /// If the \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] to
        /// delete does not exist, a NOT_FOUND error is returned.
        pub async fn delete_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConversationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/DeleteConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "DeleteConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Conversation.
        ///
        /// \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] action type
        /// cannot be changed. If the
        /// \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] to update does
        /// not exist, a NOT_FOUND error is returned.
        pub async fn update_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/UpdateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "UpdateConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Conversation.
        pub async fn get_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/GetConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "GetConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Conversations by their parent
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn list_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConversationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/ListConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "ListConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Answer query method.
        pub async fn answer_query(
            &mut self,
            request: impl tonic::IntoRequest<super::AnswerQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnswerQueryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/AnswerQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "AnswerQuery",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Answer.
        pub async fn get_answer(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnswerRequest>,
        ) -> std::result::Result<tonic::Response<super::Answer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/GetAnswer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "GetAnswer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Session.
        ///
        /// If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to create already
        /// exists, an ALREADY_EXISTS error is returned.
        pub async fn create_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/CreateSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "CreateSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Session.
        ///
        /// If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to delete does
        /// not exist, a NOT_FOUND error is returned.
        pub async fn delete_session(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSessionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/DeleteSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "DeleteSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Session.
        ///
        /// \[Session\]\[google.cloud.discoveryengine.v1.Session\] action type cannot be
        /// changed. If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to
        /// update does not exist, a NOT_FOUND error is returned.
        pub async fn update_session(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/UpdateSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "UpdateSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Session.
        pub async fn get_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/GetSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "GetSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Sessions by their parent
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn list_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSessionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSessionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/ListSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "ListSessions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestionDenyListEntry {
    #[prost(string, tag = "1")]
    pub block_phrase: ::prost::alloc::string::String,
    #[prost(enumeration = "suggestion_deny_list_entry::MatchOperator", tag = "2")]
    pub match_operator: i32,
}
/// Nested message and enum types in `SuggestionDenyListEntry`.
pub mod suggestion_deny_list_entry {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MatchOperator {
        Unspecified = 0,
        ExactMatch = 1,
        Contains = 2,
    }
    impl MatchOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MatchOperator::Unspecified => "MATCH_OPERATOR_UNSPECIFIED",
                MatchOperator::ExactMatch => "EXACT_MATCH",
                MatchOperator::Contains => "CONTAINS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MATCH_OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                "EXACT_MATCH" => Some(Self::ExactMatch),
                "CONTAINS" => Some(Self::Contains),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionSuggestion {
    #[prost(string, tag = "1")]
    pub suggestion: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(double, tag = "6")]
    pub group_score: f64,
    #[prost(string, repeated, tag = "7")]
    pub alternative_phrases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "completion_suggestion::RankingInfo", tags = "2, 3")]
    pub ranking_info: ::core::option::Option<completion_suggestion::RankingInfo>,
}
/// Nested message and enum types in `CompletionSuggestion`.
pub mod completion_suggestion {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum RankingInfo {
        #[prost(double, tag = "2")]
        GlobalScore(f64),
        #[prost(int64, tag = "3")]
        Frequency(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    #[prost(string, repeated, tag = "1")]
    pub input_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub data_schema: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuerySource {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub data_schema: ::prost::alloc::string::String,
    #[prost(oneof = "big_query_source::Partition", tags = "5")]
    pub partition: ::core::option::Option<big_query_source::Partition>,
}
/// Nested message and enum types in `BigQuerySource`.
pub mod big_query_source {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Partition {
        #[prost(message, tag = "5")]
        PartitionDate(super::super::super::super::r#type::Date),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpannerSource {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub database_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub enable_data_boost: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableOptions {
    #[prost(string, tag = "1")]
    pub key_field_name: ::prost::alloc::string::String,
    #[prost(btree_map = "string, message", tag = "2")]
    pub families: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        bigtable_options::BigtableColumnFamily,
    >,
}
/// Nested message and enum types in `BigtableOptions`.
pub mod bigtable_options {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigtableColumnFamily {
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        #[prost(enumeration = "Encoding", tag = "2")]
        pub encoding: i32,
        #[prost(enumeration = "Type", tag = "3")]
        pub r#type: i32,
        #[prost(message, repeated, tag = "4")]
        pub columns: ::prost::alloc::vec::Vec<BigtableColumn>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigtableColumn {
        #[prost(bytes = "bytes", tag = "1")]
        pub qualifier: ::prost::bytes::Bytes,
        #[prost(string, tag = "2")]
        pub field_name: ::prost::alloc::string::String,
        #[prost(enumeration = "Encoding", tag = "3")]
        pub encoding: i32,
        #[prost(enumeration = "Type", tag = "4")]
        pub r#type: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        String = 1,
        Number = 2,
        Integer = 3,
        VarInteger = 4,
        BigNumeric = 5,
        Boolean = 6,
        Json = 7,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::String => "STRING",
                Type::Number => "NUMBER",
                Type::Integer => "INTEGER",
                Type::VarInteger => "VAR_INTEGER",
                Type::BigNumeric => "BIG_NUMERIC",
                Type::Boolean => "BOOLEAN",
                Type::Json => "JSON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "NUMBER" => Some(Self::Number),
                "INTEGER" => Some(Self::Integer),
                "VAR_INTEGER" => Some(Self::VarInteger),
                "BIG_NUMERIC" => Some(Self::BigNumeric),
                "BOOLEAN" => Some(Self::Boolean),
                "JSON" => Some(Self::Json),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Encoding {
        Unspecified = 0,
        Text = 1,
        Binary = 2,
    }
    impl Encoding {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Encoding::Unspecified => "ENCODING_UNSPECIFIED",
                Encoding::Text => "TEXT",
                Encoding::Binary => "BINARY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
                "TEXT" => Some(Self::Text),
                "BINARY" => Some(Self::Binary),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableSource {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub bigtable_options: ::core::option::Option<BigtableOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FhirStoreSource {
    #[prost(string, tag = "1")]
    pub fhir_store: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudSqlSource {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub database_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub offload: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlloyDbSource {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub location_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub database_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirestoreSource {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub database_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub collection_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportErrorConfig {
    #[prost(oneof = "import_error_config::Destination", tags = "1")]
    pub destination: ::core::option::Option<import_error_config::Destination>,
}
/// Nested message and enum types in `ImportErrorConfig`.
pub mod import_error_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(string, tag = "1")]
        GcsPrefix(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    #[prost(oneof = "import_user_events_request::Source", tags = "2, 3, 4")]
    pub source: ::core::option::Option<import_user_events_request::Source>,
}
/// Nested message and enum types in `ImportUserEventsRequest`.
pub mod import_user_events_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        #[prost(message, repeated, tag = "1")]
        pub user_events: ::prost::alloc::vec::Vec<super::UserEvent>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "4")]
        BigquerySource(super::BigQuerySource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "2")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    #[prost(int64, tag = "3")]
    pub joined_events_count: i64,
    #[prost(int64, tag = "4")]
    pub unjoined_events_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportUserEventsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportDocumentsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
    #[prost(int64, tag = "5")]
    pub total_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    #[prost(enumeration = "import_documents_request::ReconciliationMode", tag = "6")]
    pub reconciliation_mode: i32,
    #[prost(message, optional, tag = "7")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "8")]
    pub auto_generate_ids: bool,
    #[prost(string, tag = "9")]
    pub id_field: ::prost::alloc::string::String,
    #[prost(
        oneof = "import_documents_request::Source",
        tags = "2, 3, 4, 10, 11, 12, 13, 14, 15"
    )]
    pub source: ::core::option::Option<import_documents_request::Source>,
}
/// Nested message and enum types in `ImportDocumentsRequest`.
pub mod import_documents_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        #[prost(message, repeated, tag = "1")]
        pub documents: ::prost::alloc::vec::Vec<super::Document>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReconciliationMode {
        Unspecified = 0,
        Incremental = 1,
        Full = 2,
    }
    impl ReconciliationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReconciliationMode::Unspecified => "RECONCILIATION_MODE_UNSPECIFIED",
                ReconciliationMode::Incremental => "INCREMENTAL",
                ReconciliationMode::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECONCILIATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCREMENTAL" => Some(Self::Incremental),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "4")]
        BigquerySource(super::BigQuerySource),
        #[prost(message, tag = "10")]
        FhirStoreSource(super::FhirStoreSource),
        #[prost(message, tag = "11")]
        SpannerSource(super::SpannerSource),
        #[prost(message, tag = "12")]
        CloudSqlSource(super::CloudSqlSource),
        #[prost(message, tag = "13")]
        FirestoreSource(super::FirestoreSource),
        #[prost(message, tag = "14")]
        AlloyDbSource(super::AlloyDbSource),
        #[prost(message, tag = "15")]
        BigtableSource(super::BigtableSource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "2")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(
        oneof = "import_suggestion_deny_list_entries_request::Source",
        tags = "2, 3"
    )]
    pub source: ::core::option::Option<
        import_suggestion_deny_list_entries_request::Source,
    >,
}
/// Nested message and enum types in `ImportSuggestionDenyListEntriesRequest`.
pub mod import_suggestion_deny_list_entries_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        #[prost(message, repeated, tag = "1")]
        pub entries: ::prost::alloc::vec::Vec<super::SuggestionDenyListEntry>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(int64, tag = "2")]
    pub imported_entries_count: i64,
    #[prost(int64, tag = "3")]
    pub failed_entries_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCompletionSuggestionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    #[prost(oneof = "import_completion_suggestions_request::Source", tags = "2, 3, 4")]
    pub source: ::core::option::Option<import_completion_suggestions_request::Source>,
}
/// Nested message and enum types in `ImportCompletionSuggestionsRequest`.
pub mod import_completion_suggestions_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        #[prost(message, repeated, tag = "1")]
        pub suggestions: ::prost::alloc::vec::Vec<super::CompletionSuggestion>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "4")]
        BigquerySource(super::BigQuerySource),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCompletionSuggestionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "2")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportCompletionSuggestionsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteUserEventRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub user_event: ::core::option::Option<UserEvent>,
    #[prost(bool, tag = "3")]
    pub write_async: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectUserEventRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_event: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub uri: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "4")]
    pub ets: ::core::option::Option<i64>,
}
/// Generated client implementations.
pub mod user_event_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for ingesting end user actions on a website to Discovery Engine API.
    #[derive(Debug, Clone)]
    pub struct UserEventServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> UserEventServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserEventServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            UserEventServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Writes a single user event.
        pub async fn write_user_event(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteUserEventRequest>,
        ) -> std::result::Result<tonic::Response<super::UserEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserEventService/WriteUserEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserEventService",
                        "WriteUserEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Writes a single user event from the browser. This uses a GET request to
        /// due to browser restriction of POST-ing to a third-party domain.
        ///
        /// This method is used only by the Discovery Engine API JavaScript pixel and
        /// Google Tag Manager. Users should not call this method directly.
        pub async fn collect_user_event(
            &mut self,
            request: impl tonic::IntoRequest<super::CollectUserEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserEventService/CollectUserEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserEventService",
                        "CollectUserEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk import of user events. Request processing might be
        /// synchronous. Events that already exist are skipped.
        /// Use this method for backfilling historical user events.
        ///
        /// Operation.response is of type ImportResponse. Note that it is
        /// possible for a subset of the items to be successfully inserted.
        /// Operation.metadata is of type ImportMetadata.
        pub async fn import_user_events(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportUserEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserEventService/ImportUserEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserEventService",
                        "ImportUserEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentProcessingConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub chunking_config: ::core::option::Option<
        document_processing_config::ChunkingConfig,
    >,
    #[prost(message, optional, tag = "4")]
    pub default_parsing_config: ::core::option::Option<
        document_processing_config::ParsingConfig,
    >,
    #[prost(btree_map = "string, message", tag = "5")]
    pub parsing_config_overrides: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        document_processing_config::ParsingConfig,
    >,
}
/// Nested message and enum types in `DocumentProcessingConfig`.
pub mod document_processing_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ChunkingConfig {
        #[prost(oneof = "chunking_config::ChunkMode", tags = "1")]
        pub chunk_mode: ::core::option::Option<chunking_config::ChunkMode>,
    }
    /// Nested message and enum types in `ChunkingConfig`.
    pub mod chunking_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct LayoutBasedChunkingConfig {
            #[prost(int32, tag = "1")]
            pub chunk_size: i32,
            #[prost(bool, tag = "2")]
            pub include_ancestor_headings: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum ChunkMode {
            #[prost(message, tag = "1")]
            LayoutBasedChunkingConfig(LayoutBasedChunkingConfig),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParsingConfig {
        #[prost(oneof = "parsing_config::TypeDedicatedConfig", tags = "1, 2, 3")]
        pub type_dedicated_config: ::core::option::Option<
            parsing_config::TypeDedicatedConfig,
        >,
    }
    /// Nested message and enum types in `ParsingConfig`.
    pub mod parsing_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DigitalParsingConfig {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OcrParsingConfig {
            #[deprecated]
            #[prost(string, repeated, tag = "1")]
            pub enhanced_document_elements: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            #[prost(bool, tag = "2")]
            pub use_native_text: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct LayoutParsingConfig {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TypeDedicatedConfig {
            #[prost(message, tag = "1")]
            DigitalParsingConfig(DigitalParsingConfig),
            #[prost(message, tag = "2")]
            OcrParsingConfig(OcrParsingConfig),
            #[prost(message, tag = "3")]
            LayoutParsingConfig(LayoutParsingConfig),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeDocumentsResponse {
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    #[prost(string, repeated, tag = "2")]
    pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeDocumentsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
    #[prost(int64, tag = "5")]
    pub ignored_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesResponse {
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    #[prost(message, repeated, tag = "2")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeCompletionSuggestionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeCompletionSuggestionsResponse {
    #[prost(bool, tag = "1")]
    pub purge_succeeded: bool,
    #[prost(message, repeated, tag = "2")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurgeCompletionSuggestionsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryRequest {
    #[prost(string, tag = "1")]
    pub data_store: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub query_model: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub include_tail_suggestions: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub query_suggestions: ::prost::alloc::vec::Vec<
        complete_query_response::QuerySuggestion,
    >,
    #[prost(bool, tag = "2")]
    pub tail_match_triggered: bool,
}
/// Nested message and enum types in `CompleteQueryResponse`.
pub mod complete_query_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QuerySuggestion {
        #[prost(string, tag = "1")]
        pub suggestion: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub completable_field_paths: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
}
/// Generated client implementations.
pub mod completion_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for Auto-Completion.
    #[derive(Debug, Clone)]
    pub struct CompletionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CompletionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CompletionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CompletionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Completes the specified user input with keyword suggestions.
        pub async fn complete_query(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompleteQueryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/CompleteQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "CompleteQuery",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports all
        /// \[SuggestionDenyListEntry\]\[google.cloud.discoveryengine.v1.SuggestionDenyListEntry\]
        /// for a DataStore.
        pub async fn import_suggestion_deny_list_entries(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ImportSuggestionDenyListEntriesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/ImportSuggestionDenyListEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "ImportSuggestionDenyListEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes all
        /// \[SuggestionDenyListEntry\]\[google.cloud.discoveryengine.v1.SuggestionDenyListEntry\]
        /// for a DataStore.
        pub async fn purge_suggestion_deny_list_entries(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PurgeSuggestionDenyListEntriesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/PurgeSuggestionDenyListEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "PurgeSuggestionDenyListEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports
        /// \[CompletionSuggestion\]\[google.cloud.discoveryengine.v1.CompletionSuggestion\]s
        /// for a DataStore.
        pub async fn import_completion_suggestions(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportCompletionSuggestionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/ImportCompletionSuggestions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "ImportCompletionSuggestions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes all
        /// \[CompletionSuggestion\]\[google.cloud.discoveryengine.v1.CompletionSuggestion\]s
        /// for a DataStore.
        pub async fn purge_completion_suggestions(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeCompletionSuggestionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/PurgeCompletionSuggestions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "PurgeCompletionSuggestions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "schema::Schema", tags = "2, 3")]
    pub schema: ::core::option::Option<schema::Schema>,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Schema {
        #[prost(message, tag = "2")]
        StructSchema(::prost_types::Struct),
        #[prost(string, tag = "3")]
        JsonSchema(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataStore {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "IndustryVertical", tag = "3")]
    pub industry_vertical: i32,
    #[prost(enumeration = "SolutionType", repeated, tag = "5")]
    pub solution_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "7")]
    pub default_schema_id: ::prost::alloc::string::String,
    #[prost(enumeration = "data_store::ContentConfig", tag = "6")]
    pub content_config: i32,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "27")]
    pub document_processing_config: ::core::option::Option<DocumentProcessingConfig>,
    #[prost(message, optional, tag = "28")]
    pub starting_schema: ::core::option::Option<Schema>,
}
/// Nested message and enum types in `DataStore`.
pub mod data_store {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentConfig {
        Unspecified = 0,
        NoContent = 1,
        ContentRequired = 2,
        PublicWebsite = 3,
    }
    impl ContentConfig {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContentConfig::Unspecified => "CONTENT_CONFIG_UNSPECIFIED",
                ContentConfig::NoContent => "NO_CONTENT",
                ContentConfig::ContentRequired => "CONTENT_REQUIRED",
                ContentConfig::PublicWebsite => "PUBLIC_WEBSITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTENT_CONFIG_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_CONTENT" => Some(Self::NoContent),
                "CONTENT_REQUIRED" => Some(Self::ContentRequired),
                "PUBLIC_WEBSITE" => Some(Self::PublicWebsite),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataStoreRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub data_store: ::core::option::Option<DataStore>,
    #[prost(string, tag = "3")]
    pub data_store_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub create_advanced_site_search: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataStoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateDataStoreMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataStoresRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataStoresResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_stores: ::prost::alloc::vec::Vec<DataStore>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataStoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataStoreRequest {
    #[prost(message, optional, tag = "1")]
    pub data_store: ::core::option::Option<DataStore>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteDataStoreMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod data_store_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]
    /// configuration.
    #[derive(Debug, Clone)]
    pub struct DataStoreServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DataStoreServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataStoreServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DataStoreServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        ///
        /// DataStore is for storing
        /// \[Documents\]\[google.cloud.discoveryengine.v1.Document\]. To serve these
        /// documents for Search, or Recommendation use case, an
        /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] needs to be created
        /// separately.
        pub async fn create_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataStoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/CreateDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "CreateDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn get_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::DataStore>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/GetDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "GetDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s
        /// associated with the project.
        pub async fn list_data_stores(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataStoresRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataStoresResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/ListDataStores",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "ListDataStores",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn delete_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataStoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/DeleteDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "DeleteDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]
        pub async fn update_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::DataStore>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/UpdateDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "UpdateDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Engine {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag = "5")]
    pub data_store_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "SolutionType", tag = "6")]
    pub solution_type: i32,
    #[prost(enumeration = "IndustryVertical", tag = "16")]
    pub industry_vertical: i32,
    #[prost(message, optional, tag = "15")]
    pub common_config: ::core::option::Option<engine::CommonConfig>,
    #[prost(oneof = "engine::EngineConfig", tags = "11, 13")]
    pub engine_config: ::core::option::Option<engine::EngineConfig>,
    #[prost(oneof = "engine::EngineMetadata", tags = "12")]
    pub engine_metadata: ::core::option::Option<engine::EngineMetadata>,
}
/// Nested message and enum types in `Engine`.
pub mod engine {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SearchEngineConfig {
        #[prost(enumeration = "super::SearchTier", tag = "1")]
        pub search_tier: i32,
        #[prost(enumeration = "super::SearchAddOn", repeated, tag = "2")]
        pub search_add_ons: ::prost::alloc::vec::Vec<i32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChatEngineConfig {
        #[prost(message, optional, tag = "1")]
        pub agent_creation_config: ::core::option::Option<
            chat_engine_config::AgentCreationConfig,
        >,
        #[prost(string, tag = "2")]
        pub dialogflow_agent_to_link: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ChatEngineConfig`.
    pub mod chat_engine_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AgentCreationConfig {
            #[prost(string, tag = "1")]
            pub business: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub default_language_code: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub time_zone: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub location: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommonConfig {
        #[prost(string, tag = "1")]
        pub company_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChatEngineMetadata {
        #[prost(string, tag = "1")]
        pub dialogflow_agent: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EngineConfig {
        #[prost(message, tag = "11")]
        ChatEngineConfig(ChatEngineConfig),
        #[prost(message, tag = "13")]
        SearchEngineConfig(SearchEngineConfig),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EngineMetadata {
        #[prost(message, tag = "12")]
        ChatEngineMetadata(ChatEngineMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEngineRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub engine: ::core::option::Option<Engine>,
    #[prost(string, tag = "3")]
    pub engine_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateEngineMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEngineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteEngineMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEngineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnginesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnginesResponse {
    #[prost(message, repeated, tag = "1")]
    pub engines: ::prost::alloc::vec::Vec<Engine>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEngineRequest {
    #[prost(message, optional, tag = "1")]
    pub engine: ::core::option::Option<Engine>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod engine_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]
    /// configuration.
    #[derive(Debug, Clone)]
    pub struct EngineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> EngineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EngineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            EngineServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a \[Engine\]\[google.cloud.discoveryengine.v1.Engine\].
        pub async fn create_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEngineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/CreateEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "CreateEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Engine\]\[google.cloud.discoveryengine.v1.Engine\].
        pub async fn delete_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEngineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/DeleteEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "DeleteEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]
        pub async fn update_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEngineRequest>,
        ) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/UpdateEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "UpdateEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a \[Engine\]\[google.cloud.discoveryengine.v1.Engine\].
        pub async fn get_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEngineRequest>,
        ) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/GetEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "GetEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]s associated
        /// with the project.
        pub async fn list_engines(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEnginesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEnginesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/ListEngines",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "ListEngines",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingFact {
    #[prost(string, tag = "1")]
    pub fact_text: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "2")]
    pub attributes: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FactChunk {
    #[prost(string, tag = "1")]
    pub chunk_text: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub index: i32,
    #[prost(btree_map = "string, string", tag = "3")]
    pub source_metadata: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckGroundingSpec {
    #[prost(double, optional, tag = "1")]
    pub citation_threshold: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroundingRequest {
    #[prost(string, tag = "1")]
    pub grounding_config: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub answer_candidate: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub facts: ::prost::alloc::vec::Vec<GroundingFact>,
    #[prost(message, optional, tag = "4")]
    pub grounding_spec: ::core::option::Option<CheckGroundingSpec>,
    #[prost(btree_map = "string, string", tag = "5")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroundingResponse {
    #[prost(float, optional, tag = "1")]
    pub support_score: ::core::option::Option<f32>,
    #[prost(message, repeated, tag = "3")]
    pub cited_chunks: ::prost::alloc::vec::Vec<FactChunk>,
    #[prost(message, repeated, tag = "4")]
    pub claims: ::prost::alloc::vec::Vec<check_grounding_response::Claim>,
}
/// Nested message and enum types in `CheckGroundingResponse`.
pub mod check_grounding_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Claim {
        #[prost(int32, optional, tag = "1")]
        pub start_pos: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub end_pos: ::core::option::Option<i32>,
        #[prost(string, tag = "3")]
        pub claim_text: ::prost::alloc::string::String,
        #[prost(int32, repeated, tag = "4")]
        pub citation_indices: ::prost::alloc::vec::Vec<i32>,
        #[prost(bool, optional, tag = "6")]
        pub grounding_check_required: ::core::option::Option<bool>,
    }
}
/// Generated client implementations.
pub mod grounded_generation_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for grounded generation.
    #[derive(Debug, Clone)]
    pub struct GroundedGenerationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GroundedGenerationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GroundedGenerationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GroundedGenerationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Performs a grounding check.
        pub async fn check_grounding(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckGroundingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckGroundingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.GroundedGenerationService/CheckGrounding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.GroundedGenerationService",
                        "CheckGrounding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
    #[prost(string, tag = "3")]
    pub document_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(bool, tag = "2")]
    pub allow_missing: bool,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod document_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for ingesting \[Document\]\[google.cloud.discoveryengine.v1.Document\]
    /// information of the customer's website.
    #[derive(Debug, Clone)]
    pub struct DocumentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DocumentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DocumentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DocumentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn get_document(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/GetDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "GetDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
        pub async fn list_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDocumentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/ListDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "ListDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn create_document(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/CreateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "CreateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn update_document(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/UpdateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "UpdateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn delete_document(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/DeleteDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "DeleteDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk import of multiple
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s. Request processing
        /// may be synchronous. Non-existing items are created.
        ///
        /// Note: It is possible for a subset of the
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s to be successfully
        /// updated.
        pub async fn import_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/ImportDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "ImportDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes all selected
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s in a branch.
        ///
        /// This process is asynchronous. Depending on the number of
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s to be deleted, this
        /// operation can take hours to complete. Before the delete operation
        /// completes, some \[Document\]\[google.cloud.discoveryengine.v1.Document\]s might
        /// still be returned by
        /// \[DocumentService.GetDocument\]\[google.cloud.discoveryengine.v1.DocumentService.GetDocument\]
        /// or
        /// \[DocumentService.ListDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ListDocuments\].
        ///
        /// To get a list of the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s
        /// to be deleted, set
        /// \[PurgeDocumentsRequest.force\]\[google.cloud.discoveryengine.v1.PurgeDocumentsRequest.force\]
        /// to false.
        pub async fn purge_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/PurgeDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "PurgeDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    #[prost(message, repeated, tag = "2")]
    pub query_terms: ::prost::alloc::vec::Vec<condition::QueryTerm>,
    #[prost(message, repeated, tag = "3")]
    pub active_time_range: ::prost::alloc::vec::Vec<condition::TimeRange>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryTerm {
        #[prost(string, tag = "1")]
        pub value: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub full_match: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TimeRange {
        #[prost(message, optional, tag = "1")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Control {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub associated_serving_config_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "SolutionType", tag = "4")]
    pub solution_type: i32,
    #[prost(enumeration = "SearchUseCase", repeated, tag = "8")]
    pub use_cases: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "5")]
    pub conditions: ::prost::alloc::vec::Vec<Condition>,
    #[prost(oneof = "control::Action", tags = "6, 7, 9, 10")]
    pub action: ::core::option::Option<control::Action>,
}
/// Nested message and enum types in `Control`.
pub mod control {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoostAction {
        #[prost(float, tag = "1")]
        pub boost: f32,
        #[prost(string, tag = "2")]
        pub filter: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub data_store: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilterAction {
        #[prost(string, tag = "1")]
        pub filter: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub data_store: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RedirectAction {
        #[prost(string, tag = "1")]
        pub redirect_uri: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SynonymsAction {
        #[prost(string, repeated, tag = "1")]
        pub synonyms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "6")]
        BoostAction(BoostAction),
        #[prost(message, tag = "7")]
        FilterAction(FilterAction),
        #[prost(message, tag = "9")]
        RedirectAction(RedirectAction),
        #[prost(message, tag = "10")]
        SynonymsAction(SynonymsAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub schemas: ::prost::alloc::vec::Vec<Schema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
    #[prost(string, tag = "3")]
    pub schema_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSchemaRequest {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<Schema>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateSchemaMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateSchemaMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSchemaMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod schema_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing \[Schema\]\[google.cloud.discoveryengine.v1.Schema\]s.
    #[derive(Debug, Clone)]
    pub struct SchemaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SchemaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SchemaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SchemaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn get_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/GetSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "GetSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of \[Schema\]\[google.cloud.discoveryengine.v1.Schema\]s.
        pub async fn list_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchemasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/ListSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "ListSchemas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn create_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/CreateSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "CreateSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn update_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/UpdateSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "UpdateSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn delete_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/DeleteSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "DeleteSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendRequest {
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub user_event: ::core::option::Option<UserEvent>,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    #[prost(btree_map = "string, message", tag = "6")]
    pub params: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
    #[prost(btree_map = "string, string", tag = "8")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<recommend_response::RecommendationResult>,
    #[prost(string, tag = "2")]
    pub attribution_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub missing_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Nested message and enum types in `RecommendResponse`.
pub mod recommend_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RecommendationResult {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub document: ::core::option::Option<super::Document>,
        #[prost(btree_map = "string, message", tag = "3")]
        pub metadata: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost_types::Value,
        >,
    }
}
/// Generated client implementations.
pub mod recommendation_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for making recommendations.
    #[derive(Debug, Clone)]
    pub struct RecommendationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RecommendationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RecommendationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RecommendationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Makes a recommendation, which requires a contextual user event.
        pub async fn recommend(
            &mut self,
            request: impl tonic::IntoRequest<super::RecommendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecommendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.RecommendationService/Recommend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.RecommendationService",
                        "Recommend",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateControlRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub control: ::core::option::Option<Control>,
    #[prost(string, tag = "3")]
    pub control_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateControlRequest {
    #[prost(message, optional, tag = "1")]
    pub control: ::core::option::Option<Control>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteControlRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetControlRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsResponse {
    #[prost(message, repeated, tag = "1")]
    pub controls: ::prost::alloc::vec::Vec<Control>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod control_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for performing CRUD operations on Controls.
    /// Controls allow for custom logic to be implemented in the serving path.
    /// Controls need to be attached to a Serving Config to be considered during a
    /// request.
    #[derive(Debug, Clone)]
    pub struct ControlServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ControlServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ControlServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ControlServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a Control.
        ///
        /// By default 1000 controls are allowed for a data store.
        /// A request can be submitted to adjust this limit.
        /// If the \[Control\]\[google.cloud.discoveryengine.v1.Control\] to create already
        /// exists, an ALREADY_EXISTS error is returned.
        pub async fn create_control(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/CreateControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "CreateControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Control.
        ///
        /// If the \[Control\]\[google.cloud.discoveryengine.v1.Control\] to delete does
        /// not exist, a NOT_FOUND error is returned.
        pub async fn delete_control(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteControlRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/DeleteControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "DeleteControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Control.
        ///
        /// \[Control\]\[google.cloud.discoveryengine.v1.Control\] action type cannot be
        /// changed. If the \[Control\]\[google.cloud.discoveryengine.v1.Control\] to
        /// update does not exist, a NOT_FOUND error is returned.
        pub async fn update_control(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/UpdateControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "UpdateControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Control.
        pub async fn get_control(
            &mut self,
            request: impl tonic::IntoRequest<super::GetControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/GetControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "GetControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Controls by their parent
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn list_controls(
            &mut self,
            request: impl tonic::IntoRequest<super::ListControlsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListControlsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/ListControls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "ListControls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankingRecord {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub score: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankRequest {
    #[prost(string, tag = "1")]
    pub ranking_config: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub top_n: i32,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub records: ::prost::alloc::vec::Vec<RankingRecord>,
    #[prost(bool, tag = "6")]
    pub ignore_record_details_in_response: bool,
    #[prost(btree_map = "string, string", tag = "7")]
    pub user_labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankResponse {
    #[prost(message, repeated, tag = "5")]
    pub records: ::prost::alloc::vec::Vec<RankingRecord>,
}
/// Generated client implementations.
pub mod rank_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for ranking text records.
    #[derive(Debug, Clone)]
    pub struct RankServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RankServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RankServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RankServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Ranks a list of text records based on the given input query.
        pub async fn rank(
            &mut self,
            request: impl tonic::IntoRequest<super::RankRequest>,
        ) -> std::result::Result<tonic::Response<super::RankResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.RankService/Rank",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.RankService",
                        "Rank",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionProjectRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub accept_data_use_terms: bool,
    #[prost(string, tag = "3")]
    pub data_use_terms_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProvisionProjectMetadata {}
/// Generated client implementations.
pub mod project_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for operations on the
    /// \[Project\]\[google.cloud.discoveryengine.v1.Project\].
    #[derive(Debug, Clone)]
    pub struct ProjectServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ProjectServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProjectServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ProjectServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Provisions the project resource. During the
        /// process, related systems will get prepared and initialized.
        ///
        /// Caller must read the [Terms for data
        /// use](https://cloud.google.com/retail/data-use-terms), and optionally
        /// specify in request to provide consent to that service terms.
        pub async fn provision_project(
            &mut self,
            request: impl tonic::IntoRequest<super::ProvisionProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ProjectService/ProvisionProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ProjectService",
                        "ProvisionProject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
