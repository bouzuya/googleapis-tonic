// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceAccessSpec {
    #[prost(string, repeated, tag = "1")]
    pub readers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub writers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub owners: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAccessSpec {
    #[prost(string, repeated, tag = "1")]
    pub readers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lake {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    #[prost(string, tag = "9")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "102")]
    pub metastore: ::core::option::Option<lake::Metastore>,
    #[prost(message, optional, tag = "103")]
    pub asset_status: ::core::option::Option<AssetStatus>,
    #[prost(message, optional, tag = "104")]
    pub metastore_status: ::core::option::Option<lake::MetastoreStatus>,
}
/// Nested message and enum types in `Lake`.
pub mod lake {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metastore {
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetastoreStatus {
        #[prost(enumeration = "metastore_status::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "4")]
        pub endpoint: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `MetastoreStatus`.
    pub mod metastore_status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            None = 1,
            Ready = 2,
            Updating = 3,
            Error = 4,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::None => "NONE",
                    State::Ready => "READY",
                    State::Updating => "UPDATING",
                    State::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NONE" => Some(Self::None),
                    "READY" => Some(Self::Ready),
                    "UPDATING" => Some(Self::Updating),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetStatus {
    #[prost(message, optional, tag = "1")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "2")]
    pub active_assets: i32,
    #[prost(int32, tag = "3")]
    pub security_policy_applying_assets: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    #[prost(enumeration = "zone::Type", tag = "9")]
    pub r#type: i32,
    #[prost(message, optional, tag = "103")]
    pub discovery_spec: ::core::option::Option<zone::DiscoverySpec>,
    #[prost(message, optional, tag = "104")]
    pub resource_spec: ::core::option::Option<zone::ResourceSpec>,
    #[prost(message, optional, tag = "105")]
    pub asset_status: ::core::option::Option<AssetStatus>,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ResourceSpec {
        #[prost(enumeration = "resource_spec::LocationType", tag = "1")]
        pub location_type: i32,
    }
    /// Nested message and enum types in `ResourceSpec`.
    pub mod resource_spec {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LocationType {
            Unspecified = 0,
            SingleRegion = 1,
            MultiRegion = 2,
        }
        impl LocationType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    LocationType::Unspecified => "LOCATION_TYPE_UNSPECIFIED",
                    LocationType::SingleRegion => "SINGLE_REGION",
                    LocationType::MultiRegion => "MULTI_REGION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LOCATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SINGLE_REGION" => Some(Self::SingleRegion),
                    "MULTI_REGION" => Some(Self::MultiRegion),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoverySpec {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        #[prost(string, repeated, tag = "2")]
        pub include_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "4")]
        pub csv_options: ::core::option::Option<discovery_spec::CsvOptions>,
        #[prost(message, optional, tag = "5")]
        pub json_options: ::core::option::Option<discovery_spec::JsonOptions>,
        #[prost(oneof = "discovery_spec::Trigger", tags = "10")]
        pub trigger: ::core::option::Option<discovery_spec::Trigger>,
    }
    /// Nested message and enum types in `DiscoverySpec`.
    pub mod discovery_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CsvOptions {
            #[prost(int32, tag = "1")]
            pub header_rows: i32,
            #[prost(string, tag = "2")]
            pub delimiter: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub encoding: ::prost::alloc::string::String,
            #[prost(bool, tag = "4")]
            pub disable_type_inference: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonOptions {
            #[prost(string, tag = "1")]
            pub encoding: ::prost::alloc::string::String,
            #[prost(bool, tag = "2")]
            pub disable_type_inference: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            #[prost(string, tag = "10")]
            Schedule(::prost::alloc::string::String),
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Raw = 1,
        Curated = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Raw => "RAW",
                Type::Curated => "CURATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RAW" => Some(Self::Raw),
                "CURATED" => Some(Self::Curated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(enumeration = "action::Category", tag = "1")]
    pub category: i32,
    #[prost(string, tag = "2")]
    pub issue: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub detect_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub lake: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub zone: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub data_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "action::Details", tags = "10, 11, 12, 13, 14, 15, 21, 22")]
    pub details: ::core::option::Option<action::Details>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MissingResource {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UnauthorizedResource {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FailedSecurityPolicyApply {
        #[prost(string, tag = "1")]
        pub asset: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InvalidDataFormat {
        #[prost(string, repeated, tag = "1")]
        pub sampled_data_locations: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "2")]
        pub expected_format: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub new_format: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IncompatibleDataSchema {
        #[prost(string, tag = "1")]
        pub table: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub existing_schema: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub new_schema: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "4")]
        pub sampled_data_locations: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(enumeration = "incompatible_data_schema::SchemaChange", tag = "5")]
        pub schema_change: i32,
    }
    /// Nested message and enum types in `IncompatibleDataSchema`.
    pub mod incompatible_data_schema {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SchemaChange {
            Unspecified = 0,
            Incompatible = 1,
            Modified = 2,
        }
        impl SchemaChange {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    SchemaChange::Unspecified => "SCHEMA_CHANGE_UNSPECIFIED",
                    SchemaChange::Incompatible => "INCOMPATIBLE",
                    SchemaChange::Modified => "MODIFIED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCHEMA_CHANGE_UNSPECIFIED" => Some(Self::Unspecified),
                    "INCOMPATIBLE" => Some(Self::Incompatible),
                    "MODIFIED" => Some(Self::Modified),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InvalidDataPartition {
        #[prost(enumeration = "invalid_data_partition::PartitionStructure", tag = "1")]
        pub expected_structure: i32,
    }
    /// Nested message and enum types in `InvalidDataPartition`.
    pub mod invalid_data_partition {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PartitionStructure {
            Unspecified = 0,
            ConsistentKeys = 1,
            HiveStyleKeys = 2,
        }
        impl PartitionStructure {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    PartitionStructure::Unspecified => "PARTITION_STRUCTURE_UNSPECIFIED",
                    PartitionStructure::ConsistentKeys => "CONSISTENT_KEYS",
                    PartitionStructure::HiveStyleKeys => "HIVE_STYLE_KEYS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PARTITION_STRUCTURE_UNSPECIFIED" => Some(Self::Unspecified),
                    "CONSISTENT_KEYS" => Some(Self::ConsistentKeys),
                    "HIVE_STYLE_KEYS" => Some(Self::HiveStyleKeys),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MissingData {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InvalidDataOrganization {}
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Category {
        Unspecified = 0,
        ResourceManagement = 1,
        SecurityPolicy = 2,
        DataDiscovery = 3,
    }
    impl Category {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Category::Unspecified => "CATEGORY_UNSPECIFIED",
                Category::ResourceManagement => "RESOURCE_MANAGEMENT",
                Category::SecurityPolicy => "SECURITY_POLICY",
                Category::DataDiscovery => "DATA_DISCOVERY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_MANAGEMENT" => Some(Self::ResourceManagement),
                "SECURITY_POLICY" => Some(Self::SecurityPolicy),
                "DATA_DISCOVERY" => Some(Self::DataDiscovery),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag = "10")]
        InvalidDataFormat(InvalidDataFormat),
        #[prost(message, tag = "11")]
        IncompatibleDataSchema(IncompatibleDataSchema),
        #[prost(message, tag = "12")]
        InvalidDataPartition(InvalidDataPartition),
        #[prost(message, tag = "13")]
        MissingData(MissingData),
        #[prost(message, tag = "14")]
        MissingResource(MissingResource),
        #[prost(message, tag = "15")]
        UnauthorizedResource(UnauthorizedResource),
        #[prost(message, tag = "21")]
        FailedSecurityPolicyApply(FailedSecurityPolicyApply),
        #[prost(message, tag = "22")]
        InvalidDataOrganization(InvalidDataOrganization),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    #[prost(message, optional, tag = "100")]
    pub resource_spec: ::core::option::Option<asset::ResourceSpec>,
    #[prost(message, optional, tag = "101")]
    pub resource_status: ::core::option::Option<asset::ResourceStatus>,
    #[prost(message, optional, tag = "103")]
    pub security_status: ::core::option::Option<asset::SecurityStatus>,
    #[prost(message, optional, tag = "106")]
    pub discovery_spec: ::core::option::Option<asset::DiscoverySpec>,
    #[prost(message, optional, tag = "107")]
    pub discovery_status: ::core::option::Option<asset::DiscoveryStatus>,
}
/// Nested message and enum types in `Asset`.
pub mod asset {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecurityStatus {
        #[prost(enumeration = "security_status::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `SecurityStatus`.
    pub mod security_status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Ready = 1,
            Applying = 2,
            Error = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::Ready => "READY",
                    State::Applying => "APPLYING",
                    State::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "READY" => Some(Self::Ready),
                    "APPLYING" => Some(Self::Applying),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoverySpec {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        #[prost(string, repeated, tag = "2")]
        pub include_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "4")]
        pub csv_options: ::core::option::Option<discovery_spec::CsvOptions>,
        #[prost(message, optional, tag = "5")]
        pub json_options: ::core::option::Option<discovery_spec::JsonOptions>,
        #[prost(oneof = "discovery_spec::Trigger", tags = "10")]
        pub trigger: ::core::option::Option<discovery_spec::Trigger>,
    }
    /// Nested message and enum types in `DiscoverySpec`.
    pub mod discovery_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CsvOptions {
            #[prost(int32, tag = "1")]
            pub header_rows: i32,
            #[prost(string, tag = "2")]
            pub delimiter: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub encoding: ::prost::alloc::string::String,
            #[prost(bool, tag = "4")]
            pub disable_type_inference: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonOptions {
            #[prost(string, tag = "1")]
            pub encoding: ::prost::alloc::string::String,
            #[prost(bool, tag = "2")]
            pub disable_type_inference: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            #[prost(string, tag = "10")]
            Schedule(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceSpec {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "resource_spec::Type", tag = "2")]
        pub r#type: i32,
        #[prost(enumeration = "resource_spec::AccessMode", tag = "5")]
        pub read_access_mode: i32,
    }
    /// Nested message and enum types in `ResourceSpec`.
    pub mod resource_spec {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            StorageBucket = 1,
            BigqueryDataset = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::StorageBucket => "STORAGE_BUCKET",
                    Type::BigqueryDataset => "BIGQUERY_DATASET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "STORAGE_BUCKET" => Some(Self::StorageBucket),
                    "BIGQUERY_DATASET" => Some(Self::BigqueryDataset),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AccessMode {
            Unspecified = 0,
            Direct = 1,
            Managed = 2,
        }
        impl AccessMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    AccessMode::Unspecified => "ACCESS_MODE_UNSPECIFIED",
                    AccessMode::Direct => "DIRECT",
                    AccessMode::Managed => "MANAGED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACCESS_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "DIRECT" => Some(Self::Direct),
                    "MANAGED" => Some(Self::Managed),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceStatus {
        #[prost(enumeration = "resource_status::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "4")]
        pub managed_access_identity: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ResourceStatus`.
    pub mod resource_status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Ready = 1,
            Error = 2,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::Ready => "READY",
                    State::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "READY" => Some(Self::Ready),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoveryStatus {
        #[prost(enumeration = "discovery_status::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "4")]
        pub last_run_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "6")]
        pub stats: ::core::option::Option<discovery_status::Stats>,
        #[prost(message, optional, tag = "7")]
        pub last_run_duration: ::core::option::Option<::prost_types::Duration>,
    }
    /// Nested message and enum types in `DiscoveryStatus`.
    pub mod discovery_status {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Stats {
            #[prost(int64, tag = "1")]
            pub data_items: i64,
            #[prost(int64, tag = "2")]
            pub data_size: i64,
            #[prost(int64, tag = "3")]
            pub tables: i64,
            #[prost(int64, tag = "4")]
            pub filesets: i64,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Scheduled = 1,
            InProgress = 2,
            Paused = 3,
            Disabled = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::Scheduled => "SCHEDULED",
                    State::InProgress => "IN_PROGRESS",
                    State::Paused => "PAUSED",
                    State::Disabled => "DISABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SCHEDULED" => Some(Self::Scheduled),
                    "IN_PROGRESS" => Some(Self::InProgress),
                    "PAUSED" => Some(Self::Paused),
                    "DISABLED" => Some(Self::Disabled),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    Unspecified = 0,
    Active = 1,
    Creating = 2,
    Deleting = 3,
    ActionRequired = 4,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            State::Unspecified => "STATE_UNSPECIFIED",
            State::Active => "ACTIVE",
            State::Creating => "CREATING",
            State::Deleting => "DELETING",
            State::ActionRequired => "ACTION_REQUIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVE" => Some(Self::Active),
            "CREATING" => Some(Self::Creating),
            "DELETING" => Some(Self::Deleting),
            "ACTION_REQUIRED" => Some(Self::ActionRequired),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Environment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    #[prost(message, optional, tag = "100")]
    pub infrastructure_spec: ::core::option::Option<environment::InfrastructureSpec>,
    #[prost(message, optional, tag = "101")]
    pub session_spec: ::core::option::Option<environment::SessionSpec>,
    #[prost(message, optional, tag = "102")]
    pub session_status: ::core::option::Option<environment::SessionStatus>,
    #[prost(message, optional, tag = "200")]
    pub endpoints: ::core::option::Option<environment::Endpoints>,
}
/// Nested message and enum types in `Environment`.
pub mod environment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InfrastructureSpec {
        #[prost(oneof = "infrastructure_spec::Resources", tags = "50")]
        pub resources: ::core::option::Option<infrastructure_spec::Resources>,
        #[prost(oneof = "infrastructure_spec::Runtime", tags = "100")]
        pub runtime: ::core::option::Option<infrastructure_spec::Runtime>,
    }
    /// Nested message and enum types in `InfrastructureSpec`.
    pub mod infrastructure_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ComputeResources {
            #[prost(int32, tag = "1")]
            pub disk_size_gb: i32,
            #[prost(int32, tag = "2")]
            pub node_count: i32,
            #[prost(int32, tag = "3")]
            pub max_node_count: i32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OsImageRuntime {
            #[prost(string, tag = "1")]
            pub image_version: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub java_libraries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, repeated, tag = "3")]
            pub python_packages: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            #[prost(map = "string, string", tag = "4")]
            pub properties: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Resources {
            #[prost(message, tag = "50")]
            Compute(ComputeResources),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Runtime {
            #[prost(message, tag = "100")]
            OsImage(OsImageRuntime),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SessionSpec {
        #[prost(message, optional, tag = "1")]
        pub max_idle_duration: ::core::option::Option<::prost_types::Duration>,
        #[prost(bool, tag = "2")]
        pub enable_fast_startup: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SessionStatus {
        #[prost(bool, tag = "1")]
        pub active: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Endpoints {
        #[prost(string, tag = "1")]
        pub notebooks: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub sql: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(oneof = "content::Data", tags = "9")]
    pub data: ::core::option::Option<content::Data>,
    #[prost(oneof = "content::Content", tags = "100, 101")]
    pub content: ::core::option::Option<content::Content>,
}
/// Nested message and enum types in `Content`.
pub mod content {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SqlScript {
        #[prost(enumeration = "sql_script::QueryEngine", tag = "1")]
        pub engine: i32,
    }
    /// Nested message and enum types in `SqlScript`.
    pub mod sql_script {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum QueryEngine {
            Unspecified = 0,
            Spark = 2,
        }
        impl QueryEngine {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    QueryEngine::Unspecified => "QUERY_ENGINE_UNSPECIFIED",
                    QueryEngine::Spark => "SPARK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "QUERY_ENGINE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SPARK" => Some(Self::Spark),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Notebook {
        #[prost(enumeration = "notebook::KernelType", tag = "1")]
        pub kernel_type: i32,
    }
    /// Nested message and enum types in `Notebook`.
    pub mod notebook {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum KernelType {
            Unspecified = 0,
            Python3 = 1,
        }
        impl KernelType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    KernelType::Unspecified => "KERNEL_TYPE_UNSPECIFIED",
                    KernelType::Python3 => "PYTHON3",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KERNEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "PYTHON3" => Some(Self::Python3),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(string, tag = "9")]
        DataText(::prost::alloc::string::String),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "100")]
        SqlScript(SqlScript),
        #[prost(message, tag = "101")]
        Notebook(Notebook),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "State", tag = "4")]
    pub state: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "State", tag = "7")]
    pub state: i32,
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "100")]
    pub trigger_spec: ::core::option::Option<task::TriggerSpec>,
    #[prost(message, optional, tag = "101")]
    pub execution_spec: ::core::option::Option<task::ExecutionSpec>,
    #[prost(message, optional, tag = "201")]
    pub execution_status: ::core::option::Option<task::ExecutionStatus>,
    #[prost(oneof = "task::Config", tags = "300, 302")]
    pub config: ::core::option::Option<task::Config>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InfrastructureSpec {
        #[prost(oneof = "infrastructure_spec::Resources", tags = "52")]
        pub resources: ::core::option::Option<infrastructure_spec::Resources>,
        #[prost(oneof = "infrastructure_spec::Runtime", tags = "101")]
        pub runtime: ::core::option::Option<infrastructure_spec::Runtime>,
        #[prost(oneof = "infrastructure_spec::Network", tags = "150")]
        pub network: ::core::option::Option<infrastructure_spec::Network>,
    }
    /// Nested message and enum types in `InfrastructureSpec`.
    pub mod infrastructure_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct BatchComputeResources {
            #[prost(int32, tag = "1")]
            pub executors_count: i32,
            #[prost(int32, tag = "2")]
            pub max_executors_count: i32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ContainerImageRuntime {
            #[prost(string, tag = "1")]
            pub image: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub java_jars: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, repeated, tag = "3")]
            pub python_packages: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            #[prost(map = "string, string", tag = "4")]
            pub properties: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct VpcNetwork {
            #[prost(string, repeated, tag = "3")]
            pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(oneof = "vpc_network::NetworkName", tags = "1, 2")]
            pub network_name: ::core::option::Option<vpc_network::NetworkName>,
        }
        /// Nested message and enum types in `VpcNetwork`.
        pub mod vpc_network {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum NetworkName {
                #[prost(string, tag = "1")]
                Network(::prost::alloc::string::String),
                #[prost(string, tag = "2")]
                SubNetwork(::prost::alloc::string::String),
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Resources {
            #[prost(message, tag = "52")]
            Batch(BatchComputeResources),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Runtime {
            #[prost(message, tag = "101")]
            ContainerImage(ContainerImageRuntime),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Network {
            #[prost(message, tag = "150")]
            VpcNetwork(VpcNetwork),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TriggerSpec {
        #[prost(enumeration = "trigger_spec::Type", tag = "5")]
        pub r#type: i32,
        #[prost(message, optional, tag = "6")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(bool, tag = "4")]
        pub disabled: bool,
        #[prost(int32, tag = "7")]
        pub max_retries: i32,
        #[prost(oneof = "trigger_spec::Trigger", tags = "100")]
        pub trigger: ::core::option::Option<trigger_spec::Trigger>,
    }
    /// Nested message and enum types in `TriggerSpec`.
    pub mod trigger_spec {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            OnDemand = 1,
            Recurring = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::OnDemand => "ON_DEMAND",
                    Type::Recurring => "RECURRING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ON_DEMAND" => Some(Self::OnDemand),
                    "RECURRING" => Some(Self::Recurring),
                    _ => None,
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            #[prost(string, tag = "100")]
            Schedule(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionSpec {
        #[prost(map = "string, string", tag = "4")]
        pub args: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "5")]
        pub service_account: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub project: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "8")]
        pub max_job_execution_lifetime: ::core::option::Option<::prost_types::Duration>,
        #[prost(string, tag = "9")]
        pub kms_key: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SparkTaskConfig {
        #[prost(string, repeated, tag = "3")]
        pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub archive_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "6")]
        pub infrastructure_spec: ::core::option::Option<InfrastructureSpec>,
        #[prost(oneof = "spark_task_config::Driver", tags = "100, 101, 102, 104, 105")]
        pub driver: ::core::option::Option<spark_task_config::Driver>,
    }
    /// Nested message and enum types in `SparkTaskConfig`.
    pub mod spark_task_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Driver {
            #[prost(string, tag = "100")]
            MainJarFileUri(::prost::alloc::string::String),
            #[prost(string, tag = "101")]
            MainClass(::prost::alloc::string::String),
            #[prost(string, tag = "102")]
            PythonScriptFile(::prost::alloc::string::String),
            #[prost(string, tag = "104")]
            SqlScriptFile(::prost::alloc::string::String),
            #[prost(string, tag = "105")]
            SqlScript(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotebookTaskConfig {
        #[prost(string, tag = "4")]
        pub notebook: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub infrastructure_spec: ::core::option::Option<InfrastructureSpec>,
        #[prost(string, repeated, tag = "5")]
        pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "6")]
        pub archive_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionStatus {
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "9")]
        pub latest_job: ::core::option::Option<super::Job>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        #[prost(message, tag = "300")]
        Spark(SparkTaskConfig),
        #[prost(message, tag = "302")]
        Notebook(NotebookTaskConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "job::State", tag = "5")]
    pub state: i32,
    #[prost(uint32, tag = "6")]
    pub retry_count: u32,
    #[prost(enumeration = "job::Service", tag = "7")]
    pub service: i32,
    #[prost(string, tag = "8")]
    pub service_job: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "job::Trigger", tag = "11")]
    pub trigger: i32,
    #[prost(message, optional, tag = "100")]
    pub execution_spec: ::core::option::Option<task::ExecutionSpec>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Service {
        Unspecified = 0,
        Dataproc = 1,
    }
    impl Service {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Service::Unspecified => "SERVICE_UNSPECIFIED",
                Service::Dataproc => "DATAPROC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATAPROC" => Some(Self::Dataproc),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Running = 1,
        Cancelling = 2,
        Cancelled = 3,
        Succeeded = 4,
        Failed = 5,
        Aborted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Running => "RUNNING",
                State::Cancelling => "CANCELLING",
                State::Cancelled => "CANCELLED",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Aborted => "ABORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "CANCELLING" => Some(Self::Cancelling),
                "CANCELLED" => Some(Self::Cancelled),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "ABORTED" => Some(Self::Aborted),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Trigger {
        Unspecified = 0,
        TaskConfig = 1,
        RunRequest = 2,
    }
    impl Trigger {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Trigger::Unspecified => "TRIGGER_UNSPECIFIED",
                Trigger::TaskConfig => "TASK_CONFIG",
                Trigger::RunRequest => "RUN_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRIGGER_UNSPECIFIED" => Some(Self::Unspecified),
                "TASK_CONFIG" => Some(Self::TaskConfig),
                "RUN_REQUEST" => Some(Self::RunRequest),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLakeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub lake_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub lake: ::core::option::Option<Lake>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateLakeRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub lake: ::core::option::Option<Lake>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLakeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLakesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLakesResponse {
    #[prost(message, repeated, tag = "1")]
    pub lakes: ::prost::alloc::vec::Vec<Lake>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLakeActionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLakeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateZoneRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub zone: ::core::option::Option<Zone>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateZoneRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub zone: ::core::option::Option<Zone>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteZoneRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesResponse {
    #[prost(message, repeated, tag = "1")]
    pub zones: ::prost::alloc::vec::Vec<Zone>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZoneActionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub asset_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub asset: ::core::option::Option<Asset>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAssetRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<Asset>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAssetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetActionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTaskRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub task: ::core::option::Option<Task>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTaskRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub task: ::core::option::Option<Task>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTaskRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksResponse {
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunTaskRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "4")]
    pub args: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunTaskResponse {
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<Job>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub jobs: ::prost::alloc::vec::Vec<Job>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEnvironmentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub environment_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub environment: ::core::option::Option<Environment>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEnvironmentRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub environment: ::core::option::Option<Environment>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEnvironmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnvironmentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnvironmentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub environments: ::prost::alloc::vec::Vec<Environment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEnvironmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod dataplex_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Dataplex service provides data lakes as a service. The primary resources
    /// offered by this service are Lakes, Zones and Assets which collectively allow
    /// a data administrator to organize, manage, secure and catalog data across
    /// their organization located across cloud projects in a variety of storage
    /// systems including Cloud Storage and BigQuery.
    #[derive(Debug, Clone)]
    pub struct DataplexServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DataplexServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataplexServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DataplexServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a lake resource.
        pub async fn create_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateLakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a lake resource.
        pub async fn update_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateLakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a lake resource. All zones within the lake must be deleted before
        /// the lake can be deleted.
        pub async fn delete_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteLakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists lake resources in a project and location.
        pub async fn list_lakes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLakesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLakesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListLakes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListLakes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a lake resource.
        pub async fn get_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLakeRequest>,
        ) -> std::result::Result<tonic::Response<super::Lake>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists action resources in a lake.
        pub async fn list_lake_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLakeActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListLakeActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListLakeActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a zone resource within a lake.
        pub async fn create_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a zone resource.
        pub async fn update_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a zone resource. All assets within a zone must be deleted before
        /// the zone can be deleted.
        pub async fn delete_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists zone resources in a lake.
        pub async fn list_zones(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZonesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListZonesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListZones",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListZones",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a zone resource.
        pub async fn get_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::GetZoneRequest>,
        ) -> std::result::Result<tonic::Response<super::Zone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists action resources in a zone.
        pub async fn list_zone_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZoneActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListZoneActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListZoneActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an asset resource.
        pub async fn create_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an asset resource.
        pub async fn update_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an asset resource. The referenced storage resource is detached
        /// (default) or deleted based on the associated Lifecycle policy.
        pub async fn delete_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists asset resources in a zone.
        pub async fn list_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an asset resource.
        pub async fn get_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetRequest>,
        ) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists action resources in an asset.
        pub async fn list_asset_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListAssetActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListAssetActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a task resource within a lake.
        pub async fn create_task(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the task resource.
        pub async fn update_task(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete the task resource.
        pub async fn delete_task(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists tasks under the given lake.
        pub async fn list_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTasksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTasksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListTasks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get task resource.
        pub async fn get_task(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::Task>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Jobs under the given task.
        pub async fn list_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Run an on demand execution of a Task.
        pub async fn run_task(
            &mut self,
            request: impl tonic::IntoRequest<super::RunTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RunTaskResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/RunTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "RunTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get job resource.
        pub async fn get_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.dataplex.v1.DataplexService", "GetJob"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancel jobs running for the task resource.
        pub async fn cancel_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CancelJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CancelJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create an environment resource.
        pub async fn create_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEnvironmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the environment resource.
        pub async fn update_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEnvironmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete the environment resource. All the child resources must have been
        /// deleted before environment deletion can be initiated.
        pub async fn delete_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEnvironmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists environments under the given lake.
        pub async fn list_environments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEnvironmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEnvironmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListEnvironments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListEnvironments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get environment resource.
        pub async fn get_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEnvironmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Environment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists session resources in an environment.
        pub async fn list_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSessionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSessionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListSessions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataTaxonomy {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "9")]
    pub attribute_count: i32,
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub class_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttribute {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "9")]
    pub attribute_count: i32,
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub resource_access_spec: ::core::option::Option<ResourceAccessSpec>,
    #[prost(message, optional, tag = "101")]
    pub data_access_spec: ::core::option::Option<DataAccessSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeBinding {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "110")]
    pub attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "120")]
    pub paths: ::prost::alloc::vec::Vec<data_attribute_binding::Path>,
    #[prost(oneof = "data_attribute_binding::ResourceReference", tags = "100")]
    pub resource_reference: ::core::option::Option<
        data_attribute_binding::ResourceReference,
    >,
}
/// Nested message and enum types in `DataAttributeBinding`.
pub mod data_attribute_binding {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Path {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResourceReference {
        #[prost(string, tag = "100")]
        Resource(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataTaxonomyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub data_taxonomy_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data_taxonomy: ::core::option::Option<DataTaxonomy>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataTaxonomyRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub data_taxonomy: ::core::option::Option<DataTaxonomy>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataTaxonomyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataTaxonomiesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataTaxonomiesResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_taxonomies: ::prost::alloc::vec::Vec<DataTaxonomy>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataTaxonomyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataAttributeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub data_attribute_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data_attribute: ::core::option::Option<DataAttribute>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataAttributeRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub data_attribute: ::core::option::Option<DataAttribute>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataAttributeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributesResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_attributes: ::prost::alloc::vec::Vec<DataAttribute>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataAttributeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataAttributeBindingRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub data_attribute_binding_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data_attribute_binding: ::core::option::Option<DataAttributeBinding>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataAttributeBindingRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub data_attribute_binding: ::core::option::Option<DataAttributeBinding>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataAttributeBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributeBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributeBindingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_attribute_bindings: ::prost::alloc::vec::Vec<DataAttributeBinding>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataAttributeBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod data_taxonomy_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// DataTaxonomyService enables attribute-based governance. The resources
    /// currently offered include DataTaxonomy and DataAttribute.
    #[derive(Debug, Clone)]
    pub struct DataTaxonomyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DataTaxonomyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataTaxonomyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DataTaxonomyServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a DataTaxonomy resource.
        pub async fn create_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataTaxonomyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/CreateDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "CreateDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataTaxonomy resource.
        pub async fn update_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataTaxonomyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/UpdateDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "UpdateDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DataTaxonomy resource. All attributes within the DataTaxonomy
        /// must be deleted before the DataTaxonomy can be deleted.
        pub async fn delete_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataTaxonomyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/DeleteDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "DeleteDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataTaxonomy resources in a project and location.
        pub async fn list_data_taxonomies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataTaxonomiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataTaxonomiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/ListDataTaxonomies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "ListDataTaxonomies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a DataTaxonomy resource.
        pub async fn get_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataTaxonomyRequest>,
        ) -> std::result::Result<tonic::Response<super::DataTaxonomy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/GetDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "GetDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a DataAttributeBinding resource.
        pub async fn create_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/CreateDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "CreateDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataAttributeBinding resource.
        pub async fn update_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/UpdateDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "UpdateDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DataAttributeBinding resource. All attributes within the
        /// DataAttributeBinding must be deleted before the DataAttributeBinding can be
        /// deleted.
        pub async fn delete_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/DeleteDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "DeleteDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataAttributeBinding resources in a project and location.
        pub async fn list_data_attribute_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataAttributeBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataAttributeBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/ListDataAttributeBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "ListDataAttributeBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a DataAttributeBinding resource.
        pub async fn get_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DataAttributeBinding>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/GetDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "GetDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a DataAttribute resource.
        pub async fn create_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataAttributeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/CreateDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "CreateDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataAttribute resource.
        pub async fn update_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataAttributeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/UpdateDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "UpdateDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Data Attribute resource.
        pub async fn delete_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataAttributeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/DeleteDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "DeleteDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Data Attribute resources in a DataTaxonomy.
        pub async fn list_data_attributes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataAttributesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataAttributesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/ListDataAttributes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "ListDataAttributes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a Data Attribute resource.
        pub async fn get_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::DataAttribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/GetDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "GetDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AspectType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "52")]
    pub authorization: ::core::option::Option<aspect_type::Authorization>,
    #[prost(message, optional, tag = "53")]
    pub metadata_template: ::core::option::Option<aspect_type::MetadataTemplate>,
    #[prost(enumeration = "TransferStatus", tag = "202")]
    pub transfer_status: i32,
}
/// Nested message and enum types in `AspectType`.
pub mod aspect_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Authorization {
        #[prost(string, tag = "1")]
        pub alternate_use_permission: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetadataTemplate {
        #[prost(int32, tag = "1")]
        pub index: i32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "6")]
        pub record_fields: ::prost::alloc::vec::Vec<MetadataTemplate>,
        #[prost(message, repeated, tag = "8")]
        pub enum_values: ::prost::alloc::vec::Vec<metadata_template::EnumValue>,
        #[prost(message, optional, boxed, tag = "10")]
        pub map_items: ::core::option::Option<
            ::prost::alloc::boxed::Box<MetadataTemplate>,
        >,
        #[prost(message, optional, boxed, tag = "11")]
        pub array_items: ::core::option::Option<
            ::prost::alloc::boxed::Box<MetadataTemplate>,
        >,
        #[prost(string, tag = "12")]
        pub type_id: ::prost::alloc::string::String,
        #[prost(string, tag = "13")]
        pub type_ref: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "50")]
        pub constraints: ::core::option::Option<metadata_template::Constraints>,
        #[prost(message, optional, tag = "51")]
        pub annotations: ::core::option::Option<metadata_template::Annotations>,
    }
    /// Nested message and enum types in `MetadataTemplate`.
    pub mod metadata_template {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EnumValue {
            #[prost(int32, tag = "1")]
            pub index: i32,
            #[prost(string, tag = "2")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub deprecated: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Constraints {
            #[prost(bool, tag = "1")]
            pub required: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Annotations {
            #[prost(string, tag = "1")]
            pub deprecated: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub display_name: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub description: ::prost::alloc::string::String,
            #[prost(int32, tag = "4")]
            pub display_order: i32,
            #[prost(string, tag = "6")]
            pub string_type: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "7")]
            pub string_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntryGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(enumeration = "TransferStatus", tag = "202")]
    pub transfer_status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntryType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub type_aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "10")]
    pub platform: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub system: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "50")]
    pub required_aspects: ::prost::alloc::vec::Vec<entry_type::AspectInfo>,
    #[prost(message, optional, tag = "51")]
    pub authorization: ::core::option::Option<entry_type::Authorization>,
}
/// Nested message and enum types in `EntryType`.
pub mod entry_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AspectInfo {
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Authorization {
        #[prost(string, tag = "1")]
        pub alternate_use_permission: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aspect {
    #[prost(string, tag = "1")]
    pub aspect_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub data: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, optional, tag = "9")]
    pub aspect_source: ::core::option::Option<AspectSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AspectSource {
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entry {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub entry_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, message", tag = "9")]
    pub aspects: ::std::collections::HashMap<::prost::alloc::string::String, Aspect>,
    #[prost(string, tag = "10")]
    pub parent_entry: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub fully_qualified_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub entry_source: ::core::option::Option<EntrySource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntrySource {
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub system: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub platform: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "9")]
    pub ancestors: ::prost::alloc::vec::Vec<entry_source::Ancestor>,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "12")]
    pub location: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EntrySource`.
pub mod entry_source {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ancestor {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub r#type: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntryGroupRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entry_group_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub entry_group: ::core::option::Option<EntryGroup>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntryGroupRequest {
    #[prost(message, optional, tag = "1")]
    pub entry_group: ::core::option::Option<EntryGroup>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntryGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryGroupsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub entry_groups: ::prost::alloc::vec::Vec<EntryGroup>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntryGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntryTypeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entry_type_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub entry_type: ::core::option::Option<EntryType>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntryTypeRequest {
    #[prost(message, optional, tag = "1")]
    pub entry_type: ::core::option::Option<EntryType>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntryTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entry_types: ::prost::alloc::vec::Vec<EntryType>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntryTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAspectTypeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub aspect_type_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub aspect_type: ::core::option::Option<AspectType>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAspectTypeRequest {
    #[prost(message, optional, tag = "1")]
    pub aspect_type: ::core::option::Option<AspectType>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAspectTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAspectTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAspectTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub aspect_types: ::prost::alloc::vec::Vec<AspectType>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAspectTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntryRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entry_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub entry: ::core::option::Option<Entry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntryRequest {
    #[prost(message, optional, tag = "1")]
    pub entry: ::core::option::Option<Entry>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    #[prost(bool, tag = "4")]
    pub delete_missing_aspects: bool,
    #[prost(string, repeated, tag = "5")]
    pub aspect_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntryRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<Entry>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntryRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "EntryView", tag = "2")]
    pub view: i32,
    #[prost(string, repeated, tag = "3")]
    pub aspect_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupEntryRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "EntryView", tag = "2")]
    pub view: i32,
    #[prost(string, repeated, tag = "3")]
    pub aspect_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub entry: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntriesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub scope: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntriesResult {
    #[deprecated]
    #[prost(string, tag = "8")]
    pub linked_resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub dataplex_entry: ::core::option::Option<Entry>,
    #[deprecated]
    #[prost(message, optional, tag = "12")]
    pub snippets: ::core::option::Option<search_entries_result::Snippets>,
}
/// Nested message and enum types in `SearchEntriesResult`.
pub mod search_entries_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Snippets {
        #[deprecated]
        #[prost(message, optional, tag = "1")]
        pub dataplex_entry: ::core::option::Option<super::Entry>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<SearchEntriesResult>,
    #[prost(int32, tag = "2")]
    pub total_size: i32,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntryView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
    Custom = 3,
    All = 4,
}
impl EntryView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EntryView::Unspecified => "ENTRY_VIEW_UNSPECIFIED",
            EntryView::Basic => "BASIC",
            EntryView::Full => "FULL",
            EntryView::Custom => "CUSTOM",
            EntryView::All => "ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTRY_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIC" => Some(Self::Basic),
            "FULL" => Some(Self::Full),
            "CUSTOM" => Some(Self::Custom),
            "ALL" => Some(Self::All),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransferStatus {
    Unspecified = 0,
    Migrated = 1,
    Transferred = 2,
}
impl TransferStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransferStatus::Unspecified => "TRANSFER_STATUS_UNSPECIFIED",
            TransferStatus::Migrated => "TRANSFER_STATUS_MIGRATED",
            TransferStatus::Transferred => "TRANSFER_STATUS_TRANSFERRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSFER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSFER_STATUS_MIGRATED" => Some(Self::Migrated),
            "TRANSFER_STATUS_TRANSFERRED" => Some(Self::Transferred),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod catalog_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The primary resources offered by this service are EntryGroups, EntryTypes,
    /// AspectTypes, Entry and Aspect which collectively allow a data administrator
    /// to organize, manage, secure and catalog data across their organization
    /// located across cloud projects in a variety of storage systems including Cloud
    /// Storage and BigQuery.
    #[derive(Debug, Clone)]
    pub struct CatalogServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CatalogServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CatalogServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            CatalogServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates an EntryType
        pub async fn create_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntryTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a EntryType resource.
        pub async fn update_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntryTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a EntryType resource.
        pub async fn delete_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntryTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists EntryType resources in a project and location.
        pub async fn list_entry_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntryTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntryTypesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListEntryTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListEntryTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a EntryType resource.
        pub async fn get_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntryTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::EntryType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an AspectType
        pub async fn create_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAspectTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a AspectType resource.
        pub async fn update_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAspectTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a AspectType resource.
        pub async fn delete_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAspectTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists AspectType resources in a project and location.
        pub async fn list_aspect_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAspectTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAspectTypesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListAspectTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListAspectTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a AspectType resource.
        pub async fn get_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAspectTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::AspectType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an EntryGroup
        pub async fn create_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntryGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a EntryGroup resource.
        pub async fn update_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntryGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a EntryGroup resource.
        pub async fn delete_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntryGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists EntryGroup resources in a project and location.
        pub async fn list_entry_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntryGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntryGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListEntryGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListEntryGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a EntryGroup resource.
        pub async fn get_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntryGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::EntryGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an Entry.
        pub async fn create_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an Entry.
        pub async fn update_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an Entry.
        pub async fn delete_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists entries within an entry group.
        pub async fn list_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single entry.
        pub async fn get_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Looks up a single entry.
        pub async fn lookup_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/LookupEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "LookupEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for entries matching given query and scope.
        pub async fn search_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/SearchEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "SearchEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContentRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContentResponse {
    #[prost(message, repeated, tag = "1")]
    pub content: ::prost::alloc::vec::Vec<Content>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "get_content_request::ContentView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetContentRequest`.
pub mod get_content_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentView {
        Unspecified = 0,
        Basic = 1,
        Full = 2,
    }
    impl ContentView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContentView::Unspecified => "CONTENT_VIEW_UNSPECIFIED",
                ContentView::Basic => "BASIC",
                ContentView::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTENT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod content_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// ContentService manages Notebook and SQL Scripts for Dataplex.
    #[derive(Debug, Clone)]
    pub struct ContentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ContentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ContentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a content.
        pub async fn create_content(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateContentRequest>,
        ) -> std::result::Result<tonic::Response<super::Content>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/CreateContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "CreateContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a content. Only supports full resource update.
        pub async fn update_content(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateContentRequest>,
        ) -> std::result::Result<tonic::Response<super::Content>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/UpdateContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "UpdateContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a content.
        pub async fn delete_content(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteContentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/DeleteContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "DeleteContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a content resource.
        pub async fn get_content(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContentRequest>,
        ) -> std::result::Result<tonic::Response<super::Content>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/GetContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "GetContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a contentitem resource. A `NOT_FOUND`
        /// error is returned if the resource does not exist. An empty policy is
        /// returned if the resource exists but does not have a policy set on it.
        ///
        /// Caller must have Google IAM `dataplex.content.getIamPolicy` permission
        /// on the resource.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified contentitem resource.
        /// Replaces any existing policy.
        ///
        /// Caller must have Google IAM `dataplex.content.setIamPolicy` permission
        /// on the resource.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the caller's permissions on a resource.
        /// If the resource does not exist, an empty set of
        /// permissions is returned (a `NOT_FOUND` error is not returned).
        ///
        /// A caller is not required to have Google IAM permission to make this
        /// request.
        ///
        /// Note: This operation is designed to be used for building permission-aware
        /// UIs and command-line tools, not for authorization checking. This operation
        /// may "fail open" without warning.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::TestIamPermissionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::super::super::iam::v1::TestIamPermissionsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List content.
        pub async fn list_content(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/ListContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "ListContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trigger {
    #[prost(oneof = "trigger::Mode", tags = "100, 101")]
    pub mode: ::core::option::Option<trigger::Mode>,
}
/// Nested message and enum types in `Trigger`.
pub mod trigger {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OnDemand {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Schedule {
        #[prost(string, tag = "1")]
        pub cron: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        #[prost(message, tag = "100")]
        OnDemand(OnDemand),
        #[prost(message, tag = "101")]
        Schedule(Schedule),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSource {
    #[prost(oneof = "data_source::Source", tags = "100, 101")]
    pub source: ::core::option::Option<data_source::Source>,
}
/// Nested message and enum types in `DataSource`.
pub mod data_source {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(string, tag = "100")]
        Entity(::prost::alloc::string::String),
        #[prost(string, tag = "101")]
        Resource(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScannedData {
    #[prost(oneof = "scanned_data::DataRange", tags = "1")]
    pub data_range: ::core::option::Option<scanned_data::DataRange>,
}
/// Nested message and enum types in `ScannedData`.
pub mod scanned_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IncrementalField {
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub start: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub end: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataRange {
        #[prost(message, tag = "1")]
        IncrementalField(IncrementalField),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataProfileSpec {
    #[prost(float, tag = "2")]
    pub sampling_percent: f32,
    #[prost(string, tag = "3")]
    pub row_filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub post_scan_actions: ::core::option::Option<data_profile_spec::PostScanActions>,
    #[prost(message, optional, tag = "5")]
    pub include_fields: ::core::option::Option<data_profile_spec::SelectedFields>,
    #[prost(message, optional, tag = "6")]
    pub exclude_fields: ::core::option::Option<data_profile_spec::SelectedFields>,
}
/// Nested message and enum types in `DataProfileSpec`.
pub mod data_profile_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActions {
        #[prost(message, optional, tag = "1")]
        pub bigquery_export: ::core::option::Option<post_scan_actions::BigQueryExport>,
    }
    /// Nested message and enum types in `PostScanActions`.
    pub mod post_scan_actions {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExport {
            #[prost(string, tag = "1")]
            pub results_table: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SelectedFields {
        #[prost(string, repeated, tag = "1")]
        pub field_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataProfileResult {
    #[prost(int64, tag = "3")]
    pub row_count: i64,
    #[prost(message, optional, tag = "4")]
    pub profile: ::core::option::Option<data_profile_result::Profile>,
    #[prost(message, optional, tag = "5")]
    pub scanned_data: ::core::option::Option<ScannedData>,
    #[prost(message, optional, tag = "6")]
    pub post_scan_actions_result: ::core::option::Option<
        data_profile_result::PostScanActionsResult,
    >,
}
/// Nested message and enum types in `DataProfileResult`.
pub mod data_profile_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Profile {
        #[prost(message, repeated, tag = "2")]
        pub fields: ::prost::alloc::vec::Vec<profile::Field>,
    }
    /// Nested message and enum types in `Profile`.
    pub mod profile {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Field {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub r#type: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub mode: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "4")]
            pub profile: ::core::option::Option<field::ProfileInfo>,
        }
        /// Nested message and enum types in `Field`.
        pub mod field {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ProfileInfo {
                #[prost(double, tag = "2")]
                pub null_ratio: f64,
                #[prost(double, tag = "3")]
                pub distinct_ratio: f64,
                #[prost(message, repeated, tag = "4")]
                pub top_n_values: ::prost::alloc::vec::Vec<profile_info::TopNValue>,
                #[prost(oneof = "profile_info::FieldInfo", tags = "101, 102, 103")]
                pub field_info: ::core::option::Option<profile_info::FieldInfo>,
            }
            /// Nested message and enum types in `ProfileInfo`.
            pub mod profile_info {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct StringFieldInfo {
                    #[prost(int64, tag = "1")]
                    pub min_length: i64,
                    #[prost(int64, tag = "2")]
                    pub max_length: i64,
                    #[prost(double, tag = "3")]
                    pub average_length: f64,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct IntegerFieldInfo {
                    #[prost(double, tag = "1")]
                    pub average: f64,
                    #[prost(double, tag = "3")]
                    pub standard_deviation: f64,
                    #[prost(int64, tag = "4")]
                    pub min: i64,
                    #[prost(int64, repeated, tag = "6")]
                    pub quartiles: ::prost::alloc::vec::Vec<i64>,
                    #[prost(int64, tag = "5")]
                    pub max: i64,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct DoubleFieldInfo {
                    #[prost(double, tag = "1")]
                    pub average: f64,
                    #[prost(double, tag = "3")]
                    pub standard_deviation: f64,
                    #[prost(double, tag = "4")]
                    pub min: f64,
                    #[prost(double, repeated, tag = "6")]
                    pub quartiles: ::prost::alloc::vec::Vec<f64>,
                    #[prost(double, tag = "5")]
                    pub max: f64,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TopNValue {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                    #[prost(int64, tag = "2")]
                    pub count: i64,
                    #[prost(double, tag = "3")]
                    pub ratio: f64,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum FieldInfo {
                    #[prost(message, tag = "101")]
                    StringProfile(StringFieldInfo),
                    #[prost(message, tag = "102")]
                    IntegerProfile(IntegerFieldInfo),
                    #[prost(message, tag = "103")]
                    DoubleProfile(DoubleFieldInfo),
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActionsResult {
        #[prost(message, optional, tag = "1")]
        pub bigquery_export_result: ::core::option::Option<
            post_scan_actions_result::BigQueryExportResult,
        >,
    }
    /// Nested message and enum types in `PostScanActionsResult`.
    pub mod post_scan_actions_result {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExportResult {
            #[prost(enumeration = "big_query_export_result::State", tag = "1")]
            pub state: i32,
            #[prost(string, tag = "2")]
            pub message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BigQueryExportResult`.
        pub mod big_query_export_result {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum State {
                Unspecified = 0,
                Succeeded = 1,
                Failed = 2,
                Skipped = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        State::Unspecified => "STATE_UNSPECIFIED",
                        State::Succeeded => "SUCCEEDED",
                        State::Failed => "FAILED",
                        State::Skipped => "SKIPPED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SUCCEEDED" => Some(Self::Succeeded),
                        "FAILED" => Some(Self::Failed),
                        "SKIPPED" => Some(Self::Skipped),
                        _ => None,
                    }
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntityRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub entity: ::core::option::Option<Entity>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntityRequest {
    #[prost(message, optional, tag = "2")]
    pub entity: ::core::option::Option<Entity>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntityRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitiesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "list_entities_request::EntityView", tag = "2")]
    pub view: i32,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ListEntitiesRequest`.
pub mod list_entities_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EntityView {
        Unspecified = 0,
        Tables = 1,
        Filesets = 2,
    }
    impl EntityView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EntityView::Unspecified => "ENTITY_VIEW_UNSPECIFIED",
                EntityView::Tables => "TABLES",
                EntityView::Filesets => "FILESETS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "TABLES" => Some(Self::Tables),
                "FILESETS" => Some(Self::Filesets),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitiesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entities: ::prost::alloc::vec::Vec<Entity>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntityRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "get_entity_request::EntityView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetEntityRequest`.
pub mod get_entity_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EntityView {
        Unspecified = 0,
        Basic = 1,
        Schema = 2,
        Full = 4,
    }
    impl EntityView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EntityView::Unspecified => "ENTITY_VIEW_UNSPECIFIED",
                EntityView::Basic => "BASIC",
                EntityView::Schema => "SCHEMA",
                EntityView::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "SCHEMA" => Some(Self::Schema),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartitionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePartitionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub partition: ::core::option::Option<Partition>,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePartitionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartitionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub partitions: ::prost::alloc::vec::Vec<Partition>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPartitionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "7")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(enumeration = "entity::Type", tag = "10")]
    pub r#type: i32,
    #[prost(string, tag = "11")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub data_path: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub data_path_pattern: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub catalog_entry: ::prost::alloc::string::String,
    #[prost(enumeration = "StorageSystem", tag = "15")]
    pub system: i32,
    #[prost(message, optional, tag = "16")]
    pub format: ::core::option::Option<StorageFormat>,
    #[prost(message, optional, tag = "19")]
    pub compatibility: ::core::option::Option<entity::CompatibilityStatus>,
    #[prost(message, optional, tag = "21")]
    pub access: ::core::option::Option<StorageAccess>,
    #[prost(string, tag = "22")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "50")]
    pub schema: ::core::option::Option<Schema>,
}
/// Nested message and enum types in `Entity`.
pub mod entity {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompatibilityStatus {
        #[prost(message, optional, tag = "1")]
        pub hive_metastore: ::core::option::Option<compatibility_status::Compatibility>,
        #[prost(message, optional, tag = "2")]
        pub bigquery: ::core::option::Option<compatibility_status::Compatibility>,
    }
    /// Nested message and enum types in `CompatibilityStatus`.
    pub mod compatibility_status {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Compatibility {
            #[prost(bool, tag = "1")]
            pub compatible: bool,
            #[prost(string, tag = "2")]
            pub reason: ::prost::alloc::string::String,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Table = 1,
        Fileset = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Table => "TABLE",
                Type::Fileset => "FILESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TABLE" => Some(Self::Table),
                "FILESET" => Some(Self::Fileset),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Partition {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub location: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(bool, tag = "1")]
    pub user_managed: bool,
    #[prost(message, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<schema::SchemaField>,
    #[prost(message, repeated, tag = "3")]
    pub partition_fields: ::prost::alloc::vec::Vec<schema::PartitionField>,
    #[prost(enumeration = "schema::PartitionStyle", tag = "4")]
    pub partition_style: i32,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SchemaField {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(enumeration = "Type", tag = "3")]
        pub r#type: i32,
        #[prost(enumeration = "Mode", tag = "4")]
        pub mode: i32,
        #[prost(message, repeated, tag = "10")]
        pub fields: ::prost::alloc::vec::Vec<SchemaField>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartitionField {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "Type", tag = "2")]
        pub r#type: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Boolean = 1,
        Byte = 2,
        Int16 = 3,
        Int32 = 4,
        Int64 = 5,
        Float = 6,
        Double = 7,
        Decimal = 8,
        String = 9,
        Binary = 10,
        Timestamp = 11,
        Date = 12,
        Time = 13,
        Record = 14,
        Null = 100,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Boolean => "BOOLEAN",
                Type::Byte => "BYTE",
                Type::Int16 => "INT16",
                Type::Int32 => "INT32",
                Type::Int64 => "INT64",
                Type::Float => "FLOAT",
                Type::Double => "DOUBLE",
                Type::Decimal => "DECIMAL",
                Type::String => "STRING",
                Type::Binary => "BINARY",
                Type::Timestamp => "TIMESTAMP",
                Type::Date => "DATE",
                Type::Time => "TIME",
                Type::Record => "RECORD",
                Type::Null => "NULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BOOLEAN" => Some(Self::Boolean),
                "BYTE" => Some(Self::Byte),
                "INT16" => Some(Self::Int16),
                "INT32" => Some(Self::Int32),
                "INT64" => Some(Self::Int64),
                "FLOAT" => Some(Self::Float),
                "DOUBLE" => Some(Self::Double),
                "DECIMAL" => Some(Self::Decimal),
                "STRING" => Some(Self::String),
                "BINARY" => Some(Self::Binary),
                "TIMESTAMP" => Some(Self::Timestamp),
                "DATE" => Some(Self::Date),
                "TIME" => Some(Self::Time),
                "RECORD" => Some(Self::Record),
                "NULL" => Some(Self::Null),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        Required = 1,
        Nullable = 2,
        Repeated = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::Unspecified => "MODE_UNSPECIFIED",
                Mode::Required => "REQUIRED",
                Mode::Nullable => "NULLABLE",
                Mode::Repeated => "REPEATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "REQUIRED" => Some(Self::Required),
                "NULLABLE" => Some(Self::Nullable),
                "REPEATED" => Some(Self::Repeated),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PartitionStyle {
        Unspecified = 0,
        HiveCompatible = 1,
    }
    impl PartitionStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PartitionStyle::Unspecified => "PARTITION_STYLE_UNSPECIFIED",
                PartitionStyle::HiveCompatible => "HIVE_COMPATIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARTITION_STYLE_UNSPECIFIED" => Some(Self::Unspecified),
                "HIVE_COMPATIBLE" => Some(Self::HiveCompatible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageFormat {
    #[prost(enumeration = "storage_format::Format", tag = "1")]
    pub format: i32,
    #[prost(enumeration = "storage_format::CompressionFormat", tag = "2")]
    pub compression_format: i32,
    #[prost(string, tag = "3")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(oneof = "storage_format::Options", tags = "10, 11, 12")]
    pub options: ::core::option::Option<storage_format::Options>,
}
/// Nested message and enum types in `StorageFormat`.
pub mod storage_format {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CsvOptions {
        #[prost(string, tag = "1")]
        pub encoding: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub header_rows: i32,
        #[prost(string, tag = "3")]
        pub delimiter: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub quote: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JsonOptions {
        #[prost(string, tag = "1")]
        pub encoding: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IcebergOptions {
        #[prost(string, tag = "1")]
        pub metadata_location: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        Unspecified = 0,
        Parquet = 1,
        Avro = 2,
        Orc = 3,
        Csv = 100,
        Json = 101,
        Image = 200,
        Audio = 201,
        Video = 202,
        Text = 203,
        Tfrecord = 204,
        Other = 1000,
        Unknown = 1001,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Format::Unspecified => "FORMAT_UNSPECIFIED",
                Format::Parquet => "PARQUET",
                Format::Avro => "AVRO",
                Format::Orc => "ORC",
                Format::Csv => "CSV",
                Format::Json => "JSON",
                Format::Image => "IMAGE",
                Format::Audio => "AUDIO",
                Format::Video => "VIDEO",
                Format::Text => "TEXT",
                Format::Tfrecord => "TFRECORD",
                Format::Other => "OTHER",
                Format::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "PARQUET" => Some(Self::Parquet),
                "AVRO" => Some(Self::Avro),
                "ORC" => Some(Self::Orc),
                "CSV" => Some(Self::Csv),
                "JSON" => Some(Self::Json),
                "IMAGE" => Some(Self::Image),
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                "TEXT" => Some(Self::Text),
                "TFRECORD" => Some(Self::Tfrecord),
                "OTHER" => Some(Self::Other),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompressionFormat {
        Unspecified = 0,
        Gzip = 2,
        Bzip2 = 3,
    }
    impl CompressionFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompressionFormat::Unspecified => "COMPRESSION_FORMAT_UNSPECIFIED",
                CompressionFormat::Gzip => "GZIP",
                CompressionFormat::Bzip2 => "BZIP2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPRESSION_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "GZIP" => Some(Self::Gzip),
                "BZIP2" => Some(Self::Bzip2),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Options {
        #[prost(message, tag = "10")]
        Csv(CsvOptions),
        #[prost(message, tag = "11")]
        Json(JsonOptions),
        #[prost(message, tag = "12")]
        Iceberg(IcebergOptions),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StorageAccess {
    #[prost(enumeration = "storage_access::AccessMode", tag = "21")]
    pub read: i32,
}
/// Nested message and enum types in `StorageAccess`.
pub mod storage_access {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessMode {
        Unspecified = 0,
        Direct = 1,
        Managed = 2,
    }
    impl AccessMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccessMode::Unspecified => "ACCESS_MODE_UNSPECIFIED",
                AccessMode::Direct => "DIRECT",
                AccessMode::Managed => "MANAGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACCESS_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DIRECT" => Some(Self::Direct),
                "MANAGED" => Some(Self::Managed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageSystem {
    Unspecified = 0,
    CloudStorage = 1,
    Bigquery = 2,
}
impl StorageSystem {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StorageSystem::Unspecified => "STORAGE_SYSTEM_UNSPECIFIED",
            StorageSystem::CloudStorage => "CLOUD_STORAGE",
            StorageSystem::Bigquery => "BIGQUERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORAGE_SYSTEM_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOUD_STORAGE" => Some(Self::CloudStorage),
            "BIGQUERY" => Some(Self::Bigquery),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod metadata_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Metadata service manages metadata resources such as tables, filesets and
    /// partitions.
    #[derive(Debug, Clone)]
    pub struct MetadataServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MetadataServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MetadataServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MetadataServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a metadata entity.
        pub async fn create_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntityRequest>,
        ) -> std::result::Result<tonic::Response<super::Entity>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/CreateEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "CreateEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a metadata entity. Only supports full resource update.
        pub async fn update_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntityRequest>,
        ) -> std::result::Result<tonic::Response<super::Entity>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/UpdateEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "UpdateEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a metadata entity.
        pub async fn delete_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntityRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/DeleteEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "DeleteEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a metadata entity.
        pub async fn get_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntityRequest>,
        ) -> std::result::Result<tonic::Response<super::Entity>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/GetEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "GetEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List metadata entities in a zone.
        pub async fn list_entities(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/ListEntities",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "ListEntities",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a metadata partition.
        pub async fn create_partition(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePartitionRequest>,
        ) -> std::result::Result<tonic::Response<super::Partition>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/CreatePartition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "CreatePartition",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a metadata partition.
        pub async fn delete_partition(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePartitionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/DeletePartition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "DeletePartition",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a metadata partition of an entity.
        pub async fn get_partition(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPartitionRequest>,
        ) -> std::result::Result<tonic::Response<super::Partition>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/GetPartition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "GetPartition",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List metadata partitions of an entity.
        pub async fn list_partitions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPartitionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPartitionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/ListPartitions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "ListPartitions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualitySpec {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<DataQualityRule>,
    #[prost(float, tag = "4")]
    pub sampling_percent: f32,
    #[prost(string, tag = "5")]
    pub row_filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub post_scan_actions: ::core::option::Option<data_quality_spec::PostScanActions>,
}
/// Nested message and enum types in `DataQualitySpec`.
pub mod data_quality_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActions {
        #[prost(message, optional, tag = "1")]
        pub bigquery_export: ::core::option::Option<post_scan_actions::BigQueryExport>,
        #[prost(message, optional, tag = "2")]
        pub notification_report: ::core::option::Option<
            post_scan_actions::NotificationReport,
        >,
    }
    /// Nested message and enum types in `PostScanActions`.
    pub mod post_scan_actions {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExport {
            #[prost(string, tag = "1")]
            pub results_table: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Recipients {
            #[prost(string, repeated, tag = "1")]
            pub emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ScoreThresholdTrigger {
            #[prost(float, tag = "2")]
            pub score_threshold: f32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct JobFailureTrigger {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct JobEndTrigger {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct NotificationReport {
            #[prost(message, optional, tag = "1")]
            pub recipients: ::core::option::Option<Recipients>,
            #[prost(message, optional, tag = "2")]
            pub score_threshold_trigger: ::core::option::Option<ScoreThresholdTrigger>,
            #[prost(message, optional, tag = "4")]
            pub job_failure_trigger: ::core::option::Option<JobFailureTrigger>,
            #[prost(message, optional, tag = "5")]
            pub job_end_trigger: ::core::option::Option<JobEndTrigger>,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityResult {
    #[prost(bool, tag = "5")]
    pub passed: bool,
    #[prost(float, optional, tag = "9")]
    pub score: ::core::option::Option<f32>,
    #[prost(message, repeated, tag = "2")]
    pub dimensions: ::prost::alloc::vec::Vec<DataQualityDimensionResult>,
    #[prost(message, repeated, tag = "10")]
    pub columns: ::prost::alloc::vec::Vec<DataQualityColumnResult>,
    #[prost(message, repeated, tag = "3")]
    pub rules: ::prost::alloc::vec::Vec<DataQualityRuleResult>,
    #[prost(int64, tag = "4")]
    pub row_count: i64,
    #[prost(message, optional, tag = "7")]
    pub scanned_data: ::core::option::Option<ScannedData>,
    #[prost(message, optional, tag = "8")]
    pub post_scan_actions_result: ::core::option::Option<
        data_quality_result::PostScanActionsResult,
    >,
}
/// Nested message and enum types in `DataQualityResult`.
pub mod data_quality_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActionsResult {
        #[prost(message, optional, tag = "1")]
        pub bigquery_export_result: ::core::option::Option<
            post_scan_actions_result::BigQueryExportResult,
        >,
    }
    /// Nested message and enum types in `PostScanActionsResult`.
    pub mod post_scan_actions_result {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExportResult {
            #[prost(enumeration = "big_query_export_result::State", tag = "1")]
            pub state: i32,
            #[prost(string, tag = "2")]
            pub message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BigQueryExportResult`.
        pub mod big_query_export_result {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum State {
                Unspecified = 0,
                Succeeded = 1,
                Failed = 2,
                Skipped = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        State::Unspecified => "STATE_UNSPECIFIED",
                        State::Succeeded => "SUCCEEDED",
                        State::Failed => "FAILED",
                        State::Skipped => "SKIPPED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SUCCEEDED" => Some(Self::Succeeded),
                        "FAILED" => Some(Self::Failed),
                        "SKIPPED" => Some(Self::Skipped),
                        _ => None,
                    }
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityRuleResult {
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<DataQualityRule>,
    #[prost(bool, tag = "7")]
    pub passed: bool,
    #[prost(int64, tag = "9")]
    pub evaluated_count: i64,
    #[prost(int64, tag = "8")]
    pub passed_count: i64,
    #[prost(int64, tag = "5")]
    pub null_count: i64,
    #[prost(double, tag = "6")]
    pub pass_ratio: f64,
    #[prost(string, tag = "10")]
    pub failing_rows_query: ::prost::alloc::string::String,
    #[prost(int64, tag = "11")]
    pub assertion_row_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityDimensionResult {
    #[prost(message, optional, tag = "1")]
    pub dimension: ::core::option::Option<DataQualityDimension>,
    #[prost(bool, tag = "3")]
    pub passed: bool,
    #[prost(float, optional, tag = "4")]
    pub score: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityDimension {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityRule {
    #[prost(string, tag = "500")]
    pub column: ::prost::alloc::string::String,
    #[prost(bool, tag = "501")]
    pub ignore_null: bool,
    #[prost(string, tag = "502")]
    pub dimension: ::prost::alloc::string::String,
    #[prost(double, tag = "503")]
    pub threshold: f64,
    #[prost(string, tag = "504")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "505")]
    pub description: ::prost::alloc::string::String,
    #[prost(
        oneof = "data_quality_rule::RuleType",
        tags = "1, 2, 3, 4, 100, 101, 200, 201, 202"
    )]
    pub rule_type: ::core::option::Option<data_quality_rule::RuleType>,
}
/// Nested message and enum types in `DataQualityRule`.
pub mod data_quality_rule {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RangeExpectation {
        #[prost(string, tag = "1")]
        pub min_value: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub max_value: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub strict_min_enabled: bool,
        #[prost(bool, tag = "4")]
        pub strict_max_enabled: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NonNullExpectation {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetExpectation {
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RegexExpectation {
        #[prost(string, tag = "1")]
        pub regex: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UniquenessExpectation {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatisticRangeExpectation {
        #[prost(enumeration = "statistic_range_expectation::ColumnStatistic", tag = "1")]
        pub statistic: i32,
        #[prost(string, tag = "2")]
        pub min_value: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub max_value: ::prost::alloc::string::String,
        #[prost(bool, tag = "4")]
        pub strict_min_enabled: bool,
        #[prost(bool, tag = "5")]
        pub strict_max_enabled: bool,
    }
    /// Nested message and enum types in `StatisticRangeExpectation`.
    pub mod statistic_range_expectation {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ColumnStatistic {
            StatisticUndefined = 0,
            Mean = 1,
            Min = 2,
            Max = 3,
        }
        impl ColumnStatistic {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ColumnStatistic::StatisticUndefined => "STATISTIC_UNDEFINED",
                    ColumnStatistic::Mean => "MEAN",
                    ColumnStatistic::Min => "MIN",
                    ColumnStatistic::Max => "MAX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATISTIC_UNDEFINED" => Some(Self::StatisticUndefined),
                    "MEAN" => Some(Self::Mean),
                    "MIN" => Some(Self::Min),
                    "MAX" => Some(Self::Max),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RowConditionExpectation {
        #[prost(string, tag = "1")]
        pub sql_expression: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableConditionExpectation {
        #[prost(string, tag = "1")]
        pub sql_expression: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SqlAssertion {
        #[prost(string, tag = "1")]
        pub sql_statement: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RuleType {
        #[prost(message, tag = "1")]
        RangeExpectation(RangeExpectation),
        #[prost(message, tag = "2")]
        NonNullExpectation(NonNullExpectation),
        #[prost(message, tag = "3")]
        SetExpectation(SetExpectation),
        #[prost(message, tag = "4")]
        RegexExpectation(RegexExpectation),
        #[prost(message, tag = "100")]
        UniquenessExpectation(UniquenessExpectation),
        #[prost(message, tag = "101")]
        StatisticRangeExpectation(StatisticRangeExpectation),
        #[prost(message, tag = "200")]
        RowConditionExpectation(RowConditionExpectation),
        #[prost(message, tag = "201")]
        TableConditionExpectation(TableConditionExpectation),
        #[prost(message, tag = "202")]
        SqlAssertion(SqlAssertion),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityColumnResult {
    #[prost(string, tag = "1")]
    pub column: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "2")]
    pub score: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataScanRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub data_scan: ::core::option::Option<DataScan>,
    #[prost(string, tag = "3")]
    pub data_scan_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataScanRequest {
    #[prost(message, optional, tag = "1")]
    pub data_scan: ::core::option::Option<DataScan>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataScanRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataScanRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "get_data_scan_request::DataScanView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetDataScanRequest`.
pub mod get_data_scan_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataScanView {
        Unspecified = 0,
        Basic = 1,
        Full = 10,
    }
    impl DataScanView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataScanView::Unspecified => "DATA_SCAN_VIEW_UNSPECIFIED",
                DataScanView::Basic => "BASIC",
                DataScanView::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_SCAN_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScansRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScansResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_scans: ::prost::alloc::vec::Vec<DataScan>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunDataScanRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunDataScanResponse {
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<DataScanJob>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataScanJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "get_data_scan_job_request::DataScanJobView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetDataScanJobRequest`.
pub mod get_data_scan_job_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataScanJobView {
        Unspecified = 0,
        Basic = 1,
        Full = 10,
    }
    impl DataScanJobView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataScanJobView::Unspecified => "DATA_SCAN_JOB_VIEW_UNSPECIFIED",
                DataScanJobView::Basic => "BASIC",
                DataScanJobView::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_SCAN_JOB_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScanJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScanJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_scan_jobs: ::prost::alloc::vec::Vec<DataScanJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateDataQualityRulesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateDataQualityRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rule: ::prost::alloc::vec::Vec<DataQualityRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScan {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "State", tag = "6")]
    pub state: i32,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub data: ::core::option::Option<DataSource>,
    #[prost(message, optional, tag = "10")]
    pub execution_spec: ::core::option::Option<data_scan::ExecutionSpec>,
    #[prost(message, optional, tag = "11")]
    pub execution_status: ::core::option::Option<data_scan::ExecutionStatus>,
    #[prost(enumeration = "DataScanType", tag = "12")]
    pub r#type: i32,
    #[prost(oneof = "data_scan::Spec", tags = "100, 101")]
    pub spec: ::core::option::Option<data_scan::Spec>,
    #[prost(oneof = "data_scan::Result", tags = "200, 201")]
    pub result: ::core::option::Option<data_scan::Result>,
}
/// Nested message and enum types in `DataScan`.
pub mod data_scan {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionSpec {
        #[prost(message, optional, tag = "1")]
        pub trigger: ::core::option::Option<super::Trigger>,
        #[prost(oneof = "execution_spec::Incremental", tags = "100")]
        pub incremental: ::core::option::Option<execution_spec::Incremental>,
    }
    /// Nested message and enum types in `ExecutionSpec`.
    pub mod execution_spec {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Incremental {
            #[prost(string, tag = "100")]
            Field(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExecutionStatus {
        #[prost(message, optional, tag = "4")]
        pub latest_job_start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "5")]
        pub latest_job_end_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "6")]
        pub latest_job_create_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Spec {
        #[prost(message, tag = "100")]
        DataQualitySpec(super::DataQualitySpec),
        #[prost(message, tag = "101")]
        DataProfileSpec(super::DataProfileSpec),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "200")]
        DataQualityResult(super::DataQualityResult),
        #[prost(message, tag = "201")]
        DataProfileResult(super::DataProfileResult),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "data_scan_job::State", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
    #[prost(enumeration = "DataScanType", tag = "7")]
    pub r#type: i32,
    #[prost(oneof = "data_scan_job::Spec", tags = "100, 101")]
    pub spec: ::core::option::Option<data_scan_job::Spec>,
    #[prost(oneof = "data_scan_job::Result", tags = "200, 201")]
    pub result: ::core::option::Option<data_scan_job::Result>,
}
/// Nested message and enum types in `DataScanJob`.
pub mod data_scan_job {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Running = 1,
        Canceling = 2,
        Cancelled = 3,
        Succeeded = 4,
        Failed = 5,
        Pending = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Running => "RUNNING",
                State::Canceling => "CANCELING",
                State::Cancelled => "CANCELLED",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Pending => "PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "CANCELING" => Some(Self::Canceling),
                "CANCELLED" => Some(Self::Cancelled),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "PENDING" => Some(Self::Pending),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Spec {
        #[prost(message, tag = "100")]
        DataQualitySpec(super::DataQualitySpec),
        #[prost(message, tag = "101")]
        DataProfileSpec(super::DataProfileSpec),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "200")]
        DataQualityResult(super::DataQualityResult),
        #[prost(message, tag = "201")]
        DataProfileResult(super::DataProfileResult),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataScanType {
    Unspecified = 0,
    DataQuality = 1,
    DataProfile = 2,
}
impl DataScanType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DataScanType::Unspecified => "DATA_SCAN_TYPE_UNSPECIFIED",
            DataScanType::DataQuality => "DATA_QUALITY",
            DataScanType::DataProfile => "DATA_PROFILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_SCAN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_QUALITY" => Some(Self::DataQuality),
            "DATA_PROFILE" => Some(Self::DataProfile),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod data_scan_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// DataScanService manages DataScan resources which can be configured to run
    /// various types of data scanning workload and generate enriched metadata (e.g.
    /// Data Profile, Data Quality) for the data source.
    #[derive(Debug, Clone)]
    pub struct DataScanServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DataScanServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataScanServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DataScanServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a DataScan resource.
        pub async fn create_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/CreateDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "CreateDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataScan resource.
        pub async fn update_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/UpdateDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "UpdateDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DataScan resource.
        pub async fn delete_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/DeleteDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "DeleteDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a DataScan resource.
        pub async fn get_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataScanRequest>,
        ) -> std::result::Result<tonic::Response<super::DataScan>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/GetDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "GetDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataScans.
        pub async fn list_data_scans(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataScansRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataScansResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/ListDataScans",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "ListDataScans",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs an on-demand execution of a DataScan
        pub async fn run_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::RunDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RunDataScanResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/RunDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "RunDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a DataScanJob resource.
        pub async fn get_data_scan_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataScanJobRequest>,
        ) -> std::result::Result<tonic::Response<super::DataScanJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/GetDataScanJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "GetDataScanJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataScanJobs under the given DataScan.
        pub async fn list_data_scan_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataScanJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataScanJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/ListDataScanJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "ListDataScanJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates recommended data quality rules based on the results of a data
        /// profiling scan.
        ///
        /// Use the recommendations to build rules for a data quality scan.
        pub async fn generate_data_quality_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateDataQualityRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateDataQualityRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/GenerateDataQualityRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "GenerateDataQualityRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscoveryEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub lake_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub asset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub data_location: ::prost::alloc::string::String,
    #[prost(enumeration = "discovery_event::EventType", tag = "10")]
    pub r#type: i32,
    #[prost(oneof = "discovery_event::Details", tags = "20, 21, 22, 23")]
    pub details: ::core::option::Option<discovery_event::Details>,
}
/// Nested message and enum types in `DiscoveryEvent`.
pub mod discovery_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfigDetails {
        #[prost(map = "string, string", tag = "1")]
        pub parameters: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EntityDetails {
        #[prost(string, tag = "1")]
        pub entity: ::prost::alloc::string::String,
        #[prost(enumeration = "EntityType", tag = "2")]
        pub r#type: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartitionDetails {
        #[prost(string, tag = "1")]
        pub partition: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub entity: ::prost::alloc::string::String,
        #[prost(enumeration = "EntityType", tag = "3")]
        pub r#type: i32,
        #[prost(string, repeated, tag = "4")]
        pub sampled_data_locations: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionDetails {
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        Unspecified = 0,
        Config = 1,
        EntityCreated = 2,
        EntityUpdated = 3,
        EntityDeleted = 4,
        PartitionCreated = 5,
        PartitionUpdated = 6,
        PartitionDeleted = 7,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EventType::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                EventType::Config => "CONFIG",
                EventType::EntityCreated => "ENTITY_CREATED",
                EventType::EntityUpdated => "ENTITY_UPDATED",
                EventType::EntityDeleted => "ENTITY_DELETED",
                EventType::PartitionCreated => "PARTITION_CREATED",
                EventType::PartitionUpdated => "PARTITION_UPDATED",
                EventType::PartitionDeleted => "PARTITION_DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONFIG" => Some(Self::Config),
                "ENTITY_CREATED" => Some(Self::EntityCreated),
                "ENTITY_UPDATED" => Some(Self::EntityUpdated),
                "ENTITY_DELETED" => Some(Self::EntityDeleted),
                "PARTITION_CREATED" => Some(Self::PartitionCreated),
                "PARTITION_UPDATED" => Some(Self::PartitionUpdated),
                "PARTITION_DELETED" => Some(Self::PartitionDeleted),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EntityType {
        Unspecified = 0,
        Table = 1,
        Fileset = 2,
    }
    impl EntityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EntityType::Unspecified => "ENTITY_TYPE_UNSPECIFIED",
                EntityType::Table => "TABLE",
                EntityType::Fileset => "FILESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TABLE" => Some(Self::Table),
                "FILESET" => Some(Self::Fileset),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag = "20")]
        Config(ConfigDetails),
        #[prost(message, tag = "21")]
        Entity(EntityDetails),
        #[prost(message, tag = "22")]
        Partition(PartitionDetails),
        #[prost(message, tag = "23")]
        Action(ActionDetails),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "job_event::State", tag = "5")]
    pub state: i32,
    #[prost(int32, tag = "6")]
    pub retries: i32,
    #[prost(enumeration = "job_event::Type", tag = "7")]
    pub r#type: i32,
    #[prost(enumeration = "job_event::Service", tag = "8")]
    pub service: i32,
    #[prost(string, tag = "9")]
    pub service_job: ::prost::alloc::string::String,
    #[prost(enumeration = "job_event::ExecutionTrigger", tag = "11")]
    pub execution_trigger: i32,
}
/// Nested message and enum types in `JobEvent`.
pub mod job_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Spark = 1,
        Notebook = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Spark => "SPARK",
                Type::Notebook => "NOTEBOOK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SPARK" => Some(Self::Spark),
                "NOTEBOOK" => Some(Self::Notebook),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Succeeded = 1,
        Failed = 2,
        Cancelled = 3,
        Aborted = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Cancelled => "CANCELLED",
                State::Aborted => "ABORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                "ABORTED" => Some(Self::Aborted),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Service {
        Unspecified = 0,
        Dataproc = 1,
    }
    impl Service {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Service::Unspecified => "SERVICE_UNSPECIFIED",
                Service::Dataproc => "DATAPROC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATAPROC" => Some(Self::Dataproc),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionTrigger {
        Unspecified = 0,
        TaskConfig = 1,
        RunRequest = 2,
    }
    impl ExecutionTrigger {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExecutionTrigger::Unspecified => "EXECUTION_TRIGGER_UNSPECIFIED",
                ExecutionTrigger::TaskConfig => "TASK_CONFIG",
                ExecutionTrigger::RunRequest => "RUN_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_TRIGGER_UNSPECIFIED" => Some(Self::Unspecified),
                "TASK_CONFIG" => Some(Self::TaskConfig),
                "RUN_REQUEST" => Some(Self::RunRequest),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(enumeration = "session_event::EventType", tag = "4")]
    pub r#type: i32,
    #[prost(bool, tag = "6")]
    pub event_succeeded: bool,
    #[prost(bool, tag = "7")]
    pub fast_startup_enabled: bool,
    #[prost(message, optional, tag = "8")]
    pub unassigned_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(oneof = "session_event::Detail", tags = "5")]
    pub detail: ::core::option::Option<session_event::Detail>,
}
/// Nested message and enum types in `SessionEvent`.
pub mod session_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryDetail {
        #[prost(string, tag = "1")]
        pub query_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub query_text: ::prost::alloc::string::String,
        #[prost(enumeration = "query_detail::Engine", tag = "3")]
        pub engine: i32,
        #[prost(message, optional, tag = "4")]
        pub duration: ::core::option::Option<::prost_types::Duration>,
        #[prost(int64, tag = "5")]
        pub result_size_bytes: i64,
        #[prost(int64, tag = "6")]
        pub data_processed_bytes: i64,
    }
    /// Nested message and enum types in `QueryDetail`.
    pub mod query_detail {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Engine {
            Unspecified = 0,
            SparkSql = 1,
            Bigquery = 2,
        }
        impl Engine {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Engine::Unspecified => "ENGINE_UNSPECIFIED",
                    Engine::SparkSql => "SPARK_SQL",
                    Engine::Bigquery => "BIGQUERY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ENGINE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SPARK_SQL" => Some(Self::SparkSql),
                    "BIGQUERY" => Some(Self::Bigquery),
                    _ => None,
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        Unspecified = 0,
        Start = 1,
        Stop = 2,
        Query = 3,
        Create = 4,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EventType::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                EventType::Start => "START",
                EventType::Stop => "STOP",
                EventType::Query => "QUERY",
                EventType::Create => "CREATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                "QUERY" => Some(Self::Query),
                "CREATE" => Some(Self::Create),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "5")]
        Query(QueryDetail),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GovernanceEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(enumeration = "governance_event::EventType", tag = "2")]
    pub event_type: i32,
    #[prost(message, optional, tag = "3")]
    pub entity: ::core::option::Option<governance_event::Entity>,
}
/// Nested message and enum types in `GovernanceEvent`.
pub mod governance_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entity {
        #[prost(string, tag = "1")]
        pub entity: ::prost::alloc::string::String,
        #[prost(enumeration = "entity::EntityType", tag = "2")]
        pub entity_type: i32,
    }
    /// Nested message and enum types in `Entity`.
    pub mod entity {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum EntityType {
            Unspecified = 0,
            Table = 1,
            Fileset = 2,
        }
        impl EntityType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    EntityType::Unspecified => "ENTITY_TYPE_UNSPECIFIED",
                    EntityType::Table => "TABLE",
                    EntityType::Fileset => "FILESET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TABLE" => Some(Self::Table),
                    "FILESET" => Some(Self::Fileset),
                    _ => None,
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        Unspecified = 0,
        ResourceIamPolicyUpdate = 1,
        BigqueryTableCreate = 2,
        BigqueryTableUpdate = 3,
        BigqueryTableDelete = 4,
        BigqueryConnectionCreate = 5,
        BigqueryConnectionUpdate = 6,
        BigqueryConnectionDelete = 7,
        BigqueryTaxonomyCreate = 10,
        BigqueryPolicyTagCreate = 11,
        BigqueryPolicyTagDelete = 12,
        BigqueryPolicyTagSetIamPolicy = 13,
        AccessPolicyUpdate = 14,
        GovernanceRuleMatchedResources = 15,
        GovernanceRuleSearchLimitExceeds = 16,
        GovernanceRuleErrors = 17,
        GovernanceRuleProcessing = 18,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EventType::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                EventType::ResourceIamPolicyUpdate => "RESOURCE_IAM_POLICY_UPDATE",
                EventType::BigqueryTableCreate => "BIGQUERY_TABLE_CREATE",
                EventType::BigqueryTableUpdate => "BIGQUERY_TABLE_UPDATE",
                EventType::BigqueryTableDelete => "BIGQUERY_TABLE_DELETE",
                EventType::BigqueryConnectionCreate => "BIGQUERY_CONNECTION_CREATE",
                EventType::BigqueryConnectionUpdate => "BIGQUERY_CONNECTION_UPDATE",
                EventType::BigqueryConnectionDelete => "BIGQUERY_CONNECTION_DELETE",
                EventType::BigqueryTaxonomyCreate => "BIGQUERY_TAXONOMY_CREATE",
                EventType::BigqueryPolicyTagCreate => "BIGQUERY_POLICY_TAG_CREATE",
                EventType::BigqueryPolicyTagDelete => "BIGQUERY_POLICY_TAG_DELETE",
                EventType::BigqueryPolicyTagSetIamPolicy => {
                    "BIGQUERY_POLICY_TAG_SET_IAM_POLICY"
                }
                EventType::AccessPolicyUpdate => "ACCESS_POLICY_UPDATE",
                EventType::GovernanceRuleMatchedResources => {
                    "GOVERNANCE_RULE_MATCHED_RESOURCES"
                }
                EventType::GovernanceRuleSearchLimitExceeds => {
                    "GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS"
                }
                EventType::GovernanceRuleErrors => "GOVERNANCE_RULE_ERRORS",
                EventType::GovernanceRuleProcessing => "GOVERNANCE_RULE_PROCESSING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_IAM_POLICY_UPDATE" => Some(Self::ResourceIamPolicyUpdate),
                "BIGQUERY_TABLE_CREATE" => Some(Self::BigqueryTableCreate),
                "BIGQUERY_TABLE_UPDATE" => Some(Self::BigqueryTableUpdate),
                "BIGQUERY_TABLE_DELETE" => Some(Self::BigqueryTableDelete),
                "BIGQUERY_CONNECTION_CREATE" => Some(Self::BigqueryConnectionCreate),
                "BIGQUERY_CONNECTION_UPDATE" => Some(Self::BigqueryConnectionUpdate),
                "BIGQUERY_CONNECTION_DELETE" => Some(Self::BigqueryConnectionDelete),
                "BIGQUERY_TAXONOMY_CREATE" => Some(Self::BigqueryTaxonomyCreate),
                "BIGQUERY_POLICY_TAG_CREATE" => Some(Self::BigqueryPolicyTagCreate),
                "BIGQUERY_POLICY_TAG_DELETE" => Some(Self::BigqueryPolicyTagDelete),
                "BIGQUERY_POLICY_TAG_SET_IAM_POLICY" => {
                    Some(Self::BigqueryPolicyTagSetIamPolicy)
                }
                "ACCESS_POLICY_UPDATE" => Some(Self::AccessPolicyUpdate),
                "GOVERNANCE_RULE_MATCHED_RESOURCES" => {
                    Some(Self::GovernanceRuleMatchedResources)
                }
                "GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS" => {
                    Some(Self::GovernanceRuleSearchLimitExceeds)
                }
                "GOVERNANCE_RULE_ERRORS" => Some(Self::GovernanceRuleErrors),
                "GOVERNANCE_RULE_PROCESSING" => Some(Self::GovernanceRuleProcessing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanEvent {
    #[prost(string, tag = "1")]
    pub data_source: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "data_scan_event::ScanType", tag = "5")]
    pub r#type: i32,
    #[prost(enumeration = "data_scan_event::State", tag = "6")]
    pub state: i32,
    #[prost(string, tag = "7")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub spec_version: ::prost::alloc::string::String,
    #[prost(enumeration = "data_scan_event::Trigger", tag = "9")]
    pub trigger: i32,
    #[prost(enumeration = "data_scan_event::Scope", tag = "10")]
    pub scope: i32,
    #[prost(message, optional, tag = "11")]
    pub post_scan_actions_result: ::core::option::Option<
        data_scan_event::PostScanActionsResult,
    >,
    #[prost(oneof = "data_scan_event::Result", tags = "101, 102")]
    pub result: ::core::option::Option<data_scan_event::Result>,
    #[prost(oneof = "data_scan_event::AppliedConfigs", tags = "201, 202")]
    pub applied_configs: ::core::option::Option<data_scan_event::AppliedConfigs>,
}
/// Nested message and enum types in `DataScanEvent`.
pub mod data_scan_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataProfileResult {
        #[prost(int64, tag = "1")]
        pub row_count: i64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataQualityResult {
        #[prost(int64, tag = "1")]
        pub row_count: i64,
        #[prost(bool, tag = "2")]
        pub passed: bool,
        #[prost(map = "string, bool", tag = "3")]
        pub dimension_passed: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            bool,
        >,
        #[prost(float, tag = "4")]
        pub score: f32,
        #[prost(map = "string, float", tag = "5")]
        pub dimension_score: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            f32,
        >,
        #[prost(map = "string, float", tag = "6")]
        pub column_score: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            f32,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataProfileAppliedConfigs {
        #[prost(float, tag = "1")]
        pub sampling_percent: f32,
        #[prost(bool, tag = "2")]
        pub row_filter_applied: bool,
        #[prost(bool, tag = "3")]
        pub column_filter_applied: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataQualityAppliedConfigs {
        #[prost(float, tag = "1")]
        pub sampling_percent: f32,
        #[prost(bool, tag = "2")]
        pub row_filter_applied: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActionsResult {
        #[prost(message, optional, tag = "1")]
        pub bigquery_export_result: ::core::option::Option<
            post_scan_actions_result::BigQueryExportResult,
        >,
    }
    /// Nested message and enum types in `PostScanActionsResult`.
    pub mod post_scan_actions_result {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExportResult {
            #[prost(enumeration = "big_query_export_result::State", tag = "1")]
            pub state: i32,
            #[prost(string, tag = "2")]
            pub message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BigQueryExportResult`.
        pub mod big_query_export_result {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum State {
                Unspecified = 0,
                Succeeded = 1,
                Failed = 2,
                Skipped = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        State::Unspecified => "STATE_UNSPECIFIED",
                        State::Succeeded => "SUCCEEDED",
                        State::Failed => "FAILED",
                        State::Skipped => "SKIPPED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SUCCEEDED" => Some(Self::Succeeded),
                        "FAILED" => Some(Self::Failed),
                        "SKIPPED" => Some(Self::Skipped),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScanType {
        Unspecified = 0,
        DataProfile = 1,
        DataQuality = 2,
    }
    impl ScanType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ScanType::Unspecified => "SCAN_TYPE_UNSPECIFIED",
                ScanType::DataProfile => "DATA_PROFILE",
                ScanType::DataQuality => "DATA_QUALITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCAN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATA_PROFILE" => Some(Self::DataProfile),
                "DATA_QUALITY" => Some(Self::DataQuality),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Started = 1,
        Succeeded = 2,
        Failed = 3,
        Cancelled = 4,
        Created = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Started => "STARTED",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::Cancelled => "CANCELLED",
                State::Created => "CREATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STARTED" => Some(Self::Started),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                "CREATED" => Some(Self::Created),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Trigger {
        Unspecified = 0,
        OnDemand = 1,
        Schedule = 2,
    }
    impl Trigger {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Trigger::Unspecified => "TRIGGER_UNSPECIFIED",
                Trigger::OnDemand => "ON_DEMAND",
                Trigger::Schedule => "SCHEDULE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRIGGER_UNSPECIFIED" => Some(Self::Unspecified),
                "ON_DEMAND" => Some(Self::OnDemand),
                "SCHEDULE" => Some(Self::Schedule),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scope {
        Unspecified = 0,
        Full = 1,
        Incremental = 2,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Scope::Unspecified => "SCOPE_UNSPECIFIED",
                Scope::Full => "FULL",
                Scope::Incremental => "INCREMENTAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL" => Some(Self::Full),
                "INCREMENTAL" => Some(Self::Incremental),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "101")]
        DataProfile(DataProfileResult),
        #[prost(message, tag = "102")]
        DataQuality(DataQualityResult),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum AppliedConfigs {
        #[prost(message, tag = "201")]
        DataProfileConfigs(DataProfileAppliedConfigs),
        #[prost(message, tag = "202")]
        DataQualityConfigs(DataQualityAppliedConfigs),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityScanRuleResult {
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub data_source: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub column: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rule_name: ::prost::alloc::string::String,
    #[prost(enumeration = "data_quality_scan_rule_result::RuleType", tag = "5")]
    pub rule_type: i32,
    #[prost(enumeration = "data_quality_scan_rule_result::EvaluationType", tag = "6")]
    pub evalution_type: i32,
    #[prost(string, tag = "7")]
    pub rule_dimension: ::prost::alloc::string::String,
    #[prost(double, tag = "8")]
    pub threshold_percent: f64,
    #[prost(enumeration = "data_quality_scan_rule_result::Result", tag = "9")]
    pub result: i32,
    #[prost(int64, tag = "10")]
    pub evaluated_row_count: i64,
    #[prost(int64, tag = "11")]
    pub passed_row_count: i64,
    #[prost(int64, tag = "12")]
    pub null_row_count: i64,
    #[prost(int64, tag = "13")]
    pub assertion_row_count: i64,
}
/// Nested message and enum types in `DataQualityScanRuleResult`.
pub mod data_quality_scan_rule_result {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RuleType {
        Unspecified = 0,
        NonNullExpectation = 1,
        RangeExpectation = 2,
        RegexExpectation = 3,
        RowConditionExpectation = 4,
        SetExpectation = 5,
        StatisticRangeExpectation = 6,
        TableConditionExpectation = 7,
        UniquenessExpectation = 8,
        SqlAssertion = 9,
    }
    impl RuleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RuleType::Unspecified => "RULE_TYPE_UNSPECIFIED",
                RuleType::NonNullExpectation => "NON_NULL_EXPECTATION",
                RuleType::RangeExpectation => "RANGE_EXPECTATION",
                RuleType::RegexExpectation => "REGEX_EXPECTATION",
                RuleType::RowConditionExpectation => "ROW_CONDITION_EXPECTATION",
                RuleType::SetExpectation => "SET_EXPECTATION",
                RuleType::StatisticRangeExpectation => "STATISTIC_RANGE_EXPECTATION",
                RuleType::TableConditionExpectation => "TABLE_CONDITION_EXPECTATION",
                RuleType::UniquenessExpectation => "UNIQUENESS_EXPECTATION",
                RuleType::SqlAssertion => "SQL_ASSERTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NON_NULL_EXPECTATION" => Some(Self::NonNullExpectation),
                "RANGE_EXPECTATION" => Some(Self::RangeExpectation),
                "REGEX_EXPECTATION" => Some(Self::RegexExpectation),
                "ROW_CONDITION_EXPECTATION" => Some(Self::RowConditionExpectation),
                "SET_EXPECTATION" => Some(Self::SetExpectation),
                "STATISTIC_RANGE_EXPECTATION" => Some(Self::StatisticRangeExpectation),
                "TABLE_CONDITION_EXPECTATION" => Some(Self::TableConditionExpectation),
                "UNIQUENESS_EXPECTATION" => Some(Self::UniquenessExpectation),
                "SQL_ASSERTION" => Some(Self::SqlAssertion),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EvaluationType {
        Unspecified = 0,
        PerRow = 1,
        Aggregate = 2,
    }
    impl EvaluationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EvaluationType::Unspecified => "EVALUATION_TYPE_UNSPECIFIED",
                EvaluationType::PerRow => "PER_ROW",
                EvaluationType::Aggregate => "AGGREGATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVALUATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PER_ROW" => Some(Self::PerRow),
                "AGGREGATE" => Some(Self::Aggregate),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        Unspecified = 0,
        Passed = 1,
        Failed = 2,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::Unspecified => "RESULT_UNSPECIFIED",
                Result::Passed => "PASSED",
                Result::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "PASSED" => Some(Self::Passed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
