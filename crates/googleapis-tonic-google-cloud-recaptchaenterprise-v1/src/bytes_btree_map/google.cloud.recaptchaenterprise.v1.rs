// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssessmentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub assessment: ::core::option::Option<Assessment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvent {
    #[prost(enumeration = "transaction_event::TransactionEventType", tag = "1")]
    pub event_type: i32,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub value: f64,
    #[prost(message, optional, tag = "4")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TransactionEvent`.
pub mod transaction_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionEventType {
        Unspecified = 0,
        MerchantApprove = 1,
        MerchantDeny = 2,
        ManualReview = 3,
        Authorization = 4,
        AuthorizationDecline = 5,
        PaymentCapture = 6,
        PaymentCaptureDecline = 7,
        Cancel = 8,
        ChargebackInquiry = 9,
        ChargebackAlert = 10,
        FraudNotification = 11,
        Chargeback = 12,
        ChargebackRepresentment = 13,
        ChargebackReverse = 14,
        RefundRequest = 15,
        RefundDecline = 16,
        Refund = 17,
        RefundReverse = 18,
    }
    impl TransactionEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TransactionEventType::Unspecified => "TRANSACTION_EVENT_TYPE_UNSPECIFIED",
                TransactionEventType::MerchantApprove => "MERCHANT_APPROVE",
                TransactionEventType::MerchantDeny => "MERCHANT_DENY",
                TransactionEventType::ManualReview => "MANUAL_REVIEW",
                TransactionEventType::Authorization => "AUTHORIZATION",
                TransactionEventType::AuthorizationDecline => "AUTHORIZATION_DECLINE",
                TransactionEventType::PaymentCapture => "PAYMENT_CAPTURE",
                TransactionEventType::PaymentCaptureDecline => "PAYMENT_CAPTURE_DECLINE",
                TransactionEventType::Cancel => "CANCEL",
                TransactionEventType::ChargebackInquiry => "CHARGEBACK_INQUIRY",
                TransactionEventType::ChargebackAlert => "CHARGEBACK_ALERT",
                TransactionEventType::FraudNotification => "FRAUD_NOTIFICATION",
                TransactionEventType::Chargeback => "CHARGEBACK",
                TransactionEventType::ChargebackRepresentment => {
                    "CHARGEBACK_REPRESENTMENT"
                }
                TransactionEventType::ChargebackReverse => "CHARGEBACK_REVERSE",
                TransactionEventType::RefundRequest => "REFUND_REQUEST",
                TransactionEventType::RefundDecline => "REFUND_DECLINE",
                TransactionEventType::Refund => "REFUND",
                TransactionEventType::RefundReverse => "REFUND_REVERSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTION_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MERCHANT_APPROVE" => Some(Self::MerchantApprove),
                "MERCHANT_DENY" => Some(Self::MerchantDeny),
                "MANUAL_REVIEW" => Some(Self::ManualReview),
                "AUTHORIZATION" => Some(Self::Authorization),
                "AUTHORIZATION_DECLINE" => Some(Self::AuthorizationDecline),
                "PAYMENT_CAPTURE" => Some(Self::PaymentCapture),
                "PAYMENT_CAPTURE_DECLINE" => Some(Self::PaymentCaptureDecline),
                "CANCEL" => Some(Self::Cancel),
                "CHARGEBACK_INQUIRY" => Some(Self::ChargebackInquiry),
                "CHARGEBACK_ALERT" => Some(Self::ChargebackAlert),
                "FRAUD_NOTIFICATION" => Some(Self::FraudNotification),
                "CHARGEBACK" => Some(Self::Chargeback),
                "CHARGEBACK_REPRESENTMENT" => Some(Self::ChargebackRepresentment),
                "CHARGEBACK_REVERSE" => Some(Self::ChargebackReverse),
                "REFUND_REQUEST" => Some(Self::RefundRequest),
                "REFUND_DECLINE" => Some(Self::RefundDecline),
                "REFUND" => Some(Self::Refund),
                "REFUND_REVERSE" => Some(Self::RefundReverse),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotateAssessmentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "annotate_assessment_request::Annotation", tag = "2")]
    pub annotation: i32,
    #[prost(
        enumeration = "annotate_assessment_request::Reason",
        repeated,
        packed = "false",
        tag = "3"
    )]
    pub reasons: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "7")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "4")]
    pub hashed_account_id: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "5")]
    pub transaction_event: ::core::option::Option<TransactionEvent>,
}
/// Nested message and enum types in `AnnotateAssessmentRequest`.
pub mod annotate_assessment_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Annotation {
        Unspecified = 0,
        Legitimate = 1,
        Fraudulent = 2,
        PasswordCorrect = 3,
        PasswordIncorrect = 4,
    }
    impl Annotation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Annotation::Unspecified => "ANNOTATION_UNSPECIFIED",
                Annotation::Legitimate => "LEGITIMATE",
                Annotation::Fraudulent => "FRAUDULENT",
                Annotation::PasswordCorrect => "PASSWORD_CORRECT",
                Annotation::PasswordIncorrect => "PASSWORD_INCORRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANNOTATION_UNSPECIFIED" => Some(Self::Unspecified),
                "LEGITIMATE" => Some(Self::Legitimate),
                "FRAUDULENT" => Some(Self::Fraudulent),
                "PASSWORD_CORRECT" => Some(Self::PasswordCorrect),
                "PASSWORD_INCORRECT" => Some(Self::PasswordIncorrect),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        Unspecified = 0,
        Chargeback = 1,
        ChargebackFraud = 8,
        ChargebackDispute = 9,
        Refund = 10,
        RefundFraud = 11,
        TransactionAccepted = 12,
        TransactionDeclined = 13,
        PaymentHeuristics = 2,
        InitiatedTwoFactor = 7,
        PassedTwoFactor = 3,
        FailedTwoFactor = 4,
        CorrectPassword = 5,
        IncorrectPassword = 6,
        SocialSpam = 14,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unspecified => "REASON_UNSPECIFIED",
                Reason::Chargeback => "CHARGEBACK",
                Reason::ChargebackFraud => "CHARGEBACK_FRAUD",
                Reason::ChargebackDispute => "CHARGEBACK_DISPUTE",
                Reason::Refund => "REFUND",
                Reason::RefundFraud => "REFUND_FRAUD",
                Reason::TransactionAccepted => "TRANSACTION_ACCEPTED",
                Reason::TransactionDeclined => "TRANSACTION_DECLINED",
                Reason::PaymentHeuristics => "PAYMENT_HEURISTICS",
                Reason::InitiatedTwoFactor => "INITIATED_TWO_FACTOR",
                Reason::PassedTwoFactor => "PASSED_TWO_FACTOR",
                Reason::FailedTwoFactor => "FAILED_TWO_FACTOR",
                Reason::CorrectPassword => "CORRECT_PASSWORD",
                Reason::IncorrectPassword => "INCORRECT_PASSWORD",
                Reason::SocialSpam => "SOCIAL_SPAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "CHARGEBACK" => Some(Self::Chargeback),
                "CHARGEBACK_FRAUD" => Some(Self::ChargebackFraud),
                "CHARGEBACK_DISPUTE" => Some(Self::ChargebackDispute),
                "REFUND" => Some(Self::Refund),
                "REFUND_FRAUD" => Some(Self::RefundFraud),
                "TRANSACTION_ACCEPTED" => Some(Self::TransactionAccepted),
                "TRANSACTION_DECLINED" => Some(Self::TransactionDeclined),
                "PAYMENT_HEURISTICS" => Some(Self::PaymentHeuristics),
                "INITIATED_TWO_FACTOR" => Some(Self::InitiatedTwoFactor),
                "PASSED_TWO_FACTOR" => Some(Self::PassedTwoFactor),
                "FAILED_TWO_FACTOR" => Some(Self::FailedTwoFactor),
                "CORRECT_PASSWORD" => Some(Self::CorrectPassword),
                "INCORRECT_PASSWORD" => Some(Self::IncorrectPassword),
                "SOCIAL_SPAM" => Some(Self::SocialSpam),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnnotateAssessmentResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointVerificationInfo {
    #[prost(string, tag = "3")]
    pub request_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub last_verification_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "endpoint_verification_info::Endpoint", tags = "1, 2")]
    pub endpoint: ::core::option::Option<endpoint_verification_info::Endpoint>,
}
/// Nested message and enum types in `EndpointVerificationInfo`.
pub mod endpoint_verification_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Endpoint {
        #[prost(string, tag = "1")]
        EmailAddress(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        PhoneNumber(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountVerificationInfo {
    #[prost(message, repeated, tag = "1")]
    pub endpoints: ::prost::alloc::vec::Vec<EndpointVerificationInfo>,
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(enumeration = "account_verification_info::Result", tag = "7")]
    pub latest_verification_result: i32,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AccountVerificationInfo`.
pub mod account_verification_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        Unspecified = 0,
        SuccessUserVerified = 1,
        ErrorUserNotVerified = 2,
        ErrorSiteOnboardingIncomplete = 3,
        ErrorRecipientNotAllowed = 4,
        ErrorRecipientAbuseLimitExhausted = 5,
        ErrorCriticalInternal = 6,
        ErrorCustomerQuotaExhausted = 7,
        ErrorVerificationBypassed = 8,
        ErrorVerdictMismatch = 9,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::Unspecified => "RESULT_UNSPECIFIED",
                Result::SuccessUserVerified => "SUCCESS_USER_VERIFIED",
                Result::ErrorUserNotVerified => "ERROR_USER_NOT_VERIFIED",
                Result::ErrorSiteOnboardingIncomplete => {
                    "ERROR_SITE_ONBOARDING_INCOMPLETE"
                }
                Result::ErrorRecipientNotAllowed => "ERROR_RECIPIENT_NOT_ALLOWED",
                Result::ErrorRecipientAbuseLimitExhausted => {
                    "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED"
                }
                Result::ErrorCriticalInternal => "ERROR_CRITICAL_INTERNAL",
                Result::ErrorCustomerQuotaExhausted => "ERROR_CUSTOMER_QUOTA_EXHAUSTED",
                Result::ErrorVerificationBypassed => "ERROR_VERIFICATION_BYPASSED",
                Result::ErrorVerdictMismatch => "ERROR_VERDICT_MISMATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCESS_USER_VERIFIED" => Some(Self::SuccessUserVerified),
                "ERROR_USER_NOT_VERIFIED" => Some(Self::ErrorUserNotVerified),
                "ERROR_SITE_ONBOARDING_INCOMPLETE" => {
                    Some(Self::ErrorSiteOnboardingIncomplete)
                }
                "ERROR_RECIPIENT_NOT_ALLOWED" => Some(Self::ErrorRecipientNotAllowed),
                "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED" => {
                    Some(Self::ErrorRecipientAbuseLimitExhausted)
                }
                "ERROR_CRITICAL_INTERNAL" => Some(Self::ErrorCriticalInternal),
                "ERROR_CUSTOMER_QUOTA_EXHAUSTED" => {
                    Some(Self::ErrorCustomerQuotaExhausted)
                }
                "ERROR_VERIFICATION_BYPASSED" => Some(Self::ErrorVerificationBypassed),
                "ERROR_VERDICT_MISMATCH" => Some(Self::ErrorVerdictMismatch),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePasswordLeakVerification {
    #[prost(bytes = "bytes", tag = "1")]
    pub lookup_hash_prefix: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "2")]
    pub encrypted_user_credentials_hash: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", repeated, tag = "3")]
    pub encrypted_leak_match_prefixes: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", tag = "4")]
    pub reencrypted_user_credentials_hash: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assessment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub event: ::core::option::Option<Event>,
    #[prost(message, optional, tag = "3")]
    pub risk_analysis: ::core::option::Option<RiskAnalysis>,
    #[prost(message, optional, tag = "4")]
    pub token_properties: ::core::option::Option<TokenProperties>,
    #[prost(message, optional, tag = "5")]
    pub account_verification: ::core::option::Option<AccountVerificationInfo>,
    #[prost(message, optional, tag = "6")]
    pub account_defender_assessment: ::core::option::Option<AccountDefenderAssessment>,
    #[prost(message, optional, tag = "8")]
    pub private_password_leak_verification: ::core::option::Option<
        PrivatePasswordLeakVerification,
    >,
    #[prost(message, optional, tag = "10")]
    pub firewall_policy_assessment: ::core::option::Option<FirewallPolicyAssessment>,
    #[prost(message, optional, tag = "11")]
    pub fraud_prevention_assessment: ::core::option::Option<FraudPreventionAssessment>,
    #[prost(message, optional, tag = "13")]
    pub fraud_signals: ::core::option::Option<FraudSignals>,
    #[prost(message, optional, tag = "12")]
    pub phone_fraud_assessment: ::core::option::Option<PhoneFraudAssessment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub site_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub user_agent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub user_ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub expected_action: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bytes = "bytes", tag = "6")]
    pub hashed_account_id: ::prost::bytes::Bytes,
    #[prost(bool, tag = "14")]
    pub express: bool,
    #[prost(string, tag = "8")]
    pub requested_uri: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub waf_token_assessment: bool,
    #[prost(string, tag = "10")]
    pub ja3: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "11")]
    pub headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "12")]
    pub firewall_policy_evaluation: bool,
    #[prost(message, optional, tag = "13")]
    pub transaction_data: ::core::option::Option<TransactionData>,
    #[prost(message, optional, tag = "15")]
    pub user_info: ::core::option::Option<UserInfo>,
    #[prost(enumeration = "event::FraudPrevention", tag = "17")]
    pub fraud_prevention: i32,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FraudPrevention {
        Unspecified = 0,
        Enabled = 1,
        Disabled = 2,
    }
    impl FraudPrevention {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FraudPrevention::Unspecified => "FRAUD_PREVENTION_UNSPECIFIED",
                FraudPrevention::Enabled => "ENABLED",
                FraudPrevention::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FRAUD_PREVENTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionData {
    #[prost(string, optional, tag = "11")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "1")]
    pub payment_method: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub card_bin: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub card_last_four: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub currency_code: ::prost::alloc::string::String,
    #[prost(double, tag = "5")]
    pub value: f64,
    #[prost(double, tag = "12")]
    pub shipping_value: f64,
    #[prost(message, optional, tag = "6")]
    pub shipping_address: ::core::option::Option<transaction_data::Address>,
    #[prost(message, optional, tag = "7")]
    pub billing_address: ::core::option::Option<transaction_data::Address>,
    #[prost(message, optional, tag = "8")]
    pub user: ::core::option::Option<transaction_data::User>,
    #[prost(message, repeated, tag = "13")]
    pub merchants: ::prost::alloc::vec::Vec<transaction_data::User>,
    #[prost(message, repeated, tag = "14")]
    pub items: ::prost::alloc::vec::Vec<transaction_data::Item>,
    #[prost(message, optional, tag = "10")]
    pub gateway_info: ::core::option::Option<transaction_data::GatewayInfo>,
}
/// Nested message and enum types in `TransactionData`.
pub mod transaction_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Address {
        #[prost(string, tag = "1")]
        pub recipient: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub address: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "3")]
        pub locality: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub administrative_area: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub region_code: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub postal_code: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct User {
        #[prost(string, tag = "6")]
        pub account_id: ::prost::alloc::string::String,
        #[prost(int64, tag = "1")]
        pub creation_ms: i64,
        #[prost(string, tag = "2")]
        pub email: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub email_verified: bool,
        #[prost(string, tag = "4")]
        pub phone_number: ::prost::alloc::string::String,
        #[prost(bool, tag = "5")]
        pub phone_verified: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(double, tag = "2")]
        pub value: f64,
        #[prost(int64, tag = "3")]
        pub quantity: i64,
        #[prost(string, tag = "4")]
        pub merchant_account_id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GatewayInfo {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub gateway_response_code: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub avs_response_code: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub cvv_response_code: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    #[prost(message, optional, tag = "1")]
    pub create_account_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub user_ids: ::prost::alloc::vec::Vec<UserId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserId {
    #[prost(oneof = "user_id::IdOneof", tags = "1, 2, 3")]
    pub id_oneof: ::core::option::Option<user_id::IdOneof>,
}
/// Nested message and enum types in `UserId`.
pub mod user_id {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IdOneof {
        #[prost(string, tag = "1")]
        Email(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        PhoneNumber(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        Username(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskAnalysis {
    #[prost(float, tag = "1")]
    pub score: f32,
    #[prost(
        enumeration = "risk_analysis::ClassificationReason",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub reasons: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "3")]
    pub extended_verdict_reasons: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `RiskAnalysis`.
pub mod risk_analysis {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClassificationReason {
        Unspecified = 0,
        Automation = 1,
        UnexpectedEnvironment = 2,
        TooMuchTraffic = 3,
        UnexpectedUsagePatterns = 4,
        LowConfidenceScore = 5,
        SuspectedCarding = 6,
        SuspectedChargeback = 7,
    }
    impl ClassificationReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClassificationReason::Unspecified => "CLASSIFICATION_REASON_UNSPECIFIED",
                ClassificationReason::Automation => "AUTOMATION",
                ClassificationReason::UnexpectedEnvironment => "UNEXPECTED_ENVIRONMENT",
                ClassificationReason::TooMuchTraffic => "TOO_MUCH_TRAFFIC",
                ClassificationReason::UnexpectedUsagePatterns => {
                    "UNEXPECTED_USAGE_PATTERNS"
                }
                ClassificationReason::LowConfidenceScore => "LOW_CONFIDENCE_SCORE",
                ClassificationReason::SuspectedCarding => "SUSPECTED_CARDING",
                ClassificationReason::SuspectedChargeback => "SUSPECTED_CHARGEBACK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLASSIFICATION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATION" => Some(Self::Automation),
                "UNEXPECTED_ENVIRONMENT" => Some(Self::UnexpectedEnvironment),
                "TOO_MUCH_TRAFFIC" => Some(Self::TooMuchTraffic),
                "UNEXPECTED_USAGE_PATTERNS" => Some(Self::UnexpectedUsagePatterns),
                "LOW_CONFIDENCE_SCORE" => Some(Self::LowConfidenceScore),
                "SUSPECTED_CARDING" => Some(Self::SuspectedCarding),
                "SUSPECTED_CHARGEBACK" => Some(Self::SuspectedChargeback),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenProperties {
    #[prost(bool, tag = "1")]
    pub valid: bool,
    #[prost(enumeration = "token_properties::InvalidReason", tag = "2")]
    pub invalid_reason: i32,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub android_package_name: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub ios_bundle_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub action: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TokenProperties`.
pub mod token_properties {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InvalidReason {
        Unspecified = 0,
        UnknownInvalidReason = 1,
        Malformed = 2,
        Expired = 3,
        Dupe = 4,
        Missing = 5,
        BrowserError = 6,
    }
    impl InvalidReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InvalidReason::Unspecified => "INVALID_REASON_UNSPECIFIED",
                InvalidReason::UnknownInvalidReason => "UNKNOWN_INVALID_REASON",
                InvalidReason::Malformed => "MALFORMED",
                InvalidReason::Expired => "EXPIRED",
                InvalidReason::Dupe => "DUPE",
                InvalidReason::Missing => "MISSING",
                InvalidReason::BrowserError => "BROWSER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN_INVALID_REASON" => Some(Self::UnknownInvalidReason),
                "MALFORMED" => Some(Self::Malformed),
                "EXPIRED" => Some(Self::Expired),
                "DUPE" => Some(Self::Dupe),
                "MISSING" => Some(Self::Missing),
                "BROWSER_ERROR" => Some(Self::BrowserError),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FraudPreventionAssessment {
    #[prost(float, tag = "1")]
    pub transaction_risk: f32,
    #[prost(message, optional, tag = "2")]
    pub stolen_instrument_verdict: ::core::option::Option<
        fraud_prevention_assessment::StolenInstrumentVerdict,
    >,
    #[prost(message, optional, tag = "3")]
    pub card_testing_verdict: ::core::option::Option<
        fraud_prevention_assessment::CardTestingVerdict,
    >,
    #[prost(message, optional, tag = "4")]
    pub behavioral_trust_verdict: ::core::option::Option<
        fraud_prevention_assessment::BehavioralTrustVerdict,
    >,
}
/// Nested message and enum types in `FraudPreventionAssessment`.
pub mod fraud_prevention_assessment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StolenInstrumentVerdict {
        #[prost(float, tag = "1")]
        pub risk: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CardTestingVerdict {
        #[prost(float, tag = "1")]
        pub risk: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BehavioralTrustVerdict {
        #[prost(float, tag = "1")]
        pub trust: f32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FraudSignals {
    #[prost(message, optional, tag = "1")]
    pub user_signals: ::core::option::Option<fraud_signals::UserSignals>,
    #[prost(message, optional, tag = "2")]
    pub card_signals: ::core::option::Option<fraud_signals::CardSignals>,
}
/// Nested message and enum types in `FraudSignals`.
pub mod fraud_signals {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UserSignals {
        #[prost(int32, tag = "1")]
        pub active_days_lower_bound: i32,
        #[prost(float, tag = "2")]
        pub synthetic_risk: f32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CardSignals {
        #[prost(
            enumeration = "card_signals::CardLabel",
            repeated,
            packed = "false",
            tag = "1"
        )]
        pub card_labels: ::prost::alloc::vec::Vec<i32>,
    }
    /// Nested message and enum types in `CardSignals`.
    pub mod card_signals {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum CardLabel {
            Unspecified = 0,
            Prepaid = 1,
            Virtual = 2,
            UnexpectedLocation = 3,
        }
        impl CardLabel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    CardLabel::Unspecified => "CARD_LABEL_UNSPECIFIED",
                    CardLabel::Prepaid => "PREPAID",
                    CardLabel::Virtual => "VIRTUAL",
                    CardLabel::UnexpectedLocation => "UNEXPECTED_LOCATION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CARD_LABEL_UNSPECIFIED" => Some(Self::Unspecified),
                    "PREPAID" => Some(Self::Prepaid),
                    "VIRTUAL" => Some(Self::Virtual),
                    "UNEXPECTED_LOCATION" => Some(Self::UnexpectedLocation),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmsTollFraudVerdict {
    #[prost(float, tag = "1")]
    pub risk: f32,
    #[prost(
        enumeration = "sms_toll_fraud_verdict::SmsTollFraudReason",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub reasons: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `SmsTollFraudVerdict`.
pub mod sms_toll_fraud_verdict {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmsTollFraudReason {
        Unspecified = 0,
        InvalidPhoneNumber = 1,
    }
    impl SmsTollFraudReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SmsTollFraudReason::Unspecified => "SMS_TOLL_FRAUD_REASON_UNSPECIFIED",
                SmsTollFraudReason::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SMS_TOLL_FRAUD_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhoneFraudAssessment {
    #[prost(message, optional, tag = "1")]
    pub sms_toll_fraud_verdict: ::core::option::Option<SmsTollFraudVerdict>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountDefenderAssessment {
    #[prost(
        enumeration = "account_defender_assessment::AccountDefenderLabel",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub labels: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `AccountDefenderAssessment`.
pub mod account_defender_assessment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountDefenderLabel {
        Unspecified = 0,
        ProfileMatch = 1,
        SuspiciousLoginActivity = 2,
        SuspiciousAccountCreation = 3,
        RelatedAccountsNumberHigh = 4,
    }
    impl AccountDefenderLabel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountDefenderLabel::Unspecified => "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED",
                AccountDefenderLabel::ProfileMatch => "PROFILE_MATCH",
                AccountDefenderLabel::SuspiciousLoginActivity => {
                    "SUSPICIOUS_LOGIN_ACTIVITY"
                }
                AccountDefenderLabel::SuspiciousAccountCreation => {
                    "SUSPICIOUS_ACCOUNT_CREATION"
                }
                AccountDefenderLabel::RelatedAccountsNumberHigh => {
                    "RELATED_ACCOUNTS_NUMBER_HIGH"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED" => Some(Self::Unspecified),
                "PROFILE_MATCH" => Some(Self::ProfileMatch),
                "SUSPICIOUS_LOGIN_ACTIVITY" => Some(Self::SuspiciousLoginActivity),
                "SUSPICIOUS_ACCOUNT_CREATION" => Some(Self::SuspiciousAccountCreation),
                "RELATED_ACCOUNTS_NUMBER_HIGH" => Some(Self::RelatedAccountsNumberHigh),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateKeyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub key: ::core::option::Option<Key>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<Key>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveLegacySecretKeyRequest {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<Key>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFirewallPolicyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub firewall_policy: ::core::option::Option<FirewallPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallPoliciesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallPoliciesResponse {
    #[prost(message, repeated, tag = "1")]
    pub firewall_policies: ::prost::alloc::vec::Vec<FirewallPolicy>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFirewallPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFirewallPolicyRequest {
    #[prost(message, optional, tag = "1")]
    pub firewall_policy: ::core::option::Option<FirewallPolicy>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFirewallPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReorderFirewallPoliciesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReorderFirewallPoliciesResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub skip_billing_check: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metrics {
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "2")]
    pub score_metrics: ::prost::alloc::vec::Vec<ScoreMetrics>,
    #[prost(message, repeated, tag = "3")]
    pub challenge_metrics: ::prost::alloc::vec::Vec<ChallengeMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveLegacySecretKeyResponse {
    #[prost(string, tag = "1")]
    pub legacy_secret_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Key {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "6")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub testing_options: ::core::option::Option<TestingOptions>,
    #[prost(message, optional, tag = "10")]
    pub waf_settings: ::core::option::Option<WafSettings>,
    #[prost(oneof = "key::PlatformSettings", tags = "3, 4, 5")]
    pub platform_settings: ::core::option::Option<key::PlatformSettings>,
}
/// Nested message and enum types in `Key`.
pub mod key {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PlatformSettings {
        #[prost(message, tag = "3")]
        WebSettings(super::WebKeySettings),
        #[prost(message, tag = "4")]
        AndroidSettings(super::AndroidKeySettings),
        #[prost(message, tag = "5")]
        IosSettings(super::IosKeySettings),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TestingOptions {
    #[prost(float, tag = "1")]
    pub testing_score: f32,
    #[prost(enumeration = "testing_options::TestingChallenge", tag = "2")]
    pub testing_challenge: i32,
}
/// Nested message and enum types in `TestingOptions`.
pub mod testing_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TestingChallenge {
        Unspecified = 0,
        Nocaptcha = 1,
        UnsolvableChallenge = 2,
    }
    impl TestingChallenge {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TestingChallenge::Unspecified => "TESTING_CHALLENGE_UNSPECIFIED",
                TestingChallenge::Nocaptcha => "NOCAPTCHA",
                TestingChallenge::UnsolvableChallenge => "UNSOLVABLE_CHALLENGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TESTING_CHALLENGE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOCAPTCHA" => Some(Self::Nocaptcha),
                "UNSOLVABLE_CHALLENGE" => Some(Self::UnsolvableChallenge),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebKeySettings {
    #[prost(bool, tag = "3")]
    pub allow_all_domains: bool,
    #[prost(string, repeated, tag = "1")]
    pub allowed_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub allow_amp_traffic: bool,
    #[prost(enumeration = "web_key_settings::IntegrationType", tag = "4")]
    pub integration_type: i32,
    #[prost(enumeration = "web_key_settings::ChallengeSecurityPreference", tag = "5")]
    pub challenge_security_preference: i32,
}
/// Nested message and enum types in `WebKeySettings`.
pub mod web_key_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IntegrationType {
        Unspecified = 0,
        Score = 1,
        Checkbox = 2,
        Invisible = 3,
    }
    impl IntegrationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IntegrationType::Unspecified => "INTEGRATION_TYPE_UNSPECIFIED",
                IntegrationType::Score => "SCORE",
                IntegrationType::Checkbox => "CHECKBOX",
                IntegrationType::Invisible => "INVISIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INTEGRATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCORE" => Some(Self::Score),
                "CHECKBOX" => Some(Self::Checkbox),
                "INVISIBLE" => Some(Self::Invisible),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChallengeSecurityPreference {
        Unspecified = 0,
        Usability = 1,
        Balance = 2,
        Security = 3,
    }
    impl ChallengeSecurityPreference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChallengeSecurityPreference::Unspecified => {
                    "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED"
                }
                ChallengeSecurityPreference::Usability => "USABILITY",
                ChallengeSecurityPreference::Balance => "BALANCE",
                ChallengeSecurityPreference::Security => "SECURITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                "USABILITY" => Some(Self::Usability),
                "BALANCE" => Some(Self::Balance),
                "SECURITY" => Some(Self::Security),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidKeySettings {
    #[prost(bool, tag = "2")]
    pub allow_all_package_names: bool,
    #[prost(string, repeated, tag = "1")]
    pub allowed_package_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "3")]
    pub support_non_google_app_store_distribution: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosKeySettings {
    #[prost(bool, tag = "2")]
    pub allow_all_bundle_ids: bool,
    #[prost(string, repeated, tag = "1")]
    pub allowed_bundle_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub apple_developer_id: ::core::option::Option<AppleDeveloperId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppleDeveloperId {
    #[prost(string, tag = "1")]
    pub private_key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub team_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScoreDistribution {
    #[prost(btree_map = "int32, int64", tag = "1")]
    pub score_buckets: ::prost::alloc::collections::BTreeMap<i32, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScoreMetrics {
    #[prost(message, optional, tag = "1")]
    pub overall_metrics: ::core::option::Option<ScoreDistribution>,
    #[prost(btree_map = "string, message", tag = "2")]
    pub action_metrics: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ScoreDistribution,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChallengeMetrics {
    #[prost(int64, tag = "1")]
    pub pageload_count: i64,
    #[prost(int64, tag = "2")]
    pub nocaptcha_count: i64,
    #[prost(int64, tag = "3")]
    pub failed_count: i64,
    #[prost(int64, tag = "4")]
    pub passed_count: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyAssessment {
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "8")]
    pub firewall_policy: ::core::option::Option<FirewallPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallAction {
    #[prost(oneof = "firewall_action::FirewallActionOneof", tags = "1, 2, 6, 5, 3, 4")]
    pub firewall_action_oneof: ::core::option::Option<
        firewall_action::FirewallActionOneof,
    >,
}
/// Nested message and enum types in `FirewallAction`.
pub mod firewall_action {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AllowAction {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BlockAction {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IncludeRecaptchaScriptAction {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RedirectAction {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubstituteAction {
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetHeaderAction {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FirewallActionOneof {
        #[prost(message, tag = "1")]
        Allow(AllowAction),
        #[prost(message, tag = "2")]
        Block(BlockAction),
        #[prost(message, tag = "6")]
        IncludeRecaptchaScript(IncludeRecaptchaScriptAction),
        #[prost(message, tag = "5")]
        Redirect(RedirectAction),
        #[prost(message, tag = "3")]
        Substitute(SubstituteAction),
        #[prost(message, tag = "4")]
        SetHeader(SetHeaderAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicy {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub condition: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub actions: ::prost::alloc::vec::Vec<FirewallAction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupMembershipsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupMembershipsResponse {
    #[prost(message, repeated, tag = "1")]
    pub related_account_group_memberships: ::prost::alloc::vec::Vec<
        RelatedAccountGroupMembership,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub related_account_groups: ::prost::alloc::vec::Vec<RelatedAccountGroup>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRelatedAccountGroupMembershipsRequest {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub account_id: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bytes = "bytes", tag = "2")]
    pub hashed_account_id: ::prost::bytes::Bytes,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRelatedAccountGroupMembershipsResponse {
    #[prost(message, repeated, tag = "1")]
    pub related_account_group_memberships: ::prost::alloc::vec::Vec<
        RelatedAccountGroupMembership,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelatedAccountGroupMembership {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub account_id: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bytes = "bytes", tag = "2")]
    pub hashed_account_id: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelatedAccountGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WafSettings {
    #[prost(enumeration = "waf_settings::WafService", tag = "1")]
    pub waf_service: i32,
    #[prost(enumeration = "waf_settings::WafFeature", tag = "2")]
    pub waf_feature: i32,
}
/// Nested message and enum types in `WafSettings`.
pub mod waf_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WafFeature {
        Unspecified = 0,
        ChallengePage = 1,
        SessionToken = 2,
        ActionToken = 3,
        Express = 5,
    }
    impl WafFeature {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WafFeature::Unspecified => "WAF_FEATURE_UNSPECIFIED",
                WafFeature::ChallengePage => "CHALLENGE_PAGE",
                WafFeature::SessionToken => "SESSION_TOKEN",
                WafFeature::ActionToken => "ACTION_TOKEN",
                WafFeature::Express => "EXPRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WAF_FEATURE_UNSPECIFIED" => Some(Self::Unspecified),
                "CHALLENGE_PAGE" => Some(Self::ChallengePage),
                "SESSION_TOKEN" => Some(Self::SessionToken),
                "ACTION_TOKEN" => Some(Self::ActionToken),
                "EXPRESS" => Some(Self::Express),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WafService {
        Unspecified = 0,
        Ca = 1,
        Fastly = 3,
        Cloudflare = 4,
    }
    impl WafService {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WafService::Unspecified => "WAF_SERVICE_UNSPECIFIED",
                WafService::Ca => "CA",
                WafService::Fastly => "FASTLY",
                WafService::Cloudflare => "CLOUDFLARE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WAF_SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "CA" => Some(Self::Ca),
                "FASTLY" => Some(Self::Fastly),
                "CLOUDFLARE" => Some(Self::Cloudflare),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod recaptcha_enterprise_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to determine the likelihood an event is legitimate.
    #[derive(Debug, Clone)]
    pub struct RecaptchaEnterpriseServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RecaptchaEnterpriseServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RecaptchaEnterpriseServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RecaptchaEnterpriseServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates an Assessment of the likelihood an event is legitimate.
        pub async fn create_assessment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAssessmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Assessment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/CreateAssessment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "CreateAssessment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Annotates a previously created Assessment to provide additional information
        /// on whether the event turned out to be authentic or fraudulent.
        pub async fn annotate_assessment(
            &mut self,
            request: impl tonic::IntoRequest<super::AnnotateAssessmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnnotateAssessmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/AnnotateAssessment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "AnnotateAssessment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new reCAPTCHA Enterprise key.
        pub async fn create_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/CreateKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "CreateKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of all keys that belong to a project.
        pub async fn list_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the secret key related to the specified public key.
        /// You must use the legacy secret key only in a 3rd party integration with
        /// legacy reCAPTCHA.
        pub async fn retrieve_legacy_secret_key(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveLegacySecretKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveLegacySecretKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/RetrieveLegacySecretKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "RetrieveLegacySecretKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified key.
        pub async fn get_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/GetKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "GetKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified key.
        pub async fn update_key(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/UpdateKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "UpdateKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified key.
        pub async fn delete_key(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteKeyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/DeleteKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "DeleteKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Migrates an existing key from reCAPTCHA to reCAPTCHA Enterprise.
        /// Once a key is migrated, it can be used from either product. SiteVerify
        /// requests are billed as CreateAssessment calls. You must be
        /// authenticated as one of the current owners of the reCAPTCHA Key, and
        /// your user must have the reCAPTCHA Enterprise Admin IAM role in the
        /// destination project.
        pub async fn migrate_key(
            &mut self,
            request: impl tonic::IntoRequest<super::MigrateKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/MigrateKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "MigrateKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get some aggregated metrics for a Key. This data can be used to build
        /// dashboards.
        pub async fn get_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMetricsRequest>,
        ) -> std::result::Result<tonic::Response<super::Metrics>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/GetMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "GetMetrics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new FirewallPolicy, specifying conditions at which reCAPTCHA
        /// Enterprise actions can be executed.
        /// A project may have a maximum of 1000 policies.
        pub async fn create_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/CreateFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "CreateFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of all firewall policies that belong to a project.
        pub async fn list_firewall_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFirewallPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFirewallPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListFirewallPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListFirewallPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified firewall policy.
        pub async fn get_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/GetFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "GetFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified firewall policy.
        pub async fn update_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/UpdateFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "UpdateFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified firewall policy.
        pub async fn delete_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/DeleteFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "DeleteFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reorders all firewall policies.
        pub async fn reorder_firewall_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ReorderFirewallPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReorderFirewallPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ReorderFirewallPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ReorderFirewallPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List groups of related accounts.
        pub async fn list_related_account_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRelatedAccountGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRelatedAccountGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListRelatedAccountGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListRelatedAccountGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get memberships in a group of related accounts.
        pub async fn list_related_account_group_memberships(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListRelatedAccountGroupMembershipsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListRelatedAccountGroupMembershipsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListRelatedAccountGroupMemberships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListRelatedAccountGroupMemberships",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Search group memberships related to a given account.
        pub async fn search_related_account_group_memberships(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SearchRelatedAccountGroupMembershipsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SearchRelatedAccountGroupMembershipsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/SearchRelatedAccountGroupMemberships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "SearchRelatedAccountGroupMemberships",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
